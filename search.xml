<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>Charles抓包配置</title>
    <url>/2021/08/16/Charles%E6%8A%93%E5%8C%85%E9%85%8D%E7%BD%AE-charles%E6%8A%93%E5%8C%85%E9%85%8D%E7%BD%AE/</url>
    <content><![CDATA[<p>Charles是Fiddler之外的另一个抓包工具。传说比Fiddler好用，但配置起来其实是有几点坑的。还是可以掰扯掰扯。</p>
<span id="more"></span>

<h2 id="配置步骤概览"><a href="#配置步骤概览" class="headerlink" title="配置步骤概览"></a>配置步骤概览</h2><p>我们配置的目的是利用Charles抓取同局域网下的IOS上应用软件的HTTPS包。环境为Mac OS</p>
<ol>
<li><p>配置Charles</p>
<ol>
<li>Proxy → Proxy Setting，设置端口为8888</li>
<li>Proxy → SSL Proxying Settings，开启SSL代理</li>
<li>Help → SSL Proxying → Install Charles Root Certificate，给本机安装SSL证书</li>
</ol>
</li>
<li><p>配置IOS</p>
<ol>
<li><p>连接局域网，为该网络手动设置代理，代理地址为PC的局域网地址，端口为8888</p>
</li>
<li><p>电脑端：Help → SSL Proxying → Install Charles Root Certificate on a Mobile or Remote Server</p>
<p> 此时弹出一个框，按照其指示为手机安装证书</p>
</li>
</ol>
</li>
<li><p>抓包</p>
<p> 在需要抓包的链接单击右键 → Enable SSL Proxying</p>
</li>
</ol>
<p>然后，就可以快乐滴抓包了。</p>
<h2 id="坑点"><a href="#坑点" class="headerlink" title="坑点"></a>坑点</h2><p>这是本文的重点。上面基本步骤网上一搜一大把，因此文字描述足矣。</p>
<h3 id="要怎么看mac本机地址"><a href="#要怎么看mac本机地址" class="headerlink" title="要怎么看mac本机地址"></a>要怎么看mac本机地址</h3><p>要么ifconfig | grep 192.168</p>
<p>要么Help → Local IP Adress</p>
<h3 id="mac端安装根证书"><a href="#mac端安装根证书" class="headerlink" title="mac端安装根证书"></a>mac端安装根证书</h3><p>安装是比较好安装，但别忘了还要手动设置信任证书，否则不能用。</p>
<p><img src="https://gdz.oss-cn-shenzhen.aliyuncs.com/halo/mac-root-certificate_1629125032475.png" alt="macrootcertificate.png"></p>
<h3 id="ios端安装根证书"><a href="#ios端安装根证书" class="headerlink" title="ios端安装根证书"></a>ios端安装根证书</h3><p>手机端有两个注意事项</p>
<ul>
<li><p>证书下载地址一定要用safari打开，否则IOS不会将其当做描述文件添加到设置中</p>
</li>
<li><p>描述文件安装后，还要在 通用 → 关于本机 → 证书信任设置。手动开启对Charles证书的信任，否则不能使用</p>
<p>  <img src="https://gdz.oss-cn-shenzhen.aliyuncs.com/halo/ios-root-certificate_1629125032475.png" alt="iosrootcertificate.png"></p>
</li>
</ul>
<h3 id="charles反复打开几次后代理失效"><a href="#charles反复打开几次后代理失效" class="headerlink" title="charles反复打开几次后代理失效"></a>charles反复打开几次后代理失效</h3><p>这一点不知道是不是Charles本身的问题，在Charles自动退出再进入之后，iOS端就无法再使用，也无法连接上网络。</p>
<p>解决方案——重启电脑。</p>
<h2 id="初步感受到Charles比Fiddler好的地方"><a href="#初步感受到Charles比Fiddler好的地方" class="headerlink" title="初步感受到Charles比Fiddler好的地方"></a>初步感受到Charles比Fiddler好的地方</h2><p>会按路径将所有请求进行归类，看起来清楚明了。</p>
<p>比如我抓幕布的包，就很明晰</p>
<p><img src="https://gdz.oss-cn-shenzhen.aliyuncs.com/halo/chares-folder_1629125032474.png" alt="charesfolder.png"></p>
]]></content>
      <categories>
        <category>工具</category>
      </categories>
      <tags>
        <tag>Charles</tag>
      </tags>
  </entry>
  <entry>
    <title>Common FileUpload介绍</title>
    <url>/2019/09/07/Common%20FileUpload%E4%BB%8B%E7%BB%8D-commonfileupload%E4%BB%8B%E7%BB%8D/</url>
    <content><![CDATA[<blockquote>
<p>这是一篇半翻译半笔记式的文章，如果你之前对Common FileUpload了解不多，本文可以快速了解如何使用方法，如果你有时间，推荐你看<a href="http://commons.apache.org/proper/commons-fileupload/using.html">官方文档</a></p>
</blockquote>
<span id="more"></span>
<h1 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h1><p>FileUpload能够以多种不同的方式使用，具体取决于应用程序的要求。在最简单的情况下，您将调用单个方法来解析servlet请求，然后处理解析出来的Item集合。此外也可以自定义FileUpload以完全控制各个Item的存储方式，比如设置缓存目录、直接将接收到的Item以流的形式写入数据库等。</p>
<blockquote>
<p>FileUpload依赖于Commons IO，因此类路径下要有Commons IO的jar包。当然采用Maven依赖的方式不用担心，maven会自动为我们下载Commons IO包</p>
</blockquote>
<h1 id="工作原理"><a href="#工作原理" class="headerlink" title="工作原理"></a>工作原理</h1><p>FileUpload依据规范<a href="http://www.ietf.org/rfc/rfc1867.txt">RFC1867</a>中”基于表单的HTML文件上载”对上传的文件数据进行解析，解析出来的每个项目对应一个FileItem对象。<br>每个FileItem都有许多我们可能感兴趣的属性：获取contentType，获取原本的文件名，获取文件大小，获取FiledName(如果是表单域上传)，判断是否在内存中，判断是否属于表单域等。<br>FileUpload使用<strong>FileItemFactory</strong>创建新的FileItem。该工厂可以控制每个项目的创建方式。目前提供的工厂实现可以将项目的数据存储临时存储在内存或磁盘上，具体取决于项目的大小（即数据字节，在指定的大小内时，存在内存中，超出范围，存在磁盘上）。</p>
<h1 id="开始之前的判断"><a href="#开始之前的判断" class="headerlink" title="开始之前的判断"></a>开始之前的判断</h1><p>在处理上传项目前，最好是先解析一下当前请求是否属于文件上传请求，采用如下方式：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">//检查我们是否有文件上传请求</span><br><span class="line">boolean isMultipart = ServletFileUpload.isMultipartContent(request);</span><br></pre></td></tr></table></figure>
<p>该方法的原理也很简单，就是获取request的contentType以判断是否是multipart，源码如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public static final boolean isMultipartContent(</span><br><span class="line">            HttpServletRequest request) &#123;</span><br><span class="line">    if (!POST_METHOD.equalsIgnoreCase(request.getMethod())) &#123;</span><br><span class="line">        return false;</span><br><span class="line">    &#125;</span><br><span class="line">    return FileUploadBase.isMultipartContent(new ServletRequestContext(request));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public static final String MULTIPART = &quot;multipart/&quot;;</span><br><span class="line">... ...</span><br><span class="line">... ...</span><br><span class="line">public static final boolean isMultipartContent(RequestContext ctx) &#123;</span><br><span class="line">    String contentType = ctx.getContentType();</span><br><span class="line">    if (contentType == null) &#123;</span><br><span class="line">        return false;</span><br><span class="line">    &#125;</span><br><span class="line">    if (contentType.toLowerCase(Locale.ENGLISH).startsWith(MULTIPART)) &#123;</span><br><span class="line">        return true;</span><br><span class="line">    &#125;</span><br><span class="line">    return false;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="可用的最简配置"><a href="#可用的最简配置" class="headerlink" title="可用的最简配置"></a>可用的最简配置</h1><p>有两种方式能够接收上传文件</p>
<ul>
<li>传统方式：首先创建FileItemFactory，创建ServletFileUpload时传入factory，再从upload对象获取FileItem，然后调用write(File)直接写入文件。这种方式将接收到的文件临时存储到内存或磁盘中，后续用户再进行处理，比较方便，但是占用时间和空间</li>
<li>流方式：直接ServletFileUpload中获取FileItem，再从FileItem中获取输入流，从流中直接接收数据，没有临时缓存这一步。使用没那么方便，但是比较节省时间和空间</li>
</ul>
<p>如下演示两种方式</p>
<h2 id="使用传统API"><a href="#使用传统API" class="headerlink" title="使用传统API"></a>使用传统API</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">// Create a factory for disk-based file items</span><br><span class="line">DiskFileItemFactory factory = new DiskFileItemFactory();</span><br><span class="line"></span><br><span class="line">// Configure a repository (to ensure a secure temp location is used)</span><br><span class="line">ServletContext servletContext = this.getServletConfig().getServletContext();</span><br><span class="line">File repository = (File) servletContext.getAttribute(&quot;javax.servlet.context.tempdir&quot;);</span><br><span class="line">factory.setRepository(repository);</span><br><span class="line"></span><br><span class="line">// Create a new file upload handler</span><br><span class="line">ServletFileUpload upload = new ServletFileUpload(factory);</span><br><span class="line"></span><br><span class="line">// Parse the request</span><br><span class="line">List&lt;FileItem&gt; items = upload.parseRequest(request);</span><br><span class="line">Iterator&lt;FileItem&gt; iter = items.iterator();</span><br><span class="line">while (iter.hasNext()) &#123;</span><br><span class="line">    FileItem item = iter.next();</span><br><span class="line">    </span><br><span class="line">    // upload 是这里假定的上传文件的field name</span><br><span class="line">    if(&quot;upload&quot;.equals(item.getFieldName))&#123;</span><br><span class="line">	    File uploadFile = new File(&quot;...&quot;);</span><br><span class="line">	    item.write(uploadFile);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>FileItemFctory可以设置的内容如下</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">factory.setRepository(File dir); // 设置临时文件存储位置</span><br><span class="line">factory.setSizeThreshold(long bytes); // 设置请求大小阈值，当请求大于该值时，接收到的数据是缓存在磁盘中的，否则直接缓存在内存中。</span><br><span class="line">factory.setFileCleaningTracker(FileCleaningTracker pTracker); // 设置临时文件清理跟踪器，后面会讲到</span><br></pre></td></tr></table></figure>
<p>ServletFileUpload可以设置的内容如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">upload.setMaxSize(long bytes); //设置整个请求的最大值，大于该值时，是不允许传送的</span><br><span class="line">upload.setFileMaxSize(long bytes); //设置单个文件的最大值，大于该值时，大于该值时，是不允许传送的</span><br><span class="line">upload.setHeaderEncoding(String charset); // 设置读取每个FileItem的头数据的字符编码，不设置时采用request的编码，也没有时采用系统默认编码</span><br><span class="line">upload.setProgressListener(ProgressListener pListener); // 设置上传进度监听器，后面会讲</span><br></pre></td></tr></table></figure>
<p>FileItem能够获取的内容如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">item.getContentType(); // 获取单个Item的ContentType</span><br><span class="line">item.getName(); // 获取item本来的文件名，如果不是文件则为null</span><br><span class="line">item.getFieldName(); // 获取item的field名</span><br><span class="line">item.getSize(); // 获取item的大小</span><br><span class="line">item.get(); // 将item转换成字节数组返回</span><br><span class="line">item.isInMemory(); // item目前是否存在内存中</span><br><span class="line">item.isFormField(); // 是否是表单域</span><br><span class="line">item.getInputStream(); // 获取输入流，用于读取item</span><br></pre></td></tr></table></figure>

<h2 id="使用流API"><a href="#使用流API" class="headerlink" title="使用流API"></a>使用流API</h2><p>这种方式其实说来应该是最好的选择，因为他也并不麻烦，而且节省了缓存的空间和时间，在性能上是最好的选择。只需要按照如下方式使用即可</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">// Create a new file upload handler</span><br><span class="line">ServletFileUpload upload = new ServletFileUpload();</span><br><span class="line"></span><br><span class="line">// Parse the request</span><br><span class="line">FileItemIterator iter = upload.getItemIterator(request);</span><br><span class="line">while (iter.hasNext()) &#123;</span><br><span class="line">    FileItemStream item = iter.next();</span><br><span class="line">    String fileName = item.getName();</span><br><span class="line">    InputStream stream = item.getInputStream();</span><br><span class="line">    FileOutputStream os = new FileOutputStream(new File(fileName));</span><br><span class="line">    /*</span><br><span class="line">	 *	在这里将输入流的内容写入输出流即可</span><br><span class="line">	 */</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="文件上传进度监听器"><a href="#文件上传进度监听器" class="headerlink" title="文件上传进度监听器"></a>文件上传进度监听器</h1><p>当上传文件非常大时，进度监听器就能够排上用场了，使用方式也非常简单，创建监听器对象，设置到ServletFileUpload即可。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">ProgressListener listener = new ProgressListener() &#123;</span><br><span class="line">    /*</span><br><span class="line">     * pBytesRead: 到目前为止总共读了多少个Byte</span><br><span class="line">     * pContentLength: 整个content的长度，按Byte计算，也有可能是未知的：-1</span><br><span class="line">     * pItems: 正在读取的item编号，0代表尚未开始读取，1代表第一个，以此类推</span><br><span class="line">     */</span><br><span class="line">    public void update(long pBytesRead, long pContentLength, int pItems) &#123;</span><br><span class="line">        // 获取进度百分比，并放在session中</span><br><span class="line">        request.getSession().setAttribute(&quot;progress&quot;, 1.0*pBytesRead/pContentLength);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line">upload.setProgressListener(progressListener);</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>此处有一个问题：监听器会被频繁调用，当其内部实现的逻辑较为简单时，可能无伤大雅，但当逻辑较为复杂或占用资源时，监听器就可能影响到程序的性能。<br>解决方案：以某种方式减少监听器内部逻辑执行的次数，比如下面这种方式</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">ProgressListener progressListener = new ProgressListener()&#123;</span><br><span class="line">   private long megaBytes = -1;</span><br><span class="line">   public void update(long pBytesRead, long pContentLength, int pItems) &#123;</span><br><span class="line">	   // 每接收1M数据才执行一次后面的动作</span><br><span class="line">       long mBytes = pBytesRead / 1000000;</span><br><span class="line">       if (megaBytes == mBytes) &#123;</span><br><span class="line">           return;</span><br><span class="line">       &#125;</span><br><span class="line">       megaBytes = mBytes;</span><br><span class="line">       request.getSession().setAttribute(&quot;progress&quot;, 1.0*pBytesRead/pContentLength);</span><br><span class="line">   &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h1 id="临时文件清理跟踪器"><a href="#临时文件清理跟踪器" class="headerlink" title="临时文件清理跟踪器"></a>临时文件清理跟踪器</h1><p>文件清理跟踪器仅适用于传统方式: 传统方式在处理文件之前将文件写入临时文件，这样的临时文件在我们上传任务完成时就成了垃圾，需要进行自动回收。Cmmons FileUpload当然也提供了这个功能，其运行原理：org.apache.commons.io.FileCleanerTracker开启一个收割线程，在DiskFileItem被垃圾回收器回收时，自动清理掉对应的临时文件。<br>要想开启文件自动清理功能，需要按照如下配置：</p>
<ul>
<li>在Servlet中我们应该在web.xml中配置一个Servlet监听器<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;listener&gt;</span><br><span class="line">  &lt;listener-class&gt;</span><br><span class="line">    org.apache.commons.fileupload.servlet.FileCleanerCleanup</span><br><span class="line">  &lt;/listener-class&gt;</span><br><span class="line">&lt;/listener&gt;</span><br></pre></td></tr></table></figure></li>
<li>创建org.apache.commons.io.FileCleaningTracker对象，设置给DiskFileItemFactory。</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">FileCleaningTracker fileCleaningTracker = FileCleanerCleanup.getFileCleaningTracker(context);</span><br><span class="line">DiskFileItemFactory factory = new DiskFileItemFactory();</span><br><span class="line">factory.setFileCleaningTracker(fileCleaningTracker);</span><br></pre></td></tr></table></figure>
<ul>
<li>然后就是按照我们之前学习的步骤正常操作即可</li>
</ul>
<p>要想禁用临时文件自动删除功能，可将FileCleaningTracker设置为null(其实默认就为null)</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">factory.setFileCleaningTracker(null);</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>工具</category>
      </categories>
      <tags>
        <tag>文件上传</tag>
      </tags>
  </entry>
  <entry>
    <title>Git基础知识</title>
    <url>/2018/02/15/Git%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86-git%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/</url>
    <content><![CDATA[<h2 id="GIT简介"><a href="#GIT简介" class="headerlink" title="GIT简介"></a>GIT简介</h2><ol>
<li>版本控制系统：即记录同一个文档在不同人和不同时间修改的各版本的系统，对于恢复文档、差异对比、协同工作有非常大的帮助。</li>
<li>GIT是由linux创始人linus花费两周时间写成的，用于托管linux系统。目前已经有众多开源项目，如jQuery、PHP、Ruby等。<span id="more"></span></li>
<li>集中式版本控制系统：以CVS、SVN为代表，版本库是集中存放在中央服务器的，在使用时候要先从服务器中取得最新版本，本地操作完成后还要上传给服务器，非常不方便，而且不安全。</li>
<li>分布式版本控制系统：以GIT为代表，没有集中式的中央服务器，每个人的电脑上都是一个完整的版本库，在工作完成之后只需要和其他同事交换修改的部分即可。具体工作方式还要实际体会。<br>分布式在本地维护一个完整的库，因此不需要联网也可以工作，等有网络时再把本地库推送到远程库即可。</li>
</ol>
<h2 id="基础知识"><a href="#基础知识" class="headerlink" title="基础知识"></a>基础知识</h2><ol>
<li><p>所有的版本控制系统只能跟踪文本文件的改动，如txt文件、网页、程序代码等，并且可以明确告诉你在什么地方改了什么。而图片、视频等二进制文件则没有办法跟踪其变化，只能告知文件的大小改变情况，但是不知道具体改了什么。而微软的word就是二进制格式，因此不能详细跟踪。<br>基于以上原因，使用GIT时，就要以纯文本方式编写文件。</p>
</li>
<li><p>为了长久性和通用性考虑，编写文本时一定要通通使用UTF-8编码。</p>
</li>
<li><p>老司机寄语：千万不要用windows自带的记事本编辑任何文本文件。<br>原因：记事本团队使用了一个非常弱智的行为来保存UTF-8编码的文件，他们自作聪明地在每个文件开头添加了0xefbbbf字符，对程序的编译之类的会造成错误。推荐使用Ntepad++</p>
</li>
<li><p>Git的版本会退速度很快，因为其内部有个指向当前版本的指针HEAD，回退或前进时只是改变了HEAD指向的位置。</p>
</li>
<li><p>工作区和暂存区<br>工作区：就是电脑上能够看到的目录（working directory）<br>版本库：工作区内有一个隐藏目录 .git，这是Gti的版本库<br>暂存区：Git的版本库中存了很多东西，最重要的就是成为stage（或者叫index）的缓存区。还有自动创建的第一个分支master，以及指向master的一个指针HEAD，如下图所示：</p>
<p> <img src="https://imgconvert.csdnimg.cn/aHR0cDovL2ltZy5ibG9nLmNzZG4ubmV0LzIwMTgwMjE1MTU0OTA5ODgy?x-oss-process=image/format,png" alt="工作区、缓存区、版本库的关系"></p>
<p> 执行git add时，就是把文件修改添加到了缓存区；</p>
<p> 执行git commit时，就是把缓存区的所有内容提交到当前分支。</p>
</li>
<li><p>git每次提交的是修改，不是整个文件，因此执行“第一次修改 -&gt; git add -&gt; 第二次修改 -&gt; git add -&gt; git commit”这样的操作后，第二次修改是不会被提交的，因为第二次修改没有添加到暂存区。</p>
</li>
<li><p>在创建远程仓库之前，由于git和github之间是通过SSH加密传输的，因此要先创建SSH Key<br><font color=#0000ff><i>ssh-keygen -t rsa -C “<a href="mailto:&#121;&#111;&#x75;&#x72;&#x65;&#x6d;&#97;&#x69;&#108;&#x40;&#101;&#x78;&#97;&#x6d;&#112;&#x6c;&#101;&#x2e;&#99;&#111;&#109;">&#121;&#111;&#x75;&#x72;&#x65;&#x6d;&#97;&#x69;&#108;&#x40;&#101;&#x78;&#97;&#x6d;&#112;&#x6c;&#101;&#x2e;&#99;&#111;&#109;</a>“</i></font><br>创建之后在用户主目录下面会生成两个文件：id_rsa、id_rsa.pub，其中id_rsa是私钥，不能泄露出去，id_rsa.pub是公钥，可以告诉任何人。<br>为什么要SSH Key?<br>因为github需要识别你推送的文件确实是你推送的，而不是别人冒充的，因此需要身份验证。也可任意添加多个Key，每个Key对应不同的电脑，添加之后你可以使用不同的电脑推送文件。<br>本地生成SSH Key后，需要在github的个人账户中添加该公钥，这样才能正常使用。</p>
</li>
<li><p>添加远程库时，在创建一个repository后github会提示进行本地库的添加，按照提示来就好。</p>
</li>
<li><p>本地库在推送或从远程库提取东西时，支持两种协议：https和ssh，相比而言，ssh的速度更快。</p>
</li>
<li><p><strong>分支的概念</strong><br>分支就是科幻电影中的平行宇宙，当你在学习Git时，另一个你在另一个平行宇宙学习SVN，正常时两个宇宙互不干扰，但在某一个时间点，两个宇宙合并了，你就及学会了Git，又会了SVN。<br>实际用途：开发新功能，需要两周，第一周写了50%，如果立刻提交，会导致代码库不完整，致使别人不能干活，如果等写完了再一起上传，又存在丢失每天进度的风险。有了分支后，可以创建一个专属于你的分支，别人看不到，你在自己的分支上工作，等工作完成后，再把你自己的分支一次性合并到原来的分支上。<br>git中维护方式：默认创建一个master分支，master分支指向提交，HEAD指向当前分支，默认是master，每次提交，master就向前移一步，随着不断提交，master分支的线越来越长。<br><img src="https://imgconvert.csdnimg.cn/aHR0cDovL2ltZy5ibG9nLmNzZG4ubmV0LzIwMTgwMjE1MTYwNTA3OTcx?x-oss-process=image/format,png" alt="这里写图片描述"><br>当创建新的分支时，Git新建一个指针dev，指向master相同指向的提交，再把HEAD指向dev，就表示当前分支在dev上。之后对工作区的修改和提交就是针对dev分支了，重新提交一次后，dev指针往前移动一步，而master指针不变。<br><img src="https://imgconvert.csdnimg.cn/aHR0cDovL2ltZy5ibG9nLmNzZG4ubmV0LzIwMTgwMjE1MTYwNjExNzA5?x-oss-process=image/format,png" alt="这里写图片描述"><br>此时要把dev合并到master上，最简单的方法就是将master指向dev的当前提交，完成合并。<br><img src="https://imgconvert.csdnimg.cn/aHR0cDovL2ltZy5ibG9nLmNzZG4ubmV0LzIwMTgwMjE1MTYwNjUzMjM2?x-oss-process=image/format,png" alt="这里写图片描述"><br>由于git的分支管理使用的是指针的方式，因此切换和合并起来操作非常快捷。同时<font color=red>鼓励使用分支进行工作</font>，工作完成后再合并到master上，这样有助于提升master的安全性。</p>
</li>
<li><p><strong>分支冲突</strong><br>当创建一个分支dev，并且提交了一个修改，同时切换到master上对同一文件进行了修改并提交，在合并分支时很可能会发生冲突，无法完成自动合并，此时只有手动解决冲突再提交才能继续合并。合并后时间线就变成如下。<br><img src="https://imgconvert.csdnimg.cn/aHR0cDovL2ltZy5ibG9nLmNzZG4ubmV0LzIwMTgwMjE1MTYwODM4ODg1?x-oss-process=image/format,png" alt="这里写图片描述"></p>
</li>
<li><p><strong>分支的非快速合并方式</strong><br>分支合并时，会默认使用ff(fast forward)模式进行合并，但这样带来的坏处是会丢掉分支信息。此时可以禁用ff模式，在merge时生成新的提交。<br>如下是ff模式<br><img src="https://imgconvert.csdnimg.cn/aHR0cDovL2ltZy5ibG9nLmNzZG4ubmV0LzIwMTgwMjE1MTYxMDAwMzg1?x-oss-process=image/format,png" alt="这里写图片描述"><br>如下是非ff模式<br><img src="https://imgconvert.csdnimg.cn/aHR0cDovL2ltZy5ibG9nLmNzZG4ubmV0LzIwMTgwMjE1MTYxMTM0Mzg5?x-oss-process=image/format,png" alt="这里写图片描述"></p>
</li>
<li><p><strong>分支策略</strong><br>实际开发中管理分支的几个基本原则（还是要开发中实际应用才会有体会，现在体会不深）<br>（1）master分支应该是稳定的，仅用来发布新版本，平时不能在上面干活<br>（2）干活都在新建的dev分支上，dev是不稳定的，到版本发布时再将dev分支合并到master上<br>（3）每个工作人员建立一个自己的分支，时不时在dev上进行合并就可以了。<br><img src="https://imgconvert.csdnimg.cn/aHR0cDovL2ltZy5ibG9nLmNzZG4ubmV0LzIwMTgwMjE1MTYxMTA5MjMw?x-oss-process=image/format,png" alt="这里写图片描述"></p>
</li>
<li><p><strong>BUG分支和feature分支</strong><br>当我们临时解决一个BUG，或者增加一个新功能时，最好新建一个分支，待完成工作后再将该分支合并到工作分支中。</p>
</li>
<li><p>当你从远程仓库克隆时，Git自动把本地master分支和远程的master分支对应起来，并且远程仓库的默认名称是origin。可以把本地的分支往远程推送，推送完成后远程库的分支结构就基本和本地一样了，但是也可以不必把所有的分支推送，这个要看实际需求。</p>
</li>
<li><p><strong>多人协作的情况（需要实际体会）</strong><br>（1）首先，可以试图用<font color=green><i>git push origin branch-name</i></font>推送自己的修改；<br>（2）如果推送失败，则因为远程分支比你的本地更新，需要先用<font color=green><i>git pull</i></font>抓取到本地试图合并；<br>（3）如果合并有冲突，则解决冲突，并在本地提交；<br>（4）没有冲突或者解决掉冲突后，再用<font color=green><i>git push origin branch-name</i></font>推送就能成功！<br>注意：如果git pull提示“no tracking information”，则说明本地分支和远程分支的链接关系没有创建，用命令<font color=green><i>git branch –set-upstream branch-name origin/branch-name。</i></font></p>
</li>
<li><p>标签<br>通常在版本库中打一个标签（tag），将来任何时候都可以按照标签名称来取某个时刻的历史版本。tag实际上是指向某个commit的指针，与分支不同的是，标签不能移动。可以理解为标签是固定在某一时刻的commit的指针。目的是能够很快地找到某一时刻的commit，而不用记复杂的commit id</p>
</li>
<li><p>在github上参与别人的开源项目</p>
<ul>
<li><p>访问项目主页，点击fork，在自己的账号下克隆一个相同的仓库。</p>
</li>
<li><p>按照正常克隆的方式从自己的账号下克隆到本地，此时开源项目、你的远程库和本地库关系如下。<br><img src="https://imgconvert.csdnimg.cn/aHR0cDovL2ltZy5ibG9nLmNzZG4ubmV0LzIwMTgwMjE1MTYxODA4NDk0?x-oss-process=image/format,png" alt="这里写图片描述"></p>
</li>
<li><p>本地修改后推送到自己账号的远程库</p>
</li>
<li><p>要想把自己修改的点推送给开源项目，可以在自己账号发起pull request。</p>
</li>
</ul>
</li>
<li><p>忽略特殊文件<br>有不想提交的文件时候，可以编写.gitignore文件，将不想提交的文件写到.gitignore文件中，这样在提交时候就会忽略该文件。注意文件名就是“.gitignore”，前面没有东西的。</p>
</li>
<li><p>添加.gitignore文件后没有效果解决办法<br>原因：.gitignore只能忽略那些原来没有被track的文件，如果某些文件已经被纳入了版本管理中，则修改.gitignore是无效的。解决的办法就是先把本地缓存删除，改成未track状态，然后提交。<br>（1）先将所有文件提交到Git<br>（2）在Git根目录执行以下命令<br><font color=green><i>git rm -r –cached .</i></font><br><font color=green><i>git add .</i></font><br><font color=green><i>git commit -m “fixed untracked files”.</i></font></p>
</li>
<li><p>配置<br>配置git时，加上–global是针对当前用户起作用的，如果不加就只对当前仓库起作用。<br>每个仓库的配置文件都放在.git/config中，对整个仓库起作用。<br>用户的配置恩见放在用户主目录下的一个隐藏文件/gitconfig中，对用户的所有仓库起作用<br>可以直接修改配置文件，如果改错了可以删掉文件重新通过命令进行配置。<br><font color=red>鼓励进行别名的配置。</font></p>
</li>
<li><p>自己搭建Git服务器<br>Git功能强大，但是github并不是必须的，他只是作为一个一直开着的服务器而已，且兼有社区的作用。如果想要自己的代码不开源，又要用Git，那么可以自己搭建一个Git服务器。搭建方式<a href="http://www.liaoxuefeng.com/wiki/0013739516305929606dd18361248578c67b8067c8c017b000/00137583770360579bc4b458f044ce7afed3df579123eca000">看这里</a></p>
</li>
<li><p>其它<br><a href="http://git-scm.com/">Git官方网站</a><br><a href="https://pan.baidu.com/s/1kU5OCOB#list/path=%2Fpub%2Fgit">Git cheat sheet</a></p>
</li>
</ol>
]]></content>
      <categories>
        <category>工具</category>
      </categories>
      <tags>
        <tag>Git</tag>
      </tags>
  </entry>
  <entry>
    <title>HTTP2重点PICK</title>
    <url>/2021/09/12/HTTP2%E9%87%8D%E7%82%B9PICK-http2-zhong-dian-pick/</url>
    <content><![CDATA[<blockquote>
<p>花了两天时间读完HTTP2的<a href="https://www.rfc-editor.org/rfc/pdfrfc/rfc7540.txt.pdf">RFC</a>，揭开HTTP2的神秘面纱，驱散心中迷雾，它比HTTP1.1，到底改变了什么。</p>
</blockquote>
<span id="more"></span>

<h2 id="这是一篇什么样的文章"><a href="#这是一篇什么样的文章" class="headerlink" title="这是一篇什么样的文章"></a>这是一篇什么样的文章</h2><p>这是一篇化繁为简的文章，只pick HTTP2中最为关键的部分，忽略细节实现部分。毕竟，每个人读一个文档的目的是不一样的。像我只是想从原理上理解，以便之后使用时能够更加顺畅；而如果是为了实现一个支持HTTP2的库，则需要抠细节，当然花费的时间肯定也不一样，那会是一遍一遍又一遍。</p>
<p>同时我也受够了网上花花绿绿的文章，它们，十之八九，乃基于数篇至数百篇咀嚼过的N手知识，稀碎拼凑而成。看完之后，给人似懂非懂，缺斤少两的感觉。当然，并不是在说人家不好，我也没那个资格，深以为，大家写文章、做总结，其受众非我等小明小红小丽，实为作者自己。认知闭合，学习金字塔，是公共的概念，也是大家的需求。写文章，也算是教授给他人的一种方式。</p>
<p>并不是说我这个文章就比别人的好，那也不见得。文章的好坏与否，取决于本身质量、表述方式等诸多因素。我写这篇文章，也更多是给今后的自己看，于其他人，和网上其它千百文章并无二致。大家并不会因为看了它对HTTP2变得更加了解，这不符合正常的学习曲线。</p>
<p>不过，硬要说的话，我还是可以推荐一篇写得好的HTTP2文章的，详尽，且带有实例讲解，文章基于RFC，同时查阅了很多其他资料，可说是长篇佳作。但它也有缺点，即没有重点，或重点过多。比如HTTP2的优势一节，服务端推送、应用层重置连接、优先级设置、流量控制等，未见得是优势，对理解来说并无关键作用。</p>
<p><a href="https://juejin.cn/post/6844903667569541133#heading-59">HTTP2详解</a></p>
<h2 id="HTTP2升级了什么"><a href="#HTTP2升级了什么" class="headerlink" title="HTTP2升级了什么"></a>HTTP2升级了什么</h2><p>HTTP1.x和HTTP1.1有几个主要的问题</p>
<ul>
<li>对同一地址的多次请求，会创建多个TCP连接。HTTP1.0自不必多说，每个请求就会创建一个连接；HTTP1.1虽有所优化，还引入了pipline技术，但也仅仅是将几个请求合并在一个连接，且pipline技术还会有管线头问题，即响应的顺序必须和请求的顺序一致，如果管线中第一个请求阻塞了，会导致同一管线中其它请求的阻塞，即请求之间互相影响了。</li>
<li>HTTP请求头多且重复，浪费带宽。</li>
</ul>
<p>HTTP2的解决方案，也是HTTP2的主要内容，说是所有内容也不为过</p>
<ul>
<li>针对第一个问题，HTTP2提供的解决方案是多路复用，同一地址只会建立一个连接，节省资源；引入Stream和帧，使得不同请求之间完全不干扰，提升传输效率。</li>
<li>针对请求头多的问题，HTTP2使用HPACK压缩算法，压缩掉重复的请求头。</li>
<li>还有一个额外的优化：服务端推送，它使得服务端可以自动发送预加载资源，而不必客户端主动请求。</li>
</ul>
<h2 id="先强调几个点"><a href="#先强调几个点" class="headerlink" title="先强调几个点"></a>先强调几个点</h2><ul>
<li>HTTP2是一个二进制协议，不像HTTP1.x那样是文本协议。</li>
<li>HTTP2的服务端推送，与WebSocket、SSE等完全不一样，只是为了更快地在浏览器和服务器之间传输数据，我们并不能随意操作。</li>
</ul>
<h2 id="HTTP2通信过程"><a href="#HTTP2通信过程" class="headerlink" title="HTTP2通信过程"></a>HTTP2通信过程</h2><p>在语义上，HTTP2继承了绝大部分HTTP1.1的内容，因此在使用时完全感觉不到，浏览器或者我们HTTP库自动做了升级操作，不信看我们的Ingress访问日志，相当一部分请求已经走的HTTP2协议了。</p>
<p><img src="https://gdz.oss-cn-shenzhen.aliyuncs.com/halo/image-20210912104305705.png" alt="image-20210912104305705"></p>
<p>总体来说，一个完整的通信过程包括：协议升级 -&gt; 数据分帧 -&gt; 发送 -&gt; 服务端组装帧 -&gt; 服务端逻辑处理并响应 -&gt; 数据分帧 -&gt; 发送 -&gt; 客户端组装帧 -&gt; 处理响应。</p>
<p>可以看到，相对HTTP1.x，多了两类步骤，其它的和之前的协议一样，怪不得我们感受不到。</p>
<ul>
<li>协议升级</li>
<li>数据分帧、合帧等中间操作</li>
</ul>
<h3 id="协议升级"><a href="#协议升级" class="headerlink" title="协议升级"></a>协议升级</h3><p>还记得WebSocket的升级方式吗？是一样的。</p>
<p>这样的请求</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line">GET / HTTP/1.1</span><br><span class="line">Host: server.example.com</span><br><span class="line">Connection: Upgrade, HTTP2-Settings</span><br><span class="line">Upgrade: h2c</span><br><span class="line">HTTP2-Settings: <span class="tag">&lt;<span class="name">base64url</span> <span class="attr">encoding</span> <span class="attr">of</span> <span class="attr">HTTP</span>/<span class="attr">2</span> <span class="attr">SETTINGS</span> <span class="attr">payload</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>升级成功就是这样的响应，然后就在同一个TCP连接上快乐地发送数据了</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line">HTTP/1.1 101 Switching Protocols</span><br><span class="line">Connection: Upgrade</span><br><span class="line">Upgrade: h2c</span><br></pre></td></tr></table></figure>

<p>请求头说明</p>
<ul>
<li>Upgrade：表明升级的目标是HTTP2协议。h2c是HTTP2从非加密通道升级时的标识符；加密通道则为h2</li>
<li>HTT2-Settings：关于HTTP2传输参数的配置，配置的参数包括请求头索引表大小、并发流的个数等</li>
</ul>
<h3 id="数据分帧、合帧"><a href="#数据分帧、合帧" class="headerlink" title="数据分帧、合帧"></a>数据分帧、合帧</h3><p>HTTP2是二进制帧，而为了兼容当前的HTTP语义，即请求-响应机制，HTTP请求、响应中又包含请求行、头部、body等，这些内容都会被封装成HTTP2的帧进行传输，到远端再重新合并，这里给出一个RFC中对一些请求的分帧示例。</p>
<img src="https://gdz.oss-cn-shenzhen.aliyuncs.com/halo/image-20210912111358587.png" alt="image-20210912111358587" style="zoom:80%;" />

<p>例子中的POST请求，共被分为三帧。</p>
<ul>
<li>HEADERS帧：将请求的方法、路径、scheme转换为伪头，封装进一个HEADER帧</li>
<li>CONTINUATION帧：这是作为上面那个HEADER的续帧，将请求的头部封装了进来</li>
<li>DATA帧：封装了该请求的请求体中的内容</li>
</ul>
<p>接收方按照分帧的方式进行合帧，就能得到原始数据</p>
<h2 id="关键点说明"><a href="#关键点说明" class="headerlink" title="关键点说明"></a>关键点说明</h2><p>表层看，通信过程就如上面讲的那样，但理解HTTP2的关键，要完全了解帧的概念，它是HTTP2数据传输的最小单位；要了解流的概念，它是实现多路复用的最关键技术；要了解头部压缩，它是实现带宽节省的关键技术。此外，还有两个点我忽略掉了，他们并不会给理解带来任何阻碍：流控和流的优先级</p>
<h3 id="帧"><a href="#帧" class="headerlink" title="帧"></a>帧</h3><p>帧在整个协议栈中的位置如下：</p>
<img src="https://gdz.oss-cn-shenzhen.aliyuncs.com/halo/image-20210912115557314.png" alt="image-20210912115557314" style="zoom:80%;" />

<p>这就是HTTP2的帧结构，其实挺简单</p>
<img src="https://gdz.oss-cn-shenzhen.aliyuncs.com/halo/image-20210912112208591.png" alt="image-20210912112208591" style="zoom:80%;" />

<table>
<thead>
<tr>
<th>字段名</th>
<th>字段说明</th>
</tr>
</thead>
<tbody><tr>
<td>Length</td>
<td>帧的载荷长度</td>
</tr>
<tr>
<td>Type</td>
<td>帧类型</td>
</tr>
<tr>
<td>Flags</td>
<td>标记位，不同的帧类型会使用到不同的标记位</td>
</tr>
<tr>
<td>Stream ID</td>
<td>流ID</td>
</tr>
</tbody></table>
<p>帧类型大概有这么多（忽略了流控（WINDOW_UPADTE）和优先级（PRIORITY）两个类型）</p>
<table>
<thead>
<tr>
<th>帧类型</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>DATA</td>
<td>数据帧</td>
</tr>
<tr>
<td>HEADERS</td>
<td>头部帧，用于开启一个流</td>
</tr>
<tr>
<td>CONTINUATION</td>
<td>作为HEADERS帧的续帧</td>
</tr>
<tr>
<td>RST_STREAM</td>
<td>复位帧，用于中止一个流，当流发生错误时发送。<br />用它只会中止流，对连接上的其它流没有影响</td>
</tr>
<tr>
<td>SETTINGS</td>
<td>设置帧，用于在数据发送交流通信参数</td>
</tr>
<tr>
<td>PUSH_PROMISE</td>
<td>服务端推送帧，服务端发往客户端，表明服务端将要有数据推送下来，客户端等着</td>
</tr>
<tr>
<td>PING</td>
<td>注意这不是心跳，而是测量一个请求-响应完成时间的帧</td>
</tr>
<tr>
<td>GOAWAY</td>
<td>整个连接关闭前发送的帧，该帧携带了远端处理成功的最后一个流ID，以便接收方做优雅关闭</td>
</tr>
</tbody></table>
<p>这么多帧，数据相关的帧只有前三种，其它都是控制帧。</p>
<h3 id="多路复用（Stream、Frame）"><a href="#多路复用（Stream、Frame）" class="headerlink" title="多路复用（Stream、Frame）"></a>多路复用（Stream、Frame）</h3><p>三张图对比最原始的HTTP请求响应、pipeline、HTTP多路复用的区别。</p>
<img src=" https://gdz.oss-cn-shenzhen.aliyuncs.com/halo/image-20210912114949108.png" alt="image-20210912114949108" style="zoom:80%;" />

<p>解读</p>
<ul>
<li><p>无pipeline时，一个HTTP请求必须等待上一个请求响应完成后才可进行，完全串行</p>
</li>
<li><p>有pipeline时，请求可以不等待响应直接发送了，但是响应的顺序和请求的顺序必须完全一致。如果第一个请求响应很慢，会阻塞其它两个请求。</p>
<p>这个，顶多相当于批量执行。</p>
</li>
<li><p>多路复用时，与pipeline的区别，是响应之间互不干涉，随便怎么发都行。</p>
</li>
</ul>
<p><strong>怎么理解多路复用</strong></p>
<p>多路：其实指的是请求与响应两路；也可以理解为一个请求响应理解为一路，多个请求连接复用一个连接。</p>
<p>复用：即同一个TCP连接，可以同时传输请求与响应的数据，数据之间互不干扰。这在之前可是不行的哦。</p>
<p><strong>如何实现</strong></p>
<p>多路复用，是帧（Frame）和流（Stream）共同作用的结果。</p>
<ul>
<li>帧有两个作用：一是可以携带额外的控制参数，如流ID；二是拆分数据包</li>
<li>流则是一个逻辑上的抽象：一个TCP连接上所承载的数据，通过流进行逻辑识别。应用到HTTP语义的协议上，一个请求对应一个流，而TCP连接上胡乱交叉的请求与响应的数据帧才能被正确识别，因为有唯一识别符——流ID嘛</li>
</ul>
<p>比如下面这个图，如果stream 3这两帧被服务端处理完后，服务端发送响应，只需要将响应帧的流也标识为stream 3，这样，无乱什么时候发过来，客户端都知道这个响应对应的是原来stream 3发出去的那个请求。</p>
<img src=" https://gdz.oss-cn-shenzhen.aliyuncs.com/halo/image-20210912120902351.png" alt="image-20210912120902351" style="zoom:80%;" />

<p><strong>HTTP1.1为什么不做多路复用</strong></p>
<p>这是交付模型的直接结果，HTTP1.x还是直接的请求-响应模型，如果顺序打乱，将无法在茫茫请求中找到将发送的响应到底属于哪个请求，客户端在接收方也无法区分出收到的这个响应到底是哪个请求发送出去的。而HTTP2不一样，每个请求都被对应一个Stream（流），流有ID，逻辑上只要保证流内部的帧顺序不出错即可，至于响应，无论什么时候，我处理完的请求发送回去只要带流ID即可，客户端知道这个流ID对应的请求是谁。</p>
<p><strong>流多说两点</strong></p>
<p>HTTP2中的流，是一个逻辑概念，即拥有连续帧的抽象。关于流，有几个注意事项</p>
<ul>
<li>一个流内部，帧之间的顺序是绝对的，不然收到之后组装不回去，会报错的</li>
<li>流可以指定优先级，优先级高的流会被优先处理，这在资源有限时会比较有用</li>
</ul>
<h3 id="头部编排和压缩"><a href="#头部编排和压缩" class="headerlink" title="头部编排和压缩"></a>头部编排和压缩</h3><p>HTTP2的HEADERS帧并不直接对应HTTP1.x语义的头部哦，有没有发现HTTP2并没有为请求行和状态行这些HTTP1.x语义的内容留专门的定义，事实上确实没有，因此在进行HTTP1.x数据传输时，需要先做头部编排。</p>
<p>其中最重要的是将请求行编排为<strong>伪头</strong>，以冒号开头，具体来说</p>
<table>
<thead>
<tr>
<th>伪头</th>
<th>举例</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>:method</td>
<td>GET</td>
<td>方法</td>
</tr>
<tr>
<td>:scheme</td>
<td>https</td>
<td>协议</td>
</tr>
<tr>
<td>:host</td>
<td>api.wemore.com</td>
<td>主机地址</td>
</tr>
<tr>
<td>:path</td>
<td>/resource</td>
<td>资源路径</td>
</tr>
</tbody></table>
<p>至于压缩，HTTP2采用HPACK压缩算法，即构建一个索引表，将传输过的头部存入表中，下次传输时，如果头部已经在表中，则传索引号即可，否则传输实际请求头。需要注意的是，这个索引表是针对整个连接都有效的，所以能够跨Stream使用。</p>
<p>如下，第一个请求时，传输完整的头部，第二次请求时，仅有一个头部不一样，因此只传输这个头部即可，其它头部传索引（图中没画出来）。</p>
<img src=" https://gdz.oss-cn-shenzhen.aliyuncs.com/halo/image-20210912114305063.png" alt="image-20210912114305063" style="zoom:80%;" />

<h3 id="服务端推送"><a href="#服务端推送" class="headerlink" title="服务端推送"></a>服务端推送</h3><p>相信我，它并不是你想象的那个样子。</p>
<p>我刚开始想象的样子：有了HTTP2，我们将不再需要WebSocket，因为它是长连接，也是支持服务端主动发送数据。</p>
<p>但我想多了，看<a href="https://developers.google.com/web/fundamentals/performance/http2#%E6%9C%8D%E5%8A%A1%E5%99%A8%E6%8E%A8%E9%80%81">这里</a>可以了解到，HTTP2所谓的服务端推送，只是打破了一个请求对应一个响应的语义，只有有限场景能够用到，即服务端知道客户端将要请求什么数据，比如服务端返回一个网页，网页内嵌了很多图片、css、js等静态资源，按照以往的规则，都是要等待客户端发起推送的，但现在不一样，服务端可以告诉客户端：你先等着，我还有数据要发给你。</p>
<p><strong>实现方式</strong></p>
<p>服务端发送PUSH_PROMISE帧，客户端收到之后，不关闭流，而是待机等待。</p>
<p><strong>应用范围</strong></p>
<p>目前还很窄，nginx支持简单的静态资源推送，如下</p>
<figure class="highlight nginx"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 这表明访问index.html时，服务端会主动推送下面这些静态文件</span></span><br><span class="line"><span class="attribute">location</span> = /index.html &#123;</span><br><span class="line">  <span class="attribute">http2_push</span> /css/style.css;</span><br><span class="line">  <span class="attribute">http2_push</span> /js/main.js;</span><br><span class="line">  <span class="attribute">http2_push</span> /img/yule.jpg;</span><br><span class="line">  <span class="attribute">http2_push</span> /img/avatar.jpg;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>其它场景应用也不是很多，主要还是对资源加载的优化，并不像WebSocket那样，完全将客户端-服务端之间数据传输的控制权完全交给用户。</p>
<h2 id="抓个包看一下"><a href="#抓个包看一下" class="headerlink" title="抓个包看一下"></a>抓个包看一下</h2><p>主要抓包有三种方式，网上搜一搜就知道了</p>
<ul>
<li>chrome：并不能通过控制台看到HTTP2的通信过程，而是要通过特殊的工具：chrome://net-internals/#http2</li>
<li><a href="https://github.com/nghttp2/nghttp2">nghttp2</a>：一个开源命令行工具，能够抓取一个网站的HTTP2完整的通信过程</li>
<li><a href="https://www.cnblogs.com/jesse131/p/12686304.html">wireshark</a>：TCP抓包工具，但是要抓HTTP2包需要先配置秘钥，配置方式和Charles等不一样：Charles是伪造TLS证书，wireshark是窃取TLS握手成功后交换的对称秘钥</li>
</ul>
<p>我用nghttp2抓了一个nghttp2.org网站的包，可以看到大致流程</p>
<ul>
<li>建立连接，协议升级，https内标识：h2</li>
<li>发送SETTINGS帧，设置的内容有<ul>
<li>客户端流最大并发度：100</li>
<li>客户端的流控窗口初始值：65535</li>
</ul>
</li>
<li>发送PRIORITY帧，分别设置了流3、5、7、9、11、13的优先级（weight），依赖关系（dep_stream_id），流优先级及依赖关系请自行参考RFC</li>
<li>发送HEADERS帧，对GET <a href="https://nghttp2.org进行访问/">https://nghttp2.org进行访问</a></li>
<li>收到服务端发来的SETTINGS帧，设置的内容有<ul>
<li>服务端流最大并发度：100</li>
<li>服务端流控窗口初始值：1048576</li>
<li>请求头索引表大小：8192</li>
</ul>
</li>
<li>收到服务端对之前SETTINGS帧的ACK响应（这是ACK可靠传输的机制，参见RFC）</li>
<li>收到PUSH_PROMISE帧，服务端即将推送screen.css帧给我们</li>
<li>发送对之前服务端SETTINGS帧的ACK响应</li>
<li>收到DATA帧，即传输内容</li>
<li>处理处理完收到的内容后，本地处理能力有所变化，发送WINDOW_UPDATE帧给客户端，通知对方调整流控窗口</li>
<li>收到带有END_STREAM标记的DATA帧，表明数据传输完成</li>
<li>发送GOAWAY帧，告诉客户端连接即将关闭，同时告知上一个成功的流ID为2，且没有任何错误，方便服务端进行优雅地关闭。</li>
</ul>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">zouguodong@zouguodongdeMacBook-Pro ~ % nghttp -nv https://nghttp2.org/</span><br><span class="line">[  0.228] Connected</span><br><span class="line">The negotiated protocol: h2</span><br><span class="line">[  0.358] send SETTINGS frame &lt;length=12, flags=0x00, stream_id=0&gt;</span><br><span class="line">          (niv=2)</span><br><span class="line">          [SETTINGS_MAX_CONCURRENT_STREAMS(0x03):100]</span><br><span class="line">          [SETTINGS_INITIAL_WINDOW_SIZE(0x04):65535]</span><br><span class="line">[  0.358] send PRIORITY frame &lt;length=5, flags=0x00, stream_id=3&gt;</span><br><span class="line">          (dep_stream_id=0, weight=201, exclusive=0)</span><br><span class="line">[  0.358] send PRIORITY frame &lt;length=5, flags=0x00, stream_id=5&gt;</span><br><span class="line">          (dep_stream_id=0, weight=101, exclusive=0)</span><br><span class="line">[  0.358] send PRIORITY frame &lt;length=5, flags=0x00, stream_id=7&gt;</span><br><span class="line">          (dep_stream_id=0, weight=1, exclusive=0)</span><br><span class="line">[  0.358] send PRIORITY frame &lt;length=5, flags=0x00, stream_id=9&gt;</span><br><span class="line">          (dep_stream_id=7, weight=1, exclusive=0)</span><br><span class="line">[  0.358] send PRIORITY frame &lt;length=5, flags=0x00, stream_id=11&gt;</span><br><span class="line">          (dep_stream_id=3, weight=1, exclusive=0)</span><br><span class="line">[  0.358] send HEADERS frame &lt;length=36, flags=0x25, stream_id=13&gt;</span><br><span class="line">          ; END_STREAM | END_HEADERS | PRIORITY</span><br><span class="line">          (padlen=0, dep_stream_id=11, weight=16, exclusive=0)</span><br><span class="line">          ; Open new stream</span><br><span class="line">          :method: GET</span><br><span class="line">          :path: /</span><br><span class="line">          :scheme: https</span><br><span class="line">          :authority: nghttp2.org</span><br><span class="line">          accept: */*</span><br><span class="line">          accept-encoding: gzip, deflate</span><br><span class="line">          user-agent: nghttp2/1.43.0</span><br><span class="line">[  0.474] recv SETTINGS frame &lt;length=24, flags=0x00, stream_id=0&gt;</span><br><span class="line">          (niv=4)</span><br><span class="line">          [SETTINGS_MAX_CONCURRENT_STREAMS(0x03):100]</span><br><span class="line">          [SETTINGS_INITIAL_WINDOW_SIZE(0x04):1048576]</span><br><span class="line">          [SETTINGS_ENABLE_CONNECT_PROTOCOL(0x08):1]</span><br><span class="line">          [SETTINGS_HEADER_TABLE_SIZE(0x01):8192]</span><br><span class="line">[  0.475] recv SETTINGS frame &lt;length=0, flags=0x01, stream_id=0&gt;</span><br><span class="line">          ; ACK</span><br><span class="line">          (niv=0)</span><br><span class="line">[  0.475] recv (stream_id=13) :method: GET</span><br><span class="line">[  0.475] recv (stream_id=13) :scheme: https</span><br><span class="line">[  0.475] recv (stream_id=13) :path: /stylesheets/screen.css</span><br><span class="line">[  0.475] recv (stream_id=13) :authority: nghttp2.org</span><br><span class="line">[  0.475] recv (stream_id=13) accept-encoding: gzip, deflate</span><br><span class="line">[  0.475] recv (stream_id=13) user-agent: nghttp2/1.43.0</span><br><span class="line">[  0.475] recv PUSH_PROMISE frame &lt;length=47, flags=0x04, stream_id=13&gt;</span><br><span class="line">          ; END_HEADERS</span><br><span class="line">          (padlen=0, promised_stream_id=2)</span><br><span class="line">[  0.475] send SETTINGS frame &lt;length=0, flags=0x01, stream_id=0&gt;</span><br><span class="line">          ; ACK</span><br><span class="line">          (niv=0)</span><br><span class="line">[  0.673] recv (stream_id=13) :status: 200</span><br><span class="line">[  0.673] recv (stream_id=13) date: Sun, 12 Sep 2021 04:53:16 GMT</span><br><span class="line">[  0.673] recv (stream_id=13) content-type: text/html</span><br><span class="line">[  0.673] recv (stream_id=13) last-modified: Sun, 18 Jul 2021 04:17:59 GMT</span><br><span class="line">[  0.673] recv (stream_id=13) etag: <span class="string">&quot;60f3ab77-19d8&quot;</span></span><br><span class="line">[  0.673] recv (stream_id=13) accept-ranges: bytes</span><br><span class="line">[  0.673] recv (stream_id=13) content-length: 6616</span><br><span class="line">[  0.673] recv (stream_id=13) x-backend-header-rtt: 0.001926</span><br><span class="line">[  0.673] recv (stream_id=13) strict-transport-security: max-age=31536000</span><br><span class="line">[  0.673] recv (stream_id=13) server: nghttpx</span><br><span class="line">[  0.673] recv (stream_id=13) alt-svc: h3=<span class="string">&quot;:443&quot;</span>; ma=3600</span><br><span class="line">[  0.673] recv (stream_id=13) via: 2 nghttpx</span><br><span class="line">[  0.673] recv (stream_id=13) x-frame-options: SAMEORIGIN</span><br><span class="line">[  0.673] recv (stream_id=13) x-xss-protection: 1; mode=block</span><br><span class="line">[  0.673] recv (stream_id=13) x-content-type-options: nosniff</span><br><span class="line">[  0.673] recv HEADERS frame &lt;length=235, flags=0x04, stream_id=13&gt;</span><br><span class="line">          ; END_HEADERS</span><br><span class="line">          (padlen=0)</span><br><span class="line">          ; First response header</span><br><span class="line">[  0.673] recv (stream_id=2) :status: 200</span><br><span class="line">[  0.673] recv (stream_id=2) date: Sun, 12 Sep 2021 04:53:16 GMT</span><br><span class="line">[  0.673] recv (stream_id=2) content-type: text/css</span><br><span class="line">[  0.674] recv (stream_id=2) last-modified: Sun, 18 Jul 2021 04:17:59 GMT</span><br><span class="line">[  0.674] recv (stream_id=2) etag: <span class="string">&quot;60f3ab77-98aa&quot;</span></span><br><span class="line">[  0.674] recv (stream_id=2) accept-ranges: bytes</span><br><span class="line">[  0.674] recv (stream_id=2) content-length: 39082</span><br><span class="line">[  0.674] recv (stream_id=2) x-backend-header-rtt: 0.002213</span><br><span class="line">[  0.674] recv (stream_id=2) strict-transport-security: max-age=31536000</span><br><span class="line">[  0.674] recv (stream_id=2) server: nghttpx</span><br><span class="line">[  0.674] recv (stream_id=2) alt-svc: h3=<span class="string">&quot;:443&quot;</span>; ma=3600</span><br><span class="line">[  0.674] recv (stream_id=2) via: 2 nghttpx</span><br><span class="line">[  0.674] recv (stream_id=2) x-frame-options: SAMEORIGIN</span><br><span class="line">[  0.674] recv (stream_id=2) x-xss-protection: 1; mode=block</span><br><span class="line">[  0.674] recv (stream_id=2) x-content-type-options: nosniff</span><br><span class="line">[  0.674] recv (stream_id=2) x-http2-push: 1</span><br><span class="line">[  0.674] recv HEADERS frame &lt;length=63, flags=0x04, stream_id=2&gt;</span><br><span class="line">          ; END_HEADERS</span><br><span class="line">          (padlen=0)</span><br><span class="line">          ; First push response header</span><br><span class="line">[  0.674] recv DATA frame &lt;length=6616, flags=0x01, stream_id=13&gt;</span><br><span class="line">          ; END_STREAM</span><br><span class="line">[  0.674] recv DATA frame &lt;length=9434, flags=0x00, stream_id=2&gt;</span><br><span class="line">[  0.763] recv DATA frame &lt;length=14467, flags=0x00, stream_id=2&gt;</span><br><span class="line">[  0.851] recv DATA frame &lt;length=2623, flags=0x00, stream_id=2&gt;</span><br><span class="line">[  0.851] recv DATA frame &lt;length=2623, flags=0x00, stream_id=2&gt;</span><br><span class="line">[  0.852] recv DATA frame &lt;length=2623, flags=0x00, stream_id=2&gt;</span><br><span class="line">[  0.852] recv DATA frame &lt;length=2623, flags=0x00, stream_id=2&gt;</span><br><span class="line">[  0.852] send WINDOW_UPDATE frame &lt;length=4, flags=0x00, stream_id=0&gt;</span><br><span class="line">          (window_size_increment=33140)</span><br><span class="line">[  0.852] send WINDOW_UPDATE frame &lt;length=4, flags=0x00, stream_id=2&gt;</span><br><span class="line">          (window_size_increment=34393)</span><br><span class="line">[  0.943] recv DATA frame &lt;length=2623, flags=0x00, stream_id=2&gt;</span><br><span class="line">[  0.964] recv DATA frame &lt;length=2066, flags=0x01, stream_id=2&gt;</span><br><span class="line">          ; END_STREAM</span><br><span class="line">[  0.964] send GOAWAY frame &lt;length=8, flags=0x00, stream_id=0&gt;</span><br><span class="line">          (last_stream_id=2, error_code=NO_ERROR(0x00), opaque_data(0)=[])</span><br></pre></td></tr></table></figure>

<h2 id="请注意"><a href="#请注意" class="headerlink" title="请注意"></a>请注意</h2><p>HTTP2是一个二进制协议，Stream、分帧等行为，并不具有更多语义上的意义（尽管帧类型规定是那些，但帧类型是可扩展的，协议也留出了扩展空间），也就是说，它能被用在其它应用场景下，比如GRPC</p>
]]></content>
      <categories>
        <category>网络基础</category>
      </categories>
      <tags>
        <tag>HTTP2</tag>
      </tags>
  </entry>
  <entry>
    <title>Docker速记 - Dockerfile</title>
    <url>/2021/12/05/Dockerfile/</url>
    <content><![CDATA[<p>本文介绍Dockerfile中主要命令的用途</p>
<span id="more"></span>

<h2 id="FROM"><a href="#FROM" class="headerlink" title="FROM"></a>FROM</h2><p>指定基础镜像，推荐的方式是 image:tag，精确指定。注意：可以使用多条FROM，这样就会构建多个镜像。</p>
<p>比如我同时想要busybox和nginx，我可以这么写</p>
<figure class="highlight dockerfile"><table><tr><td class="code"><pre><span class="line"><span class="keyword">FROM</span> busybox:latest</span><br><span class="line"><span class="keyword">FROM</span> nginx:latest</span><br></pre></td></tr></table></figure>

<p>然后构建运行</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 构建</span></span><br><span class="line">root@10-9-175-15:/home/ubuntu/docker-learn$ docker build -t busybox-nginx .</span><br><span class="line">Sending build context to Docker daemon  40.96kB</span><br><span class="line"><span class="meta">#</span><span class="bash"> layer 1</span></span><br><span class="line">Step 1/2 : FROM busybox</span><br><span class="line"><span class="meta"> ---&gt;</span><span class="bash"> d23834f29b38</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> layer 2</span></span><br><span class="line">Step 2/2 : FROM nginx</span><br><span class="line">latest: Pulling from library/nginx</span><br><span class="line">e5ae68f74026: Pull complete </span><br><span class="line">21e0df283cd6: Pull complete </span><br><span class="line">ed835de16acd: Pull complete </span><br><span class="line">881ff011f1c9: Pull complete </span><br><span class="line">77700c52c969: Pull complete </span><br><span class="line">44be98c0fab6: Pull complete </span><br><span class="line">Digest: sha256:9522864dd661dcadfd9958f9e0de192a1fdda2c162a35668ab6ac42b465f0603</span><br><span class="line">Status: Downloaded newer image for nginx:latest</span><br><span class="line"><span class="meta"> ---&gt;</span><span class="bash"> f652ca386ed1</span></span><br><span class="line">Successfully built f652ca386ed1</span><br><span class="line">Successfully tagged busybox-nginx:latest</span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 我们运行它，并进入shell</span></span><br><span class="line">root@10-9-175-15:/home/ubuntu/docker-learn$ docker run -it f652ca386ed1 sh</span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 查看nginx，没错，在的</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> nginx -v</span></span><br><span class="line">nginx version: nginx/1.21.4</span><br></pre></td></tr></table></figure>

<h2 id="ENV和ARG"><a href="#ENV和ARG" class="headerlink" title="ENV和ARG"></a>ENV和ARG</h2><p>ENV为创建出来的容器声明环境变量。该环境变量在启动的容器中可用，在特定的指令中也能够使用，这些指令包括ENV、ADD、COPY、WORKDIR、EXPOSE、VOLUME、USER。</p>
<p>ARG类似，但它声明的变量只能在Dockerfile中使用，不能再启动的容器中使用。</p>
<p>我们做个实验，在docker build过程中输出定义的环境变量，在容器中输出该环境变量</p>
<figure class="highlight dockerfile"><table><tr><td class="code"><pre><span class="line"><span class="keyword">FROM</span> busybox</span><br><span class="line">  </span><br><span class="line"><span class="keyword">ENV</span> ENVTEST=<span class="string">&quot;hello,world&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">RUN</span><span class="bash"> <span class="built_in">echo</span> <span class="variable">$ENVTEST</span></span></span><br></pre></td></tr></table></figure>

<p>然后构建运行</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">root@10-9-175-15:/home/ubuntu/docker-learn$ docker build -t busybox-env .</span><br><span class="line">Sending build context to Docker daemon  40.96kB</span><br><span class="line"><span class="meta">#</span><span class="bash"> layer 1</span></span><br><span class="line">Step 1/3 : FROM busybox</span><br><span class="line"><span class="meta"> ---&gt;</span><span class="bash"> d23834f29b38</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> layer 2</span></span><br><span class="line">Step 2/3 : ENV ENVTEST=&quot;hello,world&quot;</span><br><span class="line"><span class="meta"> ---&gt;</span><span class="bash"> Running <span class="keyword">in</span> 4e20395f2f9a</span></span><br><span class="line">Removing intermediate container 4e20395f2f9a</span><br><span class="line"><span class="meta"> ---&gt;</span><span class="bash"> 79a34075b8ca</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> layer 3</span></span><br><span class="line">Step 3/3 : RUN echo $ENVTEST</span><br><span class="line"><span class="meta"> ---&gt;</span><span class="bash"> Running <span class="keyword">in</span> 3a9ca99e38c6</span></span><br><span class="line">hello,world</span><br><span class="line">Removing intermediate container 3a9ca99e38c6</span><br><span class="line"><span class="meta"> ---&gt;</span><span class="bash"> 79b312023015</span></span><br><span class="line">Successfully built 79b312023015</span><br><span class="line">Successfully tagged busybox-env:latest</span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 运行起来</span></span><br><span class="line">root@10-9-175-15:/home/ubuntu/docker-learn$ docker run -it --name busybox-env busybox-env sh</span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 打印上面设置的环境变量</span></span><br><span class="line">/ $ env | grep ENVTEST</span><br><span class="line">ENVTEST=hello,world</span><br></pre></td></tr></table></figure>

<h2 id="RUN"><a href="#RUN" class="headerlink" title="RUN"></a>RUN</h2><p>RUN会在前一条命令创建出来的镜像的基础上创建一个容器，并在容器中运行命令，结束后将容器提交为新的镜像，新镜像作为下一条命令的基础。</p>
<p>RUN有两种格式</p>
<figure class="highlight dockerfile"><table><tr><td class="code"><pre><span class="line"><span class="comment"># shell格式，通过/bin/sh -c运行的</span></span><br><span class="line"><span class="keyword">RUN</span><span class="bash"> ls -a -l</span></span><br><span class="line"><span class="comment"># exec格式，直接运行可执行文件，后面跟的参数</span></span><br><span class="line"><span class="keyword">RUN</span><span class="bash"> [<span class="string">&quot;ls&quot;</span>, <span class="string">&quot;-a&quot;</span>, <span class="string">&quot;-l&quot;</span>]</span></span><br></pre></td></tr></table></figure>

<p>几个注意点</p>
<ul>
<li>推荐使用exec格式。</li>
<li>exec格式中，<code>[&quot;ls&quot;, &quot;-a&quot;, &quot;-l&quot;]</code>会被Docker当成json数组解析，因此必须使用双引号</li>
<li>exec格式中，由于没有使用sh运行，因此环境变量是不会被解析的，除非你的可执行文件指的就是sh，即<code>[&quot;sh&quot;, &quot;-c&quot;, &quot;ls&quot;, &quot;-al&quot;]</code></li>
</ul>
<p>这里就不演示了，在ENV我们演示过了，截取片段：如下，启动的临时容器id为3a9ca99e38c6，运行了echo后移除了该容器，并生成了id为79b312023015的层。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">Step 3/3 : RUN echo $ENVTEST</span><br><span class="line"><span class="meta"> ---&gt;</span><span class="bash"> Running <span class="keyword">in</span> 3a9ca99e38c6</span></span><br><span class="line">hello,world</span><br><span class="line">Removing intermediate container 3a9ca99e38c6</span><br><span class="line"><span class="meta"> ---&gt;</span><span class="bash"> 79b312023015</span></span><br></pre></td></tr></table></figure>

<h2 id="COPY和ADD"><a href="#COPY和ADD" class="headerlink" title="COPY和ADD"></a>COPY和ADD</h2><p>这两个很相似，它们的共同点是：作用在本地文件时候，都是普通的复制关系，即将本地文件或文件夹复制到新镜像中；不同点是，ADD额外增加了两个功能，当源文件是URL时，它会下载下来，然后放到镜像中，当源文件是本地压缩文件时，它能将该文件解压然后复制到镜像中。</p>
<p>一般来说推荐使用COPY，因为它更方便理解。能用ADD的地方，完全可以用RUN加上wget或的命令完成。下面演示</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">FROM busybox</span><br><span class="line">  </span><br><span class="line">ENV ENVTEST=&quot;hello,world&quot;</span><br><span class="line"></span><br><span class="line">RUN echo $ENVTEST</span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 镜像中创建/data/<span class="built_in">test</span>文件夹</span></span><br><span class="line">RUN mkdir -p /data/test</span><br><span class="line"><span class="meta">#</span><span class="bash"> 当前目录的Dockerfile复制进来</span></span><br><span class="line">COPY ./Dockerfile /data/test/</span><br><span class="line"><span class="meta">#</span><span class="bash"> namespace.c复制进来</span></span><br><span class="line">ADD ./namespace.c /data/test/</span><br><span class="line"><span class="meta">#</span><span class="bash"> 远程下载一个文件然后复制进来</span></span><br><span class="line">ADD https://github.com/moby/moby/blob/master/client/client.go /data/test/</span><br><span class="line"><span class="meta">#</span><span class="bash"> 本地压缩文件解压然后复制进来</span></span><br><span class="line">ADD ./test.tar.gz /data/test/</span><br></pre></td></tr></table></figure>

<p>验证</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">root@10-9-175-15:/home/ubuntu/docker-learn# docker build -t busybox-add-copy .</span><br><span class="line">Sending build context to Docker daemon  25.09kB</span><br><span class="line">Step 1/8 : FROM busybox</span><br><span class="line"><span class="meta"> ---&gt;</span><span class="bash"> d23834f29b38</span></span><br><span class="line">Step 2/8 : ENV ENVTEST=&quot;hello,world&quot;</span><br><span class="line"><span class="meta"> ---&gt;</span><span class="bash"> Using cache</span></span><br><span class="line"><span class="meta"> ---&gt;</span><span class="bash"> 79a34075b8ca</span></span><br><span class="line">Step 3/8 : RUN echo $ENVTEST</span><br><span class="line"><span class="meta"> ---&gt;</span><span class="bash"> Using cache</span></span><br><span class="line"><span class="meta"> ---&gt;</span><span class="bash"> 79b312023015</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 创建目录</span></span><br><span class="line">Step 4/8 : RUN mkdir -p /data/test</span><br><span class="line"><span class="meta"> ---&gt;</span><span class="bash"> Running <span class="keyword">in</span> 221ac6587f2e</span></span><br><span class="line">Removing intermediate container 221ac6587f2e</span><br><span class="line"><span class="meta"> ---&gt;</span><span class="bash"> 4e3602a7ab46</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 复制</span></span><br><span class="line">Step 5/8 : COPY ./Dockerfile /data/test/</span><br><span class="line"><span class="meta"> ---&gt;</span><span class="bash"> ad3cb3d4e974</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 复制</span></span><br><span class="line">Step 6/8 : ADD ./namespace.c /data/test/</span><br><span class="line"><span class="meta"> ---&gt;</span><span class="bash"> 057dfbef575c</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 下载</span></span><br><span class="line">Step 7/8 : ADD https://github.com/moby/moby/blob/master/client/client.go /data/test/</span><br><span class="line">Downloading  283.9kB</span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta"> ---&gt;</span><span class="bash"> 587b68473628</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 解压</span></span><br><span class="line">Step 8/8 : ADD ./test.tar.gz /data/test/</span><br><span class="line"><span class="meta"> ---&gt;</span><span class="bash"> 908872aeb387</span></span><br><span class="line">Successfully built 908872aeb387</span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 启动容器</span></span><br><span class="line">root@10-9-175-15:/home/ubuntu/docker-learn# docker run -it --name busybox-add-copy busybox-add-copy sh</span><br><span class="line"><span class="meta">#</span><span class="bash"> 跳转到目标目录下，查看</span></span><br><span class="line">/ # cd data/test/</span><br><span class="line">/data/test # ls</span><br><span class="line">Dockerfile   client.go    namespace.c  namespace.o</span><br></pre></td></tr></table></figure>

<p>可以看到</p>
<ul>
<li>Dockerfile被复制进来了</li>
<li>namespace.c被复制进来了</li>
<li>client.go被下载然后复制进来了</li>
<li>test.tar.gz被解压成namespace.o并复制进来了</li>
</ul>
<h2 id="CMD和ENTRYPOINT"><a href="#CMD和ENTRYPOINT" class="headerlink" title="CMD和ENTRYPOINT"></a>CMD和ENTRYPOINT</h2><p>这两个必须一起提，因为很多时候开发者都搞不懂他们之间的关系</p>
<p>我们先看CMD，它有三种格式</p>
<figure class="highlight dockerfile"><table><tr><td class="code"><pre><span class="line"><span class="comment"># shell格式</span></span><br><span class="line"><span class="keyword">CMD</span><span class="bash"> ls</span></span><br><span class="line"><span class="comment"># exec格式</span></span><br><span class="line"><span class="keyword">CMD</span><span class="bash"> [<span class="string">&quot;ls&quot;</span>, <span class="string">&quot;-a&quot;</span>, <span class="string">&quot;-l&quot;</span>]</span></span><br><span class="line"><span class="comment"># param格式，为ENTRYPOINT指定提供参数用</span></span><br><span class="line"><span class="keyword">CMD</span><span class="bash"> [<span class="string">&quot;-a&quot;</span>, <span class="string">&quot;-l&quot;</span>]</span></span><br></pre></td></tr></table></figure>

<p>它的注意事项</p>
<ul>
<li>一个Dockerfile中可以有多个CMD指令，但只有最后一个会生效</li>
<li>CMD的前两种格式与RUN类似，但它本身的作用于RUN完全不同。它不会在容器构建过程中执行，而是在容器启动时作为第一条执行指令</li>
<li>如果用户在docker run时明确指定了指令，则会覆盖CMD指定的指令</li>
</ul>
<p>再来看ENTRYPOINT，它只有两种格式</p>
<figure class="highlight dockerfile"><table><tr><td class="code"><pre><span class="line"><span class="comment"># shell格式</span></span><br><span class="line"><span class="keyword">ENTRYPOINT</span><span class="bash"> ls</span></span><br><span class="line"><span class="comment"># exec格式</span></span><br><span class="line"><span class="keyword">ENTRYPOINT</span><span class="bash"> [<span class="string">&quot;ls&quot;</span>, <span class="string">&quot;-a&quot;</span>, <span class="string">&quot;-l&quot;</span>]</span></span><br></pre></td></tr></table></figure>

<p>它的注意事项</p>
<ul>
<li><p>一个Dockerfile可以有多个ENTRYPOINT指令的，但只有最后一个会生效</p>
</li>
<li><p>使用shell格式时，ENTRYPOINT会忽略任何CMD和docker run指定的指令，并会运行在sh -c中。这意味着我们指定的进程PID将不会是1，不能接收Unix信号。在使用docker stop结束容器时，我们的进程收不到结束信号。</p>
</li>
<li><p>使用exec格式时，docker run传入的参数会覆盖CMD指定的内容，并附加到ENTRYPOINT指令的参数中。</p>
<p>也就是说，如果我有如下dockerfile声明</p>
<figure class="highlight dockerfile"><table><tr><td class="code"><pre><span class="line"><span class="keyword">CMD</span><span class="bash"> [<span class="string">&quot;java&quot;</span>, <span class="string">&quot;-jar&quot;</span>, <span class="string">&quot;hello.jar&quot;</span>]</span></span><br><span class="line"><span class="keyword">ENTRYPOINT</span><span class="bash"> [<span class="string">&quot;sh&quot;</span>, <span class="string">&quot;-c&quot;</span>]</span></span><br></pre></td></tr></table></figure>

<p>不带任何参数启动容器时，实际执行的是：<code>sh -c java -jar hello.jar</code>。</p>
<p>如果运行<code>docker run xxx ls</code>，实际执行的就是：<code>sh -c ls</code></p>
</li>
</ul>
<h3 id="验证CMD"><a href="#验证CMD" class="headerlink" title="验证CMD"></a>验证CMD</h3><figure class="highlight dockerfile"><table><tr><td class="code"><pre><span class="line"><span class="keyword">FROM</span> ubuntu</span><br><span class="line">  </span><br><span class="line"><span class="keyword">ENV</span> ENVTEST=<span class="string">&quot;hello,world&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">RUN</span><span class="bash"> <span class="built_in">echo</span> <span class="variable">$ENVTEST</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">CMD</span><span class="bash"> [<span class="string">&quot;/bin/bash&quot;</span>]</span></span><br></pre></td></tr></table></figure>

<p>运行</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">root@10-9-175-15:/home/ubuntu/docker-learn# docker build -t ubuntu-cmd .</span><br><span class="line">Sending build context to Docker daemon  25.09kB</span><br><span class="line">Step 1/4 : FROM ubuntu</span><br><span class="line"><span class="meta"> ---&gt;</span><span class="bash"> ba6acccedd29</span></span><br><span class="line">Step 2/4 : ENV ENVTEST=&quot;hello,world&quot;</span><br><span class="line"><span class="meta"> ---&gt;</span><span class="bash"> Running <span class="keyword">in</span> 1f3709504258</span></span><br><span class="line">Removing intermediate container 1f3709504258</span><br><span class="line"><span class="meta"> ---&gt;</span><span class="bash"> 0ff22c83d97b</span></span><br><span class="line">Step 3/4 : RUN echo $ENVTEST</span><br><span class="line"><span class="meta"> ---&gt;</span><span class="bash"> Running <span class="keyword">in</span> 270682e9ba4c</span></span><br><span class="line">hello,world</span><br><span class="line">Removing intermediate container 270682e9ba4c</span><br><span class="line"><span class="meta"> ---&gt;</span><span class="bash"> 61316edd34e2</span></span><br><span class="line">Step 4/4 : CMD [&quot;/bin/bash&quot;]</span><br><span class="line"><span class="meta"> ---&gt;</span><span class="bash"> Running <span class="keyword">in</span> 4178afd282b1</span></span><br><span class="line">Removing intermediate container 4178afd282b1</span><br><span class="line"><span class="meta"> ---&gt;</span><span class="bash"> ddf82bc91062</span></span><br><span class="line">Successfully built ddf82bc91062</span><br><span class="line">Successfully tagged ubuntu-cmd:latest</span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 运行起来</span></span><br><span class="line">root@10-9-175-15:/home/ubuntu/docker-learn# docker run -it ubuntu-cmd</span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 查看当前进程号</span></span><br><span class="line">root@a0bf5cba468b:/# echo $$</span><br><span class="line">1</span><br></pre></td></tr></table></figure>

<p>可见：容器启动时默认运行了/bin/bash，并且，该进程号为1。</p>
<p>使用docker run进行覆盖</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 指定容器启动运行ls，这里看到，确实运行了ls，然后马上退出了容器，说明确实已经覆盖了CMD指令</span></span><br><span class="line">root@10-9-175-15:/home/ubuntu/docker-learn# docker run -it ubuntu-cmd ls</span><br><span class="line">bin   dev  home  lib32  libx32  mnt  proc  run   srv  tmp  var</span><br><span class="line">boot  etc  lib   lib64  media   opt  root  sbin  sys  usr</span><br></pre></td></tr></table></figure>

<h3 id="验证ENTRYPOINT"><a href="#验证ENTRYPOINT" class="headerlink" title="验证ENTRYPOINT"></a>验证ENTRYPOINT</h3><figure class="highlight dockerfile"><table><tr><td class="code"><pre><span class="line"><span class="keyword">FROM</span> ubuntu</span><br><span class="line">  </span><br><span class="line"><span class="keyword">ENV</span> ENVTEST=<span class="string">&quot;hello,world&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">RUN</span><span class="bash"> <span class="built_in">echo</span> <span class="variable">$ENVTEST</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 故意构建一个错误的指令，/bin/bash ls -a -l，会执行失败</span></span><br><span class="line"><span class="keyword">CMD</span><span class="bash"> [<span class="string">&quot;ls&quot;</span>, -a<span class="string">&quot;, &quot;</span>-l<span class="string">&quot;]</span></span></span><br><span class="line"><span class="keyword">ENTRYPOINT</span><span class="bash"><span class="string"> [&quot;</span>/bin/bash<span class="string">&quot;]</span></span></span><br></pre></td></tr></table></figure>

<p>运行</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">root@10-9-175-15:/home/ubuntu/docker-learn# docker build -t ubuntu-entrypoint .</span><br><span class="line">Sending build context to Docker daemon  25.09kB</span><br><span class="line">Step 1/5 : FROM ubuntu</span><br><span class="line"><span class="meta"> ---&gt;</span><span class="bash"> ba6acccedd29</span></span><br><span class="line">Step 2/5 : ENV ENVTEST=&quot;hello,world&quot;</span><br><span class="line"><span class="meta"> ---&gt;</span><span class="bash"> Using cache</span></span><br><span class="line"><span class="meta"> ---&gt;</span><span class="bash"> 0ff22c83d97b</span></span><br><span class="line">Step 3/5 : RUN echo $ENVTEST</span><br><span class="line"><span class="meta"> ---&gt;</span><span class="bash"> Using cache</span></span><br><span class="line"><span class="meta"> ---&gt;</span><span class="bash"> 61316edd34e2</span></span><br><span class="line">Step 4/5 : CMD [&quot;ls&quot;, -a&quot;, &quot;-l&quot;]</span><br><span class="line"><span class="meta"> ---&gt;</span><span class="bash"> Running <span class="keyword">in</span> 5eb37a4b1820</span></span><br><span class="line">Removing intermediate container 5eb37a4b1820</span><br><span class="line"><span class="meta"> ---&gt;</span><span class="bash"> eb29627384d0</span></span><br><span class="line">Step 5/5 : ENTRYPOINT [&quot;/bin/bash&quot;]</span><br><span class="line"><span class="meta"> ---&gt;</span><span class="bash"> Running <span class="keyword">in</span> fe3f5150adb5</span></span><br><span class="line">Removing intermediate container fe3f5150adb5</span><br><span class="line"><span class="meta"> ---&gt;</span><span class="bash"> 74c6f840a68c</span></span><br><span class="line">Successfully built 74c6f840a68c</span><br><span class="line">Successfully tagged ubuntu-entrypoint:latest</span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 启动报ls错误，说明CMD确实被加到参数中去了</span></span><br><span class="line">root@10-9-175-15:/home/ubuntu/docker-learn# docker run --name ubuntu-entrypoint ubuntu-entrypoint</span><br><span class="line">/usr/bin/ls: /usr/bin/ls: cannot execute binary file</span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">#</span><span class="bash"> docker run指定启动参数touch，包touch错误，说明替代了CMD，但ENTRYPOINT没被改变</span></span><br><span class="line">root@10-9-175-15:/home/ubuntu/docker-learn# docker run --name ubuntu-entrypoint ubuntu-entrypoint touch</span><br><span class="line">/usr/bin/touch: /usr/bin/touch: cannot execute binary file</span><br></pre></td></tr></table></figure>

<h3 id="小问题"><a href="#小问题" class="headerlink" title="小问题"></a>小问题</h3><ul>
<li><p>注意不同启动方式的影响，参考<a href="https://zou8944.com/2022/05/19/Kubernetes%E9%85%8D%E7%BD%AE%E7%8E%AF%E5%A2%83%E5%8F%98%E9%87%8F%E5%AE%B9%E5%99%A8%E5%86%85%E9%83%A8%E4%B8%8D%E7%94%9F%E6%95%88/">这篇文章</a></p>
</li>
<li><p>如何在容器启动时执行两条命令？</p>
<p>使用<code>shell</code>格式启动，比如<code>CMD [&quot;sh&quot;, &quot;-c&quot;, &quot;command1 &amp;&amp; command2&quot;]</code></p>
<p>要注意的是，command1必须是能结束的命令，否则command2不会执行。</p>
</li>
</ul>
<h2 id="lt-未完待续-gt"><a href="#lt-未完待续-gt" class="headerlink" title="&lt;未完待续&gt;"></a>&lt;未完待续&gt;</h2><p>Dockerfile肯定不止这么写指令，但这几个是最重要的内容，能够正确实用Dockerfile的关键，其它等有需要时再添加</p>
<h2 id="其它"><a href="#其它" class="headerlink" title="其它"></a>其它</h2><p>几个原则和注意事项</p>
<ul>
<li>共享Dockerfile比共享Docker镜像好，因为Dockerfile容易版本控制，构建过程清晰，占用空间少</li>
<li>CMD指令和ENTRYPOINT并不存在取舍，二者结合使用最后。CMD由于可被docker run覆盖的特性，适用于指定可变参数，ENTRYPOINT相应地适用于指定不可变指令。</li>
<li>使用保证镜像尽量小<ul>
<li>使用足够轻量的基础镜像</li>
<li>不要在镜像中放置无用的内容</li>
<li>如果有文件需要共享，用volume进行挂载，不要放到镜像中</li>
</ul>
</li>
<li>充分利用缓存，Docker镜像时分层的，无论构建、拉取都会有缓存，减小Dockerfile的变化部分，有利于提升缓存命中率</li>
</ul>
]]></content>
  </entry>
  <entry>
    <title>K8S如何灰度发布</title>
    <url>/2022/06/01/K8S%E5%81%9A%E7%81%B0%E5%BA%A6%E5%8F%91%E5%B8%83/</url>
    <content><![CDATA[<p>灰度发布、蓝绿发布、金丝雀发布等，本质上没有区别，都是版本渐进式发布+流量管理，所以也不要去纠结自己的发布方式到底算哪一种。硬要说，灰度发布是渐进式发布的统称，蓝绿发布和金丝雀发布是渐进式发布的具体方式，详细区别，在于蓝绿发布强调蓝绿环境（即新版和旧版服务）的平等性，流量拆分粒度较粗；金丝雀发布拥有更细粒度的流量拆分。</p>
<span id="more"></span>

<h2 id="原理分析"><a href="#原理分析" class="headerlink" title="原理分析"></a>原理分析</h2><p>灰度发布两个核心点：流量管理、发布流程管理。先来分析流量管理，不算Istio等组件新引入的流量管理策略，仅以Kubernetes本身的组件来看。一个常见的后端服务具有如下网络拓扑结构：ingress作为流量入口、转发到Service、Service转发到Deployment下辖的RS管理的Pod（严格来说，Service背后就直接是Pod了，但此处为方便说明控制关系，将Deployment和RS也加入了其中）。</p>
<p><img src="https://gdz.oss-cn-shenzhen.aliyuncs.com/local/image-20220602103656153.png" alt="image-20220602103656153"></p>
<p>这个结构有三种拆分流量的方式：按Service拆、按Deployment拆、按RS拆，如下</p>
<p><img src="https://gdz.oss-cn-shenzhen.aliyuncs.com/local/image-20220602104135230.png" alt="image-20220602104135230"></p>
<p>下面依次说明如何进行管理</p>
<ul>
<li><p>按Service拆</p>
<ol>
<li>发布新应用的Deployment、Service资源</li>
<li>利用Nginx Ingress Controller的<code>nginx.ingress.kubernetes.io/canary</code>系列注解或<code>nginx.ingress.kubernetes.io/service-match</code>系列注解控制流量在新旧Service之间的分配</li>
<li>测试新服务</li>
<li>修改流量分配，将流量全都导入新服务，关闭旧服务</li>
</ol>
<blockquote>
<p>这种方式能够在七层进行流量控制，粒度可以任意细</p>
</blockquote>
</li>
<li><p>按Deployment拆</p>
<ol>
<li>发布新应用的Deployment，将标签修改得符合原有Service的匹配规则，这样原Service就有两个应用</li>
<li>由于无法在七层精确控制流量打到新应用，因此只能观察新应用的监控表现是否正常</li>
<li>删除旧应用</li>
</ol>
<blockquote>
<p>这种方式依赖的特性是Service的负载均衡，新应用分得的流量是pod的占比数，不适合精细控制的场合</p>
</blockquote>
</li>
<li><p>按RS拆</p>
<p>这种方式无法在用户层使用，需要为Deployment编写新的控制器，控制新版本发布时RS切换流程，由原来的自动滚动发布变更为可手动控制的手动滚动发布，得到的效果和按Deployment拆分一致，但不需要用户再去创建和删除Deployment资源，一切滚动都自动化。argo rollout的默认做法就是这样</p>
</li>
</ul>
<h2 id="argo-rollout"><a href="#argo-rollout" class="headerlink" title="argo rollout"></a>argo rollout</h2><p>了解了灰度原理，但在实现上还是需要我们手动增删资源、发布后测试，argo rollout将这一切实现了自动化。主要功能如下</p>
<ul>
<li>灰度流程自动化，命令行控制灰度的进度</li>
<li>支持多种流量管理方式，包括服务网格等</li>
<li>提供自动化分析能力。可根据prometheus、普通http接口、Job执行结果情况控制灰度进度，实现完全的自动化</li>
</ul>
<blockquote>
<p>argo rollout也不是没有缺点：学习成本高、流量管理方式固定、和gitops兼容不好等。尤其是流量管理方式，如果网络拓扑结构不在其支持方式内，就无法使用，这也是下文没有使用它的原因。</p>
</blockquote>
<h2 id="灰度实践"><a href="#灰度实践" class="headerlink" title="灰度实践"></a>灰度实践</h2><p>我们的需求：应用灰度上线(不引入正式流量) - 执行冒烟测试 - 通过则正式上线，否则灰度下线。</p>
<p>而我们的网络结构如下，只有网关服务存在网络入口，其它应用只有Service，因此无法应用上述流量管理方式中的任何一种。</p>
<p><img src="https://gdz.oss-cn-shenzhen.aliyuncs.com/local/image-20220602111856505.png" alt="image-20220602111856505"></p>
<p>对此，在网关服务做灰度流量管理更合适</p>
<p><img src="https://gdz.oss-cn-shenzhen.aliyuncs.com/local/image-20220602112021070.png" alt="image-20220602112021070"></p>
<p>进一步，一般的灰度发布，在发布完成后都会将灰度应用转正，删除原有应用相关资源，但在我们的情况下，这样做有两点不方便之处</p>
<ul>
<li>网关服务的路由映射是单独写在配置文件的，且网关后面有多个应用，至关重要，不能经常去改，容易出错</li>
<li>gitops上难以实现</li>
</ul>
<p>于是我们选择如下方式</p>
<ul>
<li><p>建立灰度发布环境</p>
<ul>
<li>gitops中建立灰度应用的yaml清单文件，与原本的应用拥有资源一致，唯一的区别是名称多了个<code>-canary</code></li>
<li>网关路由配置中配置指向灰度应用的路由规则</li>
</ul>
</li>
<li><p>灰度发布</p>
<ul>
<li>CI触发gitops更新灰度应用的yaml文件，更新副本数为1，更新灰度应用的镜像版本，等待灰度应用发布生效</li>
<li>根据网关的路由配置，通过合适的方式访问灰度应用进行测试（比如添加指定请求头）</li>
<li>CI手动触发gitops更新正式应用的yaml文件，更新镜像版本，同时更新灰度应用的yaml文件，更新副本数为0（这是为了节省资源）</li>
<li>至此，灰度发布完成</li>
</ul>
</li>
</ul>
<blockquote>
<p>更新gitops相关文件，k8s资源自动随着更新</p>
<p>涉及到大量清单配置文件，过长，这里就不贴了</p>
</blockquote>
<h2 id="总结-如何选择灰度方案"><a href="#总结-如何选择灰度方案" class="headerlink" title="总结 - 如何选择灰度方案"></a>总结 - 如何选择灰度方案</h2><p>需求不同，灰度方案也不同，能用到的工具也会不同。比如上面我们的网络拓扑结构决定了很难使用argo rollout这种现成的工具；比如需要七层的流量管理就不能使用只能在四层做流量划分的方案；如果对流量管理有更个性化的要求，流量划分还得自己来做，整个方案又有所不同。</p>
<p>抓住两个关键点，就能灵活选择适合自己的灰度方案。</p>
]]></content>
      <categories>
        <category>运维</category>
      </categories>
      <tags>
        <tag>灰度发布</tag>
      </tags>
  </entry>
  <entry>
    <title>IAP StoreKit2后端开发完全指南</title>
    <url>/2022/05/13/IAP-StoreKit2%E5%90%8E%E7%AB%AF%E5%BC%80%E5%8F%91%E6%8C%87%E5%8D%97/</url>
    <content><![CDATA[<blockquote>
<p>TL;DR;</p>
<p>2021年10月，苹果发布了StoreKit2。新API和流程看起来更加简化，但是苹果官方文档并没有让开发者接入变得简单，调试起来也是各种问题，这方面和StoreKit1一样做的不好。梳理是必要的。</p>
</blockquote>
<span id="more"></span>

<h1 id="文档研读"><a href="#文档研读" class="headerlink" title="文档研读"></a>文档研读</h1><h2 id="文档目录"><a href="#文档目录" class="headerlink" title="文档目录"></a>文档目录</h2><p>官方文档虽然有组织结构，但不清晰，按照如下结构去通读，还是很有必要的。</p>
<ul>
<li><a href="https://developer.apple.com/cn/in-app-purchase/">概览页</a></li>
<li>购买项目配置<ul>
<li><a href="https://help.apple.com/app-store-connect/?lang=zh-cn#/devb57be10e7">配置流程</a></li>
<li><a href="https://help.apple.com/app-store-connect/?lanng=zh-cn#/devae49fb316">创建购买项目</a></li>
</ul>
</li>
<li><a href="https://developer.apple.com/cn/storekit/">StoreKit2概览</a><ul>
<li><a href="https://developer.apple.com/documentation/storekit">客户端StoreKit SDK</a></li>
<li><a href="https://developer.apple.com/documentation/appstoreserverapi">服务端API概览</a></li>
</ul>
</li>
<li><a href="https://developer.apple.com/documentation/appstoreservernotifications">服务端通知</a><ul>
<li><a href="https://help.apple.com/app-store-connect/?lang=zh-cn#/dev0067a330b">在App Store Connect中配置回调URL</a></li>
<li><a href="https://developer.apple.com/documentation/appstoreservernotifications/app_store_server_notifications_changelog">服务端通知 Changelog</a></li>
<li><a href="https://developer.apple.com/documentation/appstoreservernotifications/receiving_app_store_server_notifications">通知接收概览</a><ul>
<li><a href="https://developer.apple.com/documentation/appstoreservernotifications/responsebodyv2decodedpayload">通知的数据结构</a></li>
<li><a href="https://developer.apple.com/documentation/appstoreservernotifications/responding_to_app_store_server_notifications">如何响应通知（重要：阐述了通知重试机制、通知丢失的补救措施）</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="https://developer.apple.com/documentation/appstoreserverapi">服务端API概览（没错，和上面重复了，这里提出来凸显重要性）</a><ul>
<li>访问Apple Server API的凭证 <ul>
<li><a href="https://developer.apple.com/documentation/appstoreserverapi/creating_api_keys_to_use_with_the_app_store_server_api">创建API Key</a></li>
<li><a href="https://developer.apple.com/documentation/appstoreserverapi/generating_tokens_for_api_requests">构建JWT Token</a></li>
</ul>
</li>
<li><a href="https://developer.apple.com/documentation/appstoreserverapi/get_transaction_history">获取交易历史</a></li>
<li><a href="https://developer.apple.com/documentation/appstoreserverapi/get_all_subscription_statuses">获取所有订阅状态</a></li>
</ul>
</li>
<li>如何测试<ul>
<li><a href="https://developer.apple.com/cn/documentation/storekit/in-app_purchase/testing_in-app_purchases_with_sandbox/">在沙盒中测试</a></li>
</ul>
</li>
</ul>
<p>总体来说，阅读步骤应该如下</p>
<ol>
<li><p>概览页，对IAP有初步认识，了解购买项目类型、在App Store Connect控制台 配置、使用StoreKit开发、使用沙盒环境测试等。</p>
</li>
<li><p>StoreKit2的客户端SDK和服务端API。</p>
<p>了解客户端如何操作，作为后端，要关心的是服务端在操作完成后会得到一个Transaction，于StoreKit2，该Transaction和回调通知中的Transation、以及交易历史中的Transation具有同样的结构和内容，也就是说，我们的APP可以直接将其发送到业务后端进行验证。</p>
<p>还能了解到服务端API其实主要就提供两个接口：获取交易历史、获取订阅状态</p>
</li>
<li><p>阅读服务端通知。将了解到通知的数据结构、类型，以及安全机制。这一点很重要。</p>
</li>
<li><p>详细阅读服务端API，将了解访问API的凭证如何生成，交易历史的结构、订阅状态的结构等</p>
</li>
<li><p>阅读沙盒测试。了解如何在沙盒环境中测试。</p>
</li>
</ol>
<blockquote>
<p>文档阅读过程中，由于来回跳转，很可能会去到StoreKit1的文档，它们也可能描述交易流程、支付收据、收据验证等信息，非常容易和StoreKit2混淆，注意区分。区分的主要方式：StoreKit1或Original API这俩关键字</p>
</blockquote>
<blockquote>
<p>Apple文档的不合理之处在于——没有目录、没有支付流程说明、没有demo、没有专门针对后端人员的说明（我们很可能对客户端并不熟悉）</p>
</blockquote>
<h2 id="信息提取"><a href="#信息提取" class="headerlink" title="信息提取"></a>信息提取</h2><p>下面针对文档中的关键信息进行说明</p>
<h3 id="商品类型"><a href="#商品类型" class="headerlink" title="商品类型"></a>商品类型</h3><p>IAP中，可供购买的商品类型分为如下四种。</p>
<ul>
<li>消耗型：购买后，一次使用即失效<ul>
<li>可重复购买</li>
<li>例：金币</li>
</ul>
</li>
<li>非消耗型：一次购买，永不过期<ul>
<li>例：照相软件的某一款滤镜</li>
</ul>
</li>
<li>自动续期订阅：购买后一段时间内有效<ul>
<li>到期后会自动续期</li>
<li>例：腾讯视频会员</li>
</ul>
</li>
<li>非续期订阅：购买后一段时间内有效<ul>
<li>到期后不会自动续期</li>
<li>例：没用过🤔</li>
</ul>
</li>
</ul>
<p>本文的讨论，几种在自动续期订阅的商品类型。</p>
<h3 id="理解交易（Transaction）"><a href="#理解交易（Transaction）" class="headerlink" title="理解交易（Transaction）"></a>理解交易（Transaction）</h3><p>Transation，交易。<a href="https://developer.apple.com/documentation/storekit/transaction">官方手册</a>说：Transaction代表了app中对某个产品的购买。用户的每次购买或续费都会产生一个新的Transation对象，看起来已经说得够清楚了，但还不够，它只说了定义，没有说不通场景下的含义。有时候它出现的地方会让人困惑，比如回调通知中必然会带有交易信息，但像降级、退订这种通知的交易信息的意义何在呢？我们如何知道它代表着什么呢？</p>
<p>为此，我总结了三个关于交易的要点。</p>
<p>交易要点1：<strong>只要用户发生了扣费，就会产生一个新的Transaction —— 扣费=交易</strong>。穷举所有会产生扣费的场景</p>
<ul>
<li><p>订阅成功，包括如下</p>
<ul>
<li>初次订阅</li>
<li>过期后重新订阅</li>
<li>自动续期的订阅到期时自动续订</li>
</ul>
</li>
<li><p>订阅升级成功</p>
<p>IAP中，几个产品组成一个订阅组，产品之间可以设置等级，用户可以再同一个订阅组内的产品之间互相切换，当从低级产品切换到高级产品时，马上生效（将原低级产品为使用的部分折算成钱退回账户，马上产生对高级产品的订阅，即扣费）</p>
</li>
</ul>
<p>对同一个App，一个用户（体现为一个Apple ID账号）可能因为上述操作产生多个交易，这些交易组成了交易历史。</p>
<p>交易要点2：<strong>一个用户针对同一个App的交易历史中，只有最近一条是有效的</strong>。这个可以证明，在上述会产生扣费的场景中，订阅成功的case都是建立在前一个订阅失效的前提下；订阅升级的case中，前一个低级订阅会因为马上退款而失效。因此，产生的众多交易中，有且仅有最近的那条交易是有效的。</p>
<p>交易要点3：<strong>一个用户针对同一个App的所有交易中，originalTransactionId是一样的</strong>。这里第一次出现originalTransactionId，它是第一次购买时的交易ID，今后用户的所有交易，都是基于它串成交易历史。</p>
<h3 id="交易历史"><a href="#交易历史" class="headerlink" title="交易历史"></a>交易历史</h3><p>交易历史作为Apple提供的唯二API之一，需要注意如下几点</p>
<ul>
<li>消耗型商品的交易不会出现在交易历史中</li>
<li>手册宣称默认按照购买时间从早到晚排序，但实测并不严格，可能出现局部顺序不对的情况，拿到后还是要自己排一次</li>
<li>如上所说，最近一条才是有效的。开发时应以最近一条作为判断依据</li>
</ul>
<h3 id="订阅升降级"><a href="#订阅升降级" class="headerlink" title="订阅升降级"></a>订阅升降级</h3><p>对于自动续期订阅的产品，可以设定订阅顺序，如下截图App Store Connect控制台的设置例子</p>
<img src="https://gdz.oss-cn-shenzhen.aliyuncs.com/local/image-20220514172920979.png" style="zoom: 40%;" />

<p>要点</p>
<ul>
<li><p>等级越高越靠前，上面高级会员顺序为1，普通会员顺序为2，用户由普通会员切换到高级会员为升级，反之则为降级</p>
</li>
<li><p>同一等级能够设置多个商品。同一等级内商品之间切换不算升降级，只会改变当前订阅到期后下次自动续订的产品。</p>
<p>举例：用户购买了包月高级会员，但一天后，通过设置切换为了包年高级会员。则此时用户的订阅状态依旧是包月高级会员，待一个月后，包月会员过期，App Store会自动为用户续费包年高级会员。</p>
</li>
</ul>
<p>那么，用户如何能够在不同产品之间切换呢？有两个途径</p>
<ul>
<li>App暴露的UI</li>
<li>设置 - 用户设置页面 - 订阅 - 具体App</li>
</ul>
<p>前者一般仅用于初次订阅，订阅后会将订阅按钮隐藏；后者则可以任意切换。</p>
<p>以知乎为例，App暴露的购买API如下</p>
<img src="https://gdz.oss-cn-shenzhen.aliyuncs.com/local/IMG_5914.PNG" alt="IMG_5914" style="zoom:25%;" />

<p>在设置中呈现如下</p>
<img src="https://gdz.oss-cn-shenzhen.aliyuncs.com/local/IMG_5915.PNG" alt="IMG_5915" style="zoom:25%;" />

<h3 id="支付流程"><a href="#支付流程" class="headerlink" title="支付流程"></a>支付流程</h3><p>如果只有客户端，那么支付流程如下</p>
<ol>
<li>客户端通过StoreKit SDK拉起支付</li>
<li>用户输入密码或Face ID完成支付</li>
<li>StoreKit回调客户端并传入Transaction</li>
<li>客户端校验该Transaction，校验通过后发放权益</li>
</ol>
<p>如果有服务端，权益发放在服务端，则流程如下</p>
<ul>
<li>客户端流程<ol>
<li>客户端通过StoreKit SDK拉起支付</li>
<li>用户输入密码或FaceID完成支付</li>
<li>StoreKit回调客户端并传入Transaction</li>
<li>客户端校验该Transaction，校验通过后，将Transaction发送给服务端</li>
</ol>
</li>
<li>服务端流程1<ol>
<li>接收来自客户端的Transaction并校验，校验通过后，为用户发放权益</li>
</ol>
</li>
<li>服务端流程2<ol>
<li>接收来自Apple Server的回调通知，根据通知的内容，对用户发放权益</li>
</ol>
</li>
<li>服务端流程3<ol>
<li>定期调用交易历史查询接口，为在回调通知漏掉的交易补发权益。</li>
</ol>
</li>
</ul>
<p>其中，服务端流程1和流程2是分开并行存在的，且流程1可选（回调通知较慢，加上流程1能够提升用户体验）；流程2必须有，是唯一能够及时知悉所有交易发生的时机；流程3用于补单或者恢复购买。</p>
<blockquote>
<p>注意事项：对于服务端流程3，由于交易历史查询接口需要输入originalTransactionId，所以如果用户的首次交易被一楼，是没有办法查询的。所以它需要客户端协助：客户端获取当前Apple ID的任意一条交易上传服务端，服务端取其中的originalTransactionId查询交易历史，再取交易历史的最近一条交易作为发放权益的依据。</p>
</blockquote>
<h3 id="通知类型"><a href="#通知类型" class="headerlink" title="通知类型"></a>通知类型</h3><p>回调通知通过notificationType和subType两个字段区分，自动续期订阅相关通知如下</p>
<table>
<thead>
<tr>
<th>notificationType</th>
<th>subType</th>
<th>说明</th>
<th>要处理吗？</th>
</tr>
</thead>
<tbody><tr>
<td>DID_CHANGE_RENEWAL_PREF</td>
<td>DOWNGRADE</td>
<td>降级，降级下个周期生效</td>
<td>v</td>
</tr>
<tr>
<td>DID_CHANGE_RENEWAL_PREF</td>
<td>UPGRADE</td>
<td>升级，升级马上生效</td>
<td>v</td>
</tr>
<tr>
<td>DID_CHANGE_RENEWAL_PREF</td>
<td></td>
<td>取消降级</td>
<td>v</td>
</tr>
<tr>
<td>DID_CHANGE_RENEWAL_STATUS</td>
<td>AUTO_RENEW_ENABLED</td>
<td>开启自动续期</td>
<td></td>
</tr>
<tr>
<td>DID_CHANGE_RENEWAL_STATUS</td>
<td>AUTO_RENEW_DISABLED</td>
<td>关闭自动续期；退款后也会发送这个通知</td>
<td></td>
</tr>
<tr>
<td>DID_FAIL_TO_RENEW</td>
<td>GRACE_PERIOD</td>
<td>自动续期失败，因为卡里没钱了，但在宽限期内还是提供服务</td>
<td></td>
</tr>
<tr>
<td>DID_RENEW</td>
<td></td>
<td>续订成功</td>
<td>v</td>
</tr>
<tr>
<td>DID_RENEW</td>
<td>BILLING_RECOVERY</td>
<td>开始付费失败，后来恢复订阅了</td>
<td>v</td>
</tr>
<tr>
<td>EXPIRED</td>
<td>VOLUNTARY</td>
<td>因为用户关闭自动续期而过期</td>
<td></td>
</tr>
<tr>
<td>EXPIRED</td>
<td>BILLING_RETRY</td>
<td>尝试扣费失败而过期</td>
<td></td>
</tr>
<tr>
<td>EXPIRED</td>
<td>PRICE_INCREASE</td>
<td>用户不同意涨价而过期</td>
<td></td>
</tr>
<tr>
<td>GRACE_PERIOD_EXPIRED</td>
<td></td>
<td>宽限期已过</td>
<td></td>
</tr>
<tr>
<td>PRICE_INCREASE</td>
<td>PENDING</td>
<td>涨价，用户还没同意</td>
<td></td>
</tr>
<tr>
<td>PRICE_INCREASE</td>
<td>ACCEPTED</td>
<td>涨价，用户已同意</td>
<td></td>
</tr>
<tr>
<td>REFUND</td>
<td></td>
<td>用户退款成功</td>
<td>v</td>
</tr>
<tr>
<td>REFUND_DECLINED</td>
<td></td>
<td>苹果商店拒绝退款(来自开发者)</td>
<td></td>
</tr>
<tr>
<td>RENEWAL_EXTENDED</td>
<td></td>
<td>苹果商店延长了订阅的续订日期(来自开发者)</td>
<td></td>
</tr>
<tr>
<td>REVOKE</td>
<td></td>
<td>订阅购买者撤销了家庭共享</td>
<td></td>
</tr>
<tr>
<td>SUBSCRIBED</td>
<td>INITIAL_BUY</td>
<td>初次购买</td>
<td>v</td>
</tr>
<tr>
<td>SUBSCRIBED</td>
<td>RESUBSCRIBE</td>
<td>再次订阅之前订阅的内容/或通过家庭共享得到之前订阅的内容</td>
<td>v</td>
</tr>
</tbody></table>
<p><strong>理解不同类型通知中交易信息的含义</strong></p>
<p>每个通知中都会携带交易信息，位于 data -&gt; signedTransactionInfo 字段，它总是当时（发送通知那一刻）生效的交易，举例</p>
<ul>
<li>初次购买时，携带的购买成功的交易信息</li>
<li>升级时，携带的升级之后，购买的高级商品的交易信息。原低级产品需要自己通过交易历史才能查询得到</li>
<li>降级时，不会马上生效，携带的是上次购买成功的交易信息</li>
<li>关闭自动续费时，携带的是上次购买成功的交易信息</li>
<li>退款时，携带的是上次购买成功的交易信息（这是我猜的，没有实测过，因为无法触发退款通知）</li>
</ul>
<blockquote>
<p>你可能会想，区分这么多通知类型有什么用？的确，对于发放权益来说，大多数通知都是没用的，但如果加上推广、用户留存、营销就很有用了。比如检测到用户关闭自动订阅，可以定点向该用户推送营销信息，或者推出专门的优惠套餐等。</p>
</blockquote>
<h1 id="技术点"><a href="#技术点" class="headerlink" title="技术点"></a>技术点</h1><h2 id="业务用户识别"><a href="#业务用户识别" class="headerlink" title="业务用户识别"></a>业务用户识别</h2><p>Apple服务的回调通知中，并不会携带Apple ID信息，因此无法区分该通知属于哪个具体业务用户。Apple的提供的方式是appAccountToken字段，该字段在客户端发起支付时指定，在通知中携带，以便业务后端区分。关于它注意几个点</p>
<ul>
<li>appAccountToken由业务后端自己生成维护</li>
<li>如果用户自行在控制台操作，可能出现回调通知不带appAccountToken的情况。此时可以从交易历史中查询（第一条交易一定会带appAccountToken，因为首次发起购买一定是从我们的APP客户端，就一定会设置）</li>
</ul>
<h2 id="JWS签名验证"><a href="#JWS签名验证" class="headerlink" title="JWS签名验证"></a>JWS签名验证</h2><p>StoreKit2的一个重要变化是，大部分信息都采用JWS进行组织。Transaction是JWS、通知也是JWS。上面说的交易流程中，客户端交易成功上传Transaction时，后端需要验证其有效性；接收到通知时，也要验证其有效性。</p>
<blockquote>
<p>注意这是JWS并非JWT，二者的差别在于，JWT是基于JWS构建的，赋予了更多的业务意义，即Token的意义，主要体现在payload中的字段，JWT定义了标准的字段如aud、exp等，具体可以参考我的<a href="https://zou8944.com/2021/12/20/JWT/">这篇文章</a>。而JWS并未对payload的内容做出约束，只定义了Header.Payload.Signature的组成方式、定义了Header中加密字段的含义。</p>
<p>值得一提的是，Sign In with Apple就用的JWT作为登录成功后的Token。</p>
<p>至于使用的库嘛，使用一般的JWT库都可以，只不过在验证整个加密字符串时，验证Claims咩有作用，此时关注的是验证Signature。</p>
</blockquote>
<h3 id="客户端上传交易信息的验证"><a href="#客户端上传交易信息的验证" class="headerlink" title="客户端上传交易信息的验证"></a>客户端上传交易信息的验证</h3><p>对于后端的处理，官方并没有规定一定要将客户端得到的Transaction传到服务端，加这一步只是我们为了实时性而做的。此时的签名就要我们自己来处理了。其实是有两种方式进行确认的</p>
<ol>
<li>在业务系统已有的安全传输条件下直接传输交易信息，比如业务系统已有登录鉴权，可以相信经过登录后传输的信息是可信的</li>
<li>将整个原始的Transaction JWS传输给后端，后端自己验证，验证逻辑同下文“通知的签名验证”一致。</li>
</ol>
<h3 id="通知的签名验证"><a href="#通知的签名验证" class="headerlink" title="通知的签名验证"></a>通知的签名验证</h3><p>这一点是最多人搞不清楚的，我们观察任意一个通知的Header如下。没有kid字段，取而代之的是x5c，这代表提供验证公钥的是一个证书X.509证书链。我们需要先验证证书链的正确性，再用证书链提供的公钥验证整个JWS的正确性。</p>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="attr">&quot;alg&quot;</span>: <span class="string">&quot;ES256&quot;</span>,</span><br><span class="line">  <span class="attr">&quot;x5c&quot;</span>: [</span><br><span class="line">    <span class="string">&quot;MIIEMDCCA7agAwIBAgIQaPoPldvpSoEH0lBrjDPv9jAKBggqhkjOPQQDAzB1MUQwQgYDVQQDDDtBcHBsZSBXb3JsZHdpZGUgRGV2ZWxvcGVyIFJlbGF0aW9ucyBDZXJ0aWZpY2F0aW9uIEF1dGhvcml0eTELMAkGA1UECwwCRzYxEzARBgNVBAoMCkFwcGxlIEluYy4xCzAJBgNVBAYTAlVTMB4XDTIxMDgyNTAyNTAzNFoXDTIzMDkyNDAyNTAzM1owgZIxQDA+BgNVBAMMN1Byb2QgRUNDIE1hYyBBcHAgU3RvcmUgYW5kIGlUdW5lcyBTdG9yZSBSZWNlaXB0IFNpZ25pbmcxLDAqBgNVBAsMI0FwcGxlIFdvcmxkd2lkZSBEZXZlbG9wZXIgUmVsYXRpb25zMRMwEQYDVQQKDApBcHBsZSBJbmMuMQswCQYDVQQGEwJVUzBZMBMGByqGSM49AgEGCCqGSM49AwEHA0IABOoTcaPcpeipNL9eQ06tCu7pUcwdCXdN8vGqaUjd58Z8tLxiUC0dBeA+euMYggh1/5iAk+FMxUFmA2a1r4aCZ8SjggIIMIICBDAMBgNVHRMBAf8EAjAAMB8GA1UdIwQYMBaAFD8vlCNR01DJmig97bB85c+lkGKZMHAGCCsGAQUFBwEBBGQwYjAtBggrBgEFBQcwAoYhaHR0cDovL2NlcnRzLmFwcGxlLmNvbS93d2RyZzYuZGVyMDEGCCsGAQUFBzABhiVodHRwOi8vb2NzcC5hcHBsZS5jb20vb2NzcDAzLXd3ZHJnNjAyMIIBHgYDVR0gBIIBFTCCAREwggENBgoqhkiG92NkBQYBMIH+MIHDBggrBgEFBQcCAjCBtgyBs1JlbGlhbmNlIG9uIHRoaXMgY2VydGlmaWNhdGUgYnkgYW55IHBhcnR5IGFzc3VtZXMgYWNjZXB0YW5jZSBvZiB0aGUgdGhlbiBhcHBsaWNhYmxlIHN0YW5kYXJkIHRlcm1zIGFuZCBjb25kaXRpb25zIG9mIHVzZSwgY2VydGlmaWNhdGUgcG9saWN5IGFuZCBjZXJ0aWZpY2F0aW9uIHByYWN0aWNlIHN0YXRlbWVudHMuMDYGCCsGAQUFBwIBFipodHRwOi8vd3d3LmFwcGxlLmNvbS9jZXJ0aWZpY2F0ZWF1dGhvcml0eS8wHQYDVR0OBBYEFCOCmMBq//1L5imvVmqX1oCYeqrMMA4GA1UdDwEB/wQEAwIHgDAQBgoqhkiG92NkBgsBBAIFADAKBggqhkjOPQQDAwNoADBlAjEAl4JB9GJHixP2nuibyU1k3wri5psGIxPME05sFKq7hQuzvbeyBu82FozzxmbzpogoAjBLSFl0dZWIYl2ejPV+Di5fBnKPu8mymBQtoE/H2bES0qAs8bNueU3CBjjh1lwnDsI=&quot;</span>,</span><br><span class="line">    <span class="string">&quot;MIIDFjCCApygAwIBAgIUIsGhRwp0c2nvU4YSycafPTjzbNcwCgYIKoZIzj0EAwMwZzEbMBkGA1UEAwwSQXBwbGUgUm9vdCBDQSAtIEczMSYwJAYDVQQLDB1BcHBsZSBDZXJ0aWZpY2F0aW9uIEF1dGhvcml0eTETMBEGA1UECgwKQXBwbGUgSW5jLjELMAkGA1UEBhMCVVMwHhcNMjEwMzE3MjAzNzEwWhcNMzYwMzE5MDAwMDAwWjB1MUQwQgYDVQQDDDtBcHBsZSBXb3JsZHdpZGUgRGV2ZWxvcGVyIFJlbGF0aW9ucyBDZXJ0aWZpY2F0aW9uIEF1dGhvcml0eTELMAkGA1UECwwCRzYxEzARBgNVBAoMCkFwcGxlIEluYy4xCzAJBgNVBAYTAlVTMHYwEAYHKoZIzj0CAQYFK4EEACIDYgAEbsQKC94PrlWmZXnXgtxzdVJL8T0SGYngDRGpngn3N6PT8JMEb7FDi4bBmPhCnZ3/sq6PF/cGcKXWsL5vOteRhyJ45x3ASP7cOB+aao90fcpxSv/EZFbniAbNgZGhIhpIo4H6MIH3MBIGA1UdEwEB/wQIMAYBAf8CAQAwHwYDVR0jBBgwFoAUu7DeoVgziJqkipnevr3rr9rLJKswRgYIKwYBBQUHAQEEOjA4MDYGCCsGAQUFBzABhipodHRwOi8vb2NzcC5hcHBsZS5jb20vb2NzcDAzLWFwcGxlcm9vdGNhZzMwNwYDVR0fBDAwLjAsoCqgKIYmaHR0cDovL2NybC5hcHBsZS5jb20vYXBwbGVyb290Y2FnMy5jcmwwHQYDVR0OBBYEFD8vlCNR01DJmig97bB85c+lkGKZMA4GA1UdDwEB/wQEAwIBBjAQBgoqhkiG92NkBgIBBAIFADAKBggqhkjOPQQDAwNoADBlAjBAXhSq5IyKogMCPtw490BaB677CaEGJXufQB/EqZGd6CSjiCtOnuMTbXVXmxxcxfkCMQDTSPxarZXvNrkxU3TkUMI33yzvFVVRT4wxWJC994OsdcZ4+RGNsYDyR5gmdr0nDGg=&quot;</span>,</span><br><span class="line">    <span class="string">&quot;MIICQzCCAcmgAwIBAgIILcX8iNLFS5UwCgYIKoZIzj0EAwMwZzEbMBkGA1UEAwwSQXBwbGUgUm9vdCBDQSAtIEczMSYwJAYDVQQLDB1BcHBsZSBDZXJ0aWZpY2F0aW9uIEF1dGhvcml0eTETMBEGA1UECgwKQXBwbGUgSW5jLjELMAkGA1UEBhMCVVMwHhcNMTQwNDMwMTgxOTA2WhcNMzkwNDMwMTgxOTA2WjBnMRswGQYDVQQDDBJBcHBsZSBSb290IENBIC0gRzMxJjAkBgNVBAsMHUFwcGxlIENlcnRpZmljYXRpb24gQXV0aG9yaXR5MRMwEQYDVQQKDApBcHBsZSBJbmMuMQswCQYDVQQGEwJVUzB2MBAGByqGSM49AgEGBSuBBAAiA2IABJjpLz1AcqTtkyJygRMc3RCV8cWjTnHcFBbZDuWmBSp3ZHtfTjjTuxxEtX/1H7YyYl3J6YRbTzBPEVoA/VhYDKX1DyxNB0cTddqXl5dvMVztK517IDvYuVTZXpmkOlEKMaNCMEAwHQYDVR0OBBYEFLuw3qFYM4iapIqZ3r6966/ayySrMA8GA1UdEwEB/wQFMAMBAf8wDgYDVR0PAQH/BAQDAgEGMAoGCCqGSM49BAMDA2gAMGUCMQCD6cHEFl4aXTQY2e3v9GwOAEZLuN+yRhHFD/3meoyhpmvOwgPUnPWTxnS4at+qIxUCMG1mihDK1A3UT82NQz60imOlM27jbdoXt2QfyFMm+YhidDkLF1vLUagM6BgD56KyKA==&quot;</span></span><br><span class="line">  ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>验证逻辑如下</p>
<ol>
<li>从<a href="https://link.juejin.cn/?target=https://www.apple.com/certificateauthority/AppleRootCA-G3.cer">Apple官网</a>下载根证书</li>
<li>取证书链的最后一个，和上述下载的根证书对比，如果不同则验证失败</li>
<li>验证证书链：第一个证书用第二个证书验证、第二个用第三个验证、以此类推，全都成功才算通过</li>
<li>从第一个证书取得公钥</li>
<li>用上一步得到的公钥验证整个JWS</li>
</ol>
<p>库使用<code>com.auth0:java-jwt:3.18.2</code>，编程语言使用Kotlin，验证逻辑如下</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">val</span> appleRootCert = PathMatchingResourcePatternResolver()</span><br><span class="line">        .getResources(<span class="string">&quot;classpath:cert/AppleRootCA-G3.cer&quot;</span>).first().inputStream.readBytes()</span><br><span class="line"></span><br><span class="line"><span class="comment">// 解码并验证时接收到的通知</span></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">decodeAndVerifyAppleNotification</span><span class="params">(rawNotification: <span class="type">String</span>)</span></span>: AppleNotificationPayload &#123;</span><br><span class="line">  <span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> JWT.decode(rawNotification)</span><br><span class="line">    .apply &#123; verifyAppleNotificationSignature(verifyAppleNotificationCertsThenReturnPublicKey(<span class="keyword">this</span>), <span class="keyword">this</span>) &#125;</span><br><span class="line">    .getPayload(AppleNotificationPayload::<span class="keyword">class</span>.java)</span><br><span class="line">  &#125; <span class="keyword">catch</span> (e: Exception) &#123;</span><br><span class="line">    <span class="keyword">throw</span> Exception(<span class="string">&quot;<span class="subst">$&#123;e.message&#125;</span>\nnotificationPayload: <span class="variable">$rawNotification</span>&quot;</span>, e)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="function"><span class="keyword">fun</span> <span class="title">verifyAppleNotificationCertsThenReturnPublicKey</span><span class="params">(jwt: <span class="type">DecodedJWT</span>)</span></span>: PublicKey &#123;</span><br><span class="line">  <span class="keyword">val</span> certFactory = CertificateFactory.getInstance(<span class="string">&quot;X.509&quot;</span>)</span><br><span class="line">  <span class="keyword">val</span> appleRootCert = certFactory.generateCertificate(ByteArrayInputStream(appleRootCert)) <span class="keyword">as</span> X509Certificate</span><br><span class="line">  <span class="keyword">val</span> jwsCertChain = jwt.getHeaderClaim(<span class="string">&quot;x5c&quot;</span>).asList(String::<span class="keyword">class</span>.java).map &#123;</span><br><span class="line">    certFactory.generateCertificate(ByteArrayInputStream(Base64.getDecoder().decode(it)))</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 关键点1：验证根证书</span></span><br><span class="line">  <span class="keyword">if</span> (jwsCertChain.last() != appleRootCert) <span class="keyword">throw</span> Exception(<span class="string">&quot;根证书错误&quot;</span>)</span><br><span class="line">  <span class="comment">// 关键点2：验证证书链</span></span><br><span class="line">  <span class="keyword">for</span> (index <span class="keyword">in</span> <span class="number">0.</span>.jwsCertChain.size - <span class="number">2</span>) &#123;</span><br><span class="line">    jwsCertChain[index].verify(jwsCertChain[index + <span class="number">1</span>].publicKey)</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 关键点3：第一个证书的公钥即为验证整个JWS的公钥</span></span><br><span class="line">  <span class="keyword">return</span> jwsCertChain.first().publicKey</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="function"><span class="keyword">fun</span> <span class="title">verifyAppleNotificationSignature</span><span class="params">(publicKey: <span class="type">PublicKey</span>, jwt: <span class="type">DecodedJWT</span>)</span></span> &#123;</span><br><span class="line">  <span class="comment">// 这里做了API转换，证书用的是javax.security的API，而JWT验证用的是引入的java-jwt的API</span></span><br><span class="line">  <span class="keyword">val</span> keyProvider = <span class="keyword">object</span> : ECDSAKeyProvider &#123;</span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">getPublicKeyById</span><span class="params">(keyId: <span class="type">String</span>?)</span></span>: ECPublicKey &#123;</span><br><span class="line">      <span class="keyword">val</span> keyFactory = KeyFactory.getInstance(publicKey.algorithm)</span><br><span class="line">      <span class="keyword">return</span> keyFactory.generatePublic(X509EncodedKeySpec(publicKey.encoded)) <span class="keyword">as</span> ECPublicKey</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">getPrivateKey</span><span class="params">()</span></span>: ECPrivateKey &#123;</span><br><span class="line">      <span class="keyword">throw</span> NotImplementedError()</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">getPrivateKeyId</span><span class="params">()</span></span>: String &#123;</span><br><span class="line">      <span class="keyword">throw</span> NotImplementedError()</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  JWT.require(Algorithm.ECDSA256(keyProvider)).build().verify(jwt)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>官方文档并没有较为明确的阐述，如下两个文档可以作为参考</p>
<ul>
<li><p><a href="https://zhuanlan.zhihu.com/p/36832100">X.509 数字证书的基本原理及应用</a></p>
</li>
<li><p><a href="https://juejin.cn/post/7039970403770433544">JWS X.509证书链验证</a></p>
</li>
</ul>
</blockquote>
<h2 id="Apple服务端点访问凭证"><a href="#Apple服务端点访问凭证" class="headerlink" title="Apple服务端点访问凭证"></a>Apple服务端点访问凭证</h2><p>需要访问Apple Server的交易历史接口，而Apple Server的所有API访问时都需要携带凭证。步骤如下</p>
<ol>
<li>在App Store Connect控制台中生成并下载Private Key，步骤参考<a href="https://developer.apple.com/documentation/appstoreserverapi/creating_api_keys_to_use_with_the_app_store_server_api">官方文档</a></li>
<li>按照<a href="https://developer.apple.com/documentation/appstoreserverapi/generating_tokens_for_api_requests">官方文档</a> 指定的方式构建JWT。其实就是JWT的标准生成方式，但需要注意的是各字段的填充，<strong>该JWT不只是访问的凭证，还有部分字段会参与查询</strong>。遇到过一个问题：bid字段设置错误，和真实的bundleId不一致，访问交易历史接口时，响应正常，但signedTranstions字段始终是空数组，该问题阻拦了我大半天。</li>
<li>访问时，将其放在bear token中，即添加头部 Authorization bear ${your token}</li>
</ol>
<p>生成JWT代码如下</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">constructJWT4IAP</span><span class="params">()</span></span>: String &#123;</span><br><span class="line">  <span class="keyword">val</span> header: MutableMap&lt;String, Any&gt; = HashMap()</span><br><span class="line">  header[<span class="string">&quot;alg&quot;</span>] = <span class="string">&quot;ES256&quot;</span></span><br><span class="line">  header[<span class="string">&quot;kid&quot;</span>] = <span class="string">&quot;<span class="subst">$&#123;下载的Private Key ID&#125;</span>&quot;</span></span><br><span class="line">  header[<span class="string">&quot;typ&quot;</span>] = <span class="string">&quot;JWT&quot;</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">val</span> payload: MutableMap&lt;String, Any&gt; = HashMap()</span><br><span class="line">  payload[<span class="string">&quot;iss&quot;</span>] = <span class="string">&quot;<span class="subst">$&#123;申请Private Key时同时生成的issuer ID&#125;</span>&quot;</span></span><br><span class="line">  payload[<span class="string">&quot;iat&quot;</span>] = DateUtils.currentSecond()</span><br><span class="line">  payload[<span class="string">&quot;exp&quot;</span>] = DateUtils.currentSecondPlusMinute($&#123;token有效期时间&#125;)</span><br><span class="line">  payload[<span class="string">&quot;aud&quot;</span>] = <span class="string">&quot;appstoreconnect-v1&quot;</span></span><br><span class="line">  payload[<span class="string">&quot;nonce&quot;</span>] = UUID.randomUUID().toString()</span><br><span class="line">  payload[<span class="string">&quot;bid&quot;</span>] = <span class="string">&quot;<span class="subst">$&#123;App的Bundle ID&#125;</span>&quot;</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">val</span> algorithm = Algorithm.ECDSA256(ES256KeyProviderBuilder.build($&#123;下载的Private Key&#125;, $&#123;下载的Private Key ID&#125;))</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">return</span> JWT.create().withIssuer(prop.jwt.issuerId)</span><br><span class="line">  .withHeader(header)</span><br><span class="line">  .withPayload(payload)</span><br><span class="line">  .sign(algorithm)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>以访问交易历史来说，在Spring Boot的RestTemplate API下的使用方式如下</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">listAppleTransactionHistory</span><span class="params">(appleEnv: <span class="type">AppleEnvironment</span>, originalTransactionId: <span class="type">Long</span>)</span></span>: List&lt;AppleTransactionInfo&gt; &#123;</span><br><span class="line">  <span class="keyword">val</span> bearerToken = constructJWT4IAP()</span><br><span class="line">  <span class="keyword">val</span> baseUrl = <span class="keyword">when</span> (appleEnv) &#123;</span><br><span class="line">    AppleEnvironment.Production -&gt; BusinessConstants.APPLE_PAY_SERVER_GET_TRANSACTION_HISTORY_URL</span><br><span class="line">    AppleEnvironment.Sandbox -&gt; BusinessConstants.APPLE_PAY_SANDBOX_SERVER_GET_TRANSACTION_HISTORY_URL</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">val</span> rawUrl = <span class="string">&quot;<span class="subst">$&#123;baseUrl.trimEnd(<span class="string">&#x27;/&#x27;</span>)&#125;</span>/<span class="variable">$originalTransactionId</span>&quot;</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">val</span> signedTransactions = mutableListOf&lt;String&gt;()</span><br><span class="line">  <span class="keyword">var</span> revision: String? = <span class="literal">null</span></span><br><span class="line">  <span class="keyword">do</span> &#123;</span><br><span class="line">    <span class="keyword">val</span> transactionHistoryResponse = listAppleTransactionHistory(bearerToken, rawUrl, revision)</span><br><span class="line">    signedTransactions.addAll(transactionHistoryResponse.signedTransactions)</span><br><span class="line">    revision = transactionHistoryResponse.revision</span><br><span class="line">  &#125; <span class="keyword">while</span> (transactionHistoryResponse.hasMore)</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> signedTransactions.map &#123; JwtHelper.decodeAppleTransaction(it) &#125;.sortedBy &#123; it.purchaseDate &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="function"><span class="keyword">fun</span> <span class="title">listAppleTransactionHistory</span><span class="params">(token: <span class="type">String</span>, rawUrl: <span class="type">String</span>, revision: <span class="type">String</span>?)</span></span>: GetTransactionHistoryVO &#123;</span><br><span class="line">  <span class="keyword">val</span> url = <span class="keyword">if</span> (revision == <span class="literal">null</span>) rawUrl <span class="keyword">else</span> <span class="string">&quot;<span class="variable">$rawUrl</span>?revision=<span class="variable">$revision</span>&quot;</span></span><br><span class="line">  <span class="keyword">val</span> headers = org.springframework.http.HttpHeaders().apply &#123;</span><br><span class="line">    <span class="comment">// 关键点：JWT的使用方式</span></span><br><span class="line">    <span class="keyword">this</span>.add(<span class="string">&quot;Authorization&quot;</span>, <span class="string">&quot;Bearer <span class="variable">$token</span>&quot;</span>)</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">val</span> entity = HttpEntity&lt;String&gt;(headers)</span><br><span class="line">  <span class="keyword">val</span> res = retry &#123;</span><br><span class="line">    restTemplate.exchange(url, HttpMethod.GET, entity, GetTransactionHistoryVO::<span class="keyword">class</span>.java)</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> (!res.statusCode.is2xxSuccessful) &#123;</span><br><span class="line">    logger.error(<span class="string">&quot;apple server 访问失败. <span class="variable">$res</span>&quot;</span>)</span><br><span class="line">    <span class="keyword">throw</span> BusinessException(ResErrCode.COMM_ERROR)</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> res.body!!</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="业务接入"><a href="#业务接入" class="headerlink" title="业务接入"></a>业务接入</h1><p>上面描述了简单的流程，这里考虑加入业务场景——<a href="https://apps.apple.com/cn/app/%E6%AF%8F%E8%AE%B0/id1572586388">每记APP</a>的自动续期订阅。简要描述值得注意的</p>
<blockquote>
<p>广告时间：“小小日记，大大不同”，每记是一款操作简单、功能强大的日记应用，目前已迭代到2.0版本，基本功能成熟可用，未来还有更多惊喜功能等着搭建，欢迎大家加入到每记用户的大家庭。</p>
</blockquote>
<h2 id="需求及分析"><a href="#需求及分析" class="headerlink" title="需求及分析"></a>需求及分析</h2><p>需要增加自动续期订阅功能。需要有两种级别——普通、高级；两种周期——包月、包年。</p>
<p>于是在IAP中，我们需要建立四个商品，并将他们放在同一个订阅组下，设置两个优先级，普通转高级算升级；高级转普通算降级。</p>
<ul>
<li>高级包月，优先级设置1</li>
<li>高级包年，优先级设置1</li>
<li>普通包月，优先级设置2</li>
<li>普通包年，优先级设置2</li>
</ul>
<h2 id="交易流程"><a href="#交易流程" class="headerlink" title="交易流程"></a>交易流程</h2><p>相比上面提到的交易流程，修正如下</p>
<ol>
<li>客户端从服务端请求当前登录用户对应的appAccountToken</li>
<li>客户端从服务端请求当前App已经在App Store Connect中配置好的商品信息</li>
<li>客户端用上面两个信息拉起支付</li>
<li>剩下和前面提到的流程一致</li>
</ol>
<p>服务端和上面提到的流程一致。</p>
<h2 id="订阅周期、扣费周期、权益周期"><a href="#订阅周期、扣费周期、权益周期" class="headerlink" title="订阅周期、扣费周期、权益周期"></a>订阅周期、扣费周期、权益周期</h2><p>分析产品功能时，我们说有包年、包月；查看IAP手册，我们知道自动续期订阅有按月、按年扣费；默认情况下，我们认为这二者是相同的，称作订阅周期。实际不一样，即使它们表现得一样，也是我们主动处理的结果。我更愿意将前者称作权益周期、后者称作扣费周期。</p>
<p><strong>扣费周期</strong>：来自IAP，开发者不可干预，一般来说时间很准，什么时候自动续期扣费，Apple说了算，我们只能被动接受通知</p>
<p><strong>权益周期</strong>：来自APP，由开发者全权控制，我们也可以设置其开始结束时间完全和扣费周期一致（Transaction信息中purchaseDate作为周期起点，ExpireDate作为周期终点）。但实际操作时并不建议这么做</p>
<ul>
<li><p>因为在沙盒环境下，一个月可被设置为3分钟，年也有对应缩短，意味着权益周期也会相应缩短，这样不便于测试真实日期的计算方式。而且每记是一个跨端应用，目前我们有IOS、Mac OS、Android三端应用，支付平台需要有IAP、微信、支付宝。支付服务和业务服务必须解绑，支付只负责扣费，权益发放交给业务，职责清晰。</p>
</li>
<li><p>当出现服务器宕机等情况，服务端未能及时处理用户续期支付成功的通知，理论上可以延迟数小时到数天不等，如果此时还按照Transaction中的过期时间作为权益周期的过期时间，则用户会凭空损失与延迟时间相等的会员权益。这样是不大好的。</p>
</li>
</ul>
<p>而因为支付成功通知的延迟处理（多多少少都会有些延迟），可能造成权益周期比扣费周期整体延后，我称之为周期偏移。要注意到这个现象的存在。</p>
<h2 id="可靠性考量"><a href="#可靠性考量" class="headerlink" title="可靠性考量"></a>可靠性考量</h2><h3 id="服务器宕机"><a href="#服务器宕机" class="headerlink" title="服务器宕机"></a>服务器宕机</h3><p>如果因为服务端宕机或代码bug等原因，为能正确处理Apple Server通知，Apple Server会进行重试。重试时间分别是：在上一次尝试的基础上间隔1, 12, 24, 48, 72小时。也就是说，6天13小时后，将放弃通知重试，这期间还没能正确处理通知，将发生掉单。</p>
<p>此外，如果等不及通知重试，也可以主动查询交易历史进行补单。</p>
<blockquote>
<p>注意：交易历史查询接口需要originalTransactionId作为路径参数，所以如果是丢了初次购买的交易信息，是无法补单的。</p>
</blockquote>
<h3 id="通知乱序"><a href="#通知乱序" class="headerlink" title="通知乱序"></a>通知乱序</h3><p>理论上通知存在乱序的可能：初次订阅，此时服务器未能正确处理交易信息，接着客户马上在设置界面升级，触发升级通知。会出现先收到升级通知，再收到初次订阅通知的情况。正确的处理方式是以升级通知的交易为准，忽略初次订阅通知。</p>
<p>为保证无论什么时候来通知，都能正确处理，可以在每次回调时都先查询交易历史，如果通知中的交易信息是最新的，则处理，否则忽略。</p>
<h3 id="恢复购买"><a href="#恢复购买" class="headerlink" title="恢复购买"></a>恢复购买</h3><p>前面说，丢了初次订阅信息的单光靠服务端是找不回来的，此时需要客户端通过恢复购买操作拿到之前购买的交易信息，然后传递给服务端，服务端提取originalTransactionId再调用交易历史进行查询。</p>
<h1 id="测试姿势"><a href="#测试姿势" class="headerlink" title="测试姿势"></a>测试姿势</h1><h2 id="熟悉App-Store-Connect控制台"><a href="#熟悉App-Store-Connect控制台" class="headerlink" title="熟悉App Store Connect控制台"></a>熟悉App Store Connect控制台</h2><p>要调试IAP，必须熟悉App Store Connect控制台，这个自己上去东点西点就能熟悉了。这里提两个点</p>
<ol>
<li><p>添加测试用户时，电子邮件不要是已经注册过Apple ID的，否则会提示邮箱已经被使用，也不必是真实的电子邮件，不会接收验证码，在沙盒环境登录时，只需要输入电子邮件和密码即可。</p>
<p><img src="https://gdz.oss-cn-shenzhen.aliyuncs.com/local/image-20220516143502001.png" alt="image-20220516143502001"></p>
</li>
<li><p>重新测试时，最好将测试账号的购买历史记录清除，这样最接近真实情况。而历史记录的清除可能需要好几分钟，因此注册多个测试账号，切换测试会比较方便。</p>
<p><img src="https://gdz.oss-cn-shenzhen.aliyuncs.com/local/image-20220516143816984.png" alt="image-20220516143816984"></p>
</li>
<li><p>自动续期订阅的设置在 App - 具体App - 功能 - 订阅 中设置，而不是在App 内购买项目设置</p>
<img src="https://gdz.oss-cn-shenzhen.aliyuncs.com/local/image-20220516144209209.png" alt="image-20220516144209209" style="zoom:80%;" /></li>
</ol>
<h2 id="沙盒环境"><a href="#沙盒环境" class="headerlink" title="沙盒环境"></a>沙盒环境</h2><p>IAP测试阶段只能通过沙盒环境进行测试。从客户端SDK到服务端Apple Server，都有沙盒对应的版本。对客户端，它是另外的API，对服务端，它是另外的端点。对用户端，需要在手机端进行设置。</p>
<p>手机端登录：设置 - App Store - 沙盒账户。点击 沙盒账户 - 管理，能够进入当前App的购买项目管理界面（购买过一次后才会出现），这里可以测试左右横跳。</p>
<h2 id="日志是个好东西"><a href="#日志是个好东西" class="headerlink" title="日志是个好东西"></a>日志是个好东西</h2><p>诚然，我们可以通过将Apple的通知回调URL设置为本地的内网穿透地址，但直接设到测试服地址，再将必要信息输出到日志存储系统才是长久的解决方式。对每个通知，至少需要这几样日志</p>
<ul>
<li>通知的原始信息，遇到问题时候可以直接复制到本地调试</li>
<li>解析后的通知信息，方便查看通知类型</li>
<li>解析后的交易信息，方便查看交易信息</li>
</ul>
<p><img src="https://gdz.oss-cn-shenzhen.aliyuncs.com/local/image-20220516145506230.png" alt="image-20220516145506230"></p>
<h2 id="测试场景列举"><a href="#测试场景列举" class="headerlink" title="测试场景列举"></a>测试场景列举</h2><p>列举能够遇到的场景</p>
<ul>
<li>订阅成功<ul>
<li>初次订阅成功</li>
<li>到期后续订成功</li>
<li>过期后重新订阅成功</li>
</ul>
</li>
<li>订阅失败<ul>
<li>因扣款问题导致订阅失败，可在App Store Connect控制台模拟</li>
</ul>
</li>
<li>订阅到期<ul>
<li>用户关闭自动续期后到期</li>
</ul>
</li>
<li>订阅商品切换<ul>
<li>同等级切换</li>
<li>低级升高级</li>
<li>高级降低级</li>
<li>等级恢复：先降级再升级。（先升级再降级不属于订阅恢复，因为升级马上生效，降级要本周期到期后生效）</li>
</ul>
</li>
</ul>
<h2 id="无法测试的场景"><a href="#无法测试的场景" class="headerlink" title="无法测试的场景"></a>无法测试的场景</h2><p>退款是通过IAP售后申请，非常规渠道，无法测试。</p>
<h2 id="测试数据demo"><a href="#测试数据demo" class="headerlink" title="测试数据demo"></a>测试数据demo</h2><p>看IAP手册最困惑的地方就是没有真实数据作参考，这里给出一些</p>
<h3 id="通知"><a href="#通知" class="headerlink" title="通知"></a>通知</h3><ul>
<li>原始信息：<a href="https://gist.github.com/zou8944/7e223ba95c312abd95dc9bc70d171719#file-iap-storekit2-notification-raw-json-json">iap-storekit2-notification-raw-json</a></li>
<li>解密信息：<a href="https://gist.github.com/zou8944/7e223ba95c312abd95dc9bc70d171719#file-iap-storekit2-notification-json-json">iap-storekit2-notification-json</a></li>
<li>data.signedTransactionInfo：<a href="https://gist.github.com/zou8944/7e223ba95c312abd95dc9bc70d171719#file-iap-storekit2-notification-data-signedtransactioninfo-json">iap-storekit2-notification-data-signedtransactioninfo-json</a></li>
<li>data.signedRenewalInfo：<a href="https://gist.github.com/zou8944/7e223ba95c312abd95dc9bc70d171719#file-iap-storekit2-notification-data-signedrenewalinfo-json">iap-storekit2-notification-data-signedrenewalinfo-json</a></li>
</ul>
<h3 id="交易历史-1"><a href="#交易历史-1" class="headerlink" title="交易历史"></a>交易历史</h3><ul>
<li><a href="https://gist.github.com/zou8944/7e223ba95c312abd95dc9bc70d171719#file-iap-storekit2-transaction-history-json">iap-storekit2-transaction-history-json</a></li>
</ul>
<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>StoreKit2说起来算是简单的，了解了以下几点，开发时才会相对顺利</p>
<ul>
<li>了解基础知识：JWS、JWT、X.509证书及验证</li>
<li>正确理解交易、交易历史的概念</li>
<li>正确理解商品间相互切换时对应的订阅切换逻辑</li>
<li>熟知用户对IAP的操作入口</li>
<li>应考虑到一些关乎安全性的边缘case</li>
<li>要有明确的测试方式，如果只在本地debug不大方便</li>
</ul>
]]></content>
      <categories>
        <category>业务</category>
      </categories>
      <tags>
        <tag>IAP</tag>
      </tags>
  </entry>
  <entry>
    <title>Kerberos</title>
    <url>/2022/01/02/Kerberos/</url>
    <content><![CDATA[]]></content>
  </entry>
  <entry>
    <title>Kotlin协程-使用篇</title>
    <url>/2020/05/25/Kotlin%E5%8D%8F%E7%A8%8B-%E4%BD%BF%E7%94%A8%E7%AF%87-kotlin%E5%8D%8F%E7%A8%8B-%E4%BD%BF%E7%94%A8%E7%AF%87md/</url>
    <content><![CDATA[<blockquote>
<p>使用协程已经有较长的时间了，但一直停留在launch、async启动协程，suspend方法挂起的阶段。这段时间系统梳理Kotlin知识时才发现，对协程（仅对Kotlin）还有很多概念不甚了解。例如CoroutineScope对协程生命周期的重要性、协程父子结构的作用、结构化并发、一些Kotlin协程中约定俗称的规定等。</p>
</blockquote>
<span id="more"></span>

<h1 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h1><h2 id="解释协程"><a href="#解释协程" class="headerlink" title="解释协程"></a>解释协程</h2><p>解释协程这一概念，是个作死的行为，这里斗胆一试。</p>
<p>我们尝试从几个比较流行的说法来解释协程到底是个什么东西，而不是再增加一种让人猜不透的说法</p>
<ol>
<li><p>协程是轻量级线程(官方表述)</p>
<p>可以换个说法，协程就是方法调用封装成类线程的API。方法调用当然比线程切换轻量；而封装成类线程的API后，它形似线程（可手动启动、有各种运行状态、能够协作工作、能够并发执行）。因此从这个角度说，它是轻量级线程没错。</p>
<p>当然，协程绝不仅仅是方法调用，因为方法调用不能在一个方法执行到一半时挂起，之后又在原点恢复。这一点可以使用EventLoop之类的方式实现。想象一下在库级别将回调风格或Promise/Future风格的异步代码封装成同步风格，封装的结果就非常接近协程了。</p>
<p>而协程和线程之间的区别，往大了说，那就是普通函数与线程的区别；往小了说，就是EventLoop和线程的区别。他们之间的唯一的关系，仅仅在于协程的代码是运行在线程中。一个不恰当的类比，人和地球(地球提供生成环境，人在其中生存)</p>
</li>
<li><p>线程运行在内核态，协程运行在用户态</p>
<p>主要明白什么叫用户态，我们写的几乎所有代码，都执行在用户态，协程对于操作系统来说仅仅是第三方提供的库而已，当然运行在用户态。而线程是操作系统级别的东西，运行在内核态。</p>
</li>
<li><p>协程是一个线程框架(扔物线表述)</p>
<p>对某些语言，比如Kotlin，这样说是没有问题的，Kotlin的协程库可以指定协程运行的线程池，我们只需要操作协程，必要的线程切换操作交给库，从这个角度来说，协程就是一个线程框架。</p>
<p>但理论上我们可以在单线程语言如JavaScript、Python上实现协程(事实上他们已经实现了协程)，这时我们再叫它线程框架可能就不合适了。</p>
</li>
</ol>
<p>私以为，协程要从两方面看</p>
<ul>
<li><p>概念上：coroutine(协程)和subroutine(子程序)是一个级别的(从命名上也类似)。子程序是一段具备一定功能的代码，一个函数、一个方法、一段代码都算是一个子程序。而协程，顾名思义，就是相互协作的子程序，多个子程序之间通过一定的机制相互关联、协作地完成某项任务。比如一个协程在执行上可以被分为多个子程序，每个子程序执行完成后主动挂起，等待合适的时机再恢复；一个协程被挂起时，线程可以执行其它子程序，从而达到线程高利用率的多任务处理目的——协程在一个线程上执行多个任务，而传统线程只能执行一个任务，从多任务执行的角度，协程自然比线程轻量。</p>
<p>通过提高线程利用率来提高多任务执行效率，这一点和IO多路复用、Reactor模型等基本思想一致，从这个角度看，协程并不是什么新东西。</p>
</li>
<li><p>实现上：协程的重点和难点就在于执行到挂起点时挂起和恢复的行为。它在底层技术实现上和我们常用的异步回调没有本质的区别，仅仅是根据不同的编程思想封装成对应的API。</p>
<p>其具体实现原理我们将在其它文章讨论，这里仅介绍协程概念。</p>
</li>
</ul>
<p>协程解决的问题——以同步的方式写异步代码。如果不使用协程，我们目前能够使用的API形式主要有三种：纯回调风格(如AIO)、RxJava、Promise/Future风格，他们普遍存在回调地狱问题，解回调地狱只能通过行数换层数，且对于不熟悉异步风格的程序员来说，能够看懂较为复杂的异步代码就比较费劲。</p>
<h2 id="Kotlin的协程"><a href="#Kotlin的协程" class="headerlink" title="Kotlin的协程"></a>Kotlin的协程</h2><p>根据<a href="https://github.com/Kotlin-zh/KEEP/blob/master/proposals/coroutines.md">Kotlin协程设计提案</a>，Kotlin协程的设计目标有如下三点</p>
<ul>
<li>不依赖 Future 之类复杂的库提供的特定实现</li>
<li>同时涵盖 “async/await” 用例以及“生成器代码块”</li>
<li>使 Kotlin 协程能包装各种现有的异步 API （如 Java NIO、各种 Future 的实现等）</li>
</ul>
<p>可以认为，Kotlin是想在自己的代码环境中用协程消除传统的异步API，以原语的方式提供。</p>
<h2 id="本文介绍"><a href="#本文介绍" class="headerlink" title="本文介绍"></a>本文介绍</h2><p>上面介绍了协程的基本概念和Kotlin协程的设计目的，接下来介绍Kotlin中协程的使用方法、核心组件、核心概念以及常见使用约定。有关实现原理，尚未探索，计划另开文章详述。</p>
<h1 id="使用协程"><a href="#使用协程" class="headerlink" title="使用协程"></a>使用协程</h1><h2 id="启动"><a href="#启动" class="headerlink" title="启动"></a>启动</h2><p>协程需要运行在协程上下文环境，在非协程环境中凭空启动协程，有三种方式</p>
<ul>
<li><p>runBlocking{}</p>
<p>启动一个新协程，并阻塞当前线程，直到其内部所有逻辑及子协程逻辑全部执行完成。</p>
<p>该方法的设计目的是让suspend风格编写的库能够在常规阻塞代码中使用，常在main方法和测试中使用。</p>
</li>
<li><p>GlobalScope.launch{}</p>
<p>在应用范围内启动一个新协程，协程的生命周期与应用程序一致。这样启动的协程并不能使线程保活，就像守护线程。</p>
<p>由于这样启动的协程存在启动协程的组件已被销毁但协程还存在的情况，极限情况下可能导致资源耗尽，因此并不推荐这样启动，尤其是在客户端这种需要频繁创建销毁组件的场景。</p>
</li>
<li><p>实现CoroutineScope + launch{}</p>
<p>这是在应用中最推荐使用的协程使用方式——为自己的组件实现CoroutieScope接口，在需要的地方使用launch{}方法启动协程。使得协程和该组件生命周期绑定，组件销毁时，协程一并销毁。从而实现安全可靠地协程调用。</p>
</li>
</ul>
<p>在一个协程中启动子协程，一般来说有两种方式</p>
<ul>
<li><p>launch{}</p>
<p>异步启动一个子协程</p>
</li>
<li><p>async{}</p>
<p>异步启动一个子协程，并返回Deffer对象，可通过调用Deffer.await()方法等待该子协程执行完成并获取结果，常用于并发执行-同步等待的情况</p>
</li>
</ul>
<p>一个合适的例子</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">TtpServiceImpl</span></span>(<span class="keyword">val</span> vertx: Vertx): TtpService, CoroutineScope &#123;</span><br><span class="line">    <span class="keyword">override</span> <span class="keyword">val</span> coroutineContext: CoroutineContext <span class="keyword">by</span> lazy &#123; vertx.dispatcher() &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">getContentList</span><span class="params">(resultHandler: <span class="type">Handler</span>&lt;<span class="type">AsyncResult</span>&lt;<span class="type">OperationResponse</span>&gt;&gt;)</span></span>&#123;</span><br><span class="line">        launch&#123;</span><br><span class="line">            <span class="keyword">val</span> deffer1 = async&#123; awaitResult&lt;List&lt;JsonObject&gt;&gt;&#123; dbService.getContentList(it) &#125; &#125;</span><br><span class="line">            <span class="keyword">val</span> deffer2 = async&#123; awaitResult&lt;List&lt;JsonObject&gt;&gt;&#123; dbService.getAuthorList(it) &#125; &#125;</span><br><span class="line">            <span class="keyword">val</span> contents = deffer1.await()</span><br><span class="line">            <span class="keyword">val</span> authors = deffer2.await()</span><br><span class="line">            <span class="keyword">val</span> reuslt = contents.map&#123; content -&gt; </span><br><span class="line">                content.put(<span class="string">&quot;author&quot;</span>, authors.filter&#123; ... &#125;.first())</span><br><span class="line">            &#125;</span><br><span class="line">            resultHandler.succeed(reuslt)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="取消"><a href="#取消" class="headerlink" title="取消"></a>取消</h2><p>launch{}返回Job，async{}返回Deffer，Job和Deffer都有cancel()方法，用于取消协程。</p>
<p><strong>从协程内部看取消的效果</strong></p>
<ul>
<li>标准库的挂起方法会抛出CancellationException异常。</li>
<li>用户自定义的常规逻辑并不会收到影响，除非我们手动检测isActive标志。</li>
</ul>
<p>上面两个特性和线程的interrupt机制非常类似，理解起来并不难。</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">val</span> job = launch &#123;</span><br><span class="line">    <span class="comment">// 如果这里不检测isActive标记，协程就不会被正常cancel，而是执行直到正常结束</span></span><br><span class="line">    <span class="keyword">while</span> (isActive) &#123; </span><br><span class="line">        ......</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">job.cancelAndJoin() <span class="comment">// 取消该作业并等待它结束</span></span><br></pre></td></tr></table></figure>

<p>了解协程的启动和取消，对于最基本的使用已经足够了。不过为了更加安全放心地使用，需要更加深入地了解，我们从核心组件说起。</p>
<h2 id="异常"><a href="#异常" class="headerlink" title="异常"></a>异常</h2><p>Kotlin协程的异常有两种</p>
<ul>
<li>因协程取消，协程内部suspend方法抛出的CancellationException</li>
<li>常规异常，这类异常，有两种异常传播机制<ul>
<li>launch：将异常自动向父协程抛出，将会导致父协程退出</li>
<li>async: 将异常暴露给用户(通过捕获deffer.await()抛出的异常)</li>
</ul>
</li>
</ul>
<p>这里借用官方例子讲解</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">()</span></span> = runBlocking &#123;</span><br><span class="line">    <span class="keyword">val</span> job = GlobalScope.launch &#123; <span class="comment">// root coroutine with launch</span></span><br><span class="line">        println(<span class="string">&quot;Throwing exception from launch&quot;</span>)</span><br><span class="line">        <span class="keyword">throw</span> IndexOutOfBoundsException() <span class="comment">// 我们将在控制台打印 Thread.defaultUncaughtExceptionHandler</span></span><br><span class="line">    &#125;</span><br><span class="line">    job.join()</span><br><span class="line">    println(<span class="string">&quot;Joined failed job&quot;</span>)</span><br><span class="line">    <span class="keyword">val</span> deferred = GlobalScope.async &#123; <span class="comment">// root coroutine with async</span></span><br><span class="line">        println(<span class="string">&quot;Throwing exception from async&quot;</span>)</span><br><span class="line">        <span class="keyword">throw</span> ArithmeticException() <span class="comment">// 没有打印任何东西，依赖用户去调用等待</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        deferred.await()</span><br><span class="line">        println(<span class="string">&quot;Unreached&quot;</span>)</span><br><span class="line">    &#125; <span class="keyword">catch</span> (e: ArithmeticException) &#123;</span><br><span class="line">        println(<span class="string">&quot;Caught ArithmeticException&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>输出结果</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line">Throwing exception from launch</span><br><span class="line">Exception <span class="keyword">in</span> thread <span class="string">&quot;DefaultDispatcher-worker-2 @coroutine#2&quot;</span> java.lang.IndexOutOfBoundsException</span><br><span class="line">Joined failed job</span><br><span class="line">Throwing exception from async</span><br><span class="line">Caught ArithmeticException</span><br></pre></td></tr></table></figure>

<p>注意，例子是在GlobalScope.launch{}中抛异常，不会导致父协程退出。</p>
<p><strong>全局异常处理</strong></p>
<p>指定全局异常处理器，省时省力。</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line">  <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">getContentList</span><span class="params">(resultHandler: <span class="type">Handler</span>&lt;<span class="type">AsyncResult</span>&lt;<span class="type">OperationResponse</span>&gt;&gt;)</span></span> &#123;</span><br><span class="line">    launch(CoroutineExceptionHandler &#123; _, e -&gt;</span><br><span class="line">      logger.error(<span class="string">&quot;Exception when get content list.&quot;</span>, e)</span><br><span class="line">      resultHandler.fail()</span><br><span class="line">    &#125;) &#123;</span><br><span class="line">            <span class="keyword">val</span> deffer1 = async&#123; awaitResult&lt;List&lt;JsonObject&gt;&gt;&#123; dbService.getContentList(it) &#125; &#125;</span><br><span class="line">            <span class="keyword">val</span> deffer2 = async&#123; awaitResult&lt;List&lt;JsonObject&gt;&gt;&#123; dbService.getAuthorList(it) &#125; &#125;</span><br><span class="line">            <span class="keyword">val</span> contents = deffer1.await()</span><br><span class="line">            <span class="keyword">val</span> authors = deffer2.await()</span><br><span class="line">            <span class="keyword">val</span> reuslt = contents.map&#123; content -&gt; </span><br><span class="line">                content.put(<span class="string">&quot;author&quot;</span>, authors.filter&#123; ... &#125;.first())</span><br><span class="line">            &#125;</span><br><span class="line">            resultHandler.succeed(reuslt)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="核心组件"><a href="#核心组件" class="headerlink" title="核心组件"></a>核心组件</h1><p>Kotlin的协程实现是以附加库kotlinx-coroutines-core的形式提供的，但其实协程的接口定义在核心库kotlin-stdlib-common的kotlin.coroutines中。</p>
<h2 id="协程上下文"><a href="#协程上下文" class="headerlink" title="协程上下文"></a>协程上下文</h2><p>顾名思义，协程上下文表示协程的运行环境，包括协程调度器、代表协程本身的Job、协程名称、协程ID等。通过CoroutineContext定义，CoroutineContext被定义为一个带索引的集合，集合的元素为Element，上面所提到调度器、Job等都实现了Eelement接口。</p>
<p>由于CoroutineContext被定义为集合，因此在实际使用时可以自由组合加减各种上下文元素。</p>
<p>启动子协程时，子协程默认会继承除Job外的所有父协程上下文元素，创建新的Job，并将父Job设置为当前Job的父亲。</p>
<p>启动子协程时，可以指定协程上下文元素，如果父上下文中存在该元素则覆盖，不存在则添加。</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">getContentList</span><span class="params">(resultHandler: <span class="type">Handler</span>&lt;<span class="type">AsyncResult</span>&lt;<span class="type">OperationResponse</span>&gt;&gt;)</span></span>&#123;</span><br><span class="line">    <span class="comment">// 自定义新协程名称</span></span><br><span class="line">    launch(CoroutineName(<span class="string">&quot;customName&quot;</span>))&#123;</span><br><span class="line">        ... ...</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="调度器"><a href="#调度器" class="headerlink" title="调度器"></a>调度器</h3><p>调度器是协程上下文中众多元素中最重要的一个，通过CoroutineDispatcher定义，它控制了协程以何种策略分配到哪些线程上运行。这里介绍几种常见的调度器</p>
<ul>
<li><p>Dispatcher.Default</p>
<p>默认调度器。它使用JVM的共享线程池，该调度器的最大并发度是CPU的核心数，默认为2</p>
</li>
<li><p>Dispatcher.Unconfined</p>
<p>非受限调度器，它不会将操作限制在任何线程上执行——在发起协程的线程上执行第一个挂起点之前的操作，在挂起点恢复后由对应的挂起函数决定接下来在哪个线程上执行。</p>
</li>
<li><p>Dispathcer.IO</p>
<p>IO调度器，他将阻塞的IO任务分流到一个共享的线程池中，使得不阻塞当前线程。该线程池大小为环境变量kotlinx.coroutines.io.parallelism的值，默认是64或核心数的较大者。</p>
<p>该调度器和Dispatchers.Default共享线程，因此使用withContext(Dispatchers.IO)创建新的协程不一定会导致线程的切换。</p>
</li>
<li><p>Dispathcer.Main</p>
<p>该调度器限制所有执行都在UI主线程，它是专门用于UI的，并且会随着平台的不同而不同</p>
<ul>
<li>对于JS或Native，其效果等同于Dispatchers.Default</li>
<li>对于JVM，它是Android的主线程、JavaFx或者Swing EDT的dispatcher之一。</li>
</ul>
<p>并且为了使用该调度器，还必须增加对应的组件</p>
<ul>
<li>kotlinx-coroutines-android</li>
<li>kotlinx-coroutines-javafx</li>
<li>kotlinx-coroutines-swing</li>
</ul>
</li>
<li><p>其它</p>
<p>在其它支持协程的第三方库中，也存在对应的调度器，如Vertx的vertx.dispatcher()，它将协程分配到vertx的EventLoop线程池执行。</p>
</li>
</ul>
<p>注意，由于上下文具有继承关系，因此启动子协程时不显式指定调度器时，子协程和父协程是使用相同调度器的。</p>
<h3 id="Job"><a href="#Job" class="headerlink" title="Job"></a>Job</h3><p>Job也是上下文元素，它代表协程本身。Job能够被组织成父子层次结构，并具有如下重要特性。</p>
<ul>
<li>父Job退出，所有子job会马上退出</li>
<li>子job抛出除CancellationException(意味着正常取消)意外的异常会导致父Job马上退出</li>
</ul>
<p>类似Thread，一个Job可能存在多种状态</p>
<table>
<thead>
<tr>
<th><strong>State</strong></th>
<th>[isActive]</th>
<th>[isCompleted]</th>
<th>[isCancelled]</th>
</tr>
</thead>
<tbody><tr>
<td><em>New</em> (optional initial state)</td>
<td><code>false</code></td>
<td><code>false</code></td>
<td><code>false</code></td>
</tr>
<tr>
<td><em>Active</em> (default initial state)</td>
<td><code>true</code></td>
<td><code>false</code></td>
<td><code>false</code></td>
</tr>
<tr>
<td><em>Completing</em> (transient state)</td>
<td><code>true</code></td>
<td><code>false</code></td>
<td><code>false</code></td>
</tr>
<tr>
<td><em>Cancelling</em> (transient state)</td>
<td><code>false</code></td>
<td><code>false</code></td>
<td><code>true</code></td>
</tr>
<tr>
<td><em>Cancelled</em> (final state)</td>
<td><code>false</code></td>
<td><code>true</code></td>
<td><code>true</code></td>
</tr>
<tr>
<td><em>Completed</em> (final state)</td>
<td><code>false</code></td>
<td><code>true</code></td>
<td><code>false</code></td>
</tr>
</tbody></table>
<p>我们直接使用launch获取到的job已经处于Active装填，启动时加上LAZY参数时则得到New状态的Active。</p>
<p>各状态转换关系如下，注意，Completing只是一个内部状态，外部观察还是Active状态。</p>
<p><img src="https://gdz.oss-cn-shenzhen.aliyuncs.com/hexo/Kotlin%E5%8D%8F%E7%A8%8B-%E4%BD%BF%E7%94%A8%E7%AF%87/image-20200530154420916.png" alt="image-20200530154420916"></p>
<p>要区分是主动取消还是异常导致一个协程退出，可以getCancellationException()查看退出原因。</p>
<h2 id="作用域"><a href="#作用域" class="headerlink" title="作用域"></a>作用域</h2><p>协程作用域——CoroutineScope，用于管理协程，管理的内容有</p>
<ul>
<li>启动协程的方式 - 它定义了launch、async、withContext等协程启动方法(以extention的方式)，并在这些方法内定义了启动子协程时上下文的继承方式。</li>
<li>管理协程生命周期 - 它定义了cancel()方法，用于取消当前作用域，同时取消作用域内所有协程。</li>
</ul>
<h2 id="区分作用域和上下文"><a href="#区分作用域和上下文" class="headerlink" title="区分作用域和上下文"></a>区分作用域和上下文</h2><p>从类定义看，CoroutineScope和CoroutineContext非常类似，最终目的都是协程上下文，但正如Kotlin协程负责人Roman Elizarov在<a href="https://medium.com/@elizarov/coroutine-context-and-scope-c8b255d59055">Coroutine Context and Scope</a>中所说，二者的区别只在于使用目的的不同——<strong>作用域用于管理协程；而上下文只是一个记录协程运行环境的集合</strong>。他们的关系如下。</p>
<p><img src="https://gdz.oss-cn-shenzhen.aliyuncs.com/hexo/Kotlin%E5%8D%8F%E7%A8%8B-%E4%BD%BF%E7%94%A8%E7%AF%87/image-20200530153221730.png" alt="image-20200530153221730"></p>
<p>Roman Elizarov的文章说得可能不是很明晰，我认为比较容易理解的说法是</p>
<ul>
<li>CoroutineScope规范了CoroutineContext的继承和管理方式。</li>
</ul>
<h1 id="约定和经验"><a href="#约定和经验" class="headerlink" title="约定和经验"></a>约定和经验</h1><h2 id="避免使用GlobalScope-launch"><a href="#避免使用GlobalScope-launch" class="headerlink" title="避免使用GlobalScope.launch"></a>避免使用GlobalScope.launch</h2><p>GlobalScope是实现了CoroutineScope的单例对象，含有一个空的上下文对象</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="comment">// GlobalScope的定义</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">object</span> GlobalScope : CoroutineScope &#123;</span><br><span class="line">    <span class="keyword">override</span> <span class="keyword">val</span> coroutineContext: CoroutineContext</span><br><span class="line">        <span class="keyword">get</span>() = EmptyCoroutineContext</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这意味着它的生命周期与整个应用绑定，并且永远不会被主动取消。这样启动的协程只有两个归宿:</p>
<ul>
<li>协程正常执行完成</li>
<li>协程内部发生错误，导致协程因异常自动取消</li>
</ul>
<p>这是危险的。考虑极端情况:</p>
<ol>
<li>在一个实例方法中使用GlobalScope.launch启动了一个CPU密集型协程，且执行时间较长</li>
<li>在启动协程后，该实例方法因异常退出，所属对象也被销毁</li>
<li>反复多次出现步骤1\2</li>
</ol>
<p>这样导致的结果是启动了超多CPU密集型任务，最终导致应用卡顿，甚至资源耗尽。</p>
<p>解决方案是避免使用GlobalScope。正确的做法是将自己的组件实现CoroutineScope，并在组件销毁时调用作用域的cancel()方法。实现方式多使用委托。</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 官方例子</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyActivity</span> : <span class="type">AppCompatActivity</span></span>(), CoroutineScope <span class="keyword">by</span> MainScope() &#123;</span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">onDestroy</span><span class="params">()</span></span> &#123;</span><br><span class="line">         cancel() <span class="comment">// cancel is extension on CoroutineScope</span></span><br><span class="line">    &#125;</span><br><span class="line">    ... ...</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// vertx例子</span></span><br><span class="line"><span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">CoroutineVerticle</span> : <span class="type">Verticle</span>, <span class="type">CoroutineScope &#123;</span></span></span><br><span class="line">  <span class="comment">// 默认上下文使用context.dispatcher()</span></span><br><span class="line">  <span class="keyword">override</span> <span class="keyword">val</span> coroutineContext: CoroutineContext <span class="keyword">by</span> lazy &#123; context.dispatcher() &#125;</span><br><span class="line">  ... ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="结构化并发"><a href="#结构化并发" class="headerlink" title="结构化并发"></a>结构化并发</h2><p>首先从结构化并发这一概念说起(参考<a href="https://vorpus.org/blog/notes-on-structured-concurrency-or-go-statement-considered-harmful/">这篇文章</a>)。</p>
<p><strong>非结构化并发</strong></p>
<p>与结构化并发相对的是非结构化并发，即传统的异步框架和异步库。这种异步框架在工作时，可能会在函数中启动一个新的协程，或新注册一个回调函数，当函数调用返回时，从语义上，函数貌似返回了，但实际上它仍然在后台运行(对于启动的协程，他会运行直到结束；对于注册的回调函数，仍然属于原函数的一部分，会在将来执行)，如果不了解其中的因果关系，就不知道它什么时候结束，<strong>这违反了因果关系</strong>。</p>
<p>正是由于异步框架的非结构化并发的缺点，导致出现背压这样更加复杂的副产物。尽管它们能够使程序正常工作，但会很麻烦，违反编程直觉——你不是在编程，而是在使用一种工具。</p>
<p>一个非结构化并发的逻辑流如同go语句产生的效果。</p>
<p><img src="https://gdz.oss-cn-shenzhen.aliyuncs.com/hexo/Kotlin%E5%8D%8F%E7%A8%8B-%E4%BD%BF%E7%94%A8%E7%AF%87/image-20200530165158464.png" alt="image-20200530165158464"></p>
<p><strong>结构化并发</strong></p>
<p>结构化并发，就是将多个分开的并发路径最终再次连接起来，使得符合因果关系，在意义上类比将面条代码始作俑者go语句从编程语言中剔除。</p>
<p><img src="https://gdz.oss-cn-shenzhen.aliyuncs.com/hexo/Kotlin%E5%8D%8F%E7%A8%8B-%E4%BD%BF%E7%94%A8%E7%AF%87/image-20200530165243662.png" alt="image-20200530165243662"></p>
<p>实现结构化并发需要运行环境，用于包装真正的异步操作，并暴露取消机制、异常传播机制等API。</p>
<p><strong>Kotlin如何实现结构化并发</strong></p>
<p>Kotlin协程通过CoroutineScope实现结构化并发。因为作用域具有如下特性</p>
<ul>
<li>能够控制内部协程的生命周期</li>
<li>可以取消内部所有协程</li>
<li>所有子协程完成后作用域才结束</li>
</ul>
<p>为了让我们能够对一部分代码块实现结构化并发，Kotlin提供了coroutineScope{}方法(官方声称其目的在于并行分解，即将一个长耗时任务分解成多个并发的短耗时任务，并在最终组装，正是利用了作用域的结构化并发特性，才能够实现并行分解)</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 常用的示意例子，这里用的是async，实际上用launch时，coroutineScope也会等待其结束后再返回。</span></span><br><span class="line"><span class="keyword">suspend</span> <span class="function"><span class="keyword">fun</span> <span class="title">loadAndCombine</span><span class="params">(name1: <span class="type">String</span>, name2: <span class="type">String</span>)</span></span>: Image = coroutineScope &#123;</span><br><span class="line">    <span class="keyword">val</span> deferred1 = async &#123; loadImage(name1) &#125;</span><br><span class="line">    <span class="keyword">val</span> deferred2 = async &#123; loadImage(name2) &#125;</span><br><span class="line">    combineImages(deferred1.await(), deferred2.await())</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>此外，从结构化并发的概念上看，runBlocking{}也能够结构化并发。</p>
<h2 id="suspend方法和CoroutineScope扩展方法的取舍"><a href="#suspend方法和CoroutineScope扩展方法的取舍" class="headerlink" title="suspend方法和CoroutineScope扩展方法的取舍"></a>suspend方法和CoroutineScope扩展方法的取舍</h2><p>Kotlin中，有两个约定俗成的东西</p>
<ol>
<li><p>每一个声明为CoroutineScope的扩展方法的方法，都会马上返回，但是会并发地执行扩展方法指定的内容</p>
<p>这也是runBlocking不是CoroutineScope的扩展方法的原因之一</p>
</li>
<li><p>每一个仅声明为suspend的方法，会等待其内部逻辑完成后再返回给调用者</p>
</li>
</ol>
<p>但如果拥有如下签名的方法会怎么样呢？它是suspend方法，同时也是CoroutineScope的扩展方法。调用者并不知道在方法内是否会启动新的协程，凭空给代码增加了复杂度，因此不推荐使用。</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">suspend</span> <span class="function"><span class="keyword">fun</span> CoroutineScope.<span class="title">obfuscate</span><span class="params">(<span class="keyword">data</span>: <span class="type">Data</span>)</span></span></span><br></pre></td></tr></table></figure>

<p>suspend方法就应该在所有任务都完成后再返回。如果在suspend方法内部有需要并发执行的内容，那就应该等待他们都完成后再返回，此时可以使用coroutineScope{}，而不是在方法签名上加上CoroutineScope扩展。</p>
<h1 id="区分与对比"><a href="#区分与对比" class="headerlink" title="区分与对比"></a>区分与对比</h1><p>Kotlin中，有几种方式能够启动协程，或者看似能够启动协程，这里列举</p>
<ul>
<li><p>launch{}</p>
<p>CoroutineScope的扩展方法，<strong>启动一个协程</strong>，不阻塞当前协程，并返回新协程的Job。</p>
</li>
<li><p>async{}</p>
<p>CoroutineScope的扩展方法，<strong>启动一个协程</strong>，不阻塞当前协程，返回一个Deffer，除包装了未来的结果外，其余特性与launch{}一致</p>
</li>
<li><p>withContext(){}</p>
<p>一个suspend方法，在给定的上下文执行给定挂起块并返回结果，<strong>它并不启动协程</strong>，只会(可能会)导致线程的切换。用它执行的挂起块中的上下文是当前协程的上下文和由它执行的上下文的合并结果。</p>
<p>withContext的目的不在于启动子协程，它最初用于将长耗时操作从UI线程切走，完事再切回来。</p>
<p>前面我们说过，协程取消后，位于协程中的标准库的suspend函数会抛出CancellationException，withContext也不例外。</p>
</li>
<li><p>coroutineScope{}</p>
<p>一个suspend方法，创建一个新的作用域，并在该作用域内执行指定代码块，<strong>它并不启动协程</strong>。其存在的目的是进行符合结构化并发的并行分解（即，将长耗时任务拆分为并发的多个短耗时任务，并等待所有并发任务完成后再返回）。</p>
</li>
<li><p>runBlocking{}</p>
<p>是一个裸方法，<strong>创建一个协程，并阻塞当前线程</strong>，直到协程执行完毕。前面说过，这里不再赘述。</p>
</li>
</ul>
<h1 id="Kotlin协程的其它功能"><a href="#Kotlin协程的其它功能" class="headerlink" title="Kotlin协程的其它功能"></a>Kotlin协程的其它功能</h1><h2 id="异步流"><a href="#异步流" class="headerlink" title="异步流"></a>异步流</h2><p>首先说，Kotlin中的异步流和RxJava中的流在概念上非常类似，可以被归为响应式流。并且Kotlin也提供响应的库将它转换为其它响应式流</p>
<ul>
<li>kotlinx-coroutines-reactive 用于Reactive Streams</li>
<li>kotlinx-coroutines-reactor  用于Project Reactor</li>
<li>kotlinx-coroutines-rx2      用于RxJava2</li>
</ul>
<h3 id="为什么需要异步流"><a href="#为什么需要异步流" class="headerlink" title="为什么需要异步流"></a>为什么需要异步流</h3><p>一个挂起函数能够异步地返回单一的值，如果我们要异步返回多个值并针对每个都做处理呢？这也是一般响应式流遇到的场景，在Kotlin中，异步流用来解决它。</p>
<p><strong>已有现成的响应式流，为啥还有异步流？</strong></p>
<p>从功能上说，现有的响应式流库能够解决问题，但在Kotlin中不够优雅。Flow的设计目标是拥有尽可能精简的设计，能够完美融合到Kotlin的协程API中。</p>
<h3 id="使用异步流"><a href="#使用异步流" class="headerlink" title="使用异步流"></a>使用异步流</h3><figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">val</span> flow = flow &#123;</span><br><span class="line">  <span class="comment">// 耗时操作1</span></span><br><span class="line">  delay(<span class="number">1000</span>)</span><br><span class="line">  emit(<span class="number">12</span>)</span><br><span class="line">  <span class="comment">// 耗时操作2</span></span><br><span class="line">  delay(<span class="number">1000</span>)</span><br><span class="line">  emit(<span class="number">13</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">runBlocking &#123;</span><br><span class="line">  flow.collect &#123; println(it) &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>flow接收的lambda表达式是一个协程环境，里面的操作实在一个协程中执行</li>
<li>collect是收集操作，<strong>只有收集时才会真的去执行流中定义的逻辑</strong></li>
<li>flow也可以被取消</li>
</ul>
<p>更多详情，移步<a href="https://www.kotlincn.net/docs/reference/coroutines/flow.html">官方手册</a></p>
<h2 id="通道"><a href="#通道" class="headerlink" title="通道"></a>通道</h2><p>通道(Channel)用于在多个协程之间传输数据。Channel是和BlockingQueue非常相似的概念。不同的是写入和读取数据用的是异步的send和recieve</p>
<p>这里展示简单的使用</p>
<ul>
<li><p>直接通过Channel构造函数</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">val</span> channel = Channel&lt;<span class="built_in">Int</span>&gt;()</span><br><span class="line">launch &#123;</span><br><span class="line">    <span class="keyword">for</span> (x <span class="keyword">in</span> <span class="number">1.</span><span class="number">.5</span>) channel.send(x * x)</span><br><span class="line">    channel.close()</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> (y <span class="keyword">in</span> channel) println(y)</span><br><span class="line">println(<span class="string">&quot;Done!&quot;</span>)</span><br></pre></td></tr></table></figure></li>
<li><p>使用produce构建器</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">val</span> channel = produce &#123;</span><br><span class="line">    send(<span class="number">12</span>)</span><br><span class="line">    send(<span class="number">13</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (value <span class="keyword">in</span> channel) &#123;</span><br><span class="line">    println(value)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<p>在通道没有数据时，调用recieve会导致协程挂起；在通道缓冲满时，调用send会导致协程挂起。</p>
<p>通道遵循FIFO原则，先发出的消息会先被获取。</p>
<h2 id="监督"><a href="#监督" class="headerlink" title="监督"></a>监督</h2><p>常规的Job当子协程抛异常时，父协程也会被退出。有时不想要这种情况发生，可以使用监督。使用方式是将SupervisorJob在协程启动时当上下文元素传入。</p>
<h2 id="协程-通道实现actor"><a href="#协程-通道实现actor" class="headerlink" title="协程+通道实现actor"></a>协程+通道实现actor</h2><p>Kotlin的协程本质上说是更好用的线程的封装，因此还是会有共享的可变状态的并发问题。解决方式无非几种</p>
<ul>
<li>共享变量使用并发数据结构，如Atomic数据类</li>
<li>限制访问共享变量的协程在单线程上执行</li>
<li>对共享变量的访问加锁</li>
<li>使用actor模式，将共享变量封装在actor中，通过actor的消息邮箱将并发变串行</li>
</ul>
<p>Kotlin的actor是由一个<strong>协程</strong>、协程封装的<strong>状态</strong>、一个它与其它协程通信的<strong>通道</strong>组成。</p>
<p>和scala一样，正确使用actor的方式是先创建消息类，然后定义actor，然后发送消息</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 计数器 Actor 的各种类型</span></span><br><span class="line"><span class="keyword">sealed</span> <span class="class"><span class="keyword">class</span> <span class="title">CounterMsg</span></span></span><br><span class="line"><span class="keyword">object</span> IncCounter : CounterMsg() <span class="comment">// 递增计数器的单向消息</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">GetCounter</span></span>(<span class="keyword">val</span> response: CompletableDeferred&lt;<span class="built_in">Int</span>&gt;) : CounterMsg() <span class="comment">// 携带回复的请求</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">()</span></span> = runBlocking&lt;<span class="built_in">Unit</span>&gt; &#123;</span><br><span class="line">  <span class="keyword">val</span> counter = actor&lt;CounterMsg&gt; &#123;</span><br><span class="line">    <span class="keyword">var</span> counter = <span class="number">0</span> <span class="comment">// actor 状态</span></span><br><span class="line">    <span class="keyword">for</span> (msg <span class="keyword">in</span> channel) &#123; <span class="comment">// 即将到来消息的迭代器</span></span><br><span class="line">      <span class="keyword">when</span> (msg) &#123;</span><br><span class="line">        <span class="keyword">is</span> IncCounter -&gt; counter++</span><br><span class="line">        <span class="keyword">is</span> GetCounter -&gt; msg.response.complete(counter)</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  withContext(Dispatchers.Default) &#123;</span><br><span class="line">    counter.send(IncCounter)</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 发送一条消息以用来从一个 actor 中获取计数值</span></span><br><span class="line">  <span class="keyword">val</span> response = CompletableDeferred&lt;<span class="built_in">Int</span>&gt;()</span><br><span class="line">  counter.send(GetCounter(response))</span><br><span class="line">  println(<span class="string">&quot;Counter = <span class="subst">$&#123;response.await()&#125;</span>&quot;</span>)</span><br><span class="line">  counter.close() <span class="comment">// 关闭该actor</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>actor能够并发安全的原因是它将并发过来的请求存储在通道中，再一个一个地处理。达到了不需要加锁的串行调用。比直接并发安全，比加锁高效。</p>
<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>本文详述了Kotlin协程的基本用法及重要组件的运行机制，对它们有了足够详细的了解和清晰的认识有助于我们写出正确的Kotlin协程代码。当然实际使用还需要根据具体情况选择恰当的API。文章的最后大致介绍了Kotlin协程中的其它功能，虽然不常用到，但了解总是没错的，万一有用呢。</p>
<p>文章中偏重讲解，示例代码较少，且部分实例代码来自官方，部分来自自己，并不一定能够直接运行，重在展示用法，阅读时注意区分。</p>
<p>写本文前打了很多草稿，如有兴趣翻阅，可以看<a href="">这里</a>。</p>
<h1 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h1><ol>
<li><a href="%5Bhttps://zh.wikipedia.org/wiki/%E5%8D%8F%E7%A8%8B%5D(https://zh.wikipedia.org/wiki/%E5%8D%8F%E7%A8%8B)">协程 - 维基百科</a></li>
<li><a href="https://www.bilibili.com/video/BV164411C7FK?from=search&seid=6066955533575291649">[码上开学]协程系列视频(扔物线，共3集)</a></li>
<li><a href="https://github.com/Kotlin-zh/KEEP/blob/master/proposals/coroutines.md">Kotlin协程设计提案(翻译版)</a></li>
<li><a href="https://www.kotlincn.net/docs/reference/coroutines/coroutines-guide.html">Kotlin协程官方手册</a></li>
<li>Kotlin核心组件Javadoc</li>
<li><a href="https://medium.com/@elizarov/coroutine-context-and-scope-c8b255d59055">Coroutine Context and Scope - Roman Elizarov</a></li>
<li><a href="https://medium.com/@elizarov/the-reason-to-avoid-globalscope-835337445abc">The reason to avoid GlobalScope - Roman Elizarov</a></li>
<li><a href="https://medium.com/@elizarov/structured-concurrency-722d765aa952">Structed concurrency - Roman Elizarov</a></li>
<li><a href="https://vorpus.org/blog/notes-on-structured-concurrency-or-go-statement-considered-harmful/">Structed concurrency - Somebody</a></li>
<li><a href="https://medium.com/@elizarov/explicit-concurrency-67a8e8fd9b25">Explicit Concurrency - Roman Elizarov</a></li>
</ol>
]]></content>
      <categories>
        <category>编程语言</category>
        <category>响应式</category>
      </categories>
      <tags>
        <tag>kotlin</tag>
        <tag>协程</tag>
      </tags>
  </entry>
  <entry>
    <title>Kubernetes初探 - ConfigMap和Secret</title>
    <url>/2019/10/24/Kubernetes%E5%88%9D%E6%8E%A2%20-%20ConfigMap%E5%92%8CSecret-kubernetes%E5%88%9D%E6%8E%A2-configmap%E5%92%8Csecret/</url>
    <content><![CDATA[<p>根据应用的开发进程，应用的配置一般会经历先嵌在应用本身，或通过命令行参数的形式传入。到测试生产阶段随着配置的增多会抽取为一个或多个配置文件。对于容器化应用，我们还可以为容器设置环境变量，应用中读取该变量即可。而对于K8S，还可以使用gitRepo卷作为配置文件的载体。但这些都还是太笨重了，K8S提供了更加简单的方法：ConfigMap，用于提供普通配置；Secret用于提供需要加密的配置。</p>
<span id="more"></span>
<h2 id="容器化应用的配置"><a href="#容器化应用的配置" class="headerlink" title="容器化应用的配置"></a>容器化应用的配置</h2><p>我们先来看容器本身可执行的配置方法</p>
<h3 id="使用命令行和参数"><a href="#使用命令行和参数" class="headerlink" title="使用命令行和参数"></a>使用命令行和参数</h3><h4 id="Docker的方式"><a href="#Docker的方式" class="headerlink" title="Docker的方式"></a>Docker的方式</h4><figure class="highlight dockerfile"><table><tr><td class="code"><pre><span class="line"><span class="keyword">FROM</span> ubuntu</span><br><span class="line"><span class="keyword">RUN</span><span class="bash"> apt-get update ; apt-get -y install fortune</span></span><br><span class="line"><span class="keyword">ADD</span><span class="bash"> fortuneloop.sh /bin/fortuneloop.sh</span></span><br><span class="line"><span class="keyword">ENTRYPOINT</span><span class="bash"> [<span class="string">&quot;/bin/fortuneloop.sh&quot;</span>]</span></span><br><span class="line"><span class="keyword">CMD</span><span class="bash"> [<span class="string">&quot;10&quot;</span>]</span></span><br></pre></td></tr></table></figure>

<p>上面的dockerfile定义了一个镜像，基于ubuntu，安装下载fortune，并将本地的fortuneloop脚本复制到镜像中，然后定义ENTRYPOINT运行，并且给该脚本一个参数：10。注意ENTRYPOINT有两种方式</p>
<ul>
<li>ENGTYPOINT[“/bin/fortuneloop.sh”]: exec形式，在shell环境下运行该脚本。即首先启动shell进程，再在该进程下运行这个脚本</li>
<li>ENTRYPOINT /bin/fortuneloop.sh: shell形式，直接运行该脚本</li>
</ul>
<p>一般采用exec形式。</p>
<p>上面定义后，可以在运行docker时传递一个参数覆盖CMD参数</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">docker run -it &lt;docker name&gt; 15 # 15会覆盖上面的10</span><br></pre></td></tr></table></figure>

<h4 id="K8S的方式"><a href="#K8S的方式" class="headerlink" title="K8S的方式"></a>K8S的方式</h4><p>上面用ENTRYPOINT和CMD共同决定了容器的运行命令。在POD声明时可以覆盖这二者。</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="string">......</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line">  <span class="attr">containers:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="attr">image:</span> <span class="string">zou8944/kubia</span></span><br><span class="line">      <span class="attr">command:</span> [<span class="string">&quot;node hello.js&quot;</span>]  <span class="comment"># 覆盖dockerfile中的ENTRYPOINT</span></span><br><span class="line">      <span class="attr">args:</span> [<span class="string">&quot;10&quot;</span>]   <span class="comment"># 覆盖dockerfile中的CMD</span></span><br><span class="line"><span class="string">......</span></span><br></pre></td></tr></table></figure>

<h3 id="使用环境变量"><a href="#使用环境变量" class="headerlink" title="使用环境变量"></a>使用环境变量</h3><p>容器之间相互隔离，因此可为每个容器设置各自的环境变量。</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="string">......</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line">  <span class="attr">containers:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="attr">image:</span> <span class="string">zou8944/kubia</span></span><br><span class="line">      <span class="attr">env:</span></span><br><span class="line">        <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">ENVNAME</span>  <span class="comment"># 设置了一个名为ENVNAME，值为lalal的环境变量</span></span><br><span class="line">          <span class="attr">value:</span> <span class="string">&quot;lalal&quot;</span></span><br><span class="line">        <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">ENVNAME2</span></span><br><span class="line">          <span class="attr">value:</span> <span class="string">&quot;$&#123;ENVNAME&#125; dd&quot;</span>  <span class="comment"># 设置名为ENVNAME2，值为lalal dd的环境变量，这里有引用其它变量名</span></span><br><span class="line"><span class="string">......</span></span><br></pre></td></tr></table></figure>

<p>但是，使用上面的方式会将配置和pod耦合起来，很明显不科学。</p>
<h2 id="ConfigMap"><a href="#ConfigMap" class="headerlink" title="ConfigMap"></a>ConfigMap</h2><p>和其它对象一样，ConfigMap也是一种资源，其本质上是一个键值对，值可以是字面量，也可以是配置文件。应用不用直接读取ConfigMap的内容，因此不会感知到它的存在。</p>
<h3 id="创建（命令行）"><a href="#创建（命令行）" class="headerlink" title="创建（命令行）"></a>创建（命令行）</h3><figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 创建了一个含有两个key-value的configmap。</span></span><br><span class="line"><span class="string">kubectl</span> <span class="string">create</span> <span class="string">configmap</span> <span class="string">my-config</span> </span><br><span class="line">  <span class="string">--from-literal=interval=5</span>  <span class="comment"># 从字面量创建</span></span><br><span class="line">  <span class="string">--from-file=myfile.conf</span>  <span class="comment"># 将整个配置文件中的内容导入为配置</span></span><br><span class="line">  <span class="string">--from-file=mykey=myfile.conf</span>  <span class="comment"># 导入一个key为mykey,value为myfile.config的键值对配置</span></span><br><span class="line">  <span class="string">--from-file=/path/dir</span>    <span class="comment"># 导入一个文件夹，将其中所有命名符合要求的文件名作为key，文件内容作为value</span></span><br></pre></td></tr></table></figure>

<h3 id="创建（yaml）"><a href="#创建（yaml）" class="headerlink" title="创建（yaml）"></a>创建（yaml）</h3><figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">apiVersion:</span> <span class="string">v1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">ConfigMap</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">myConfig</span></span><br><span class="line"><span class="attr">data:</span></span><br><span class="line">  <span class="attr">key1:</span> <span class="string">&quot;value1&quot;</span></span><br><span class="line">  <span class="attr">key2:</span> <span class="string">&quot;value2&quot;</span></span><br></pre></td></tr></table></figure>

<h3 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h3><ul>
<li><p>单独引用配置中的一个条目</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="string">......</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line">  <span class="attr">containers:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="attr">image:</span> <span class="string">zou8944/kubia</span></span><br><span class="line">      <span class="attr">env:</span></span><br><span class="line">        <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">ENVNAME</span>  </span><br><span class="line">          <span class="attr">valueFrom:</span></span><br><span class="line">            <span class="attr">configMapKeyRef:</span></span><br><span class="line">              <span class="attr">name:</span> <span class="string">myconfig</span>  <span class="comment"># ConfigMap的名称</span></span><br><span class="line">              <span class="attr">key:</span> <span class="string">interval</span>  <span class="comment"># 键名</span></span><br><span class="line">              <span class="attr">optional:</span> <span class="literal">true</span> <span class="comment"># 就算该ConfigMap或key不存在也照常启动。不设置时不会启动</span></span><br><span class="line"><span class="string">......</span></span><br></pre></td></tr></table></figure></li>
<li><p>将整个配置文件全部引入</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="string">......</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line">  <span class="attr">containers:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="attr">image:</span> <span class="string">zou8944/kubia</span></span><br><span class="line">      <span class="attr">envFrom:</span></span><br><span class="line">        <span class="bullet">-</span> <span class="attr">prefix:</span> <span class="string">CONFIG_</span>  <span class="comment"># 在每个键前加上前缀</span></span><br><span class="line">          <span class="attr">configMapRef:</span></span><br><span class="line">            <span class="attr">name:</span> <span class="string">myconfig</span></span><br><span class="line"><span class="string">......</span></span><br></pre></td></tr></table></figure></li>
<li><p>将ConfigMap条目暴露为文件</p>
<p>假设有如configmap-files文件夹，其中包含两个文件，my-nginx-config.conf和sleep-internal</p>
<p><img src="https://gdz.oss-cn-shenzhen.aliyuncs.com/hexo/Kubernetes%20-%20ConfigMap%E5%92%8CSecret/image-20191024202924093.png" alt="image-20191024202924093"></p>
<p>通过<code>kubectl create configmap myconfig --from-file=configmap-files</code>创建一个ConfigMap，可通过如下配置将其暴露为卷。</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 挂在整个文件， 此时就相当于将configmap-files中的两个文件放到了nginx的配置文件夹/etc/nginx/conf.d中</span></span><br><span class="line"><span class="string">......</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line">  <span class="attr">containers:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="attr">image:</span> <span class="string">nginx.alpine</span></span><br><span class="line">      <span class="attr">name:</span> <span class="string">web-server</span></span><br><span class="line">      <span class="attr">volumeMounts:</span></span><br><span class="line">        <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">config</span></span><br><span class="line">          <span class="attr">mountPath:</span> <span class="string">/etc/nginx/conf.d</span></span><br><span class="line">          <span class="attr">readOnly:</span> <span class="literal">true</span></span><br><span class="line">  <span class="attr">volumes:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">config</span></span><br><span class="line">      <span class="attr">configMap:</span>  <span class="comment"># 将configMap暴露为卷</span></span><br><span class="line">        <span class="attr">name:</span> <span class="string">myconfig</span></span><br><span class="line"><span class="string">......</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 挂在单个条目， 此时就相当于/etc/nginx/conf.d中只有一个文件gzip.conf，该文件的内容是my-nginx-config.conf中的内容</span></span><br><span class="line"><span class="string">......</span></span><br><span class="line">  <span class="attr">volumes:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">config</span></span><br><span class="line">      <span class="attr">configMap:</span>  </span><br><span class="line">        <span class="attr">name:</span> <span class="string">myconfig</span></span><br><span class="line">        <span class="attr">defaultMode:</span> <span class="string">&quot;6600&quot;</span>  <span class="comment"># 为文件设置默认权限</span></span><br><span class="line">        <span class="attr">items:</span></span><br><span class="line">          <span class="bullet">-</span> <span class="attr">key:</span> <span class="string">my-nginx-config.conf</span></span><br><span class="line">            <span class="attr">path:</span> <span class="string">gzip.conf</span></span><br><span class="line"><span class="string">......</span></span><br></pre></td></tr></table></figure></li>
<li><p>注意事项</p>
<p>如果将ConfigMap挂载在某个特定的文件夹下，则该文件夹下已存在的文件会被隐藏。所以推荐挂载在文件，或新建一个文件夹。</p>
</li>
</ul>
<h3 id="热更新ConfigMap"><a href="#热更新ConfigMap" class="headerlink" title="热更新ConfigMap"></a>热更新ConfigMap</h3><p>ConfigMap修改后，挂载它的卷中的文件也会被更新。其原理是使用符号链接，ConfigMap卷中的文件其实是一个符号链接，指向实际的文件，更新后，k8s创建新的文件，然后将链接指向新文件，然后就生效了。</p>
<p>需要注意的一点是更新ConfigMap是有延迟的，如果有多个POD，则可能会出现某个时段不一致的情况。</p>
<h2 id="Secret"><a href="#Secret" class="headerlink" title="Secret"></a>Secret</h2><p>Secret的使用方法和ConfigMap一毛一样。其保证安全性的方法是：</p>
<ul>
<li>仅将Secret分发到需要的pod所在的机器节点</li>
<li>Secret只存在内存中，不保存在磁盘上</li>
</ul>
<h3 id="创建"><a href="#创建" class="headerlink" title="创建"></a>创建</h3><p>有两种创建方式，命令行和yaml，由于Secret中字段值会被Base64处理，因此使用命令行直接处理比较好。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 证书文件都是事先生成好的</span></span><br><span class="line">kubectl create secret generic myhttps --from-file=https.key --from-file=https.cert</span><br></pre></td></tr></table></figure>

<p>查看创建好的secret如下，可以看到都变成加密的了。</p>
<p><img src="https://gdz.oss-cn-shenzhen.aliyuncs.com/hexo/Kubernetes%20-%20ConfigMap%E5%92%8CSecret/image-20191024210340290.png" alt="image-20191024210340290"></p>
<p>尽管这里看是加密的，但当其被设置为环境变量或Secret卷时填充的却是解码后的内容。</p>
<h3 id="使用-1"><a href="#使用-1" class="headerlink" title="使用"></a>使用</h3><p>还是以nginx配置为例</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="string">...</span> <span class="string">...</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line">  <span class="attr">containers:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="attr">image:</span> <span class="string">nginx.alpine</span></span><br><span class="line">      <span class="attr">name:</span> <span class="string">web-server</span></span><br><span class="line">      <span class="attr">volumeMounts:</span></span><br><span class="line">        <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">config</span></span><br><span class="line">          <span class="attr">mountPath:</span> <span class="string">/etc/nginx/conf.d</span></span><br><span class="line">          <span class="attr">readOnly:</span> <span class="literal">true</span></span><br><span class="line">        <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">certs</span></span><br><span class="line">          <span class="attr">mountPath:</span> <span class="string">/etc/nginx/certs/</span>	<span class="comment"># 将文件挂在到certs文件夹下，再在Nginx中配置即可使用https</span></span><br><span class="line">          <span class="attr">readOnly:</span> <span class="literal">true</span></span><br><span class="line">  <span class="attr">volumes:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">config</span></span><br><span class="line">      <span class="attr">configMap:</span>  <span class="comment"># 将configMap暴露为卷</span></span><br><span class="line">        <span class="attr">name:</span> <span class="string">myconfig</span></span><br><span class="line">    <span class="bullet">-</span> <span class="attr">name: certs:</span></span><br><span class="line">      <span class="attr">secret:</span></span><br><span class="line">        <span class="attr">secretName:</span> <span class="string">myhttps</span></span><br><span class="line"><span class="string">......</span></span><br></pre></td></tr></table></figure>

<p>将Secret设置为环境变量的方式和ConfigMap一致，不再赘述。</p>
]]></content>
      <categories>
        <category>运维</category>
      </categories>
      <tags>
        <tag>kubernetes</tag>
      </tags>
  </entry>
  <entry>
    <title>JWT详解</title>
    <url>/2021/12/20/JWT/</url>
    <content><![CDATA[<p>本文介绍JWT组成原理及适用范围。</p>
<span id="more"></span>

<h2 id="概览"><a href="#概览" class="headerlink" title="概览"></a>概览</h2><p>JWT，全称JSON Web Token，是一种包含信息的Token，相较于普通的Token，唯一多的内容是：包含部分信息。与JWT相关的协议比较简单，但数量较多，本文只是对此加以总结。</p>
<ul>
<li>JWS-<a href="https://www.rfc-editor.org/rfc/pdfrfc/rfc7515.txt.pdf">rfc7515</a></li>
<li>JWE-<a href="https://www.rfc-editor.org/rfc/pdfrfc/rfc7516.txt.pdf">rfc7516</a></li>
<li>JWK-<a href="https://www.rfc-editor.org/rfc/pdfrfc/rfc7517.txt.pdf">rfc7517</a></li>
<li>JWA-<a href="https://www.rfc-editor.org/rfc/pdfrfc/rfc7518.txt.pdf">rfc7518</a></li>
<li>JWT-<a href="https://www.rfc-editor.org/rfc/pdfrfc/rfc7519.txt.pdf">rfc7519</a></li>
</ul>
<h2 id="术语说明"><a href="#术语说明" class="headerlink" title="术语说明"></a>术语说明</h2><p>这其中会涉及到很多简写，先介绍一下</p>
<ul>
<li>JWS：JSON Web Signature，表示使用基于JSON的数据结构，对内容进行数字签名或MAC。具体内容下文详述。</li>
<li>JWE：JSON Web Encryption，类似JWS，但这里是加密，而非数字签名。</li>
<li>JWK：JSON Web Key，以JSON的形式表示一个加密key。</li>
<li>JWA：JSON Web Algorithms，表示上面的签名、加密支持的算法。</li>
<li>JWT：JSON Web Token，使用JSON表示的Token形式，可以采用JWS或JWE进行签名或加密。</li>
<li>JOSE：JSON Object Signature and Encryption，即对上面JWS和JWE的统称。标准中常提到JOSE Header，代表的是JWS的Header或JWE的Header。</li>
</ul>
<h2 id="JWS"><a href="#JWS" class="headerlink" title="JWS"></a>JWS</h2><h3 id="组成"><a href="#组成" class="headerlink" title="组成"></a>组成</h3><p>JWS包含三部分</p>
<ul>
<li><p>头部（JOSE Header），即一些键值对</p>
<ul>
<li><p>typ：type，即这一整个JWS代表的类型，典型值为JWT</p>
</li>
<li><p>alg：algorithm，算法，当前JWS签名或加密所采用的算法，需要在JWA中存在才可以用</p>
</li>
<li><p>jku：JWK Set URL，存放公钥的地址，必须遵守JWK规范</p>
</li>
<li><p>jwk：JSON Web Key，用于签名的秘钥，以JSON的形式发放，详情参考JWK</p>
</li>
<li><p>kid：key id，即秘钥id，jwk可能返回多个密码，kid精确指定</p>
</li>
<li><p>x5系列：X.509证书相关，这里忽略</p>
</li>
<li><p>其它</p>
</li>
</ul>
</li>
<li><p>载荷（JWS Payload），即主要的正文内容</p>
</li>
<li><p>签名（JWS Signature），签名方式如下</p>
<ul>
<li>待签名内容：<code>ASCII(BASE64URL(UTF8(JWS Protected Header)) || ’.’ || BASE64URL(JWS Payload))</code></li>
<li>签名算法：头部alg字段指定的算法</li>
</ul>
</li>
</ul>
<h3 id="两种序列化格式"><a href="#两种序列化格式" class="headerlink" title="两种序列化格式"></a>两种序列化格式</h3><ul>
<li><p>压缩方式：一种压缩的、URL安全的序列化方式</p>
<p>最终输出格式如下，即三个部分除头部需额外处理外，其余均进行BASE64及URL编码，将结果通过点号连接起来。这也是我们最常见的JWT的形式。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">BASE64URL(UTF8(JWS Protected Header)) || ’.’ ||</span><br><span class="line">BASE64URL(JWS Payload) || ’.’ ||</span><br><span class="line">BASE64URL(JWS Signature)</span><br></pre></td></tr></table></figure></li>
<li><p>JSON方式：序列化结果就是一个JSON，签名等用字段表示</p>
<p>最终输出格式如下，这种格式不常见，我们仅作了解就好</p>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="attr">&quot;protected&quot;</span>: BASE64URL(UTF8(JWS Protected Header)),</span><br><span class="line">  <span class="attr">&quot;header&quot;</span>: <span class="string">&quot;&lt;不受保护的头部&gt;&quot;</span>,</span><br><span class="line">  <span class="attr">&quot;payload&quot;</span>: BASE64URL(JWS Payload),</span><br><span class="line">  <span class="attr">&quot;signature&quot;</span>: BASE64URL(JWS Signature)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这里的不受保护的头部，指的是不参与签名的头部，即在完整性上不受保护。这只在JSON方式中会出现。</p>
</li>
</ul>
<blockquote>
<p>注意：特殊情况下，alg可以为”none”，此时的JWS是不安全的</p>
</blockquote>
<h3 id="举例"><a href="#举例" class="headerlink" title="举例"></a>举例</h3><p>以协议中的例子呈现，假设我们要以HMAC SHA256算法签名一个载荷</p>
<ul>
<li><p>待签名的载荷如下</p>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="attr">&quot;iss&quot;</span>:<span class="string">&quot;joe&quot;</span>,</span><br><span class="line">	<span class="attr">&quot;exp&quot;</span>:<span class="number">1300819380</span>,</span><br><span class="line">	<span class="attr">&quot;http://example.com/is_root&quot;</span>:<span class="literal">true</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>则<code>BASE64URL(JWS Payload)</code>计算得到的值为<code>eyJpc3MiOiJqb2UiLA0KICJleHAiOjEzMDA4MTkzODAsDQogImh0dHA6Ly9leGFtcGxlLmNvbS9pc19yb290Ijp0cnVlfQ</code></p>
</li>
<li><p>其对应的头部就会是这样（type不是必须的）</p>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="attr">&quot;type&quot;</span>: <span class="string">&quot;JWT&quot;</span>,</span><br><span class="line">  <span class="attr">&quot;alg&quot;</span>: <span class="string">&quot;HS256&quot;</span> <span class="comment">// 这表示使用HMAC SHA256的签名方式</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>则<code>BASE64URL(UTF8(JWS Protected Header))</code>计算的值为<code>eyJ0eXAiOiJKV1QiLA0KICJhbGciOiJIUzI1NiJ9</code></p>
</li>
<li><p>签名，对头部和载荷进行计算<code>ASCII(BASE64URL(UTF8(JWS Protected Header)) || ’.’ || BASE64URL(JWS Payload)) </code>，得到的签名然后做Base64计算得到的值为<code>dBjftJeZ4CVP-mB92K27uhbUJU1p1r_wW1gFWFOEjXk</code></p>
</li>
</ul>
<p>采用紧凑型的序列化格式，我们可以得到最终的结果为：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">eyJ0eXAiOiJKV1QiLA0KICJhbGciOiJIUzI1NiJ9.eyJpc3MiOiJqb2UiLA0KICJleHAiOjEzMDA4MTkzODAsDQogImh0dHA6Ly9leGFtcGxlLmNvbS9pc19yb290Ijp0cnVlfQ.dBjftJeZ4CVP-mB92K27uhbUJU1p1r_wW1gFWFOEjXk</span><br></pre></td></tr></table></figure>

<p>这是JWT的最为典型的呈现形式。</p>
<h2 id="JWE"><a href="#JWE" class="headerlink" title="JWE"></a>JWE</h2><p>有了对JWS的了解，理解JWE就容易多了。JWS是对内容签名，JWE就是对内容进行加密。要理解它需要一些加密算法相关知识，这里我们只简单有个印象。</p>
<h3 id="组成-1"><a href="#组成-1" class="headerlink" title="组成"></a>组成</h3><ul>
<li>头部（JOSE Header），头部依旧有不少，这里不再列举，需要去查看协议手册</li>
<li>加密秘钥（JWE Encrypted Key）</li>
<li>初始向量（JWE Initialization Vector）</li>
<li>额外的认证数据（JWE Additional Authenticated Data value）</li>
<li>加密的密文（JWE Ciphertext），即加密结果</li>
<li>认证标签（JWE Authentication Tag）</li>
</ul>
<h3 id="两种序列化格式-1"><a href="#两种序列化格式-1" class="headerlink" title="两种序列化格式"></a>两种序列化格式</h3><p>和JWS一样，也有紧凑型和JSON型，我们这次只关注紧凑型，其输出方式如下</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">BASE64URL(UTF8(JWE Protected Header)) || ’.’ ||</span><br><span class="line">BASE64URL(JWE Encrypted Key) || ’.’ ||</span><br><span class="line">BASE64URL(JWE Initialization Vector) || ’.’ ||</span><br><span class="line">BASE64URL(JWE Ciphertext) || ’.’ ||</span><br><span class="line">BASE64URL(JWE Authentication Tag)</span><br></pre></td></tr></table></figure>

<h3 id="举例-1"><a href="#举例-1" class="headerlink" title="举例"></a>举例</h3><p>我对加密算法不算了解，为了不曲解原文意思，又觉得在这里给出一个示例会好很多，所以直接引用原文吧</p>
<blockquote>
<p>This example encrypts the plaintext “The true sign of intelligence is not knowledge but imagination.” to the recipient. </p>
<p>The following example JWE Protected Header declares that: </p>
<ul>
<li><p>The Content Encryption Key is encrypted to the recipient using the RSAES-OAEP [RFC3447] algorithm to produce the JWE Encrypted Key.</p>
</li>
<li><p>Authenticated encryption is performed on the plaintext using the AES GCM [AES] [NIST.800-38D] algorithm with a 256-bit key to produce the ciphertext and the Authentication Tag.</p>
</li>
</ul>
<p> <code>&#123;&quot;alg&quot;:&quot;RSA-OAEP&quot;,&quot;enc&quot;:&quot;A256GCM&quot;&#125;</code></p>
<p>Encoding this JWE Protected Header as BASE64URL(UTF8(JWE Protected Header)) gives this value: </p>
<p><code>eyJhbGciOiJSU0EtT0FFUCIsImVuYyI6IkEyNTZHQ00ifQ</code></p>
<p>The remaining steps to finish creating this JWE are:</p>
<ul>
<li>Generate a random Content Encryption Key (CEK)</li>
<li>Encrypt the CEK with the recipient’s public key using the RSAES- OAEP algorithm to produce the JWE Encrypted Key</li>
<li>Base64url-encode the JWE Encrypted Key</li>
<li>Generate a random JWE Initialization Vector</li>
<li>Base64url-encode the JWE Initialization Vector</li>
<li>Let the Additional Authenticated Data encryption parameter be ASCII(BASE64URL(UTF8(JWE Protected Header)))</li>
<li>Perform authenticated encryption on the plaintext with the AES GCM algorithm using the CEK as the encryption key, the JWE Initialization Vector, and the Additional Authenticated Data value, requesting a 128-bit Authentication Tag output</li>
<li>Base64url-encode the ciphertext</li>
<li>Base64url-encode the Authentication Tag</li>
<li>Assemble the final representation: The Compact Serialization of this result is the string <code>BASE64URL(UTF8(JWE Protected Header)) || ’.’ || BASE64URL(JWE Encrypted Key) || ’.’ || BASE64URL(JWE Initialization Vector) || ’.’ || BASE64URL(JWE Ciphertext) || ’.’ || BASE64URL(JWE Authentication Tag)</code></li>
</ul>
<p>The final result is</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;</span><span class="bash">eyJhbGciOiJSU0EtT0FFUCIsImVuYyI6IkEyNTZHQ00ifQ.</span></span><br><span class="line"><span class="meta">&gt;</span><span class="bash">OKOawDo13gRp2ojaHV7LFpZcgV7T6DVZKTyKOMTYUmKoTCVJRgckCL9kiMT03JGe</span></span><br><span class="line"><span class="meta">&gt;</span><span class="bash">ipsEdY3mx_etLbbWSrFr05kLzcSr4qKAq7YN7e9jwQRb23nfa6c9d-StnImGyFDb</span></span><br><span class="line"><span class="meta">&gt;</span><span class="bash">Sv04uVuxIp5Zms1gNxKKK2Da14B8S4rzVRltdYwam_lDp5XnZAYpQdb76FdIKLaV</span></span><br><span class="line"><span class="meta">&gt;</span><span class="bash">mqgfwX7XWRxv2322i-vDxRfqNzo_tETKzpVLzfiwQyeyPGLBIO56YJ7eObdv0je8</span></span><br><span class="line"><span class="meta">&gt;</span><span class="bash">1860ppamavo35UgoRdbYaBcoh9QcfylQr66oc6vFWXRcZ_ZT2LawVCWTIy3brGPi</span></span><br><span class="line"><span class="meta">&gt;</span><span class="bash">6UklfCpIMfIjf7iGdXKHzg.</span></span><br><span class="line"><span class="meta">&gt;</span><span class="bash">48V1_ALb6US04U3b.</span></span><br><span class="line"><span class="meta">&gt;</span><span class="bash">5eym8TW_c8SuK0ltJ3rpYIzOeDQz7TALvtu6UG9oMo4vpzs9tX_EFShS8iB7j6ji</span></span><br><span class="line"><span class="meta">&gt;</span><span class="bash">SdiwkIr3ajwQzaBtQD_A.</span></span><br><span class="line"><span class="meta">&gt;</span><span class="bash">XFBoMYUZodetZdvTiFvSkQ</span></span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">#</span><span class="bash"><span class="comment"># JWK</span></span></span><br><span class="line"></span><br><span class="line">这是对JWS和JWE中用到的秘钥的提供方式，所以叫做JSON Web Key。以JSON的形式将秘钥的各项参数呈现，具体有哪些参数，需要据该秘钥的类型而定，比如</span><br><span class="line"></span><br><span class="line">```json</span><br><span class="line">&#123;</span><br><span class="line"> &quot;kty&quot;:&quot;EC&quot;,</span><br><span class="line">&quot;crv&quot;:&quot;P-256&quot;,</span><br><span class="line">&quot;x&quot;:&quot;f83OJ3D2xF1Bg8vub9tLe1gHMzV76e8Tus9uPHvRVEU&quot;,</span><br><span class="line">&quot;y&quot;:&quot;x_FEzRu9m36HLN_tue659LNpXW6pCyStikYjKIWI5a0&quot;,</span><br><span class="line">&quot;kid&quot;:&quot;Public key used in JWS spec Appendix A.3 example&quot;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</blockquote>
<p>它也可以是个数组，此时就称作JWKs，提供一组秘钥，通过kid进行挑选。</p>
<p>对于JWK，我们需要关注主要是它能包含哪些参数，总共有两类</p>
<ul>
<li><p>通用参数</p>
<ul>
<li><p>kty：key type，秘钥类型，表示秘钥族，比如RSA、EC等。</p>
</li>
<li><p>use：Public Key Use，表明公钥的用途，有两个可选项</p>
<ul>
<li>sig：用作签名</li>
<li>enc：用作加密</li>
</ul>
</li>
<li><p>key_ops：Key Operations，表明本秘钥的用途，可选选项</p>
<ul>
<li>sign：签名</li>
<li>verify：验证签名</li>
<li>encrypt：加密</li>
<li>decrypt：解密</li>
<li>wrapKey：加密key</li>
<li>unWrapKey：解密key</li>
<li>deriveKey</li>
<li>deriveBits</li>
</ul>
</li>
<li><p>alg：表明本秘钥将被用在什么算法中</p>
</li>
<li><p>kid：即本秘钥的id</p>
</li>
<li><p>x5xxx：X.509相关</p>
</li>
</ul>
</li>
<li><p>算法相关参数</p>
<ul>
<li>比如上面的额x、y、crv，都是和EC的公钥相关的参数，具体会需要哪些参数，JWA协议中有详细的规定。</li>
</ul>
</li>
</ul>
<h2 id="JWA"><a href="#JWA" class="headerlink" title="JWA"></a>JWA</h2><p>JWA协议中详细列举了支持的算法，以及算法所需秘钥的表现形式。如有需要，<a href="https://www.rfc-editor.org/rfc/pdfrfc/rfc7518.txt.pdf">可以翻一番</a></p>
<h2 id="JWT"><a href="#JWT" class="headerlink" title="JWT"></a>JWT</h2><p>至此，我们知道了JWS用于对指定载荷进行签名，JWE用于对普通文本进行加密。而JWT是基于这二者的。这里有两个重点</p>
<ul>
<li><p>JWT的主体内容是声明，即所谓Claim，它是JSON形式的键值对</p>
</li>
<li><p>JWT在网络上传输时，需要被JWS签名，或者被JWE加密，并且使用的都是紧凑的序列化方式</p>
<p>而我们大多数时候看到的，是被JWS签名的紧凑的序列化方式</p>
</li>
</ul>
<p>JWS和JWE上面我们都熟悉过了，这里就只剩下Claim，我们看看JWT的声明包含哪些内容</p>
<ul>
<li>iss：JWT发布者</li>
<li>sub：JWT的主体，在发布者的系统内唯一</li>
<li>aud：JWT的目标接收者，接受该JWT的一方，必须验证此值，如果该值和预期的不一致，则应该拒绝该JWT</li>
<li>exp：过期时间，数字化的时间类型，即时间戳，（苹果是秒为单位）</li>
<li>nbf：Not Before，规定的生效时间，必须在这个时间之后才能处理它</li>
<li>iat：issue at，JWT签发时间</li>
<li>jti：JWT ID， 为JWT提供一个唯一的ID，JTI用作防止JWT的重放</li>
</ul>
<p>协议还规定，可以自定义一些字段，只要JWT发出方和接收方协商一致即可。</p>
<p>我们给一个IOS登录时，苹果签发的JWT作为例子</p>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">     kid: <span class="string">&quot;86D88Kf&quot;</span>,</span><br><span class="line">     alg: <span class="string">&quot;RS256&quot;</span></span><br><span class="line">&#125;.</span><br><span class="line">&#123;</span><br><span class="line">     iss: <span class="string">&quot;https://appleid.apple.com&quot;</span>,</span><br><span class="line">     aud: <span class="string">&quot;com.mampod.enlighten&quot;</span>,</span><br><span class="line">     exp: <span class="number">1585110701</span>,</span><br><span class="line">     iat: <span class="number">1585110101</span>,</span><br><span class="line">     sub: <span class="string">&quot;001230.15f855de99ef4b788a18d18b7b45b053.0400&quot;</span>,</span><br><span class="line">     nonce: <span class="string">&quot;123&quot;</span>,</span><br><span class="line">     c_hash: <span class="string">&quot;lGYaArOB6z6IFuCOx2Z64A&quot;</span>,</span><br><span class="line">     email: <span class="string">&quot;d6yuqtqhv3@privaterelay.appleid.com&quot;</span>,</span><br><span class="line">     email_verified: <span class="string">&quot;true&quot;</span>,</span><br><span class="line">     is_private_email: <span class="string">&quot;true&quot;</span>,</span><br><span class="line">     auth_time: <span class="number">1585110101</span>,</span><br><span class="line">     nonce_supported: <span class="literal">true</span></span><br><span class="line">&#125;.</span><br><span class="line">[signature]</span><br></pre></td></tr></table></figure>

<blockquote>
<p>JWT在协议上只规定了能够声明的内容，而最终的呈现形式，是JWS协议提供的，这点注意区分。</p>
</blockquote>
<h2 id="适用场景-与token-session对比"><a href="#适用场景-与token-session对比" class="headerlink" title="适用场景 - 与token-session对比"></a>适用场景 - 与token-session对比</h2><p>所谓token-session模式，即服务端存储用户数据，根据用户标识生成id或token，发放给客户端，客户端依次作为访问凭证，可以获取用户信息，可以访问所有具有权限的资源。传统的session、自己签发的token，本质上都可归于这一类，他们都有共同的特点——中心化，即有一个或一组节点负责管理。</p>
<p>那么JWT能带来什么呢？JWT只是一组带有签名的一组规定好的数据，有两个点（就。。。数字证书）</p>
<ul>
<li>能够包含信息</li>
<li>带有签名，能够验证真实性，无法伪造</li>
</ul>
<p>其中，可通过签名验证真伪这一点，能带来一个最大的好处——去中心化。JWT使用者不需要再和签发方沟通以验证真伪。看起来很好，但它有一个致命的缺点</p>
<ul>
<li>在JWT过期前（exp字段决定），由于使用方只验证签名，没有对该凭证本身做验证，因此无法手动使一个token失效</li>
</ul>
<p>此时普遍的补救方法是，增加一个JWT验证的步骤，即每次使用前，向签发方发送请求验证JWT是否已经被手动失效。但这样，岂不是又退化为了传统的token-session模式？</p>
<p>那么，JWT的应用场景究竟是怎样的呢？首先参考一下<a href="https://zou8944.com/2020/03/28/Sign%20in%20with%20Apple%20-%20IOS%E5%B9%B3%E5%8F%B0%E6%9C%8D%E5%8A%A1%E7%AB%AF%E7%9A%84%E5%A4%84%E7%90%86-signinwithapple-ios%E5%B9%B3%E5%8F%B0%E6%9C%8D%E5%8A%A1%E7%AB%AF%E7%9A%84%E5%A4%84%E7%90%86/">iOS的登录方式</a>：在客户端调用登录API后，苹果服务端主要返回两个内容</p>
<ul>
<li>identity-token：这是一个JWT，内部包含了用户在苹果服务器内部的唯一ID，以及用户的邮箱信息。</li>
<li>authorization code：这是OAuth 2.0的授权码，用于向苹果服务器换取access token和refresh token，这里忽略。</li>
</ul>
<p>这里JWT只是被用来签发用户ID，而对数据的访问凭证和用户详细信息的获取还是走OAuth 2.0——JWT只用来发布信息，并没有被用来当做访问凭证。<strong>这也是我比较赞同的使用方式</strong>。作为访问凭证，JWT并不能实现去中心化的目的。</p>
<p>总结一下，如果使用JWT替换传统的token，会得到一个好处</p>
<ul>
<li>非敏感的用户信息可以放在JWT中，从而省去了获取用户信息这一步骤</li>
</ul>
<p>但同时会带来两个新的问题</p>
<ul>
<li>需要增加密码分发方式</li>
<li>并不能节省token验证这一步骤</li>
</ul>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>应该注意到，我们经常所谓的JWT，其实都是JWS签名和序列化后的结果，而从协议上看，它还可以是JWE加密结果。</p>
<p>本质上，JWT带给我们的只是安全传输数据的方式。比较好的使用场景是数据分发，而不是作为访问凭证。就算作为访问凭证，他也不是替代传统token-session的方式，而只是将传统的token进行了增强，但增强的同时，复杂度也会加大。</p>
]]></content>
      <categories>
        <category>后端</category>
      </categories>
      <tags>
        <tag>JWT</tag>
      </tags>
  </entry>
  <entry>
    <title>Kubernetes初探 - Service</title>
    <url>/2019/10/22/Kubernetes%E5%88%9D%E6%8E%A2%20-%20Service-kubernetes%E5%88%9D%E6%8E%A2-service/</url>
    <content><![CDATA[<p>第一篇文章已经说过了Service存在的意义，主要是由于POD机制无法对外提供一个稳定的地址，因此需要服务进行固定地址的暴露和负载均衡。官方一点的话：k8s的服务是一种为一组功能相同的pod提供单一不变的接入点的资源。</p>
<span id="more"></span>
<h2 id="基础"><a href="#基础" class="headerlink" title="基础"></a>基础</h2><h3 id="创建服务"><a href="#创建服务" class="headerlink" title="创建服务"></a>创建服务</h3><h4 id="方法一"><a href="#方法一" class="headerlink" title="方法一"></a>方法一</h4><p>通过expose命令创建</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">kubectl expose rc kubia --type=LoadBalancer --name kubia-http</span><br></pre></td></tr></table></figure>

<h4 id="方法二"><a href="#方法二" class="headerlink" title="方法二"></a>方法二</h4><p>使用yaml创建，如下针对所有具有标签app=kubia的node创建了一个服务，对外端口为80，对内端口为8080</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">apiVersion:</span> <span class="string">v1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">Service</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">kubia</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line">  <span class="attr">sessionAffinity:</span> <span class="string">ClientIP</span> <span class="comment"># 会话亲和性：同一个客户端请求到的POD会是同一个。（可选）</span></span><br><span class="line">                            <span class="comment"># 支持none/ClientIP，不支持cookie，因为k8s并非基于http，而是TCP</span></span><br><span class="line">  <span class="attr">ports:</span></span><br><span class="line">    <span class="comment"># 端口可以暴露多个</span></span><br><span class="line">    <span class="bullet">-</span> <span class="attr">name:</span>  <span class="string">http</span>  <span class="comment"># 名字是可选的</span></span><br><span class="line">      <span class="attr">port:</span> <span class="number">80</span></span><br><span class="line">      <span class="attr">targetPort:</span> <span class="number">8080</span></span><br><span class="line">    <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">https</span></span><br><span class="line">      <span class="attr">port:</span> <span class="number">443</span></span><br><span class="line">      <span class="attr">targetPort:</span> <span class="number">8443</span></span><br><span class="line">    <span class="attr">selector:</span></span><br><span class="line">      <span class="attr">app:</span> <span class="string">kubia</span></span><br></pre></td></tr></table></figure>

<p>会话亲和性：正常情况下，每次来自客户端的请求都会被服务随机转发到一个pod，但如果想要一个客户端的请求一直在单个pod中执行，就需要向上面那样配置会话亲和性。</p>
<h3 id="服务发现"><a href="#服务发现" class="headerlink" title="服务发现"></a>服务发现</h3><h4 id="方法一-环境变量"><a href="#方法一-环境变量" class="headerlink" title="方法一 环境变量"></a>方法一 环境变量</h4><p>此方法前提是服务创建早于pod的创建。可通过在pod中执行env获取环境变量，会有响应服务的IP和端口</p>
<h4 id="方法二-DNS"><a href="#方法二-DNS" class="headerlink" title="方法二 DNS"></a>方法二 DNS</h4><p>通过k8s的系统pod——kube-dns实现，具体操作方式尚不知晓</p>
<h4 id="方法三-FQDN"><a href="#方法三-FQDN" class="headerlink" title="方法三 FQDN"></a>方法三 FQDN</h4><p>Full Qualified Domain Name(FQDN)，全限定域名。一个服务的全限定名长这样，访问它就可以</p>
<p><code>backend database.default svc cluster. l ocal</code></p>
<h2 id="连接集群外的服务"><a href="#连接集群外的服务" class="headerlink" title="连接集群外的服务"></a>连接集群外的服务</h2><p>即不要让服务将连接重定向到集群中的pod，而是重定向到外部的IP和端口。</p>
<h3 id="Endpoint"><a href="#Endpoint" class="headerlink" title="Endpoint"></a>Endpoint</h3><p>就是暴露一个服务的IP和端口列表的k8s资源</p>
<p>创建服务时指定的标签选择器，在访问服务时并不会直接将请求重定向到匹配到的pod，而是通过标签获取到的pod构建一个IP和端口列表（endpoints列表）。客户端请求时再从这些endpoint中选择一个，然后重定向过去</p>
<h3 id="操作一波"><a href="#操作一波" class="headerlink" title="操作一波"></a>操作一波</h3><p>既然endpoint和服务是分开的，那么我们可以创建一个没有endpoint的服务，然后手动配置endpoint即可。</p>
<p>创建服务时候不指定标签选择器即可创建没有endpoint的服务。</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 创建一个没有Endpoints的服务</span></span><br><span class="line"><span class="attr">apiVersion:</span> <span class="string">v1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">Service</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">external-service</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line">  <span class="attr">ports:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="attr">port:</span> <span class="number">80</span></span><br></pre></td></tr></table></figure>

<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 创建Endpoint</span></span><br><span class="line"><span class="attr">apiVersion:</span> <span class="string">v1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">Endpoints</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">external-service</span>  <span class="comment"># name必须和service匹配</span></span><br><span class="line"><span class="attr">subsets:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">address:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="attr">ip:</span> <span class="number">1.1</span><span class="number">.1</span><span class="number">.1</span>  <span class="comment"># 目标地址</span></span><br><span class="line">    <span class="bullet">-</span> <span class="attr">ip:</span> <span class="number">2.2</span><span class="number">.2</span><span class="number">.2</span></span><br><span class="line">    <span class="attr">ports:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="attr">port:</span> <span class="number">80</span>  <span class="comment"># 目标端口</span></span><br></pre></td></tr></table></figure>

<h2 id="暴露服务给外部"><a href="#暴露服务给外部" class="headerlink" title="暴露服务给外部"></a>暴露服务给外部</h2><h3 id="通过NodePort暴露"><a href="#通过NodePort暴露" class="headerlink" title="通过NodePort暴露"></a>通过NodePort暴露</h3><p>将服务设置为NodePort类型，这样每个节点都为服务保留一个相同的端口，客户端直接访问任意节点的该端口和clusterIP都可以访问到该服务。</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">apiVersion:</span> <span class="string">v1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">Service</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">kubia-service</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line">  <span class="attr">type:</span> <span class="string">NodePort</span></span><br><span class="line">  <span class="attr">ports:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="attr">port:</span> <span class="number">80</span></span><br><span class="line">      <span class="attr">targetPort:</span> <span class="number">8080</span></span><br><span class="line">      <span class="attr">nodePort:</span> <span class="number">30111</span>  <span class="comment"># 每个节点保留该端口作为服务端口</span></span><br><span class="line">  <span class="attr">selector:</span></span><br><span class="line">    <span class="attr">app:</span> <span class="string">kubia</span></span><br></pre></td></tr></table></figure>

<p>上面设置后可以从外部访问，但还需要设置GCP的防火墙以允许外部访问</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">gcloud compute firewall-rules create kubia-svc-rule --allow=tcp:30111</span><br></pre></td></tr></table></figure>

<p>现在的问题就是找到node的IP地址了，可以通过如下JSONPath进行查询</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">kubectl get nodes -o jsonpath=&#x27;&#123;.items[*].status.addresses[?(@.type==&quot;ExternalIP&quot;)] .address&#125;&#x27; </span><br></pre></td></tr></table></figure>

<h3 id="通过负载均衡暴露"><a href="#通过负载均衡暴露" class="headerlink" title="通过负载均衡暴露"></a>通过负载均衡暴露</h3><p>将服务设置为LoadBalancer类型，这样可以调用其所在环境的负载均衡服务。如果k8s的运行环境没有负载均衡服务，则会表现的和NodePort类型一样，因为LoadBalancer是NodePort的扩展类型。</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">apiVersion:</span> <span class="string">v1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">Service</span></span><br><span class="line"><span class="string">metadata：</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">kubia-service</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line">  <span class="attr">type:</span> <span class="string">LoadBalancer</span></span><br><span class="line">  <span class="attr">ports:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="attr">port:</span> <span class="number">80</span>   <span class="comment"># 不指定端口时负载均衡器将会自动分配一个端口</span></span><br><span class="line">      <span class="attr">targetPort:</span> <span class="number">8080</span></span><br><span class="line">  <span class="attr">selector:</span></span><br><span class="line">    <span class="attr">app:</span> <span class="string">kubia</span></span><br></pre></td></tr></table></figure>

<p>其工作原理，还是基于NodePort，客户端访问负载均衡器，负载均衡器通过ClusterIP和节点IP访问服务，服务再定位到具体的POD。相对于NodePort，只是多了一层负载均衡器。</p>
<h3 id="通过Ingress暴露"><a href="#通过Ingress暴露" class="headerlink" title="通过Ingress暴露"></a>通过Ingress暴露</h3><p>没给LoadBalancer服务都需要自己的负载均衡器及独立的公网IP地址。使用Ingress可以只用一个公网IP提供多个服务的暴露。并且由于Ingress在应用层，因此可以提供cookie亲和性功能。</p>
<p><img src="https://gdz.oss-cn-shenzhen.aliyuncs.com/hexo/Kubernetes%20-%20Service/1571650418897.png" alt="1571650418897"></p>
<p>Ingress控制器是此方式工作的前提条件。不同的k8s环境提供的控制器可能不同，有些环境还不提供Ingress控制器，例如GCP使用了负载均衡器来提供Ingress功能。</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">apiVersion:</span> <span class="string">extensions/v1beta1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">Ingress</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">kubia</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line">  <span class="attr">rules:</span></span><br><span class="line">    <span class="comment"># host可以配置多个</span></span><br><span class="line">    <span class="bullet">-</span> <span class="attr">host:</span> <span class="string">kubia.example.com</span></span><br><span class="line">      <span class="attr">http:</span> </span><br><span class="line">        <span class="attr">paths:</span></span><br><span class="line">          <span class="comment"># path可以配置多个</span></span><br><span class="line">          <span class="bullet">-</span> <span class="attr">path:</span> <span class="string">/</span></span><br><span class="line">            <span class="attr">backend:</span></span><br><span class="line">              <span class="attr">serviceName:</span> <span class="string">kubia-nodeport</span></span><br><span class="line">              <span class="attr">servicePort:</span> <span class="number">80</span></span><br></pre></td></tr></table></figure>

<p>上述Ingress创建后，只要确保kubia.example.com能够解析到Ingress控制器即可工作。</p>
<p><strong>Ingress工作原理</strong></p>
<p>客户端访问DNS服务解析得到的IP地址，到达Ingress控制器，控制器确定该请求要访问哪个服务，然后查询该服务的Endpoints列表，从中选一个IP，从而定位到某个确定的POD。可见其没有经过服务进行访问，只是用了服务的endpoint表</p>
<p><strong>Ingress处理TLS传输</strong></p>
<p>客户端和Ingress控制器之间的传输是TLS连接时，控制器在和POD交流时将终止TLS传输，要使得Ingress具有TLS传输能力，需要进行配置</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 首先创建secret资源</span></span><br><span class="line">openssl genrsa -out tls. key 2048 </span><br><span class="line">openssl req -new - x509 -key tls.key -out tls.cert -days 360 -subj /CN=kubia.example.com</span><br><span class="line">kubectl create secret tls tls-secret --cert=tls.cert - -key=tls .key </span><br></pre></td></tr></table></figure>

<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 然后在创建Ingress时指定sercret</span></span><br><span class="line"><span class="string">......</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line">  <span class="attr">tls:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="attr">hosts:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">kubia.example.com</span></span><br><span class="line">      <span class="attr">secretName:</span> <span class="string">tls-secret</span></span><br><span class="line"><span class="string">......</span></span><br></pre></td></tr></table></figure>

<h2 id="POD-就绪了吗"><a href="#POD-就绪了吗" class="headerlink" title="POD 就绪了吗"></a>POD 就绪了吗</h2><p>服务需要在POD就绪后再将请求发送到POD，以便带来更好的响应速度。</p>
<h3 id="就绪探针"><a href="#就绪探针" class="headerlink" title="就绪探针"></a>就绪探针</h3><p>探测POD是否准备好接收请求的探针。和存活探针类似，也有exec、http、tcp三种。就绪探针探测到失败的节点时，会将该节点从服务中移除。</p>
<p>就绪探针是一定要有的，否则可能在pod刚启动时就纳入服务，导致访问失败。</p>
<h3 id="创建就绪探针"><a href="#创建就绪探针" class="headerlink" title="创建就绪探针"></a>创建就绪探针</h3><p>就绪探针要在POD托管对象的模板中定义，比如RC</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="string">......</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">ReplicationController</span></span><br><span class="line"><span class="string">......</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line">  <span class="string">...</span></span><br><span class="line">  <span class="attr">template:</span></span><br><span class="line">    <span class="attr">spec:</span></span><br><span class="line">      <span class="attr">containers:</span></span><br><span class="line">        <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">kubia</span></span><br><span class="line">          <span class="attr">image:</span> <span class="string">zou8944/kubia</span></span><br><span class="line">          <span class="attr">readinessProbe:</span></span><br><span class="line">            <span class="attr">exec:</span></span><br><span class="line">              <span class="attr">command:</span></span><br><span class="line">                <span class="bullet">-</span> <span class="string">ls</span></span><br><span class="line">                <span class="bullet">-</span> <span class="string">/var/ready</span></span><br><span class="line">          <span class="string">......</span></span><br></pre></td></tr></table></figure>

<h2 id="获取所有POD地址"><a href="#获取所有POD地址" class="headerlink" title="获取所有POD地址"></a>获取所有POD地址</h2><p>在某些场景下会需要获取所有POD的地址，此时使用服务就不行了。可以创建一个headless服务，即没有clusterIP的服务，然后通过某个容器中的nslookup进行DNS查找，步骤如下：</p>
<ul>
<li>创建headless服务</li>
</ul>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">apiVersion:</span> <span class="string">v1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">Service</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">kubia-headless</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line">  <span class="attr">clusterIP:</span> <span class="string">None</span></span><br><span class="line">  <span class="attr">ports:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="attr">port:</span> <span class="number">80</span></span><br><span class="line">      <span class="attr">targetPort:</span> <span class="number">8080</span></span><br><span class="line">  <span class="attr">selector:</span></span><br><span class="line">    <span class="attr">app:</span> <span class="string">kubia</span></span><br></pre></td></tr></table></figure>

<ul>
<li>创建一个有nslookup的pod</li>
</ul>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">kubect1 run dnsutils --image=tutum/dnsutils --generator=run-pod/v1 --command -- sleep infinity</span><br><span class="line"><span class="meta">#</span><span class="bash"> run-pod/v1意味着运行一个临时pod，没有任何rc会托管它</span></span><br></pre></td></tr></table></figure>

<ul>
<li>在该节点上执行nslookup，能够看到所有已经准备就绪的pod地址</li>
</ul>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">kubectl exec dnsutils nslookup kubia-headless</span><br></pre></td></tr></table></figure>

<h1 id=""><a href="#" class="headerlink" title=""></a></h1>]]></content>
      <categories>
        <category>运维</category>
      </categories>
      <tags>
        <tag>kubernetes</tag>
      </tags>
  </entry>
  <entry>
    <title>Kubernetes初探 - POD</title>
    <url>/2019/10/21/Kubernetes%E5%88%9D%E6%8E%A2%20-%20POD-kubernetes%E5%88%9D%E6%8E%A2-pod/</url>
    <content><![CDATA[<p>Kubernetes是一个容器编排系统，维护节点集群，负责创建、管理容器，本章介绍k8s的核心POD（容器的容器）和负责管理POD策略性工具（决定如何维护POD的数量和方式）。</p>
<span id="more"></span>

<h1 id="POD"><a href="#POD" class="headerlink" title="POD"></a>POD</h1><p>POD是K8S中最为核心的概念，而其它对象仅仅是用于管理、暴露POD或被POD使用。</p>
<p>POD是一组并置的容器，代表K8S中的基本模块。</p>
<h2 id="基础"><a href="#基础" class="headerlink" title="基础"></a>基础</h2><h3 id="为什么需要pod"><a href="#为什么需要pod" class="headerlink" title="为什么需要pod"></a>为什么需要pod</h3><p>容器的目的，是要在一个容器中仅运行一个进程（启动子进程除外），这是因为如果一个容器内运行多个进程，容器还需要负责进程管理、日志管理等繁复工作，这就是docker期望解决的问题。</p>
<p>docker解决了单个容器对应的多进程问题，那么原本需要相互关联的进程就变成了相互关联的容器关系，这种更加高级的关系就由pod来解决。</p>
<h3 id="同一个pod中容器的部分隔离"><a href="#同一个pod中容器的部分隔离" class="headerlink" title="同一个pod中容器的部分隔离"></a>同一个pod中容器的部分隔离</h3><p>docker容器之间是完全相互隔离的，但同一个pod中的所有容器都共享相同的主机名和网络接口，其它还是隔离。由于共享相同的IP地址和端口空间，因此同一个pod中的容器不能绑定到相同的端口，否则会冲突。</p>
<h3 id="pod间网络"><a href="#pod间网络" class="headerlink" title="pod间网络"></a>pod间网络</h3><p>k8s集群中所有pod都在同一个共享的网络地址空间中，所以pod之间可以直接通过IP地址进行互访，不需要经过网关，就像局域网一样，因此他们的访问是非常直接简单的。</p>
<h3 id="pod的容器管理策略"><a href="#pod的容器管理策略" class="headerlink" title="pod的容器管理策略"></a>pod的容器管理策略</h3><p>pod可以被视为独立的机器，且由于它比较轻量，因此我们可以轻易拥有尽可能多的pod。</p>
<p>pod的推荐策略是，除了关系非常紧密的组件或进程放在一个pod外，其它情况最好只一个pod对应一个进程。原因有二</p>
<ul>
<li>pod是k8s扩容的基本单位，一个pod对应一个进程更加具有弹性</li>
<li>一个pod只能部署在一个节点，分多个pod更加容易在多个节点之间平衡，充分利用节点资源。</li>
</ul>
<h2 id="通过配置文件创建POD"><a href="#通过配置文件创建POD" class="headerlink" title="通过配置文件创建POD"></a>通过配置文件创建POD</h2><p>一个配置文件示例</p>
<figure class="highlight yml"><table><tr><td class="code"><pre><span class="line"><span class="attr">apiVersion:</span> <span class="string">v1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">Pod</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">kubia-manual</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line">  <span class="attr">containers:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="attr">image:</span> <span class="string">zou8944/kubia</span></span><br><span class="line">      <span class="attr">name:</span> <span class="string">kubia2</span></span><br><span class="line">      <span class="attr">ports:</span></span><br><span class="line">       <span class="bullet">-</span> <span class="attr">containerPort:</span> <span class="number">8080</span></span><br><span class="line">      <span class="attr">protoctl:</span> <span class="string">TCP</span></span><br></pre></td></tr></table></figure>

<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 创建pod</span></span><br><span class="line">kubectl create -f kubia-manual.yaml # 甚至都不用指定创建什么，因为配置文件中已经说明了创建对象</span><br></pre></td></tr></table></figure>

<h2 id="查看应用程序日志"><a href="#查看应用程序日志" class="headerlink" title="查看应用程序日志"></a>查看应用程序日志</h2><h3 id="方式一"><a href="#方式一" class="headerlink" title="方式一"></a>方式一</h3><p>使用ssh登录到pod正在运行的节点，然后使用docker logs命令获取对应容器的日志</p>
<h3 id="方式二"><a href="#方式二" class="headerlink" title="方式二"></a>方式二</h3><p>直接使用kubectl logs &lt;pod name&gt;获取pod的日志</p>
<h2 id="将本地端口转发到pod中的端口"><a href="#将本地端口转发到pod中的端口" class="headerlink" title="将本地端口转发到pod中的端口"></a>将本地端口转发到pod中的端口</h2><p>在不通过service的情况下与特定的pod通信，通常是调试时需要用到，可以将本地网络端口转发到远端集群中的pod</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">kubectl port-forward kubia-manual 8888:8080 # 将本机的8888端口转到到目标pod的8080端口</span><br></pre></td></tr></table></figure>

<p><img src="https://gdz.oss-cn-shenzhen.aliyuncs.com/hexo/Kubernetes%20-%20POD/1571545693737.png" alt="1571545693737"></p>
<h2 id="标签"><a href="#标签" class="headerlink" title="标签"></a>标签</h2><h3 id="基本"><a href="#基本" class="headerlink" title="基本"></a>基本</h3><p>标签是K8S简单且强大的特性，可以应用于任何资源。简单地讲，他就是可以应用于任何资源的键值对。</p>
<ul>
<li><p>标签可以在创建时pod时指定</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="string">......</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line"><span class="attr">name:</span> <span class="string">kubia-manual</span></span><br><span class="line"><span class="attr">labels:</span></span><br><span class="line">  <span class="attr">creatingMethod:</span> <span class="string">manual</span></span><br><span class="line">  <span class="attr">env:</span> <span class="string">prod</span></span><br><span class="line"><span class="string">......</span></span><br></pre></td></tr></table></figure></li>
<li><p>也可以直接添加或修改标签</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 手动添加一个标签</span></span><br><span class="line">kubectl label po kubia-manual creation_method=manual</span><br><span class="line"><span class="meta">#</span><span class="bash"> 手动覆盖原有的标签</span></span><br><span class="line">kubectl label po kubia-manual enb=debug --override</span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="标签选择器"><a href="#标签选择器" class="headerlink" title="标签选择器"></a>标签选择器</h3><p>标签结合标签选择器可以带来丰富的效果</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 单个条件</span></span><br><span class="line">kubectl get po -l creation_method=manual</span><br><span class="line">kubectl get po -l creation_method!=manual</span><br><span class="line">kubectl get po -l env</span><br><span class="line">kubectl get po -l &#x27;!env&#x27;</span><br><span class="line">kubectl get po -l env in (prod, dev)</span><br><span class="line">kubectl get po -l env notin (prod, dev)</span><br><span class="line"><span class="meta">#</span><span class="bash"> 多个条件</span></span><br><span class="line">kubectl get po -l creation_method=manual, env in (prod, dev)</span><br></pre></td></tr></table></figure>

<h3 id="使用标签选择器约束pod调度"><a href="#使用标签选择器约束pod调度" class="headerlink" title="使用标签选择器约束pod调度"></a>使用标签选择器约束pod调度</h3><p>让pod随机调度是k8s最为理想的调度，但有时由于硬件或是其它因素导致的需要约束pod调度。</p>
<p>方式是为node添加标签，再在pod创建时利用标签选择器约束其在符合条件的节点上部署</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 将一个节点添加标签 gpu=<span class="literal">true</span></span></span><br><span class="line">kubectl label node gke-kubia-default-pool-e4a13557-8mqq gpu=true</span><br></pre></td></tr></table></figure>

<p>然后在创建时指定选择器</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="string">......</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line">  <span class="attr">nodeSelector:</span></span><br><span class="line">    <span class="attr">gpu:</span> <span class="string">&quot;true&quot;</span></span><br><span class="line">  <span class="attr">containers:</span></span><br><span class="line"><span class="string">......</span></span><br></pre></td></tr></table></figure>

<h2 id="注解"><a href="#注解" class="headerlink" title="注解"></a>注解</h2><p>注解同样可以用于所有k8s资源，也是键值对。与标签不同的是它没有注解选择器，但能够容纳更多信息（不超过256KB）。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 创建注解</span></span><br><span class="line">kubectl annoteate pod kubia-manual hello=&quot;true&quot;</span><br><span class="line"><span class="meta">#</span><span class="bash"> 查看注解，使用describe命令可以查看注解内容</span></span><br><span class="line">kubectl describe pod kubia-manual</span><br></pre></td></tr></table></figure>

<h2 id="命名空间"><a href="#命名空间" class="headerlink" title="命名空间"></a>命名空间</h2><p>使用标签可以将对象分为多个有重叠的组。但在完全不需要重复的情况下，可以将对象分组到不同的命名空间中。</p>
<p>比如k8s默认将系统相关的node放在kube-system命名空间中，将我们的node放在default命名空间中，这样不会显得混乱，还能防止用户误删除。</p>
<h3 id="创建命名空间"><a href="#创建命名空间" class="headerlink" title="创建命名空间"></a>创建命名空间</h3><p>和pod一样，命名空间在k8s中液仅仅是一个资源，因此可以通过yaml文件创建</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">apiVersion:</span> <span class="string">v1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">Namespace</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">my-first-namespace</span></span><br></pre></td></tr></table></figure>

<p>当然也可以通过命令行直接创建</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">kubectl create namespace my-first-namespace</span><br></pre></td></tr></table></figure>

<h3 id="管理命名空间中的对象"><a href="#管理命名空间中的对象" class="headerlink" title="管理命名空间中的对象"></a>管理命名空间中的对象</h3><p>创建一个资源（不一定是pod哦）时指定命名空间，可以两种方式</p>
<ul>
<li><p>在metadata字段添加  namespace字段指定命名空间</p>
</li>
<li><p>也可以在创建时指定命名空间</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">kubectl create -f kubia-manual.yaml -n custom-namespace</span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="别误会"><a href="#别误会" class="headerlink" title="别误会"></a>别误会</h3><p>命名空间并不提供正在运行的对象的任何隔离，仅仅是让我们在管理时候分离开来。当然这也不一定，我们说得是默认情况。</p>
<h2 id="删除pod"><a href="#删除pod" class="headerlink" title="删除pod"></a>删除pod</h2><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 按名称删除pod</span></span><br><span class="line">kubectl delete pod &lt;pod name&gt;</span><br><span class="line"><span class="meta">#</span><span class="bash"> 使用标签选择器删除pod</span></span><br><span class="line">kubectl delete po -l creation_method=manual</span><br><span class="line"><span class="meta">#</span><span class="bash"> 通过删除整个命名空间来删除pod</span></span><br><span class="line">kubectl delete ns custom-namespace</span><br><span class="line"><span class="meta">#</span><span class="bash"> 删除命名空间的所有pod，但保留命名空间</span></span><br><span class="line">kubectl delete po --all</span><br></pre></td></tr></table></figure>

<p>我们如果直接删除pod，会发现马上又会重新启动一个pod。这是replicationController在作怪，因为他会保证一致有一个pod在运行。因此要彻底删除必须同时删除该rc</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 删除所有资源，包括rc, service等</span></span><br><span class="line">kubectl delete all --all</span><br></pre></td></tr></table></figure>

<p>上述命令也会删除kubernetes的service，但这没有关系，因为几分钟后会自动重建。</p>
<h1 id="管理POD"><a href="#管理POD" class="headerlink" title="管理POD"></a>管理POD</h1><h2 id="保持pod健康"><a href="#保持pod健康" class="headerlink" title="保持pod健康"></a>保持pod健康</h2><p>k8s能够做到即使应用程序的进程没有崩溃，仅仅是应用停止响应，也能够重启应用程序。</p>
<h3 id="使用存活探针"><a href="#使用存活探针" class="headerlink" title="使用存活探针"></a>使用存活探针</h3><p>存活探针检测容器是否还允许，有三种机制</p>
<ul>
<li>HTTP GET请求应用给出的IP地址，不返回数据或是返回错误状态码将会导致重启</li>
<li>TCP套接字探针，与容器指定端口建立连接，建立失败则导致重启</li>
<li>Exec探针，在容器内执行任意命令，执行结果的状态码非0则重启</li>
</ul>
<h3 id="HTTP探针"><a href="#HTTP探针" class="headerlink" title="HTTP探针"></a>HTTP探针</h3><figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="string">......</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line">  <span class="attr">containers:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">image:</span> <span class="string">zou8944/kubia</span></span><br><span class="line">    <span class="attr">name:</span> <span class="string">kubia</span></span><br><span class="line">    <span class="comment"># 指定路径为/，端口为8080的http探针</span></span><br><span class="line">    <span class="attr">livenessProbe:</span></span><br><span class="line">      <span class="attr">httpGet:</span></span><br><span class="line">        <span class="attr">path:</span> <span class="string">/</span></span><br><span class="line">        <span class="attr">port:</span> <span class="number">8080</span></span><br><span class="line">      <span class="attr">initialDelaySeconds:</span> <span class="number">15</span>  <span class="comment"># 在第一次探测前等待15秒，用于等待容器启动</span></span><br><span class="line"><span class="string">......</span></span><br></pre></td></tr></table></figure>

<h2 id="ReplicationController"><a href="#ReplicationController" class="headerlink" title="ReplicationController"></a>ReplicationController</h2><p>是一种k8s资源，可确保它的pod始终处于运行状态。没有RC管理的pod在终止后不会被重新创建。</p>
<p>RC对pod的跟踪，是使用标签选择器来进行的。</p>
<p><img src="https://gdz.oss-cn-shenzhen.aliyuncs.com/hexo/Kubernetes%20-%20POD/1571565351148.png" alt="1571565351148"></p>
<p>RC三个重要组成部分</p>
<ul>
<li>标签选择器</li>
<li>副本个数 </li>
<li>pod模板：用于创建新的pod副本</li>
</ul>
<p>pod和rc的联系仅在标签选择器，当该条件获取的结果不满足副本个数时，将会使用pod模板进行闯将。</p>
<h3 id="创建"><a href="#创建" class="headerlink" title="创建"></a>创建</h3><p>使用yaml创建</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">apiVersion:</span> <span class="string">v1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">ReplicationController</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">kubia</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line">  <span class="comment"># 确保的pod实例数量</span></span><br><span class="line">  <span class="attr">replicas:</span> <span class="number">3</span></span><br><span class="line">  <span class="comment"># selector决定了RC的操作对象</span></span><br><span class="line">  <span class="attr">selector:</span> </span><br><span class="line">    <span class="attr">app:</span> <span class="string">kubia</span></span><br><span class="line">  <span class="comment"># 创建新pod时的模板</span></span><br><span class="line">  <span class="attr">template:</span></span><br><span class="line">    <span class="attr">metadata:</span> </span><br><span class="line">      <span class="attr">labels:</span> </span><br><span class="line">        <span class="attr">app:</span> <span class="string">kubia</span></span><br><span class="line">    <span class="attr">spec:</span></span><br><span class="line">      <span class="attr">containers:</span></span><br><span class="line">        <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">kubia</span></span><br><span class="line">          <span class="attr">image:</span> <span class="string">zou8944/kubia</span></span><br><span class="line">          <span class="attr">ports:</span></span><br><span class="line">            <span class="bullet">-</span> <span class="attr">containerPort:</span> <span class="number">8080</span></span><br></pre></td></tr></table></figure>

<h3 id="删除"><a href="#删除" class="headerlink" title="删除"></a>删除</h3><p>可以删除RC，但当通过kubectl delete删除时，对应的pod也会被删除。由于RC和POD只是管理与被管理的关系，因此可以做到只删RC而不删除POD</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 删除rc及其管理的POD</span></span><br><span class="line">kubectl delete rc &lt;rc name&gt;</span><br><span class="line"><span class="meta">#</span><span class="bash"> 仅删除rc，不删除POD</span></span><br><span class="line">kubectl delete rc &lt;rc name&gt; --cascade=false</span><br></pre></td></tr></table></figure>

<h2 id="ReplicaSet"><a href="#ReplicaSet" class="headerlink" title="ReplicaSet"></a>ReplicaSet</h2><p>ReplicaSet是新一代的ReplicationController，并且最终会取代RC。所以实际使用中应该使用RS，而不是RC。上文中创建那么多RC只是为了学习演示。</p>
<h3 id="与RC相比有何优势"><a href="#与RC相比有何优势" class="headerlink" title="与RC相比有何优势"></a>与RC相比有何优势</h3><p>行为上与RC完全相同，但是其标签选择器具有更强的表现力。</p>
<h3 id="创建-1"><a href="#创建-1" class="headerlink" title="创建"></a>创建</h3><figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">apiVersion:</span> <span class="string">apps/v1beta2</span>  <span class="comment"># 版本必须是这个（不知道现在的版本还是不是）</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">ReplicaSet</span></span><br><span class="line"><span class="attr">metadata:</span> </span><br><span class="line">  <span class="attr">name:</span> <span class="string">kubia</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line">  <span class="attr">replicas:</span> <span class="number">3</span></span><br><span class="line">  <span class="attr">selector:</span></span><br><span class="line">    <span class="attr">matchLabels:</span></span><br><span class="line">      <span class="attr">app:</span> <span class="string">kubia</span></span><br><span class="line">  <span class="attr">template:</span></span><br><span class="line">    <span class="attr">metadata:</span></span><br><span class="line">      <span class="attr">labels:</span></span><br><span class="line">        <span class="attr">app:</span> <span class="string">kubia</span></span><br><span class="line">    <span class="attr">spec:</span></span><br><span class="line">      <span class="attr">containers:</span></span><br><span class="line">        <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">kubia</span></span><br><span class="line">          <span class="attr">image:</span> <span class="string">zou8944/kubia</span></span><br></pre></td></tr></table></figure>

<h3 id="强大的选择器示例"><a href="#强大的选择器示例" class="headerlink" title="强大的选择器示例"></a>强大的选择器示例</h3><figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="string">......</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line">  <span class="attr">replicas:</span> <span class="number">3</span></span><br><span class="line">  <span class="attr">selector:</span></span><br><span class="line">    <span class="attr">matchExpression:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="attr">key:</span> <span class="string">app</span></span><br><span class="line">        <span class="attr">oprator:</span> <span class="string">In</span> <span class="comment"># 支持的操作：In NotIn Exists DoesNotExist</span></span><br><span class="line">        <span class="attr">values:</span></span><br><span class="line">          <span class="bullet">-</span> <span class="string">kubia</span></span><br><span class="line"><span class="string">......</span></span><br></pre></td></tr></table></figure>

<h2 id="DaemonSet"><a href="#DaemonSet" class="headerlink" title="DaemonSet"></a>DaemonSet</h2><p>适用于需要在每个节点上都运行一个pod的情况，比如一些基础设施。最典型的例子就是kube-proxy进程</p>
<p>DaemonSet确保在符合条件的节点上运行一个指定的pod：新节点加入时主动创建一个pod，一个节点下线时不做任何操作</p>
<h3 id="创建-2"><a href="#创建-2" class="headerlink" title="创建"></a>创建</h3><figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">apiVersion:</span> <span class="string">apps/v1beta2</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">DaemonSet</span></span><br><span class="line"><span class="attr">metadata:</span> </span><br><span class="line">  <span class="attr">name:</span> <span class="string">ssd-monitor</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line">  <span class="attr">selector:</span></span><br><span class="line">    <span class="attr">matchLabels:</span>  <span class="comment"># 匹配POD的节点</span></span><br><span class="line">      <span class="attr">app:</span> <span class="string">ssd-monitor</span></span><br><span class="line">  <span class="attr">template:</span></span><br><span class="line">    <span class="attr">metadata:</span></span><br><span class="line">      <span class="attr">labels:</span></span><br><span class="line">        <span class="attr">app:</span> <span class="string">ssd-monitor</span></span><br><span class="line">    <span class="attr">spec:</span></span><br><span class="line">      <span class="attr">nodeSelector:</span>  <span class="comment"># 该节点选择器用于匹配节点</span></span><br><span class="line">        <span class="attr">disk:</span> <span class="string">ssd</span></span><br><span class="line">      <span class="attr">container:</span></span><br><span class="line">        <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">kubia</span></span><br><span class="line">          <span class="attr">image:</span> <span class="string">zou8944/kubia</span></span><br></pre></td></tr></table></figure>

<h3 id="删除-1"><a href="#删除-1" class="headerlink" title="删除"></a>删除</h3><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 获取所有DaemonSet</span></span><br><span class="line">kubectl get ds</span><br></pre></td></tr></table></figure>

<h2 id="Job"><a href="#Job" class="headerlink" title="Job"></a>Job</h2><p>RC, RS, DS都会持续运行任务，永远达不到结束态。如果需要一种任务，完成工作后就马上结束，Job就很适用。</p>
<p>Job会在pod未成功执行完成而异常退出时重新启动一个pod，如果成功完成了则不再启动。</p>
<h3 id="创建-3"><a href="#创建-3" class="headerlink" title="创建"></a>创建</h3><figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">apiVersion:</span> <span class="string">batch/v1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">Job</span></span><br><span class="line"><span class="attr">metadata:</span> </span><br><span class="line">  <span class="attr">name:</span> <span class="string">batch-job</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line">  <span class="attr">template:</span></span><br><span class="line">    <span class="attr">metadata:</span></span><br><span class="line">      <span class="attr">labels:</span></span><br><span class="line">        <span class="attr">app:</span> <span class="string">batch-job</span></span><br><span class="line">    <span class="attr">spec:</span></span><br><span class="line">      <span class="attr">completions:</span> <span class="number">5</span> <span class="comment"># 将此容器顺序运行5个pod</span></span><br><span class="line">      <span class="attr">parallelism:</span> <span class="number">2</span>  <span class="comment"># 最多两个pod可以并行运行</span></span><br><span class="line">      <span class="attr">activeDeadlineSeconds:</span> <span class="number">30</span> <span class="comment"># pod运行30秒还没有成功就中止并重试</span></span><br><span class="line">      <span class="attr">restartPolicy:</span> <span class="string">OnFauilre</span></span><br><span class="line">      <span class="attr">containers:</span></span><br><span class="line">        <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">main</span></span><br><span class="line">          <span class="attr">image:</span> <span class="string">zou8944/batch-job</span></span><br></pre></td></tr></table></figure>

<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> job运行时手动将并行运行个数改为3个</span></span><br><span class="line">kubectl scale job batch-job --replicas 3</span><br></pre></td></tr></table></figure>

<h2 id="CronJob"><a href="#CronJob" class="headerlink" title="CronJob"></a>CronJob</h2><p>在特定时间或特定间隔时间运行的Job</p>
<h3 id="创建-4"><a href="#创建-4" class="headerlink" title="创建"></a>创建</h3><figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">apiversion:</span> <span class="string">batch/v1beta1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">CronJob</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">periodic-batch-job</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line">  <span class="attr">schedule:</span> <span class="string">&quot;0, 15, 30, 45, * * * * &quot;</span> <span class="comment"># 每天的每小时的0,15,30,45分钟运行一次</span></span><br><span class="line">  <span class="attr">startingDeadlineSeconds:</span> <span class="number">15</span>  <span class="comment"># pod最迟必须在预定时间的15秒内开始（可选）</span></span><br><span class="line">  <span class="attr">jobTemplate:</span></span><br><span class="line">    <span class="attr">spec:</span></span><br><span class="line">      <span class="attr">template:</span> </span><br><span class="line">        <span class="attr">metadata:</span></span><br><span class="line">          <span class="attr">labels:</span></span><br><span class="line">            <span class="attr">app:</span> <span class="string">periodic-batch-job</span></span><br><span class="line">        <span class="attr">spec:</span></span><br><span class="line">          <span class="attr">restartPolicy:</span> <span class="string">OnFailure</span></span><br><span class="line">          <span class="attr">containers:</span></span><br><span class="line">            <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">main</span></span><br><span class="line">              <span class="attr">image:</span> <span class="string">zou8944/batch-job</span></span><br></pre></td></tr></table></figure>

<h3 id="时间表解释"><a href="#时间表解释" class="headerlink" title="时间表解释"></a>时间表解释</h3><p>从左到右依次代表</p>
<ul>
<li>分钟</li>
<li>小时</li>
<li>每月中的第几天</li>
<li>月</li>
<li>星期几 （0代表周天，以此类推）</li>
</ul>
<h3 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h3><p>CronJob会创建Job，Job再去创建pod。</p>
]]></content>
      <categories>
        <category>运维</category>
      </categories>
      <tags>
        <tag>kubernetes</tag>
      </tags>
  </entry>
  <entry>
    <title>Kubernetes初探 - Deployment</title>
    <url>/2019/10/27/Kubernetes%E5%88%9D%E6%8E%A2%20-%20Deployment-kubernetes%E5%88%9D%E6%8E%A2-deployment/</url>
    <content><![CDATA[<p>前面介绍了各种Kubernetes资源以及使用方法，但在实际使用中，发布和升级总是避免不了的话题。使用一个容器级别的工具，每次发布时候敲一大段命令肯定是不行的，K8S提供声明式的发布升级方式，只需替换镜像即可触发，且提供滚动升级、回滚、暂停等操作。</p>
<span id="more"></span>
<p>应用发布后，有两种升级方法可选</p>
<ul>
<li><p>停用所有现有pod，然后创建新的pod<br>这种方式会使服务停用一段时间，但不会造成两个版本同时运行的情况。<br>实际操作上，先修改RC的模板，然后删除现有pod，这样RC会使用新的模板创建pod。</p>
</li>
<li><p>先创建新的pod，待新的pod准备就绪后，再删除旧的pod<br>这种方式虽然是无缝切换，但这会造成同时有两个版本的应用在运行。<br>实际操作上，有两种方式</p>
<ul>
<li><p>蓝绿部署<br>如下图所示，新建一个RC，待所有pod就绪后再通过Service的选择器设置将流量转到新的pod上。<br><img src="https://gdz.oss-cn-shenzhen.aliyuncs.com/hexo/Kubernetes%20-%20Deployment/image-20191027105535321.png" alt="image-20191027105535321"></p>
</li>
<li><p>滚动升级<br>实现这种方式的最笨办法就是对旧的RC缩容，新的RC扩容，直到完全到新的RC掌控。<br><img src="https://gdz.oss-cn-shenzhen.aliyuncs.com/hexo/Kubernetes%20-%20Deployment/image-20191027105724518.png" alt="image-20191027105724518"></p>
</li>
</ul>
</li>
</ul>
<h2 id="Rolling-update"><a href="#Rolling-update" class="headerlink" title="Rolling-update"></a>Rolling-update</h2><p>上述滚动升级的自动执行方式如下所示。kubia-v1是原先版本的RC，kubia-v2是需要创建的新的RC（不需要给定义文件），–image指定了新的镜像。这样k8s会自动一步一步地执行上述滚动升级的操作。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">kubectl rolling-update kubia-v1 kubia-v2  --image=luksa/kubia:v2</span><br></pre></td></tr></table></figure>

<p>k8s是如何做到的呢？如下图，在创建kubia-v2这个RC时，k8s将原有pod增加了一个deployment标签，其值为3ddd开头。新RC创建的pod标签也增加了deployment=757d…标签。这样就能区分那个pod是新的，哪个pod是旧的。</p>
<p><img src="https://gdz.oss-cn-shenzhen.aliyuncs.com/hexo/Kubernetes%20-%20Deployment/image-20191027110812026.png" alt="image-20191027110812026"></p>
<p>然后再对kubia-v1执行缩容，对kubia-v2执行扩容，直到完全切换到kubia-v2</p>
<p>不过很遗憾的是，<strong>这种升级方式已过时</strong>。因为rolling-update的每一步缩容扩容都是kubectl客户端在请求，如果网络出现问题，将会造成升级到一半卡主的情况。并且手动增删pod和修改正在运行的pod的标签等属性是不符合k8s的策略的。</p>
<h2 id="Deployment"><a href="#Deployment" class="headerlink" title="Deployment"></a>Deployment</h2><p>正是由于rolling-update的过时，催生了Deployment。它是一种k8s资源，用于以声明的方式升级应用，而不是通过操作底层的RC。通过这种方式用户只需要定义单个Deployment需要达到的状态，中间操作都将由k8s处理。</p>
<h3 id="创建"><a href="#创建" class="headerlink" title="创建"></a>创建</h3><p>Deployment的创建和RS创建很相似。它并不能直接管理pod，而是创建ReplicaSet来替它管理。</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">apiVersion:</span> <span class="string">apps/v1beta1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">Deployment</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">kubia</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line">  <span class="attr">replicas:</span> <span class="number">3</span></span><br><span class="line">  <span class="attr">progressDeadlineSeconds:</span> <span class="number">600</span>  <span class="comment"># 可选，允许最长升级时间，默认十分钟</span></span><br><span class="line">  <span class="attr">miniReadySeconds:</span> <span class="number">10</span> <span class="comment"># 可选，设置pod就绪后至少10秒才创建新的pod</span></span><br><span class="line">  <span class="attr">strategy:</span>  <span class="comment"># 可选，升级策略，默认为滚动升级</span></span><br><span class="line">    <span class="attr">type:</span> <span class="string">rollingUpdate</span></span><br><span class="line">    <span class="attr">rollingUpdate:</span></span><br><span class="line">      <span class="attr">masSurage:</span> <span class="number">1</span>  <span class="comment"># 这两个参数后面会讲</span></span><br><span class="line">      <span class="attr">maxUnavailable:</span> <span class="number">0</span></span><br><span class="line">  <span class="attr">template:</span></span><br><span class="line">    <span class="attr">matadata:</span></span><br><span class="line">      <span class="attr">name:</span> <span class="string">kubia</span></span><br><span class="line">      <span class="attr">labels:</span></span><br><span class="line">        <span class="attr">app:</span> <span class="string">kubia</span></span><br><span class="line">    <span class="attr">spec:</span></span><br><span class="line">      <span class="attr">containers:</span></span><br><span class="line">        <span class="bullet">-</span> <span class="attr">image:</span> <span class="string">zou8944/kubia:v1</span></span><br><span class="line">          <span class="attr">name:</span> <span class="string">nicai</span></span><br></pre></td></tr></table></figure>

<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 创建Deployment， record很重要，会记录每次修改，用于回滚和升级<span class="built_in">log</span>记录</span></span><br><span class="line">kubectl create -f &lt;上面的yaml&gt;  --record</span><br><span class="line"><span class="meta">#</span><span class="bash"> 创建Deployment后可使用如下命令查看状态</span></span><br><span class="line">kubectl get deployment</span><br><span class="line">kubectl describe deployment</span><br><span class="line">kubectl rollout status deployment kubia</span><br></pre></td></tr></table></figure>

<h3 id="升级"><a href="#升级" class="headerlink" title="升级"></a>升级</h3><p>从创建步骤和基本原理分析上，Deployment和rolling-update貌似没什么不同，这里展现其杀手锏。执行如下命令，仅是修改了Deployment资源中的镜像，k8s的控制处理器就会执行升级操作，其所有过程都是在服务端完成的，客户端仅仅请求了修改一个字段，这样会非常可靠。当然，整个滚动升级过程和rolling-update是非常类似的，只不过指定点移动到了服务端。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 手动触发滚动升级</span></span><br><span class="line">kubectl set image deployment kubia nicai=zou8944/kubia:v2</span><br></pre></td></tr></table></figure>

<p>主要注意的是，这里的升级也有两种策略</p>
<ul>
<li>Recreate: 先删除旧的pod，再创建新的pod</li>
<li>RollingUpdate: 逐渐删除旧的pod，同时创建新的pod，默认并推荐使用这种方式。</li>
</ul>
<p>还要注意的是，执行滚动升级后，Deployment会创建新的RS，同时原有的RS会保留，次数不要删除原有RS，它是用于回滚操作的，如果删除了就无法回滚到对应版本了。如下图所示</p>
<p><img src="https://gdz.oss-cn-shenzhen.aliyuncs.com/hexo/Kubernetes%20-%20Deployment/image-20191027120809966.png" alt="image-20191027120809966"></p>
<h3 id="暂停滚动升级"><a href="#暂停滚动升级" class="headerlink" title="暂停滚动升级"></a>暂停滚动升级</h3><p>如果只想发布一个pod用于观察情况，可以在升级启动后暂停，观察OK后再继续升级。需要注意的是，这并不是金丝雀发布的正确打开方式。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 触发升级</span></span><br><span class="line">kubectl set image deployment kubia nicai=zou8944/kubia:v3</span><br><span class="line"><span class="meta">#</span><span class="bash"> 暂停升级</span></span><br><span class="line">kubectl rollout pause deployment kubia</span><br><span class="line"><span class="meta">#</span><span class="bash"> 如果发现不妙，取消本次升级</span></span><br><span class="line">kubectl rollout undo deployment kubia</span><br><span class="line"><span class="meta">#</span><span class="bash"> 恢复升级</span></span><br><span class="line">kubectl rollout resume deployment kubia</span><br></pre></td></tr></table></figure>

<h3 id="回滚"><a href="#回滚" class="headerlink" title="回滚"></a>回滚</h3><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 回滚到上一个版本</span></span><br><span class="line">kubectl rollout undo deployment kubia</span><br><span class="line"><span class="meta">#</span><span class="bash"> 回滚到特定的版本</span></span><br><span class="line">kubectl rollout undo deployment kubia --to-revision=1</span><br><span class="line"><span class="meta">#</span><span class="bash"> 查看回滚历史</span></span><br><span class="line">kubectl rollout history deployment kubia</span><br></pre></td></tr></table></figure>

<h3 id="控制滚动升级策略"><a href="#控制滚动升级策略" class="headerlink" title="控制滚动升级策略"></a>控制滚动升级策略</h3><p>有三个关键的参数，maxSurge、maxUnavailable、minReadySeconds.</p>
<ul>
<li><p>maxSurge: Deployment期望的副本数之外，最多允许超出pod实例的数量，默认25%</p>
</li>
<li><p>maxUnavailable: 滚动升级期间，允许多少个pod实例处于不可用状态</p>
<p><img src="https://gdz.oss-cn-shenzhen.aliyuncs.com/hexo/Kubernetes%20-%20Deployment/image-20191027121408237.png" alt="image-20191027121408237"></p>
</li>
<li><p>minReadySeconds: 指定新创建的pod至少成功运行多久，才能将其视为可用。成功运行的起点为就绪探针发挥成功。如果就绪探针失败，会停止升级操作。</p>
</li>
</ul>
<p>也可为Deployment配置deadline，默认情况下，如果升级过程超过十分钟，将会被视为失败。</p>
<h3 id="取消失败的升级"><a href="#取消失败的升级" class="headerlink" title="取消失败的升级"></a>取消失败的升级</h3><p>尽管上面已经有过描述，但这里还是想加强一下，因此单独列出一个三级标题。取消失败的升级和回滚一样</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">kubectl rollout undo deployment kubia</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>运维</category>
      </categories>
      <tags>
        <tag>kubernetes</tag>
      </tags>
  </entry>
  <entry>
    <title>Kubernetes初探 - StatefulSet</title>
    <url>/2019/10/27/Kubernetes%E5%88%9D%E6%8E%A2%20-%20StatefulSet-kubernetesc%E5%88%9D%E6%8E%A2-statefulset/</url>
    <content><![CDATA[<p>什么是有状态pod，即pod的运行状态与该pod耦合，当发生pod调度时新创建的pod必须和原有pod保持一致的状态，否则会出现状态丢失。前面我们所学习的pod都是由RC或RS创建的，然而他们无法满足pod对状态的需求。于是我们有了StatefulSet，它是专门定制的一类应用，这类应用的每个实例都是不可替代的个体，都拥有稳定的名字和状态。</p>
<span id="more"></span>
<h2 id="StatefulSet和RS或RC对比"><a href="#StatefulSet和RS或RC对比" class="headerlink" title="StatefulSet和RS或RC对比"></a>StatefulSet和RS或RC对比</h2><p>RS或RC的实例挂掉后，会重新创建一个与之前并不相关的实例。而对SS来说，当一个实例挂掉后，新创建的实例会保持原有实例的名称、网络和状态。下面我们来看它是如何做到的</p>
<h3 id="稳定的网络标识"><a href="#稳定的网络标识" class="headerlink" title="稳定的网络标识"></a>稳定的网络标识</h3><p>与RS不同，SS创建的pod拥有规则的命名和主机名，这样方便管理。</p>
<p>由于每个有状态的pod之间的都是不一样的，所以经常需要定位到某一具体的pod，所以一个SS要求我们创建一个用来记录每个pod网络标记的headlessService。通过这个service，每个pod将拥有独立的DNS记录，这样集群中其它的pod就能通过主机名方便地找到它。</p>
<p>至于扩缩容，pod的命名是依照其先后顺序的索引，缩容时是先删除索引号最大的那个pod，这个比较好明确。且为了保证分布式应用的安全性，缩容时k8s每次只会操作一个pod实例，以免同时操作多个pod实例带来的潜在的数据丢失风险。</p>
<h3 id="pod的专属存储"><a href="#pod的专属存储" class="headerlink" title="pod的专属存储"></a>pod的专属存储</h3><p>RS由于pod是无状态的，因此再多pod实例都是当做一个实例看待，因此所有实例共享同样的卷。SS由于需要保存实例状态，因此每个pod实例需要单独的存储卷，这是通过为每个pod实例绑定一个卷声明做到的。如下</p>
<p><img src="https://gdz.oss-cn-shenzhen.aliyuncs.com/hexo/Kubernetes%20-%20StatefulSet/image-20191027173409275.png" alt="image-20191027173409275"></p>
<p>新增pod时，会使用SS的PVC模板创建新的PV和PVC。删除pod时，由于数据的重要性，为防止误删，k8s只会删除pod，对应的PV和PVC都不会释放，而是需要用户手动删除。如果不手动删除，当再次创建pod时，之前的PV和PVC会被重新挂载到该pod上。该pod也会运行到和删除之前一样的状态。</p>
<p><img src="https://gdz.oss-cn-shenzhen.aliyuncs.com/hexo/Kubernetes%20-%20StatefulSet/image-20191027173733318.png" alt="image-20191027173733318"></p>
<h3 id="at-most-one"><a href="#at-most-one" class="headerlink" title="at-most-one"></a>at-most-one</h3><p>一种场景：对于有状态pod，如果因为k8s对pod状态判断不准确，导致在一个pod还在运行时又创建了一个新的pod，产生了两个pod抢夺状态的情况，这是不被允许的。因此SS必须保证pod有at-most-one语义。实现方式为，如果SS无法确定一个pod的状态，将拒绝扩容的请求，此时需要用户手动强制删除该pod。</p>
<h2 id="使用SS"><a href="#使用SS" class="headerlink" title="使用SS"></a>使用SS</h2><p>使用SS部署应用需要按照如下三步走</p>
<ul>
<li>创建存储数据文件的持久卷</li>
<li>创建一个headless的控制Service</li>
<li>创建SS本身</li>
</ul>
<p>前两个的创建不再多说，可以查看前面有关服务和卷的章节，这里只说创建SS，yaml文件如下。SS创建pod时，由于有状态集群在两个节点之间的竞争是非常敏感的，因此node是一个启动成功再启动新的pod，故速度会比较慢。</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">apiVersion:</span> <span class="string">apps/v1beta1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">StatefulSet</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">kubia</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line">  <span class="attr">serviceName:</span> <span class="string">kubia</span>	<span class="comment"># 前面创建的headlessService</span></span><br><span class="line">  <span class="attr">replicas:</span> <span class="number">2</span></span><br><span class="line">  <span class="attr">template:</span></span><br><span class="line">    <span class="attr">metadata:</span></span><br><span class="line">      <span class="attr">labels:</span></span><br><span class="line">        <span class="attr">app:</span> <span class="string">kubia</span></span><br><span class="line">    <span class="attr">spec:</span></span><br><span class="line">      <span class="attr">containers:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">kubia</span></span><br><span class="line">        <span class="attr">image:</span> <span class="string">zou8944/kubia</span></span><br><span class="line">        <span class="attr">ports:</span></span><br><span class="line">        <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">http</span></span><br><span class="line">          <span class="attr">containerPort:</span> <span class="number">8080</span></span><br><span class="line">        <span class="attr">volumeMounts:</span></span><br><span class="line">        <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">data</span></span><br><span class="line">          <span class="attr">mountPath:</span> <span class="string">/var/data</span></span><br><span class="line"><span class="attr">volumeClaimTemplates:</span>	<span class="comment"># 这是RC和RS所没有的</span></span><br><span class="line"><span class="bullet">-</span> <span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">data</span></span><br><span class="line">  <span class="attr">spec:</span></span><br><span class="line">    <span class="attr">resources:</span></span><br><span class="line">      <span class="attr">requests:</span></span><br><span class="line">        <span class="attr">storage:</span> <span class="string">1Mi</span></span><br><span class="line">    <span class="attr">accessModes:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">ReadWriteOnce</span></span><br></pre></td></tr></table></figure>

<p>创建SS后，就可以开始使用了。最简单的方式就是使用Kubernetes API进行访问。还记得之前说的Kubectl proxy吗，可以在本地运行一个代理，然后通过代理访问API。命令如下</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> API 路径</span></span><br><span class="line">&lt;apiServerHost&gt;:&lt;port&gt;/api/v1/namespaces/default/pods/kubia-0/proxy/&lt;path&gt;</span><br><span class="line"><span class="meta">#</span><span class="bash"> 此处访问pod0的地址为</span></span><br><span class="line">127.0.0.1:8001/api/v1/namespaces/default/pods/kubia-0/proxy/</span><br></pre></td></tr></table></figure>

<p>此时的访问结构如下</p>
<p><img src="https://gdz.oss-cn-shenzhen.aliyuncs.com/hexo/Kubernetes%20-%20StatefulSet/image-20191027175851844.png" alt="image-20191027175851844"></p>
<h2 id="在SS中发现伙伴pod"><a href="#在SS中发现伙伴pod" class="headerlink" title="在SS中发现伙伴pod"></a>在SS中发现伙伴pod</h2><p>如何在一个有状态pod中找到同SS中的另一个pod呢？肯定不能通过Kubernetes API访问，这会使应用和k8s耦合。答案是使用SRV记录。SRV记录是用来指向提供指定服务的服务器的主机名和端口号。k8s通过一个headless service创建SRV记录来指向pod的主机名。当一个pod想要获取SS中其它pod列表时，要做的只是触发一次SRV DNS查询，而每种语言都提供了特定的方式。对于命令行，可以通过dig查看</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">dig SRV kubia.default.svc.cluster.local</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>运维</category>
      </categories>
      <tags>
        <tag>kubernetes</tag>
      </tags>
  </entry>
  <entry>
    <title>Kubernetes - 关于存储</title>
    <url>/2021/12/09/Kubernetes%E5%88%9D%E6%8E%A2%20-%20%E5%8D%B7-kubernetes%E5%88%9D%E6%8E%A2-%E5%8D%B7/</url>
    <content><![CDATA[<p>卷只是一个概念，和Docker中的卷是一个意思，可以理解为一个存储挂载点，将pod内部的文件系统与pod外部的文件系统挂载起来，以便pod数据的持久化。</p>
<p>与Docker不同的是，Kubernetes支持非常多种类型的卷（超过二十种）</p>
<p>卷是pod容器的组成部分，并非K8S中的顶级资源，其生命周期和pod一致。可以在pod的文件系统的任何位置挂在卷。如下两张图展示了同一个pod中存在多个容器时，在有卷和没有卷时的区别，可以看到在没有卷时，由于三个容器的文件系统分离，因此都各自操作自己的目录，即使他们在功能上是重复的；有卷时，将同一个卷挂在到两个容器的文件系统中，让他们共享这一块存储，既节省空间，也省去了从一个容器向另一个容器中复制的步骤。</p>
<span id="more"></span>
<p><img src="https://gdz.oss-cn-shenzhen.aliyuncs.com/hexo/Kubernetes%20-%20%E5%8D%B7/1571731921904.png" alt="1571731921904"></p>
<p><img src="https://gdz.oss-cn-shenzhen.aliyuncs.com/hexo/Kubernetes%20-%20%E5%8D%B7/1571731875603.png" alt="1571731875603"></p>
<p>卷消失后，卷的文件可能会保持原样，并且挂载到新的卷。这取决于卷的类型。</p>
<h2 id="卷的类型"><a href="#卷的类型" class="headerlink" title="卷的类型"></a>卷的类型</h2><p>分为通用卷（k8s系统都会有的）和特殊卷（特殊用途或特殊k8s环境提供的卷）。这里仅介绍最常用的卷。</p>
<h3 id="emptyDir-创建空目录"><a href="#emptyDir-创建空目录" class="headerlink" title="emptyDir - 创建空目录"></a>emptyDir - 创建空目录</h3><p>最简单的卷类型，它就是一个空目录，容器可以向其中写入任何数据。与pod声明周期一致，pod消失时，卷的内容会丢失。</p>
<p>当pod创建时，就创建一个新的空目录，没有别的额外操作，当pod消失时，该目录随pod一起被删除，这个比较好理解，熟悉容器的应该知道，pod内新建的文件系统与宿主机是隔离的，专属于pod本身，pod删除时，它自然被删除。</p>
<p>尽管它是最简单的卷，但是其它类型的卷都是在它的基础上发展而来的。比如gitRepo卷，是创建一个空目录，再拉取git仓库的文件；其它类型的卷，是创建一个空目录，然后再将指定的目录挂载到该空目录下。</p>
<p>创建emptyDir卷时需要在pod配置文件中指定</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">apiVersion:</span> <span class="string">v1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">Pod</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">fortune</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line">  <span class="attr">containers:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="attr">image:</span> <span class="string">luksa/fortune</span></span><br><span class="line">      <span class="attr">name:</span> <span class="string">html-generator</span></span><br><span class="line">      <span class="attr">volumeMounts:</span></span><br><span class="line">        <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">html</span></span><br><span class="line">          <span class="attr">mountPath:</span> <span class="string">/var/htdocs</span></span><br><span class="line">    <span class="bullet">-</span> <span class="attr">image:</span> <span class="string">nginx:apline</span></span><br><span class="line">      <span class="attr">name:</span> <span class="string">web-server</span></span><br><span class="line">      <span class="attr">volumnMounts:</span></span><br><span class="line">        <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">html</span></span><br><span class="line">        <span class="attr">mountPath:</span> <span class="string">/usr/share/nginx/html</span></span><br><span class="line">        <span class="attr">readOnly:</span> <span class="literal">true</span></span><br><span class="line">  <span class="attr">ports:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="attr">containerPort:</span> <span class="number">80</span></span><br><span class="line">      <span class="attr">protocol:</span> <span class="string">TCP</span></span><br><span class="line">  <span class="attr">volumes:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">html</span></span><br><span class="line">      <span class="attr">emptyDir:</span> &#123;&#125;	<span class="comment"># 默认是存在磁盘上的，也可以按照如下方式配置在内存中</span></span><br><span class="line">    <span class="comment">#emptyDir:</span></span><br><span class="line">    <span class="comment">#  medium: Memory</span></span><br></pre></td></tr></table></figure>

<h3 id="gitRepo-挂载git仓库文件（弃用）"><a href="#gitRepo-挂载git仓库文件（弃用）" class="headerlink" title="gitRepo - 挂载git仓库文件（弃用）"></a>gitRepo - 挂载git仓库文件（弃用）</h3><p>来源于emtryDir卷，它是在pod启动时检出git仓库中特定版本的内容填充到目录中。</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">apiVersion:</span> <span class="string">v1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">Pod</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">gitrepo-volume-pod</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line">  <span class="attr">containers:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="attr">image:</span> <span class="string">nginx:apline</span></span><br><span class="line">      <span class="attr">name:</span> <span class="string">web-server</span></span><br><span class="line">      <span class="attr">volumnMounts:</span></span><br><span class="line">        <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">html</span></span><br><span class="line">        <span class="attr">mountPath:</span> <span class="string">/usr/share/nginx/html</span></span><br><span class="line">        <span class="attr">readOnly:</span> <span class="literal">true</span></span><br><span class="line">  <span class="attr">ports:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="attr">containerPort:</span> <span class="number">80</span></span><br><span class="line">      <span class="attr">protocol:</span> <span class="string">TCP</span></span><br><span class="line">  <span class="attr">volumes:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">html</span></span><br><span class="line">      <span class="attr">gitRepo:</span> </span><br><span class="line">        <span class="attr">repository:</span> <span class="string">http://git.dev.moumoux.com/ergedd/ergeddUtils</span></span><br><span class="line">        <span class="attr">revisioin:</span> <span class="string">master</span></span><br><span class="line">        <span class="attr">directory:</span> <span class="string">.</span> <span class="comment"># 将内容克隆到卷的根目录</span></span><br></pre></td></tr></table></figure>

<p>由于gitRepo卷是在卷创建时从git克隆一次代码，因此当git仓库更新时pod是无法同步的。要做到同步，有如下两种方式</p>
<ul>
<li>删除pod再创建</li>
<li>新建一个sidecar容器，用于同步卷中内容。Docker hub中搜索“git syc”可以看到很多相关的实现。</li>
</ul>
<h3 id="hostPath-挂载工作节点上的文件"><a href="#hostPath-挂载工作节点上的文件" class="headerlink" title="hostPath - 挂载工作节点上的文件"></a>hostPath - 挂载工作节点上的文件</h3><p>hostPath卷指向pod所属节点上的特定文件路径，同一个节点运行的两个pod通过hostPath卷可以看到相同的内容。它是一种持久存储的卷，因为节点文件系统中的内容并不会随着pod的释放而被删除。</p>
<p>它的缺点是对于pod来说不稳定，因为当发生pod调度时，可能被调度到另一个节点，这样对于这个pod来说之前写在节点上的文件就不见了。</p>
<p>使用场景</p>
<ul>
<li>只读访问节点上的文件，比如某些pod专门用于访问节点上的日志</li>
<li>有状态应用的pod，需要将数据存入节点，且pod分配稳定。比如Kubernetes的存储组件——etcd</li>
</ul>
<h3 id="网络存储卷"><a href="#网络存储卷" class="headerlink" title="网络存储卷"></a>网络存储卷</h3><p>总结一下上面说的三种卷</p>
<ul>
<li>Empty：在pod内部创建一个空目录，与pod外部无关</li>
<li>gitRepo：在pod内部创建一个空目录，然后从git仓库拉取文件到该目录，与pod外部无关</li>
<li>hostPath：在pod内部创建一个空目录，然后将其所在工作节点的文件挂载到该目录，与工作节点有关</li>
</ul>
<p>还有一个场景未覆盖到：将pod的数据存储在一个与工作节点无关的独立的位置——网络存储（NAS），比如运行一个有状态应用mongodb，然后挂载GCE磁盘：</p>
<p><img src="https://gdz.oss-cn-shenzhen.aliyuncs.com/local/image-20211209113455988.png" alt="image-20211209113455988"></p>
<p>下面展示了几种合适的卷</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 基于GCP持久盘的卷</span></span><br><span class="line"><span class="string">......</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line">  <span class="attr">volumes:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">mondodb-data</span></span><br><span class="line">      <span class="attr">gcpPersistentDisk:</span></span><br><span class="line">        <span class="attr">pdName:</span> <span class="string">mondoDb</span></span><br><span class="line">        <span class="attr">fsType:</span> <span class="string">ext4</span></span><br><span class="line">  <span class="attr">containers:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="attr">image:</span> <span class="string">nginx:apline</span></span><br><span class="line">      <span class="attr">name:</span> <span class="string">web-server</span></span><br><span class="line">      <span class="attr">volumnMounts:</span></span><br><span class="line">        <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">mondodb-data</span></span><br><span class="line">          <span class="attr">mountPath:</span> <span class="string">/usr/db</span></span><br><span class="line"><span class="string">......</span></span><br><span class="line"><span class="comment"># 基于AWS持久盘的卷</span></span><br><span class="line"><span class="string">......</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line">  <span class="attr">volumes:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">mondodb-data</span></span><br><span class="line">      <span class="attr">awsElasticBlockStore:</span></span><br><span class="line">        <span class="attr">volumnId:</span> <span class="string">my-volume</span></span><br><span class="line">        <span class="attr">fsType:</span> <span class="string">ext4</span></span><br><span class="line"><span class="string">......</span></span><br><span class="line"><span class="comment"># 基于普通共享NFS存储的卷</span></span><br><span class="line"><span class="string">......</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line">  <span class="attr">volumes:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">mondodb-data</span></span><br><span class="line">      <span class="attr">nfs:</span></span><br><span class="line">        <span class="attr">server:</span> <span class="number">1.2</span><span class="number">.3</span><span class="number">.4</span></span><br><span class="line">        <span class="attr">path:</span> <span class="string">/some/path</span></span><br><span class="line"><span class="string">......</span></span><br></pre></td></tr></table></figure>

<blockquote>
<p>当然，除了云服务厂商提供的磁盘，还可以挂载nfs卷，访问自建的网络磁盘</p>
</blockquote>
<h3 id="其它"><a href="#其它" class="headerlink" title="其它"></a>其它</h3><p>卷有很多种类型，远不止上述那些，详情参考<a href="https://kubernetes.io/zh/docs/concepts/storage/volumes/">官方手册</a>。在查看时，尤其注意几个卷类型</p>
<ul>
<li>local：挂载本地磁盘、分区或目录</li>
<li>configmap：挂载ConfigMap</li>
<li>secret：挂载Secret</li>
</ul>
<h2 id="持久卷"><a href="#持久卷" class="headerlink" title="持久卷"></a>持久卷</h2><p>上面创建的持久化的卷，需要开发人员在配置pod时配置NAS的网络存储位置，使得开发人员、pod与底层的实际存储技术和存储地址耦合了起来。不符合k8s的策略，即对开发人员将底层技术抽象、解耦。</p>
<p>于是引入了<strong>持久卷</strong>和<strong>持久卷声明</strong>的概念，即<strong>PV</strong>和<strong>PVC</strong></p>
<p>持久卷（PersistentVolume）：封装了底层的存储技术，不属于任何命名空间，整个k8s共享，属于基础资源。是k8s集群管理员需要创建的资源。</p>
<p>持久卷声明（PersistentVolumeClaim）：用于开发人员声明需要的存储容量和访问模式，在命名空间内部。是开发人员自己需要创建的资源。</p>
<blockquote>
<p>持久卷，很好理解：卷是将pod外部的存储挂载到pod的挂载方式的声明，但每次都要在创建pod时声明，持久卷，就是对这种挂在方式声明的持久化，方便直接使用。</p>
</blockquote>
<p>二者都是k8s的顶级资源，需要单独创建，且不属于任何命名空间。</p>
<blockquote>
<p>注意：引入PV和PVC整体而言是提升了复杂度，但如果一个团队有系统管理员负责维护PV和PVC，开发人员的工作会减少。</p>
</blockquote>
<p>一个常规的创建PV和PVC的流程如下</p>
<p><img src="https://gdz.oss-cn-shenzhen.aliyuncs.com/local/image-20211209120814344.png"></p>
<p>与不使用持久卷相比，好处显而易见</p>
<img src="https://gdz.oss-cn-shenzhen.aliyuncs.com/local/image-20211209122252200.png" alt="image-20211209122252200" style="zoom:80%;" />

<h3 id="创建持久卷"><a href="#创建持久卷" class="headerlink" title="创建持久卷"></a>创建持久卷</h3><figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">apiVersion:</span> <span class="string">v1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">PersistentVolume</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">mogodb-pv</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line">  <span class="attr">capacity:</span></span><br><span class="line">    <span class="attr">storage:</span> <span class="string">1Gi</span>  <span class="comment"># 声明卷的大小</span></span><br><span class="line">  <span class="attr">accessModes:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">ReadWriteOnce</span>  <span class="comment"># 可以被单个用户挂载为读写模式</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">ReadOnlyMany</span>  <span class="comment"># 可以被多个用户挂在为只读模式</span></span><br><span class="line">  <span class="attr">persistentVolumeReclaimPolicy:</span> <span class="string">Retain</span>  <span class="comment"># 当声明被释放后，PersistentVolume将会被保留</span></span><br><span class="line">  <span class="attr">gcePersistentDisk:</span></span><br><span class="line">    <span class="attr">pdName:</span> <span class="string">mongodb</span></span><br><span class="line">    <span class="string">fsType</span></span><br></pre></td></tr></table></figure>



<h3 id="创建持久卷声明"><a href="#创建持久卷声明" class="headerlink" title="创建持久卷声明"></a>创建持久卷声明</h3><figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">apiVersion:</span> <span class="string">v1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">PersistentVolumeClaim</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">mongodb-pvc</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line">  <span class="attr">resources:</span></span><br><span class="line">    <span class="attr">requests:</span></span><br><span class="line">      <span class="attr">storage:</span> <span class="string">1Gi</span>  <span class="comment"># 声明需要1Gi存储空间</span></span><br><span class="line">  <span class="attr">accessModes:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">ReadWriteOnce</span>  <span class="comment"># 声明需要的访问模式为RWO</span></span><br><span class="line">  <span class="attr">storageClassName:</span> <span class="string">&quot;&quot;</span></span><br></pre></td></tr></table></figure>

<p>该声明和上面的持久卷是相匹配的，因此使用该声明时上述持久卷会被分配。</p>
<h3 id="使用持久卷"><a href="#使用持久卷" class="headerlink" title="使用持久卷"></a>使用持久卷</h3><figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 创建pod时的关于卷的声明如下</span></span><br><span class="line"><span class="string">......</span></span><br><span class="line"><span class="attr">volumes:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">mongodb-data</span></span><br><span class="line">    <span class="attr">persistentVolumeClaim:</span></span><br><span class="line">      <span class="attr">claimValue:</span> <span class="string">mongodb-pvc</span></span><br><span class="line"><span class="string">......</span></span><br></pre></td></tr></table></figure>

<p>使用后的结构</p>
<p><img src="https://gdz.oss-cn-shenzhen.aliyuncs.com/hexo/Kubernetes%20-%20%E5%8D%B7/1571738187793.png" alt="1571738187793"></p>
<h3 id="持久卷的回收机制"><a href="#持久卷的回收机制" class="headerlink" title="持久卷的回收机制"></a>持久卷的回收机制</h3><ul>
<li>Retain: 持久卷声明被释放后依然保留该持久卷，当PVC释放它后，它保持为释放状态，无法再被新的PVC引用。并且以后可以再配置给其它pod使用（文章是这么说，但我的问题是既然无法再被新的PVC引用，新的pod又如何去用这个被释放了的持久卷呢？）。删除该持久卷的唯一方式是手动删除持久卷资源。</li>
<li>Recycle: 持久卷声明被释放后，该持久卷可以被新的PVC引用（数据应该还存在）</li>
<li>Delete: 释放后删除持久卷</li>
</ul>
<h2 id="StorageClass"><a href="#StorageClass" class="headerlink" title="StorageClass"></a>StorageClass</h2><p>上面我们看到了持久卷的用法，但它还有一个问题是需要集群管理员维护存储卷资源，这样不够科学。于是有了StorageClass这个资源。它是一个顶级资源，并且和持久卷一样，也是不属于任何命名空间的。</p>
<p>StorageClass定义了一个策略，在开发者使用PVC时创建一个新的持久卷，好处是不用管理员维护，并且与预先设置的持久卷不同，他不会耗尽持久卷存储。</p>
<h3 id="谁提供存储"><a href="#谁提供存储" class="headerlink" title="谁提供存储"></a>谁提供存储</h3><p>听起来很好，只声明存储类，不声明PV，那么最终的存储设备是谁提供呢？答案是集群供应商，这是他们提供的插件。比如下面的GCE，在minikube这样的本地集群中也有相应的插件来管理。</p>
<ul>
<li>对于云服务商，一般会根据PVC的需求创建一个云盘</li>
<li>对于minikube</li>
</ul>
<h3 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h3><figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 声明一个StorageClass，这部分一般由管理员去做</span></span><br><span class="line"><span class="attr">apiVersion:</span> <span class="string">storage.k8s.io/v1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">StorageClass</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">fast</span></span><br><span class="line"><span class="attr">provisioner:</span> <span class="string">kubernetes.io/gce-pd</span>  <span class="comment"># 这是用于配置持久卷的插件，可以指定别的插件</span></span><br><span class="line"><span class="attr">parameters:</span>  <span class="comment"># 这是传给上述插件的参数</span></span><br><span class="line">  <span class="attr">type:</span> <span class="string">pd-ssd</span></span><br><span class="line">  <span class="attr">zone:</span> <span class="string">europe-west1-b</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># PVC声明</span></span><br><span class="line"><span class="attr">apiVersion:</span> <span class="string">v1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">PersistentVolumeClaim</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">mongodb-pvc</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line">  <span class="attr">storageClassName:</span> <span class="string">fast</span></span><br><span class="line">  <span class="attr">resources:</span></span><br><span class="line">    <span class="attr">requests:</span></span><br><span class="line">      <span class="attr">storage:</span> <span class="string">100Mi</span></span><br><span class="line">    <span class="attr">accessModes:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">ReadWriteOnce</span></span><br></pre></td></tr></table></figure>

<p><img src="https://gdz.oss-cn-shenzhen.aliyuncs.com/hexo/Kubernetes%20-%20%E5%8D%B7/1571746264340.png" alt="1571746264340"></p>
<h3 id="创建没有StorageClass的PVC"><a href="#创建没有StorageClass的PVC" class="headerlink" title="创建没有StorageClass的PVC"></a>创建没有StorageClass的PVC</h3><p>创建PVC时不指定SC，会被分配一个默认的SC。通过<code>kubectl get sc</code>可以查看默认的存储类。</p>
<h3 id="强制将预先设置的PV绑定到PVC"><a href="#强制将预先设置的PV绑定到PVC" class="headerlink" title="强制将预先设置的PV绑定到PVC"></a>强制将预先设置的PV绑定到PVC</h3><figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="string">......</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">PersistentVolumeClaim</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line">  <span class="attr">storageClassName:</span> <span class="string">&quot;&quot;</span>  <span class="comment"># 将该字段设置为空，则是绑定到预先手动配置的PV，而不是动态配置的PV</span></span><br><span class="line"><span class="string">......</span></span><br></pre></td></tr></table></figure>

<h2 id="最佳实践-minikube部署Redis集群"><a href="#最佳实践-minikube部署Redis集群" class="headerlink" title="最佳实践 - minikube部署Redis集群"></a>最佳实践 - minikube部署Redis集群</h2><p>首先我们需要了解：minikube是运行在隔离环境中的，比如VM、容器。在我的macbookpro m1上，它运行在docker中，因此要先将本地文件挂载minikube中，然后才能挂载到pod。</p>
<h3 id="挂载到minikube"><a href="#挂载到minikube" class="headerlink" title="挂载到minikube"></a>挂载到minikube</h3><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">mkdir ~/.minikube/data:/data</span><br><span class="line">minikube mount ~/.minikube/data:/data</span><br></pre></td></tr></table></figure>

<h3 id="创建PV"><a href="#创建PV" class="headerlink" title="创建PV"></a>创建PV</h3><p>我们的集群有三个节点，因此需要三个数据卷，因此我们创建三个PV，分别对应三个不同的文件夹，他们每个都只能被使用一次。</p>
<p>注意这里我们没有创建PVC，因为集群是有状态应用，其PVC实配置在volumeClaimTemplates中的，所以后面再配。</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">apiVersion:</span> <span class="string">v1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">PersistentVolume</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">redis-pv1</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line">  <span class="attr">capacity:</span></span><br><span class="line">    <span class="attr">storage:</span> <span class="string">10Mi</span></span><br><span class="line">  <span class="attr">volumeMode:</span> <span class="string">Filesystem</span></span><br><span class="line">  <span class="attr">accessModes:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">ReadWriteOnce</span></span><br><span class="line">  <span class="attr">persistentVolumeReclaimPolicy:</span> <span class="string">Retain</span></span><br><span class="line">  <span class="attr">local:</span></span><br><span class="line">    <span class="attr">path:</span> <span class="string">/data/redis-data-1</span></span><br><span class="line">  <span class="attr">storageClassName:</span> <span class="string">&quot;&quot;</span></span><br><span class="line">  <span class="attr">nodeAffinity:</span></span><br><span class="line">    <span class="attr">required:</span></span><br><span class="line">      <span class="attr">nodeSelectorTerms:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="attr">matchExpressions:</span></span><br><span class="line">        <span class="bullet">-</span> <span class="attr">key:</span> <span class="string">kubernetes.io/hostname</span></span><br><span class="line">          <span class="attr">operator:</span> <span class="string">In</span></span><br><span class="line">          <span class="attr">values:</span></span><br><span class="line">          <span class="bullet">-</span> <span class="string">minikube</span></span><br><span class="line"><span class="meta">---</span></span><br><span class="line"><span class="attr">apiVersion:</span> <span class="string">v1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">PersistentVolume</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">redis-pv2</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line">  <span class="attr">capacity:</span></span><br><span class="line">    <span class="attr">storage:</span> <span class="string">10Mi</span></span><br><span class="line">  <span class="attr">volumeMode:</span> <span class="string">Filesystem</span></span><br><span class="line">  <span class="attr">accessModes:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">ReadWriteOnce</span></span><br><span class="line">  <span class="attr">persistentVolumeReclaimPolicy:</span> <span class="string">Retain</span></span><br><span class="line">  <span class="attr">local:</span></span><br><span class="line">    <span class="attr">path:</span> <span class="string">/data/redis-data-2</span></span><br><span class="line">  <span class="attr">storageClassName:</span> <span class="string">&quot;&quot;</span></span><br><span class="line">  <span class="attr">nodeAffinity:</span></span><br><span class="line">    <span class="attr">required:</span></span><br><span class="line">      <span class="attr">nodeSelectorTerms:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="attr">matchExpressions:</span></span><br><span class="line">        <span class="bullet">-</span> <span class="attr">key:</span> <span class="string">kubernetes.io/hostname</span></span><br><span class="line">          <span class="attr">operator:</span> <span class="string">In</span></span><br><span class="line">          <span class="attr">values:</span></span><br><span class="line">          <span class="bullet">-</span> <span class="string">minikube</span></span><br><span class="line"><span class="meta">---</span></span><br><span class="line"><span class="attr">apiVersion:</span> <span class="string">v1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">PersistentVolume</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">redis-pv3</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line">  <span class="attr">capacity:</span></span><br><span class="line">    <span class="attr">storage:</span> <span class="string">10Mi</span></span><br><span class="line">  <span class="attr">volumeMode:</span> <span class="string">Filesystem</span></span><br><span class="line">  <span class="attr">accessModes:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">ReadWriteOnce</span></span><br><span class="line">  <span class="attr">persistentVolumeReclaimPolicy:</span> <span class="string">Retain</span></span><br><span class="line">  <span class="attr">local:</span></span><br><span class="line">    <span class="attr">path:</span> <span class="string">/data/redis-data-3</span></span><br><span class="line">  <span class="attr">storageClassName:</span> <span class="string">&quot;&quot;</span></span><br><span class="line">  <span class="attr">nodeAffinity:</span></span><br><span class="line">    <span class="attr">required:</span></span><br><span class="line">      <span class="attr">nodeSelectorTerms:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="attr">matchExpressions:</span></span><br><span class="line">        <span class="bullet">-</span> <span class="attr">key:</span> <span class="string">kubernetes.io/hostname</span></span><br><span class="line">          <span class="attr">operator:</span> <span class="string">In</span></span><br><span class="line">          <span class="attr">values:</span></span><br><span class="line">          <span class="bullet">-</span> <span class="string">minikube</span></span><br></pre></td></tr></table></figure>

<h3 id="创建Redis集群配置文件"><a href="#创建Redis集群配置文件" class="headerlink" title="创建Redis集群配置文件"></a>创建Redis集群配置文件</h3><p>三个节点，每个节点的配置文件都长得一样</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">apiVersion:</span> <span class="string">v1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">ConfigMap</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">redis-cluster</span></span><br><span class="line"><span class="attr">data:</span></span><br><span class="line">  <span class="attr">update.sh:</span> <span class="string">|</span></span><br><span class="line"><span class="string">    #!/bin/sh</span></span><br><span class="line"><span class="string">    REDIS_NODES=&quot;/data/nodes.conf&quot;</span></span><br><span class="line"><span class="string">    sed -i -e &quot;/myself/ s/[0-9]\&#123;1,3\&#125;\.[0-9]\&#123;1,3\&#125;\.[0-9]\&#123;1,3\&#125;\.[0-9]\&#123;1,3\&#125;/$&#123;POD_IP&#125;/&quot; $&#123;REDIS_NODES&#125;</span></span><br><span class="line"><span class="string">    exec &quot;$@&quot;</span></span><br><span class="line"><span class="string"></span>  <span class="attr">redis.conf:</span> <span class="string">|+</span></span><br><span class="line"><span class="string">    bind 0.0.0.0</span></span><br><span class="line"><span class="string">    cluster-enabled yes</span></span><br><span class="line"><span class="string">    cluster-require-full-coverage no</span></span><br><span class="line"><span class="string">    cluster-node-timeout 30000</span></span><br><span class="line"><span class="string">    cluster-config-file /data/nodes.conf</span></span><br><span class="line"><span class="string">    cluster-migration-barrier 1</span></span><br><span class="line"><span class="string">    appendonly yes</span></span><br><span class="line"><span class="string">    protected-mode no</span></span><br></pre></td></tr></table></figure>

<h3 id="创建网络"><a href="#创建网络" class="headerlink" title="创建网络"></a>创建网络</h3><figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">apiVersion:</span> <span class="string">v1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">Service</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">redis-cluster</span></span><br><span class="line">  <span class="attr">labels:</span></span><br><span class="line">    <span class="attr">app:</span> <span class="string">redis</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line">  <span class="attr">ports:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">redis-port</span></span><br><span class="line">    <span class="attr">port:</span> <span class="number">6379</span></span><br><span class="line">  <span class="attr">clusterIP:</span> <span class="string">None</span></span><br><span class="line">  <span class="attr">selector:</span></span><br><span class="line">    <span class="attr">app:</span> <span class="string">redis-cluster</span></span><br></pre></td></tr></table></figure>

<h3 id="创建集群"><a href="#创建集群" class="headerlink" title="创建集群"></a>创建集群</h3><p>这是一个StatefulSet，注意volumeClaimTemplates，它指定的存储大小和上面的PV要匹配。</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">apiVersion:</span> <span class="string">apps/v1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">StatefulSet</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">redis-cluster</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line">  <span class="attr">serviceName:</span> <span class="string">redis-cluster</span></span><br><span class="line">  <span class="attr">replicas:</span> <span class="number">3</span></span><br><span class="line">  <span class="attr">selector:</span></span><br><span class="line">    <span class="attr">matchLabels:</span></span><br><span class="line">      <span class="attr">app:</span> <span class="string">redis-cluster</span></span><br><span class="line">  <span class="attr">template:</span></span><br><span class="line">    <span class="attr">metadata:</span></span><br><span class="line">      <span class="attr">labels:</span></span><br><span class="line">        <span class="attr">app:</span> <span class="string">redis-cluster</span></span><br><span class="line">    <span class="attr">spec:</span></span><br><span class="line">      <span class="attr">containers:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">redis</span></span><br><span class="line">        <span class="attr">image:</span> <span class="string">redis:6.2.1-alpine</span></span><br><span class="line">        <span class="attr">ports:</span></span><br><span class="line">        <span class="bullet">-</span> <span class="attr">containerPort:</span> <span class="number">6379</span></span><br><span class="line">          <span class="attr">name:</span> <span class="string">client</span></span><br><span class="line">        <span class="bullet">-</span> <span class="attr">containerPort:</span> <span class="number">16379</span></span><br><span class="line">          <span class="attr">name:</span> <span class="string">gossip</span></span><br><span class="line">        <span class="attr">command:</span> [<span class="string">&quot;/conf/update.sh&quot;</span>, <span class="string">&quot;redis-server&quot;</span>, <span class="string">&quot;/conf/redis.conf&quot;</span>]</span><br><span class="line">        <span class="attr">env:</span></span><br><span class="line">        <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">POD_IP</span></span><br><span class="line">          <span class="attr">valueFrom:</span></span><br><span class="line">            <span class="attr">fieldRef:</span></span><br><span class="line">              <span class="attr">fieldPath:</span> <span class="string">status.podIP</span></span><br><span class="line">        <span class="attr">volumeMounts:</span></span><br><span class="line">        <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">conf</span></span><br><span class="line">          <span class="attr">mountPath:</span> <span class="string">/conf</span></span><br><span class="line">          <span class="attr">readOnly:</span> <span class="literal">false</span></span><br><span class="line">        <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">data</span></span><br><span class="line">          <span class="attr">mountPath:</span> <span class="string">/data</span></span><br><span class="line">          <span class="attr">readOnly:</span> <span class="literal">false</span></span><br><span class="line">      <span class="attr">volumes:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">conf</span></span><br><span class="line">        <span class="attr">configMap:</span></span><br><span class="line">          <span class="attr">name:</span> <span class="string">redis-cluster</span></span><br><span class="line">          <span class="attr">defaultMode:</span> <span class="number">0755</span></span><br><span class="line">  <span class="attr">volumeClaimTemplates:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">metadata:</span></span><br><span class="line">      <span class="attr">name:</span> <span class="string">data</span></span><br><span class="line">    <span class="attr">spec:</span></span><br><span class="line">      <span class="attr">accessModes:</span> [ <span class="string">&quot;ReadWriteOnce&quot;</span> ]</span><br><span class="line">      <span class="attr">resources:</span></span><br><span class="line">        <span class="attr">requests:</span></span><br><span class="line">          <span class="attr">storage:</span> <span class="string">10Mi</span></span><br><span class="line">      <span class="attr">storageClassName:</span> <span class="string">&quot;&quot;</span></span><br></pre></td></tr></table></figure>

<h3 id="跑起来"><a href="#跑起来" class="headerlink" title="跑起来"></a>跑起来</h3><p>可以发现它们确实跑起来了</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">zouguodong@zouguodongdeMBP redis-cluster % kubectl get statefulset</span><br><span class="line">NAME            READY   AGE</span><br><span class="line">redis-cluster   3/3     9m48s</span><br><span class="line"></span><br><span class="line">zouguodong@zouguodongdeMBP redis-cluster % kubectl get pods</span><br><span class="line">NAME              READY   STATUS    RESTARTS   AGE</span><br><span class="line">redis-cluster-0   1/1     Running   0          9m53s</span><br><span class="line">redis-cluster-1   1/1     Running   0          9m34s</span><br><span class="line">redis-cluster-2   1/1     Running   0          9m31s</span><br><span class="line"></span><br><span class="line">zouguodong@zouguodongdeMBP redis-cluster % kubectl get pvc</span><br><span class="line">NAME                   STATUS   VOLUME      CAPACITY   ACCESS MODES   STORAGECLASS   AGE</span><br><span class="line">data-redis-cluster-0   Bound    redis-pv1   10Mi       RWO                           10m</span><br><span class="line">data-redis-cluster-1   Bound    redis-pv2   10Mi       RWO                           9m42s</span><br><span class="line">data-redis-cluster-2   Bound    redis-pv3   10Mi       RWO                           9m39s</span><br><span class="line"></span><br><span class="line">zouguodong@zouguodongdeMBP redis-cluster % kubectl get pv</span><br><span class="line">NAME        CAPACITY   ACCESS MODES   RECLAIM POLICY   STATUS   CLAIM                          STORAGECLASS   REASON   AGE</span><br><span class="line">redis-pv1   10Mi       RWO            Retain           Bound    default/data-redis-cluster-0                           12m</span><br><span class="line">redis-pv2   10Mi       RWO            Retain           Bound    default/data-redis-cluster-1                           12m</span><br><span class="line">redis-pv3   10Mi       RWO            Retain           Bound    default/data-redis-cluster-2                           12m</span><br></pre></td></tr></table></figure>

<p>可以查看一个PVC的yaml输出，可以发现它使用了volumeName强绑定了一个pv。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">zouguodong@zouguodongdeMBP redis-cluster % kubectl get pvc data-redis-cluster-0 -o yaml</span><br><span class="line">apiVersion: v1</span><br><span class="line">kind: PersistentVolumeClaim</span><br><span class="line">metadata:</span><br><span class="line">  annotations:</span><br><span class="line">    pv.kubernetes.io/bind-completed: &quot;yes&quot;</span><br><span class="line">    pv.kubernetes.io/bound-by-controller: &quot;yes&quot;</span><br><span class="line">  creationTimestamp: &quot;2021-12-09T06:42:12Z&quot;</span><br><span class="line">  finalizers:</span><br><span class="line">  - kubernetes.io/pvc-protection</span><br><span class="line">  labels:</span><br><span class="line">    app: redis-cluster</span><br><span class="line">  name: data-redis-cluster-0</span><br><span class="line">  namespace: default</span><br><span class="line">  resourceVersion: &quot;20518&quot;</span><br><span class="line">  uid: ceedaaf5-704b-4cfa-a91b-66fb2e6793b1</span><br><span class="line">spec:</span><br><span class="line">  accessModes:</span><br><span class="line">  - ReadWriteOnce</span><br><span class="line">  resources:</span><br><span class="line">    requests:</span><br><span class="line">      storage: 10Mi</span><br><span class="line">  storageClassName: &quot;&quot;</span><br><span class="line">  volumeMode: Filesystem</span><br><span class="line"><span class="meta">  #</span><span class="bash"> 这里强绑定了，也是StatefulSet的特点</span></span><br><span class="line">  volumeName: redis-pv1</span><br><span class="line">status:</span><br><span class="line">  accessModes:</span><br><span class="line">  - ReadWriteOnce</span><br><span class="line">  capacity:</span><br><span class="line">    storage: 10Mi</span><br><span class="line">  phase: Bound</span><br></pre></td></tr></table></figure>

<h3 id="后续"><a href="#后续" class="headerlink" title="后续"></a>后续</h3><p>到这里，集群建立还没完成，因为现在每个集群都是主节点，还没构成一个集群。如果要构成一个完整的集群，需要执行更多操作，具体可参考<a href="https://github.com/Lancger/opsfull/blob/master/redis/K8s%E4%B8%8A%E8%BF%90%E8%A1%8CRedis%E9%9B%86%E7%BE%A4%E6%8C%87%E5%8D%97.md#4%E5%88%9B%E5%BB%BAheadless-service">这篇文章</a></p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>重点是理解几个概念</p>
<ul>
<li>卷Volume</li>
<li>PV</li>
<li>PVC</li>
<li>StorageClass</li>
</ul>
<p>此外，本文未涉及的一些概念同样重要，读者可以通过官方手册学习</p>
<ul>
<li>CSI：Kubernetes定义的容器存储标准接口，就像CRI（容器运行标准接口）</li>
<li>projected卷：即将多个卷来源合并成一个卷，目前支持secret、downwardAPI、configMap、serviceAccountToken</li>
<li>卷克隆：从已有的卷克隆</li>
<li>临时卷：即不需要保存的卷</li>
<li>卷快照：见名知意</li>
</ul>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ul>
<li>首先教你入门——《Kubernetes in Action》</li>
<li>然后必须看——<a href="https://kubernetes.io/zh/docs/concepts/storage/">官方手册</a></li>
</ul>
]]></content>
      <categories>
        <category>运维</category>
      </categories>
      <tags>
        <tag>kubernetes</tag>
      </tags>
  </entry>
  <entry>
    <title>Kubernetes初探 - 概览</title>
    <url>/2019/10/21/Kubernetes%E5%88%9D%E6%8E%A2%20-%20%E6%A6%82%E8%A7%88-kubernetes%E5%88%9D%E6%8E%A2-%E6%A6%82%E8%A7%88/</url>
    <content><![CDATA[<p>Kubernetes是一个软件系统， 允许部署和管理<strong>容器化</strong>的应用。使用该系统，用户不需要关心如何维护实体集群关系，也不用徒手部署应用，不必烦恼应用的运行状态，只需要按照系统说明编写描述信息，k8s会按照描述信息自动维护整个集群。对用户，k8s将维护和部署集群化应用的复杂过程隐藏起来并进行了抽象，使得开发者能够更加专注于应用的开发上。同时减轻了运维人员的工作压力</p>
<span id="more"></span>

<h2 id="工作原理"><a href="#工作原理" class="headerlink" title="工作原理"></a>工作原理</h2><p>大致工作原理如下：</p>
<ol>
<li>用户开发自己的应用， 完成后打包成容器镜像，比如Docker，发布到容器注册平台</li>
<li>用户编写应用描述信息，说明应用需要以怎样的组合方式进行运行</li>
<li>通过kubernetes控制面板将描述信息传入。kubernetes节点从容器注册平台获取用户开始发布的镜像，进行运行。</li>
<li>整个运行期间，kubernetes持续监控应用的部署状态是否与描述文件中的一致，如果单个节点或实例宕机了，则会自动重启该节点，从而保持应用的活跃。</li>
</ol>
<h2 id="kubernetes优势"><a href="#kubernetes优势" class="headerlink" title="kubernetes优势"></a>kubernetes优势</h2><ul>
<li>简化应用部署</li>
<li>更好滴利用硬件</li>
<li>健康检查和自我修复</li>
<li>自动扩容</li>
</ul>
<h2 id="POD"><a href="#POD" class="headerlink" title="POD"></a>POD</h2><p>对于我们来说，在Kubernetes中运行的最小单位是容器，即Docker镜像。但对于Kubernetes来说却不是这样的，它并不直接处理单个容器，而是处理多个共存容器的理念，这组容器叫做POD</p>
<p>一个POD的一组紧密相关的容器，他们总是同时运行在一个节点上，以及同一个linux命名空间中。</p>
<p>每个POD就像一台独立的逻辑机器，拥有自己的IP、主机名、进程等，运行一个独立的应用程序。</p>
<p><img src="https://gdz.oss-cn-shenzhen.aliyuncs.com/hexo/Kubernetes%20-%20%E6%A6%82%E8%A7%88/1571540756807.png" alt="1571540756807"></p>
<h3 id="注意"><a href="#注意" class="headerlink" title="注意"></a>注意</h3><p>由于Kubernetes的最小单位是POD，因此并不能列出单个容器，只能列出POD</p>
<h2 id="应用发布到K8S完整流程"><a href="#应用发布到K8S完整流程" class="headerlink" title="应用发布到K8S完整流程"></a>应用发布到K8S完整流程</h2><p>下面展示了一个完整的容器发布到K8S的流程</p>
<p><img src="https://gdz.oss-cn-shenzhen.aliyuncs.com/hexo/Kubernetes%20-%20%E6%A6%82%E8%A7%88/1571540922449.png" alt="1571540922449"></p>
<h2 id="服务"><a href="#服务" class="headerlink" title="服务"></a>服务</h2><p>我们的应用被打包成镜像，运行在容器中，容器在K8S中位于POD中，要访问我们的应用，就要通过IP地址访问POD，但这个IP地址是集群内部的，无法通过外网访问。</p>
<p>要访问到POD，就要通过服务对象将其公开。可以创建一个外部的负载均衡服务，通过负载均衡的公共IP访问POD。</p>
<p>服务存在的另一个关键原因，在于POD的存在可能是短暂的，可能因为K8S内部资源调配，使得一个POD被迁移到另一个节点，也可能一个POD因为某种原因挂掉或消失，存在一个稳定的服务，不管POD如何变化，都能将用户的访问转发给目标POD。</p>
<h2 id="服务、POD、ReplicationController的关系"><a href="#服务、POD、ReplicationController的关系" class="headerlink" title="服务、POD、ReplicationController的关系"></a>服务、POD、ReplicationController的关系</h2><p><img src="https://gdz.oss-cn-shenzhen.aliyuncs.com/hexo/Kubernetes%20-%20%E6%A6%82%E8%A7%88/1571541562099.png" alt="1571541562099"></p>
<p>可以看到，我们是以POD为中心的，服务用于暴露外部IP给用户，ReplicationController用于在POD挂掉时马上重启一个新的POD。</p>
<p>如下展示了当存在多个POD时候的状态</p>
<p><img src="https://gdz.oss-cn-shenzhen.aliyuncs.com/hexo/Kubernetes%20-%20%E6%A6%82%E8%A7%88/1571542030561.png" alt="1571542030561"></p>
]]></content>
      <categories>
        <category>运维</category>
      </categories>
      <tags>
        <tag>kubernetes</tag>
      </tags>
  </entry>
  <entry>
    <title>Kubernetes初探 - 访问pod元数据及其它资源</title>
    <url>/2019/10/26/Kubernetes%E5%88%9D%E6%8E%A2%20-%20%E8%AE%BF%E9%97%AEpod%E5%85%83%E6%95%B0%E6%8D%AE%E5%8F%8A%E5%85%B6%E5%AE%83%E8%B5%84%E6%BA%90-kubernetes%E5%88%9D%E6%8E%A2-%E8%AE%BF%E9%97%AEpod%E5%85%83%E6%95%B0%E6%8D%AE%E5%8F%8A%E5%85%B6%E5%AE%83%E8%B5%84%E6%BA%90/</url>
    <content><![CDATA[<p>对于特殊的pod，比如系统监控应用，知晓应用运行环境的各项参数是很常见的功能。Kubernetes对此也提供了很好的支持，用户可以通过环境变量、文件、API等多种方式获取到相关数据。</p>
<span id="more"></span>

<h2 id="通过Downward-API"><a href="#通过Downward-API" class="headerlink" title="通过Downward API"></a>通过Downward API</h2><p>想要获得预先无法知晓的数据，比如POD的IP、主机名等，可以通过Downward API获取。虽然名叫API，但它允许我们通过环境变量或者downward卷传递pod中的数据，而不是通过发送请求的方式。其结构如下</p>
<p><img src="https://gdz.oss-cn-shenzhen.aliyuncs.com/hexo/Kubernetes%20-%20%E8%AE%BF%E9%97%AEpod%E5%85%83%E6%95%B0%E6%8D%AE%E5%8F%8A%E5%85%B6%E5%AE%83%E8%B5%84%E6%BA%90/image-20191026095824633.png" alt="image-20191026095824633"></p>
<p>通过Downward API，我们可以获得如下pod数据</p>
<ul>
<li>名称</li>
<li>IP</li>
<li>命名空间</li>
<li>节点名称</li>
<li>所属服务账户名称</li>
<li>每个容器请求的CPU和内存</li>
<li>每个容器可以使用的CPU和内存的限制</li>
<li>标签和注解</li>
</ul>
<h3 id="环境变量"><a href="#环境变量" class="headerlink" title="环境变量"></a>环境变量</h3><p>通过如下方式将其暴露在环境变量中</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="string">......</span></span><br><span class="line"><span class="comment"># 这里接着一个container项的env</span></span><br><span class="line"><span class="attr">env:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">POD_NAME</span></span><br><span class="line">    <span class="attr">valueFrom:</span></span><br><span class="line">      <span class="attr">fieldRef:</span></span><br><span class="line">        <span class="attr">fieldPath:</span> <span class="string">metadata.name</span></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">POD_NAMESPACE</span></span><br><span class="line">    <span class="attr">valueFrom:</span></span><br><span class="line">      <span class="attr">fieldRef:</span></span><br><span class="line">        <span class="attr">fieldPath:</span> <span class="string">metadata.namespace</span></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">POD_IP</span></span><br><span class="line">    <span class="attr">valueFrom:</span></span><br><span class="line">      <span class="attr">fieldRef:</span></span><br><span class="line">        <span class="attr">fieldPath:</span> <span class="string">metadata.podIP</span></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">NODE_NAME</span></span><br><span class="line">    <span class="attr">valueFrom:</span></span><br><span class="line">      <span class="attr">fieldRef:</span></span><br><span class="line">        <span class="attr">fieldPath:</span> <span class="string">spec.nodeName</span></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">SERVICE_ACCOUNT</span></span><br><span class="line">    <span class="attr">valueFrom:</span></span><br><span class="line">      <span class="attr">fieldRef:</span></span><br><span class="line">        <span class="attr">fieldPath:</span> <span class="string">spec.serviceAccountName</span></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">CONTAINER_CPU_REQUEST_MILLICORES</span></span><br><span class="line">    <span class="attr">valueFrom:</span></span><br><span class="line">      <span class="attr">resourceFieldRef:</span></span><br><span class="line">        <span class="attr">resource:</span> <span class="string">requests.cpu</span></span><br><span class="line">        <span class="attr">divisor:</span> <span class="string">1m</span></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">CONTAINER_MEMORY_LIMIT_KIBIBYTES</span></span><br><span class="line">    <span class="attr">valueFrom:</span></span><br><span class="line">      <span class="attr">resourceFieldRef:</span></span><br><span class="line">        <span class="attr">resource:</span> <span class="string">limits.memory</span></span><br><span class="line">        <span class="attr">divisor:</span> <span class="string">1Ki</span></span><br></pre></td></tr></table></figure>

<p>其实对应如下图所示</p>
<p><img src="https://gdz.oss-cn-shenzhen.aliyuncs.com/hexo/Kubernetes%20-%20%E8%AE%BF%E9%97%AEpod%E5%85%83%E6%95%B0%E6%8D%AE%E5%8F%8A%E5%85%B6%E5%AE%83%E8%B5%84%E6%BA%90/image-20191026101622624.png" alt="image-20191026101622624"></p>
<h3 id="downward卷"><a href="#downward卷" class="headerlink" title="downward卷"></a>downward卷</h3><p>挂载的方式如下</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 如下接着container标签写</span></span><br><span class="line">      <span class="attr">volumeMounts:</span></span><br><span class="line">        <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">downward</span></span><br><span class="line">          <span class="attr">mountPath:</span> <span class="string">/etc/downward</span></span><br><span class="line">   <span class="attr">volumes:</span></span><br><span class="line">     <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">downward</span></span><br><span class="line">       <span class="attr">downwardAPI:</span></span><br><span class="line">         <span class="attr">items:</span></span><br><span class="line">           <span class="bullet">-</span> <span class="attr">path:</span> <span class="string">&quot;podName&quot;</span></span><br><span class="line">             <span class="attr">fieldRef:</span></span><br><span class="line">               <span class="attr">fieldPath:</span> <span class="string">metadata.name</span></span><br><span class="line">            <span class="string">......</span> <span class="comment"># 接下来写的和环境变量中的配置类似，这里不再赘述</span></span><br></pre></td></tr></table></figure>

<p>完成配置后结果如下</p>
<p><img src="image-20191026102038019.png" alt="image-20191026102038019"></p>
<h2 id="通过Kubernetes-API"><a href="#通过Kubernetes-API" class="headerlink" title="通过Kubernetes API"></a>通过Kubernetes API</h2><h3 id="探究k8s-API"><a href="#探究k8s-API" class="headerlink" title="探究k8s API"></a>探究k8s API</h3><p>可以像正常那样通过k8s提供的restful API访问，但如下图所示，这些地址都是采用https传输，因此跟他们交互也不是意见特别容易的事情。</p>
<p><img src="https://gdz.oss-cn-shenzhen.aliyuncs.com/hexo/Kubernetes%20-%20%E8%AE%BF%E9%97%AEpod%E5%85%83%E6%95%B0%E6%8D%AE%E5%8F%8A%E5%85%B6%E5%AE%83%E8%B5%84%E6%BA%90/image-20191026103024214.png" alt="image-20191026103024214"></p>
<p>为此，k8s提供了代理。运行如下命令可启动一个代理，该代理替我们处理好了一切，我们只需要访问它即可。</p>
<p><img src="https://gdz.oss-cn-shenzhen.aliyuncs.com/hexo/Kubernetes%20-%20%E8%AE%BF%E9%97%AEpod%E5%85%83%E6%95%B0%E6%8D%AE%E5%8F%8A%E5%85%B6%E5%AE%83%E8%B5%84%E6%BA%90/image-20191026103637438.png" alt="image-20191026103637438"></p>
<p>访问该代理地址，可以得到所有可用的API地址</p>
<p><img src="https://gdz.oss-cn-shenzhen.aliyuncs.com/hexo/Kubernetes%20-%20%E8%AE%BF%E9%97%AEpod%E5%85%83%E6%95%B0%E6%8D%AE%E5%8F%8A%E5%85%B6%E5%AE%83%E8%B5%84%E6%BA%90/image-20191026103733430.png" alt="image-20191026103733430"></p>
<p>访问这些地址中的一个，可以得到进一步的地址</p>
<p><img src="https://gdz.oss-cn-shenzhen.aliyuncs.com/hexo/Kubernetes%20-%20%E8%AE%BF%E9%97%AEpod%E5%85%83%E6%95%B0%E6%8D%AE%E5%8F%8A%E5%85%B6%E5%AE%83%E8%B5%84%E6%BA%90/image-20191026103807750.png" alt="image-20191026103807750"></p>
<p>再访问这些地址，可以得到最终结果</p>
<p><img src="https://gdz.oss-cn-shenzhen.aliyuncs.com/hexo/Kubernetes%20-%20%E8%AE%BF%E9%97%AEpod%E5%85%83%E6%95%B0%E6%8D%AE%E5%8F%8A%E5%85%B6%E5%AE%83%E8%B5%84%E6%BA%90/image-20191026103845268.png" alt="image-20191026103845268"></p>
<h3 id="从POD内部访问API"><a href="#从POD内部访问API" class="headerlink" title="从POD内部访问API"></a>从POD内部访问API</h3><p>上面仅介绍了从本机访问API，这里介绍如何在POD内部访问。</p>
<p>POD中就没有kubectl可用了，于是只有老老实实进行授权和验证操作，主要有以下几个步骤。</p>
<ul>
<li><p>确定访问ip和端口</p>
<p>通过查看POD的<code>KUBERNETES_SERVICE</code>环境变量可得到ip地址和端口</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">root@curl:/<span class="comment"># env | grep KUBERNETES_SERVICE</span></span><br><span class="line">KUBERNETES_SERVICE_PORT=443</span><br><span class="line">KUBERNETES_SERVICE_HOST=10.107.0.1</span><br><span class="line">KUBERNETES_SERVICE_PORT_HTTPS=443</span><br></pre></td></tr></table></figure>

<p>又由于每个服务都会自动获得一个DNS入口，因此也可以直接访问<a href="https://kubernetes/">https://kubernetes</a></p>
</li>
<li><p>安全验证</p>
<p>通过运行<code>kubectl describe pod curl</code>可以看到该pod中有挂载了一个secret卷，它是创建pod时候自动创建的。</p>
<p><img src="https://gdz.oss-cn-shenzhen.aliyuncs.com/hexo/Kubernetes%20-%20%E8%AE%BF%E9%97%AEpod%E5%85%83%E6%95%B0%E6%8D%AE%E5%8F%8A%E5%85%B6%E5%AE%83%E8%B5%84%E6%BA%90/image-20191026110236335.png" alt="image-20191026110236335"></p>
<p>访问改地址，可以看到如下结构</p>
<p><img src="https://gdz.oss-cn-shenzhen.aliyuncs.com/hexo/Kubernetes%20-%20%E8%AE%BF%E9%97%AEpod%E5%85%83%E6%95%B0%E6%8D%AE%E5%8F%8A%E5%85%B6%E5%AE%83%E8%B5%84%E6%BA%90/image-20191026110731625.png" alt="image-20191026110731625"></p>
<p>其中ca.crt是CA证书，用于客户端验证服务端身份；token用于客户端发送请求时加到Authorization请求头中，用户服务端验证客户端请求；namespace则是客户端执行增删改查时需要传递的命名空间信息。</p>
<p>于是我们可以通过如下命令访问API</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 将证书挂载到环境变量</span></span><br><span class="line">export CURL_CA_BUNDLE=/var/run/secrets/kubernetes.io/serviceaccount/ca.crt</span><br><span class="line"><span class="meta">#</span><span class="bash"> 将token挂载到环境变量</span></span><br><span class="line">export TOKEN=/var/run/secrets/kubernetes.io/serviceaccount/token</span><br><span class="line"><span class="meta">#</span><span class="bash"> 带上头访问即可</span></span><br><span class="line">curl -H &quot;Authorization: Bearer $TOKEN&quot; https://kubernetes</span><br></pre></td></tr></table></figure></li>
<li><p>使用namespace</p>
<p>如上面所说，namespace用于增删改查时的指定，这里展示</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">export NS=/var/run/secrets/kubernetes.io/serviceaccount/namespace</span><br><span class="line">curl -H &quot;Authorization: Bearer $TOKEN&quot; https://kubernetes/api/v1/namespace/$NS/pods</span><br></pre></td></tr></table></figure></li>
</ul>
<p>下面展示了三者之间的关系</p>
<p><img src="https://gdz.oss-cn-shenzhen.aliyuncs.com/hexo/Kubernetes%20-%20%E8%AE%BF%E9%97%AEpod%E5%85%83%E6%95%B0%E6%8D%AE%E5%8F%8A%E5%85%B6%E5%AE%83%E8%B5%84%E6%BA%90/image-20191026112434344.png" alt="image-20191026112434344"></p>
<h3 id="ambassador容器"><a href="#ambassador容器" class="headerlink" title="ambassador容器"></a>ambassador容器</h3><p>上述步骤实在是太麻烦了，这里介绍一个简单的方法：ambassador容器。其原理是在同一个pod中新建一个应用，它依旧使用绑定的Secret信息与k8s API进行安全通信，但暴露HTTP接口给我们的主应用访问，使得主应用访问时不用每次都指定那些安全参数。</p>
<p>其建立方式如下</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="string">......</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line">  <span class="attr">container:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">main</span></span><br><span class="line">      <span class="string">......</span></span><br><span class="line">    <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">ambassador</span></span><br><span class="line">      <span class="attr">image:</span> <span class="string">luksa/kubectl-proxy:1.6.2</span>  <span class="comment"># ambassador容器，和运行kubectl proxy命令一样的效果。</span></span><br></pre></td></tr></table></figure>

<p>这样建立后，由于pod内各应用共享ip，应用之间又是http通信，因此可以直接通过<code>localhost:8001</code>的方式直接访问。</p>
<p><img src="https://gdz.oss-cn-shenzhen.aliyuncs.com/hexo/Kubernetes%20-%20%E8%AE%BF%E9%97%AEpod%E5%85%83%E6%95%B0%E6%8D%AE%E5%8F%8A%E5%85%B6%E5%AE%83%E8%B5%84%E6%BA%90/image-20191026113239941.png" alt="image-20191026113239941"></p>
<h3 id="客户端库访问"><a href="#客户端库访问" class="headerlink" title="客户端库访问"></a>客户端库访问</h3><p>如果有复杂的访问请求，可以使用各种语言的访问库，可以网上找找Kubernetes API客户端库。</p>
<p>如果是想要概览研究API，强烈推荐Swagger UI的方式访问，默认该服务没有开启，但可手动启动。</p>
]]></content>
      <categories>
        <category>运维</category>
      </categories>
      <tags>
        <tag>kubernetes</tag>
      </tags>
  </entry>
  <entry>
    <title>Kubernetes应用资源管理实践</title>
    <url>/2022/04/25/Kubernetes%E5%BA%94%E7%94%A8%E8%B5%84%E6%BA%90%E7%AE%A1%E7%90%86%E5%AE%9E%E8%B7%B5/</url>
    <content><![CDATA[<blockquote>
<p> 文章描述由一个问题引起的解决方案思路的探究以及最终的实践，具有借鉴参考意义。</p>
</blockquote>
<span id="more"></span>

<h1 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h1><p>我们的使用场景是应用多、访问量小，细化一下</p>
<ul>
<li>应用数量接近20</li>
<li>如果每个pod都设置replicas为2，则需要40个pod</li>
<li>日常稳定运行时每个pod占用10m核、500Mi左右。40个pod也不过占用400m核、20Gi</li>
<li>目前我们使用两台2c16g配置ECS作为worker节点，用于应对日常需求。外加三个ECI节点，用于ECS资源不足时的扩展。</li>
</ul>
<p>时间下来有如下问题</p>
<ul>
<li>希望设置2个副本的应用pod均匀地分布在两个worker节点，于是设置强制性的应用反亲和（和自己反亲和），但在滚动升级时因为临时出现超过2个副本而报资源不足</li>
<li>对ECI节点使用不熟悉，拿不准pod什么时候会被分配上去</li>
<li>应用启动慢，60s往上</li>
</ul>
<h1 id="应用分布标准方案"><a href="#应用分布标准方案" class="headerlink" title="应用分布标准方案"></a>应用分布标准方案</h1><p>为了解决上述问题，首先需要了解Kubernetes为应用分布提供的标准方法，总计四种。</p>
<ul>
<li><p>节点亲和性</p>
<p>让应用强制或优先分配到某些或某类节点。具体<a href="https://kubernetes.io/zh/docs/tasks/configure-pod-container/assign-pods-nodes-using-node-affinity/">参考手册</a></p>
</li>
<li><p>应用亲和性/反亲和性</p>
<p>让应用强制或优先和某些或某类应用所属的节点上。具体<a href="https://kubernetes.io/zh/docs/concepts/scheduling-eviction/assign-pod-node/#inter-pod-affinity-and-anti-affinity">参考手册</a></p>
</li>
<li><p>污点容忍度</p>
<p>亲和性的反向操作，用于节点选择应用而不是应用选择节点（具有污点的节点，如果应用不显式声明容忍该污点，则无法被分配到该节点）。具体<a href="https://kubernetes.io/zh/docs/concepts/scheduling-eviction/taint-and-toleration/">参考手册</a></p>
</li>
<li><p>拓扑分布约束</p>
<p>让应用按照某个维度均匀分布，维度自定义，通过节点标签指定。常见的如可用区、节点等。具体<a href="https://kubernetes.io/zh/docs/concepts/workloads/pods/pod-topology-spread-constraints/">参考手册</a></p>
</li>
</ul>
<p>四者互相辅助能完成大多数应用分配的需求。我们首要的需求是：多个副本的应用均匀地分布在两个worker节点，有两种实现方式</p>
<ul>
<li><p>方式一：非强制的应用反亲和配置 + ECI污点</p>
<p>前者使得应用尽量在节点上均匀分布，但由于这些配置只是给kube scheduler提建议，不一定采纳，我们能做的也只是调大weight值到100，实测有用；后者是为了pod不被分配到ECI节点上。</p>
<p>一个配置的例子</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">spec:</span></span><br><span class="line">  <span class="attr">template:</span></span><br><span class="line">    <span class="attr">spec:</span></span><br><span class="line">      <span class="attr">affinity:</span></span><br><span class="line">        <span class="attr">podAntiAffinity:</span></span><br><span class="line">          <span class="attr">preferredDuringSchedulingIgnoredDuringExecution:</span></span><br><span class="line">            <span class="bullet">-</span> <span class="attr">podAffinityTerm:</span></span><br><span class="line">                <span class="attr">labelSelector:</span></span><br><span class="line">                  <span class="attr">matchLabels:</span></span><br><span class="line">                    <span class="attr">app:</span> <span class="string">foundation-payment</span></span><br><span class="line">                <span class="attr">topologyKey:</span> <span class="string">kubernetes.io/hostname</span></span><br><span class="line">              <span class="comment"># 写到最大</span></span><br><span class="line">              <span class="attr">weight:</span> <span class="number">100</span></span><br></pre></td></tr></table></figure></li>
<li><p>方式二：拓扑分布约束 + ECI污点</p>
<p>ECI污点作用同上；拓扑分布约束则是直接意义上的均匀分布，这应该是最标准的处理方式，实测也是有效的。如下是一个配置的例子</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">spec:</span></span><br><span class="line">  <span class="attr">template:</span></span><br><span class="line">    <span class="attr">spec:</span></span><br><span class="line">      <span class="attr">topologySpreadConstraints:</span></span><br><span class="line">        <span class="bullet">-</span> <span class="attr">maxSkew:</span> <span class="number">1</span></span><br><span class="line">          <span class="attr">topologyKey:</span> <span class="string">kubernetes.io/hostname</span></span><br><span class="line">          <span class="attr">whenUnsatisfiable:</span> <span class="string">ScheduleAnyway</span></span><br><span class="line">          <span class="attr">labelSelector:</span></span><br><span class="line">            <span class="attr">matchLabels:</span></span><br><span class="line">              <span class="attr">app:</span> <span class="string">foundation-payment</span></span><br></pre></td></tr></table></figure></li>
</ul>
<blockquote>
<p>尝试过的无效方法：设置非强制的节点亲和性，ECI节点无污点。有一点点作用，但pod还是很容易在ECS还有大量资源的情况下被分配到ECI节点。</p>
</blockquote>
<h1 id="阿里云的virtual-kubelet-autoscaler"><a href="#阿里云的virtual-kubelet-autoscaler" class="headerlink" title="阿里云的virtual-kubelet-autoscaler"></a>阿里云的virtual-kubelet-autoscaler</h1><p>上面，我们解决了pod数大于节点数均匀分布的问题。但是ECS节点资源不足时自动分配到ECI节点的需求还没有解决。</p>
<p>这个问题，可以通过安装virtual-kubelet-autoscaler插件实现，相关的几篇文档</p>
<ul>
<li><a href="https://www.xingsuyun58.com/8654.html">https://www.xingsuyun58.com/8654.html</a></li>
<li><a href="https://zhuanlan.zhihu.com/p/81238854">https://zhuanlan.zhihu.com/p/81238854</a></li>
<li><a href="https://developer.aliyun.com/ask/423342">https://developer.aliyun.com/ask/423342</a></li>
</ul>
<p>其原理是在ECI打上污点，使得平时应用不会分配上去，但检测到pod因为资源不足而创建失败的事件时，会重新尝试分配到ECI节点。十分适合我们想要的场景。</p>
<blockquote>
<p>值得注意的是，virtual-kubelet-autoscaler并不是终点，如果应用访问量上来了，日常资源占用增多，在一两个节点上挤太多应用可能出现驱逐事件，造成服务短暂宕机，而宕机的时间取决于应用启动的时间。此时弹性伸缩ECS，或者直接分配ECI才是长久的解决方式。</p>
</blockquote>
<h1 id="应用启动慢解决"><a href="#应用启动慢解决" class="headerlink" title="应用启动慢解决"></a>应用启动慢解决</h1><p>主要是Java应用启动慢，当前为每个Java应用分配的cpu资源为 requests: 100m；limits: 200m。受到<a href="https://heapdump.cn/article/2429542">这篇文章</a>启发，为每个应用分配limits: 1000m，启动速度问题得以解决，实测不加链路追踪时启动时间下降为25s；加链路追踪时启动时间也不过43s左右。</p>
<blockquote>
<p>而关于cpu设置为1000m的限制会不会对其它应用产生影响，在官方手册<a href="https://kubernetes.io/zh/docs/concepts/scheduling-eviction/node-pressure-eviction/">节点压力驱逐</a>一节并没有说明CPU高压时会怎样，而根据<a href="https://www.1024sou.com/article/288103.html">这篇文章</a>，CPU属于可压缩资源，不会造成节点驱逐，最坏的情况也不过是应用反应慢。因此为节点设置CPU阈值报警可以及时知晓问题，作出调整。</p>
</blockquote>
]]></content>
      <categories>
        <category>运维</category>
      </categories>
      <tags>
        <tag>Kubernetes</tag>
      </tags>
  </entry>
  <entry>
    <title>Kubernetes搭建血泪史（上）</title>
    <url>/2021/12/18/Kubernetes%E6%90%AD%E5%BB%BA%E8%BE%9B%E9%85%B8%E5%8F%B2/</url>
    <content><![CDATA[<p>我有一个树莓派3B，1G内存版本，以前用来当做linux主机，随便玩一玩，谢谢python，点个灯。但最近我想搭建一个Kubernetes集群，用来学习，不过集群诶，怎么能只有一台机器呢？于是在咸鱼上又购买了两台树莓派4B，一台4GB内存，一台2GB内存。为什么想用树莓派呢？一来因为还算OK的云服务器贵得离谱，对个人来说实在不划算，二来树莓派可玩性比较高。</p>
<p>然而搭建过程几经波折，浪费了大量的时间，想来，最主要的问题有两个：cgroup的开启失败和墙的问题。</p>
<span id="more"></span>

<h2 id="系统选择"><a href="#系统选择" class="headerlink" title="系统选择"></a>系统选择</h2><p>为尽量满足应用的兼容性，选择64位操作系统；又自己对Ubuntu系操作系统比较熟，于是选择Ubuntu 20.04LTS Server版。为此，到Ubuntu官网下载镜像，通过树莓派官方的Raspberry Pi Imager制作TF卡系统盘。需要严格按照<a href="https://ubuntu.com/tutorials/how-to-install-ubuntu-on-your-raspberry-pi#4-boot-ubuntu-server">官方教程</a>来，需要注意几个问题</p>
<ul>
<li>如果直接网线连接路由器，则网络配置不需要</li>
<li>如果需要开机自动连接wifi，则需要修改系统盘根目录下network-config文件，在插入树莓派之前用读卡器修改</li>
<li>默认账号ubuntu，默认密码ubuntu</li>
<li>开机第一次登录会强制要求修改密码，到时候注意修改</li>
<li>MacBook Pro m1版能够完美运行Raspberry Pi Imager</li>
</ul>
<h2 id="搭建过程"><a href="#搭建过程" class="headerlink" title="搭建过程"></a>搭建过程</h2><p>目前市场上有常规k8s、ubuntu的microk8s、rancher的k3s可供选择，最令人动心的还是microk8s，其功能齐全，还相对轻量，非常适合学习，而k3s则阉割替换了很多东西。</p>
<h3 id="搭建microk8s"><a href="#搭建microk8s" class="headerlink" title="搭建microk8s"></a>搭建microk8s</h3><p>参考<a href="https://ubuntu.com/tutorials/how-to-kubernetes-cluster-on-raspberry-pi?&_ga=2.152469631.732019699.1639280743-1880426195.1638801725#1-overview">官方手册</a>，关键点有以下几步：</p>
<ol>
<li>开启cgroup，在<code>/boot/firmware/cmdline.txt</code>文件添加<code>cgroup_enable=memory cgroup_memory=1</code>然后重启</li>
<li>直接snap安装：<code>sudo snap install microk8s --classic</code></li>
</ol>
<p>那么问题来了，我的三台机器，按照这种方式，死活无法开启cgroup，microk8s自然也无法正常工作，网上的资料，都指向一个问题</p>
<ul>
<li>根据系统的版本，开启cgroup配置的方式可能不在<code>/boot/firmware/cmdline.txt</code>中。但我确认ubuntu 20.04就是在这个文件</li>
</ul>
<p>有的人确实是这个问题，有的人却不是，那些不是的，最终也没有得到明确的解决方案。</p>
<p>于是，我被卡住了，暂时弃坑。</p>
<h3 id="再次尝试搭建microk8s"><a href="#再次尝试搭建microk8s" class="headerlink" title="再次尝试搭建microk8s"></a>再次尝试搭建microk8s</h3><p>时间来到周末，我有时间来接着搞这个问题，然后尝试了新的方式：<strong>在还没启动系统时直接在TF卡上修改cmdline.txt文件，加上cgroup启动参数</strong>，这次看起来成功了，但由于我重装了系统，需要重新snap安装microk8s，可由于墙的问题，安装过程异常缓慢，尝试了一两个小时，依旧没有安装成功。这加上下面几个原因，动摇了我使用microk8s的信心</p>
<ul>
<li>前一次即使安装成功，其命令响应时间还是非常慢</li>
<li>microk8s都这样，那原版kubernetes还得了？</li>
<li>看来留给我选择的空间不多了——k3s</li>
</ul>
<p>再次弃坑。</p>
<h3 id="kubeadm-云服务器"><a href="#kubeadm-云服务器" class="headerlink" title="kubeadm+云服务器"></a>kubeadm+云服务器</h3><p>恰逢双十二，腾讯云有一台轻量应用服务器2C4G版只需要74元一年。经过上面两次在树莓派上搭建集群的失败，我开始怀疑自己，搭建kubernetes的目的是为了研究它，而不是为了玩，应该以最短的时间完成它。那么就用kubeadm在这台新购的服务器上搭建它吧——它绝对不会有cgroup的问题。</p>
<p>对此，也有<a href="https://kubernetes.io/zh/docs/setup/production-environment/tools/kubeadm/install-kubeadm/">官方手册</a>，步骤看起来不复杂，我做了这么些事</p>
<h4 id="安装kubadm"><a href="#安装kubadm" class="headerlink" title="安装kubadm"></a>安装kubadm</h4><ul>
<li><p>允许iptables桥接流量</p>
</li>
<li><p>在云服务器安全组打开所有端口</p>
</li>
<li><p>安装运行时，我选择了docker，直接<code>sudo apt install docker.io</code>，很方便</p>
</li>
<li><p>安装kubeadm、kubectl、kubelet。这里需要添加kubernetes的源，然后它被墙了。。。。。。</p>
<p>于是参考<a href="https://zhuanlan.zhihu.com/p/46341911">这篇文章</a>使用中科大的源</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 添加中科大的源</span></span><br><span class="line">cat &lt;&lt;EOF &gt; /etc/apt/sources.list.d/kubernetes.list</span><br><span class="line">deb http://mirrors.ustc.edu.cn/kubernetes/apt kubernetes-xenial main</span><br><span class="line">EOF</span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 执行这一步会报错，提示GPGkey的问题</span></span><br><span class="line">sudo apt update</span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 这了解决那个错误，将下面的&lt;publickey&gt;更换为实际报错的key</span></span><br><span class="line">gpg --keyserver keyserver.ubuntu.com --recv-keys &lt;publickey&gt;</span><br><span class="line">gpg --export --armor &lt;publickey&gt; | sudo apt-key add -</span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 再次执行</span></span><br><span class="line">sudo apt-get update</span><br><span class="line"><span class="meta">#</span><span class="bash"> 安装</span></span><br><span class="line">sudo apt-get install -y kubelet kubeadm kubectl</span><br><span class="line"><span class="meta">#</span><span class="bash"> 锁定版本</span></span><br><span class="line">sudo apt-mark hold kubelet kubeadm kubectl</span><br></pre></td></tr></table></figure></li>
<li><p>配置cgroup驱动程序</p>
<p>这一步我是按照一个视频配置的，但其实应该按照<a href="https://kubernetes.io/zh/docs/tasks/administer-cluster/kubeadm/configure-cgroup-driver/">官网配置</a></p>
</li>
<li><p>关闭swap：<code>sudo swapoff -a</code></p>
</li>
</ul>
<h4 id="kubeadm-init"><a href="#kubeadm-init" class="headerlink" title="kubeadm init"></a>kubeadm init</h4><p>然后执行主节点的初始化工作，这里会遇到问题：kubernetes的所有组件以镜像的形式提供，是从google的容器服务gcr拉取的，然而它又被墙了。。。需要更换国内源，我们使用别人放在阿里云仓库的镜像，按照如下方式做</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 先拉取</span></span><br><span class="line">kubeadm config image pull --image-repository=registry.cn-hangzhou.aliyuncs.com/google_containers</span><br><span class="line"><span class="meta">#</span><span class="bash"> 再启动</span></span><br><span class="line">kubeadm init --image-repository=registry.cn-hangzhou.aliyuncs.com/google_containers</span><br></pre></td></tr></table></figure>

<p>启动成功后会有如下提示，关键信息有三点</p>
<ol>
<li>创建~/.kube/config文件，方便kubectl访问</li>
<li>需要马上安装网络插件</li>
<li>如果需要加入工作节点，使用这里指定的端点和token</li>
</ol>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">Your Kubernetes control-plane has initialized successfully!</span><br><span class="line"></span><br><span class="line">To start using your cluster, you need to run the following as a regular user:</span><br><span class="line"></span><br><span class="line">  mkdir -p $HOME/.kube</span><br><span class="line">  sudo cp -i /etc/kubernetes/admin.conf $HOME/.kube/config</span><br><span class="line">  sudo chown $(id -u):$(id -g) $HOME/.kube/config</span><br><span class="line"></span><br><span class="line">Alternatively, if you are the root user, you can run:</span><br><span class="line"></span><br><span class="line">  export KUBECONFIG=/etc/kubernetes/admin.conf</span><br><span class="line"></span><br><span class="line">You should now deploy a pod network to the cluster.</span><br><span class="line">Run &quot;kubectl apply -f [podnetwork].yaml&quot; with one of the options listed at:</span><br><span class="line">  https://kubernetes.io/docs/concepts/cluster-administration/addons/</span><br><span class="line"></span><br><span class="line">Then you can join any number of worker nodes by running the following on each as root:</span><br><span class="line"></span><br><span class="line">kubeadm join 10.0.20.5:6443 --token qi250a.gmbet3podjq1bcwg \</span><br><span class="line">        --discovery-token-ca-cert-hash sha256:68147e1e117e54dbeb8fce34be6c83c7d7fb918c1ad2923b404c4d03f439a178</span><br></pre></td></tr></table></figure>

<p>对于网络插件，去它提示的那个网站，进入想要的插件主页，会有提示信息</p>
<p><img src="https://gdz.oss-cn-shenzhen.aliyuncs.com/local/image-20211218165103556.png" alt="image-20211218165103556"></p>
<p>执行<code>kubectl apply -f https://raw.githubusercontent.com/coreos/flannel/master/Documentation/kube-flannel.yml</code>，安装flannel插件。</p>
<p>再等十来分钟，主节点应该就能用了，<code>kubectl get ndoes</code>能够查看效果。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">ubuntu@VM-20-5-ubuntu:~$ sudo kubectl get nodes</span><br><span class="line">NAME             STATUS   ROLES                  AGE     VERSION</span><br><span class="line">vm-20-5-ubuntu   Ready    control-plane,master   4h23m   v1.23.1</span><br></pre></td></tr></table></figure>

<h4 id="kubeadm-join"><a href="#kubeadm-join" class="headerlink" title="kubeadm join"></a>kubeadm join</h4><p>我有发现，华为云也有41块钱的1C2G机器可以买，加上我原来UCloud的1C2G的机器，是不是可以构建一个拥有三个不同云服务厂商节点的异构集群🤔。</p>
<p>要这么做，首先要解决的一个问题是，如何通过外网访问上面搭建的主节点？经验告诉我，找到config配置文件，将集群地址改为该云服务器的公网地址然后放在本地的<code>~/.kube/config</code>就行了，我确实这么做了，但使用kubectl连接时还是报了个错：提示服务器证书不允许外网访问来源。对此的解决办法参考<a href="https://blog.csdn.net/yy_diego/article/details/109362884">这篇文章</a>，思路是重新生成API Server的证书。算是解决了外网访问的问题。</p>
<p>理所当然地，我在kubeadm join的命令中也把内网地址替换为公网地址。但最终还是报错了：提示kubeadmin-config这个configmap找不到，而它居然使用了内网地址去访问🤔。这就有点麻烦了，网上搜索了一下，<strong>外网集群搭建起来会涉及到很多网络问题，属实没必要去研究</strong>。性价比太低。</p>
<p>不行，已经在这个上面耗费太多时间了，就用这个主节点吧。也算有一些成果</p>
<h3 id="搭建k3s"><a href="#搭建k3s" class="headerlink" title="搭建k3s"></a>搭建k3s</h3><p>树莓派的事情，还是有点不甘心的，明明困扰了好长一段时间的cgroup解决了，却不能安装集群。。。划不来呀。好歹，我得尝试一下k3s呀。</p>
<p>于是，我参考了<a href="https://docs.rancher.cn/docs/k3s/installation/install-options/_index">官方文档</a>和<a href="https://www.yuweizhan.cn/articles/2020/07/18/1595040455803.html">这篇文章</a>。这里的关键是使用官方提供的国内加速地址，用国外地址很可能会安装失败。</p>
<p>主节点</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 什么都不设置，直接安装，默认是作为主节点的</span></span><br><span class="line">curl -sfL http://rancher-mirror.cnrancher.com/k3s/k3s-install.sh | INSTALL_K3S_MIRROR=cn sh -</span><br></pre></td></tr></table></figure>

<p>工作节点</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 在主节点上执行:获取主节点的token</span></span><br><span class="line">cat /var/lib/rancher/k3s/server/node-token</span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 在从节点上执行</span></span><br><span class="line">export K3S_TOKEN=&lt;上面得到的token&gt;</span><br><span class="line">export K3S_URL=https://&lt;master_ip&gt;:6443</span><br><span class="line">curl -sfL http://rancher-mirror.cnrancher.com/k3s/k3s-install.sh | INSTALL_K3S_MIRROR=cn sh -</span><br></pre></td></tr></table></figure>

<p>在创建工作节点时，遇到过从节点起不来的问题，提示passwd不匹配，参照<a href="https://cloud.tencent.com/developer/article/1594895">这篇文章</a>解决了。</p>
<p>然后，就搭建完成了，此时在主节点上可以看到这两个节点</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">root@ubuntu:/home/ubuntu# kubectl get nodes</span><br><span class="line">NAME             STATUS   ROLES                  AGE    VERSION</span><br><span class="line">ubuntu           Ready    control-plane,master   3h8m   v1.21.7+k3s1</span><br><span class="line">raspberry-4c2g   Ready    &lt;none&gt;                 70m    v1.21.7+k3s1</span><br></pre></td></tr></table></figure>

<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>这三种kubernetes的搭建方式，其实都不复杂，被卡住的原因都是墙，属实蛋疼。这其中，K3s提供的支持最为友好，不但有中文资料，还有官方国内加速地址，完全不会有其它两种方式的问题。microk8s如果在网络环境允许的情况下，应该也挺简单的，它类似kubeadm，也是通过init、join这样简单的命令去构建集群，可惜的是不明原因导致在我的环境中用起来卡卡的。kubeadm相对而言是最复杂的，kubectl等软件包的软件源需要更换，镜像源也要更换。</p>
<p>不过一番折腾下来，我好歹是拥有两个kubernetes集群，一个拥有两个节点的树莓派集群和一个拥有一个节点的在腾讯云上的集群，学习用是够了。但为什么这篇文章是（上）呢？因为其它两台外网服务器，我还想要折腾一下，不过不是最近，而是等我kubernetes足够熟练之后。</p>
<p>总结一下我们遇到的问题</p>
<ul>
<li>树莓派cgroup开启失败：在启动系统之前修改cmdline.txt</li>
<li>kubernetes的apt源无法访问：更换中科大或阿里云的源</li>
<li>gcr镜像仓库无法访问：更换阿里云的镜像仓库</li>
<li>k3s安装脚本执行缓慢：使用官方提供的国内专用安装脚本</li>
<li>k3s从节点启动失败：手动将主节点的/etc/rancher/passwd复制到从节点</li>
</ul>
<p>总结一下这次的教训：折腾两三天整这么个玩意儿是很划不来的，最完美的方式，是在一个云服务厂家购买两三台中配的机器，以此搭建，这样既不会遇到cgroup问题，也不会遇到公网访问问题，还是标准的kubernetes环境。而且我们可以只买一两个月，不用了再释放掉，不会花多少钱。长远看是成本最低的一种方式。毕竟，三台树莓派的价格，也上千元了，如果再加上交换机和配件，则更贵。搭建出来的集群，还不是官方原版🤔。</p>
]]></content>
      <categories>
        <category>运维</category>
      </categories>
      <tags>
        <tag>kubernetes</tag>
      </tags>
  </entry>
  <entry>
    <title>Kubernetes节点问题排查思路</title>
    <url>/2022/02/17/Kubernetes%E8%8A%82%E7%82%B9%E7%AE%A1%E7%90%86/</url>
    <content><![CDATA[<p>Kubernetes集群运行一段时间后，通常会出现磁盘占用过高、内存占用虚高等问题。这里聊聊排查这类问题的方法和思路。</p>
<span id="more"></span>

<h2 id="问题点"><a href="#问题点" class="headerlink" title="问题点"></a>问题点</h2><p>如果是正常的Linux服务器出现这种情况，解决方案无非是ssh到该主机查看大文件然后进行删除。Kubernetes上也是如此，但问题在于，其中的节点由Kubernetes自己管理，登录秘钥管理人员很可能不知道。</p>
<p>所以问题点转化：无法进入Kubernetes节点进行管理</p>
<h2 id="进入节点"><a href="#进入节点" class="headerlink" title="进入节点"></a>进入节点</h2><p>有两个进入节点的方式</p>
<ul>
<li>使用Lens管理软件，它是一个非常厉害的Kubernetes IDE，提供直接进入节点的能力。</li>
<li>自建pod，将节点根目录挂载在该pod的子目录。即挂载整个文件系统</li>
</ul>
<p>第二种方式比较通用，这类deployment的Manifest如下，关键点：节点亲和性设置到想要管理的节点</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">apiVersion:</span> <span class="string">apps/v1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">Deployment</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">labels:</span></span><br><span class="line">    <span class="attr">app:</span> <span class="string">admin-entry</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">admin-entry</span></span><br><span class="line">  <span class="attr">namespace:</span> <span class="string">default</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line">  <span class="attr">replicas:</span> <span class="number">1</span></span><br><span class="line">  <span class="attr">selector:</span></span><br><span class="line">    <span class="attr">matchLabels:</span></span><br><span class="line">      <span class="attr">app:</span> <span class="string">admin-entry</span></span><br><span class="line">  <span class="attr">strategy:</span></span><br><span class="line">    <span class="attr">rollingUpdate:</span></span><br><span class="line">      <span class="attr">maxSurge:</span> <span class="number">25</span><span class="string">%</span></span><br><span class="line">      <span class="attr">maxUnavailable:</span> <span class="number">25</span><span class="string">%</span></span><br><span class="line">    <span class="attr">type:</span> <span class="string">RollingUpdate</span></span><br><span class="line">  <span class="attr">template:</span></span><br><span class="line">    <span class="attr">metadata:</span></span><br><span class="line">      <span class="attr">labels:</span></span><br><span class="line">        <span class="attr">app:</span> <span class="string">admin-entry</span></span><br><span class="line">    <span class="attr">spec:</span></span><br><span class="line">      <span class="attr">affinity:</span></span><br><span class="line">        <span class="attr">nodeAffinity:</span></span><br><span class="line">          <span class="attr">requiredDuringSchedulingIgnoredDuringExecution:</span></span><br><span class="line">            <span class="attr">nodeSelectorTerms:</span></span><br><span class="line">              <span class="bullet">-</span> <span class="attr">matchExpressions:</span></span><br><span class="line">                  <span class="bullet">-</span> <span class="attr">key:</span> <span class="string">kubernetes.io/hostname</span></span><br><span class="line">                    <span class="attr">operator:</span> <span class="string">In</span></span><br><span class="line">                    <span class="attr">values:</span></span><br><span class="line">                      <span class="bullet">-</span> <span class="string">cn-shenzhen.172.18.18.192</span></span><br><span class="line">      <span class="attr">containers:</span></span><br><span class="line">        <span class="bullet">-</span> <span class="attr">image:</span> <span class="string">&#x27;busybox:latest&#x27;</span></span><br><span class="line">          <span class="attr">name:</span> <span class="string">admin-entry</span></span><br><span class="line">          <span class="attr">resources:</span></span><br><span class="line">            <span class="attr">requests:</span></span><br><span class="line">              <span class="attr">cpu:</span> <span class="string">10m</span></span><br><span class="line">              <span class="attr">memory:</span> <span class="string">512Mi</span></span><br><span class="line">          <span class="attr">stdin:</span> <span class="literal">true</span></span><br><span class="line">          <span class="attr">tty:</span> <span class="literal">true</span></span><br><span class="line">          <span class="attr">volumeMounts:</span></span><br><span class="line">            <span class="bullet">-</span> <span class="attr">mountPath:</span> <span class="string">/host-dir</span></span><br><span class="line">              <span class="attr">name:</span> <span class="string">volume-1611735574911</span></span><br><span class="line">      <span class="attr">dnsPolicy:</span> <span class="string">ClusterFirst</span></span><br><span class="line">      <span class="attr">restartPolicy:</span> <span class="string">Always</span></span><br><span class="line">      <span class="attr">volumes:</span></span><br><span class="line">        <span class="bullet">-</span> <span class="attr">hostPath:</span></span><br><span class="line">            <span class="attr">path:</span> <span class="string">/</span></span><br><span class="line">            <span class="attr">type:</span> <span class="string">&#x27;&#x27;</span></span><br><span class="line">          <span class="attr">name:</span> <span class="string">volume-1611735574911</span></span><br></pre></td></tr></table></figure>

<p>然后创建</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 创建</span></span><br><span class="line">kubectl apply -f xxx.yaml</span><br><span class="line"><span class="meta">#</span><span class="bash"> 进入pod</span></span><br><span class="line">kubectl exec -it admin-entry-xxx -- sh</span><br></pre></td></tr></table></figure>

<h2 id="大文件占用排查"><a href="#大文件占用排查" class="headerlink" title="大文件占用排查"></a>大文件占用排查</h2><p>与文件相关的有两个命令</p>
<ul>
<li>du：统计列举文件或文件夹的大小</li>
<li>df：列出整个文件系统的占用情况。列出的是磁盘设备的占用率</li>
</ul>
<p>一般大文件排查用du命令。涉及到三个参数</p>
<ul>
<li>-h：以人类可读的方式展示</li>
<li>-d N：展示指定层级的目录</li>
<li>-a：不只展示文件夹，文件也展示</li>
</ul>
<p>其它参数通过<code>du --help</code>查看，对当前这个问题有如下：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 进入挂载的目录</span></span><br><span class="line">/ # cd /host-dir/</span><br><span class="line"><span class="meta">#</span><span class="bash"> 列出当前文件夹下第一层文件夹的大小</span></span><br><span class="line">/host-dir # du -h -d 1</span><br><span class="line">0	./sys</span><br><span class="line">4.0K	./media</span><br><span class="line">384.0K	./root</span><br><span class="line">4.0K	./srv</span><br><span class="line">37.5M	./etc</span><br><span class="line">46.0M	./opt</span><br><span class="line">32.0K	./tmp</span><br><span class="line">2.2G	./usr</span><br><span class="line">4.3M	./run</span><br><span class="line">4.0K	./home</span><br><span class="line">131.2M	./boot</span><br><span class="line">0	./proc</span><br><span class="line">4.0K	./mnt</span><br><span class="line">33.3G	./var</span><br><span class="line">16.0K	./lost+found</span><br><span class="line">0	./dev</span><br><span class="line">35.7G	.</span><br></pre></td></tr></table></figure>

<p>可以看出主要占用在<code>/var</code>下。继续排查发现占用高主要问题有两个</p>
<ul>
<li><code>/var/lib/docker/overlay2</code>，docker创建的容器、镜像、其他资源占用，不能随便删除。<strong>使用<code>docker image prune -a -f</code>可以删除不用的镜像，以节省资源</strong>。对ECS，通常可以直接发送命令达成此目标。</li>
<li><code>/var/log</code>，产生的日志，这里<strong>我们可以删除不用的，能节省较多空间</strong>。占用较多的是 <code>/var/log/messages</code>，来自<code>kubelet</code>和<code>systemd</code>。</li>
</ul>
<h2 id="SSH访问节点"><a href="#SSH访问节点" class="headerlink" title="SSH访问节点"></a>SSH访问节点</h2><p>既然能够访问根文件系统，岂不是可以为所欲为：修改 <code>/root/.ssh/authorized_keys</code>，将本机ssh公钥写入，就能够远程访问了。此时，就取得了节点的完整控制权。</p>
<h2 id="注意事项"><a href="#注意事项" class="headerlink" title="注意事项"></a>注意事项</h2><ul>
<li>遇到过进入节点打开过大的文件导致CPU占满，今儿导致节点不可用，大量应用挂掉的情况。所以如果要管理文件系统，还是新开一个节点，设好limit值，这样即时不小心占满pod的CPU、内存等资源，也不会导致节点出问题。比较保险。</li>
<li>如果觉得线上不方便查看日志，可以使用<code>kubectl cp</code>命令将其复制到本地，以更为便捷地查看。</li>
</ul>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>使用本文的方式可以管理文件系统，也可以在忘记密码的情况下进入节点管理，是一个通用的方案。</p>
<p>对于Kubernetes的磁盘占用率过高，通过上述两种清理闲置镜像 + 多余log文件的形式，可以节省出较多空间。如果能加个定期任务做这两件事，基本可以直接解决该问题。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash">!/bin/sh</span></span><br><span class="line">docker image prune -a -f;</span><br><span class="line">rm /var/log/messages*</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>运维</category>
      </categories>
      <tags>
        <tag>Kubernetes</tag>
      </tags>
  </entry>
  <entry>
    <title>(记)Deployment设置环境变量不生效</title>
    <url>/2022/05/19/Kubernetes%E9%85%8D%E7%BD%AE%E7%8E%AF%E5%A2%83%E5%8F%98%E9%87%8F%E5%AE%B9%E5%99%A8%E5%86%85%E9%83%A8%E4%B8%8D%E7%94%9F%E6%95%88/</url>
    <content><![CDATA[<blockquote>
<p>记一个卡了两天的问题</p>
</blockquote>
<span id="more"></span>

<h2 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h2><p>Dockerfile中，指定不同的启动方式，会有不同的读取环境变量的效果。有的能够读到，有的读不到。具体来说，如下</p>
<ul>
<li>能够读取到的方式<ul>
<li>直接启动 <code>CMD [&quot;java&quot;, &quot; -jar&quot;, &quot;xxxx.har&quot;]</code></li>
<li>tini+直接启动 <code>CMD [&quot;/tini&quot;, &quot;--&quot;, &quot;java&quot;, &quot; -jar&quot;, &quot;xxxx.har&quot;]</code></li>
<li>tini+sh启动 <code>CMD [&quot;/tini&quot;, &quot;--&quot;, &quot;sh&quot;, &quot;-c&quot;, &quot;java -jar xxxx.jar&quot;]</code></li>
</ul>
</li>
<li>不能读取的方式<ul>
<li>sh启动 <code>CMD [&quot;sh&quot;, &quot;-c&quot;, &quot;java -jar xxxx.jar&quot;]</code></li>
<li>sh启动 <code>CMD java -jar xxxx.jar</code></li>
</ul>
</li>
</ul>
<h2 id="原因"><a href="#原因" class="headerlink" title="原因"></a>原因</h2><p>没有找到官方说明，只在这篇文章中发现了一样的问题：<a href="https://blog.csdn.net/zhaopeng_yu/article/details/121375222">k8s 中env小写环境变量未注入到容器中</a>。</p>
<p>分析原因：Kubernetes不会将环境变量传给<code>sh</code>，但是会传给<code>/bin/bash</code>。一般情况下，<code>sh</code>都是链接到某个具体的shell命令，但是不同的Linux发行版有不同的行为，如果是链接到<code>/bin/bash</code>则任何方式启动都能正常读取环境变量；否则，使用<code>sh</code>的方式启动就读不到了。</p>
<p>而我的情况，<code>sh</code>链接到了<code>dash</code></p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">root@app-xxx-548f5df7bf-2gc42:/# ls -l /bin/sh</span><br><span class="line">lrwxrwxrwx 1 root root 4 Dec 20 08:00 /bin/sh -&gt; dash</span><br></pre></td></tr></table></figure>

<h2 id="解决办法"><a href="#解决办法" class="headerlink" title="解决办法"></a>解决办法</h2><p>对于读取不到的方式，可以手动将<code>sh</code>链接到<code>/bin/bash</code>。一个Djando admin的Dockerfile如下</p>
<figure class="highlight dockerfile"><table><tr><td class="code"><pre><span class="line"><span class="keyword">FROM</span> python:<span class="number">3.10</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 省略若干行</span></span><br><span class="line">... ...</span><br><span class="line"></span><br><span class="line"><span class="comment"># 修改sh的链接</span></span><br><span class="line"><span class="keyword">RUN</span><span class="bash">  ln -sf /bin/bash /bin/sh</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">CMD</span><span class="bash"> [<span class="string">&quot;sh&quot;</span>, <span class="string">&quot;-c&quot;</span>, <span class="string">&quot;python mampod/manage.py migrate &amp;&amp; python mampod/manage.py runserver 0.0.0.0:8969&quot;</span>]</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="扩展-再看ENTRYPOINT-和-CMD"><a href="#扩展-再看ENTRYPOINT-和-CMD" class="headerlink" title="扩展 - 再看ENTRYPOINT 和 CMD"></a>扩展 - 再看ENTRYPOINT 和 CMD</h2><p><a href="https://zou8944.com/2021/12/05/Dockerfile/">之前的文章</a>我们有讲过这个问题，但那侧重容器启动时哪个命令生效的问题，现在我们来捋一下它们的启动方式。</p>
<ul>
<li><p><code>ENTRYPOINT</code>的几种方式</p>
<ul>
<li><p><code>ENTRYPOINT [&quot;executable&quot;, &quot;param1&quot;, &quot;param2&quot;]</code></p>
<p><strong>exec格式，推荐方式</strong>。直接执行指定的命令，不会以任何shell形式启动</p>
</li>
<li><p><code>ENTRYPOINT command param1 param2</code></p>
<p>shell格式，相当于<code>/bin/sh -c &quot;command param1 param2&quot; </code></p>
</li>
</ul>
</li>
<li><p><code>CMD</code>的几种方式</p>
<ul>
<li><p><code>CMD [&quot;executable&quot;,&quot;param1&quot;,&quot;param2&quot;]</code></p>
<p><strong>exec格式，推荐方式</strong>。直接执行，不会以任何shell的形式启动。</p>
</li>
<li><p><code>CMD command param1 param2</code></p>
<p>shell格式，相当于<code>/bin/sh -c &quot;command param1 param2&quot; </code></p>
</li>
<li><p><code>CMD [&quot;param1&quot;,&quot;param2&quot;]</code></p>
<p>仅作为ENTRYPOINT的参数，不能单独使用</p>
</li>
</ul>
</li>
</ul>
<p>总结下来，无非两种启动方式</p>
<ul>
<li>直接执行指定的命令<ul>
<li>以exec格式启动</li>
</ul>
</li>
<li>以<code>shell</code>方式启动<ul>
<li>exec格式的命令指定为<code>&quot;sh&quot;, &quot;-c&quot;</code></li>
<li>以shell格式启动</li>
</ul>
</li>
</ul>
<p>这里的启动方式，也佐证了前面描述的问题：凡是以<code>sh</code>方式启动的case，都拿不到环境变量。</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><ul>
<li>Linux知识很重要</li>
<li>细节很重要</li>
<li>耐心很重要</li>
</ul>
]]></content>
      <categories>
        <category>运维</category>
      </categories>
      <tags>
        <tag>kubernetes</tag>
      </tags>
  </entry>
  <entry>
    <title>Linux用户和权限管理</title>
    <url>/2022/01/10/Linux%E7%94%A8%E6%88%B7%E5%92%8C%E6%9D%83%E9%99%90%E7%AE%A1%E7%90%86/</url>
    <content><![CDATA[<p>这是Linux系列第二篇文章，本来觉得Shell写完就OK了。但仔细一梳理发现对很多Linux要么是一知半解，要么是忘了。既然如此，还是遇到什么就回顾什么吧。本文试图解决以下问题</p>
<ul>
<li>Linux如何做用户管理</li>
<li>用户和权限的关系</li>
<li>一个用户安装软件后，其它用户能否使用，这是如何决定的？</li>
<li>与此相关的命令的使用方式</li>
</ul>
<span id="more"></span>

<h2 id="概览"><a href="#概览" class="headerlink" title="概览"></a>概览</h2><p>Linux的权限管理，与两个重要的特性关联甚密：一切皆文件；多用户操作系统。多用户操作系统，意味着用户之间的资源需要隔离，就有了权限存在的必要性；一切皆文件，意味着权限管理的目标只有文件。</p>
<p>Linux有两种权限管理机制</p>
<ul>
<li>原生的权限管理机制(Discretionary Access Control, DAC)，也就是UGO+RWX/ACL的权限控制。UGO标识User、Group、Other；RWX表示Read、Write、Execute；ACL表示Access Control List，即权限控制列表。这是默认的控制方式，也是我们需要关注的方式。</li>
<li>SELinux的强制访问控制(Mandatory Access Control )，即基于标签的访问控制，将所有资源打上标签，程序只能访问有标签的资源，不能访问无标签的资源。这个不在本文讨论范围内。</li>
</ul>
<h2 id="基于用户角色的管理机制"><a href="#基于用户角色的管理机制" class="headerlink" title="基于用户角色的管理机制"></a>基于用户角色的管理机制</h2><h3 id="用户、组"><a href="#用户、组" class="headerlink" title="用户、组"></a>用户、组</h3><p>Linux对账户和组的管理通过ID实现，而不是用户名。用户和组的ID分别对应UID和GID。一个用户可以属于多个组，但只能属于一个基本组，可以属于多个附加组。用户用于精确授权，组用于批量授权。可以理解为RBAC中的用户和角色关系。</p>
<blockquote>
<p>基本组和附加组的区别</p>
<p>基本组：如果没有指定用户组，创建用户的时候系统会默认同时创建一个和这个用户名同名的组，这个组就是基本组，不可以把用户从基本组中删除。在创建文件时，文件的所属组就是用户的基本组。</p>
<p>附加组：除了基本组之外，用户所在的其他组，都是附加组。用户是可以从附加组中被删除的。</p>
</blockquote>
<h4 id="useradd"><a href="#useradd" class="headerlink" title="useradd"></a>useradd</h4><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 创建账号guodong</span></span><br><span class="line">useradd guodong</span><br><span class="line"><span class="meta">#</span><span class="bash"> 创建账号guodong，设置描述信息为Administrator、家目录为/home/guodong、设置失效日期为03-04、基本组为root、附加组为mail</span></span><br><span class="line">useradd -c administrator -d /home/guodong -e 2022-03-04 -g root -G mail guodong</span><br></pre></td></tr></table></figure>

<p>创建完后可以到/etc/passwd文件下查看刚创建的用户，其含义在后文描述。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">guodong:x:1002:1002::/home/guodong:/bin/sh</span><br></pre></td></tr></table></figure>

<p>所有的参数说明如下，它能够设置的参数包括家目录、组、是否同时创建家目录、密码(编码后的)、指定UID、指定shell等。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">root@VM-20-5-ubuntu:~# useradd --help</span><br><span class="line">Usage: useradd [options] LOGIN</span><br><span class="line">       useradd -D</span><br><span class="line">       useradd -D [options]</span><br><span class="line"></span><br><span class="line">Options:</span><br><span class="line">      --badnames                do not check for bad names</span><br><span class="line">  -b, --base-dir BASE_DIR       base directory for the home directory of the</span><br><span class="line">                                new account</span><br><span class="line">      --btrfs-subvolume-home    use BTRFS subvolume for home directory</span><br><span class="line">  -c, --comment COMMENT         GECOS field of the new account</span><br><span class="line">  -d, --home-dir HOME_DIR       home directory of the new account</span><br><span class="line">  -D, --defaults                print or change default useradd configuration</span><br><span class="line">  -e, --expiredate EXPIRE_DATE  expiration date of the new account</span><br><span class="line">  -f, --inactive INACTIVE       password inactivity period of the new account</span><br><span class="line">  -g, --gid GROUP               name or ID of the primary group of the new</span><br><span class="line">                                account</span><br><span class="line">  -G, --groups GROUPS           list of supplementary groups of the new</span><br><span class="line">                                account</span><br><span class="line">  -h, --help                    display this help message and exit</span><br><span class="line">  -k, --skel SKEL_DIR           use this alternative skeleton directory</span><br><span class="line">  -K, --key KEY=VALUE           override /etc/login.defs defaults</span><br><span class="line">  -l, --no-log-init             do not add the user to the lastlog and</span><br><span class="line">                                faillog databases</span><br><span class="line">  -m, --create-home             create the user&#x27;s home directory</span><br><span class="line">  -M, --no-create-home          do not create the user&#x27;s home directory</span><br><span class="line">  -N, --no-user-group           do not create a group with the same name as</span><br><span class="line">                                the user</span><br><span class="line">  -o, --non-unique              allow to create users with duplicate</span><br><span class="line">                                (non-unique) UID</span><br><span class="line">  -p, --password PASSWORD       encrypted password of the new account</span><br><span class="line">  -r, --system                  create a system account</span><br><span class="line">  -R, --root CHROOT_DIR         directory to chroot into</span><br><span class="line">  -P, --prefix PREFIX_DIR       prefix directory where are located the /etc/* files</span><br><span class="line">  -s, --shell SHELL             login shell of the new account</span><br><span class="line">  -u, --uid UID                 user ID of the new account</span><br><span class="line">  -U, --user-group              create a group with the same name as the user</span><br><span class="line">  -Z, --selinux-user SEUSER     use a specific SEUSER for the SELinux user mapping</span><br><span class="line">      --extrausers              Use the extra users database</span><br></pre></td></tr></table></figure>

<p>如果什么选项都不加，默认会做如下几件事</p>
<ul>
<li>创建用户</li>
<li>创建用户的主目录</li>
<li>创建用户同名的组，并将用户放入其中</li>
</ul>
<h4 id="groupadd"><a href="#groupadd" class="headerlink" title="groupadd"></a>groupadd</h4><p>添加组</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 创建gg组</span></span><br><span class="line">groupadd gg</span><br><span class="line"><span class="meta">#</span><span class="bash"> 创建用户guodong，并将gg作为其primary组。</span></span><br><span class="line">useradd guodong -g gg</span><br></pre></td></tr></table></figure>

<p>添加后/etc/group文档，含义后面说</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">guodong:x:1002:</span><br></pre></td></tr></table></figure>

<p>命令详情</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">ubuntu@VM-20-5-ubuntu:~$ groupadd --help</span><br><span class="line">Usage: groupadd [options] GROUP</span><br><span class="line"></span><br><span class="line">Options:</span><br><span class="line">  -f, --force                   exit successfully if the group already exists,</span><br><span class="line">                                and cancel -g if the GID is already used</span><br><span class="line">  -g, --gid GID                 use GID for the new group</span><br><span class="line">  -h, --help                    display this help message and exit</span><br><span class="line">  -K, --key KEY=VALUE           override /etc/login.defs defaults</span><br><span class="line">  -o, --non-unique              allow to create groups with duplicate</span><br><span class="line">                                (non-unique) GID</span><br><span class="line">  -p, --password PASSWORD       use this encrypted password for the new group</span><br><span class="line">  -r, --system                  create a system account</span><br><span class="line">  -R, --root CHROOT_DIR         directory to chroot into</span><br><span class="line">  -P, --prefix PREFIX_DIR       directory prefix</span><br><span class="line">      --extrausers              Use the extra users database</span><br></pre></td></tr></table></figure>

<h4 id="id"><a href="#id" class="headerlink" title="id"></a>id</h4><p>查看某个用户的详情，会打印出uid、所属组gid、所属组等。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">ubuntu@VM-20-5-ubuntu:~$ id guodong</span><br><span class="line">uid=1002(guodong) gid=1002(guodong) groups=1002(guodong),0(root)</span><br></pre></td></tr></table></figure>

<p>命令详情，增加参数可以仅打印部分内容</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">ubuntu@VM-20-5-ubuntu:~$ id --help</span><br><span class="line">Usage: id [OPTION]... [USER]</span><br><span class="line">Print user and group information for the specified USER,</span><br><span class="line">or (when USER omitted) for the current user.</span><br><span class="line"></span><br><span class="line">  -a             ignore, for compatibility with other versions</span><br><span class="line">  -Z, --context  print only the security context of the process</span><br><span class="line">  -g, --group    print only the effective group ID</span><br><span class="line">  -G, --groups   print all group IDs</span><br><span class="line">  -n, --name     print a name instead of a number, for -ugG</span><br><span class="line">  -r, --real     print the real ID instead of the effective ID, with -ugG</span><br><span class="line">  -u, --user     print only the effective user ID</span><br><span class="line">  -z, --zero     delimit entries with NUL characters, not whitespace;</span><br><span class="line">                   not permitted in default format</span><br><span class="line">      --help     display this help and exit</span><br><span class="line">      --version  output version information and exit</span><br></pre></td></tr></table></figure>

<h4 id="passwd"><a href="#passwd" class="headerlink" title="passwd"></a>passwd</h4><p>修改某个用户的密码</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">ubuntu@VM-20-5-ubuntu:~$ sudo passwd guodong</span><br><span class="line">New password: </span><br><span class="line">Retype new password: </span><br><span class="line">passwd: password updated successfully</span><br></pre></td></tr></table></figure>

<h4 id="usermod"><a href="#usermod" class="headerlink" title="usermod"></a>usermod</h4><p>修改用户信息，如密码、家目录、组信息等。能够修改的信息和useradd类似</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 修改guodong的描述信息</span></span><br><span class="line">ubuntu@VM-20-5-ubuntu:~$ usermod guodong -c 果冻</span><br><span class="line">ubuntu@VM-20-5-ubuntu:~$ cat /etc/passwd | grep guodong</span><br><span class="line">guodong:x:1002:1002:果冻:/home/guodong:/bin/sh</span><br></pre></td></tr></table></figure>

<h4 id="userdel、groupdel"><a href="#userdel、groupdel" class="headerlink" title="userdel、groupdel"></a>userdel、groupdel</h4><p>删除用户</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 删除用户</span></span><br><span class="line">userdel guodong</span><br><span class="line"><span class="meta">#</span><span class="bash"> 删除组</span></span><br><span class="line">groupdel guodong</span><br></pre></td></tr></table></figure>

<h4 id="相关文件"><a href="#相关文件" class="headerlink" title="相关文件"></a>相关文件</h4><ul>
<li><p>/etc/passwd</p>
<p>存放用户的问题</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">root@VM-20-5-ubuntu:~# cat /etc/passwd | grep ubuntu</span><br><span class="line">ubuntu:x:1000:1000:ubuntu:/home/ubuntu:/bin/bash</span><br></pre></td></tr></table></figure>

<p>总计被分为7段。从左到右，为，<code>用户名 : 口令 : UID : GID : 描述信息 : 家目录 : 登录shell</code></p>
<p>注意口令字段，存储的只是一个x，它只是表示有密码，真正的密码在/etc/shadow中</p>
<blockquote>
<p>伪用户：整个passwd文件中还有很多没有登录shell的用户，他们叫做伪用户，不能登录，只是为了方便系统管理而存在的。</p>
</blockquote>
</li>
<li><p>/etc/group</p>
<p>存放组的文件</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">root@VM-20-5-ubuntu:~# cat /etc/group | grep ubuntu</span><br><span class="line">adm:x:4:syslog,ubuntu</span><br><span class="line">cdrom:x:24:ubuntu</span><br><span class="line">sudo:x:27:ubuntu</span><br><span class="line">dip:x:30:ubuntu</span><br><span class="line">plugdev:x:46:ubuntu</span><br><span class="line">lxd:x:116:ubuntu</span><br><span class="line">ubuntu:x:1000:</span><br><span class="line"></span><br><span class="line">root@VM-20-5-ubuntu:~# id ubuntu</span><br><span class="line">uid=1000(ubuntu) gid=1000(ubuntu) groups=1000(ubuntu),4(adm),24(cdrom),27(sudo),30(dip),46(plugdev),116(lxd)</span><br></pre></td></tr></table></figure>

<p>总计4个字段，<code>组名:组密码:GID:组内用户列表</code>。上面的命令中，刚好可以把<code>id ubuntu</code>得到的groups和上面的<code>/etc/group</code>包含ubuntu用户的组对应起来。</p>
<blockquote>
<p>组密码，用于在非本组用户切换到本组时的鉴权</p>
</blockquote>
</li>
<li><p>/etc/shadow</p>
<p>存放用户密码的文件</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">root@VM-20-5-ubuntu:~# cat /etc/shadow | grep ubuntu</span><br><span class="line">ubuntu:$6$jljvtYI5RLrh6ZwE$C/s2cHElV8XZ./cWGEV09ICjEavrLivzkpa0T/Sil1Xjv5rFTGAmSzOVDlBx8a8zUnvMlMNFcqrWt8k.F1ZHF0:18979:0:99999:7:::</span><br></pre></td></tr></table></figure>

<p>总计9个字段，<code>用户名:加密密码:最后一次修改时间:最小修改时间间隔:密码有效期:密码需要变更前的警告天数:密码过期后的宽限时间:账号失效时间:保留字段</code></p>
<p>加密密码使用了SHA512散列算法。</p>
<blockquote>
<p>伪用户的密码为!!或*，代表不能登录</p>
</blockquote>
</li>
<li><p>/etc/gshadow</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">root@VM-20-5-ubuntu:~# cat /etc/gshadow | grep ubuntu</span><br><span class="line">adm:*::syslog,ubuntu</span><br><span class="line">cdrom:*::ubuntu</span><br><span class="line">sudo:*::ubuntu</span><br><span class="line">dip:*::ubuntu</span><br><span class="line">plugdev:*::ubuntu</span><br><span class="line">lxd:!::ubuntu</span><br><span class="line">ubuntu:!::</span><br></pre></td></tr></table></figure>

<p>总计4个字段，<code>组名:组密码:组管理员名:支持的账号名</code></p>
</li>
<li><p>/etc/login.defs</p>
<p>设置用户账号限制的文件，该文件的配置对root用户无效。它用户在Linux创建用户时，对用户做一些默认的设置，比如UID范围、用户过期时间等。</p>
</li>
</ul>
<h3 id="文件权限"><a href="#文件权限" class="headerlink" title="文件权限"></a>文件权限</h3><h4 id="详述"><a href="#详述" class="headerlink" title="详述"></a>详述</h4><p>随便看一个文件</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">root@VM-20-5-ubuntu:~# ls -l /etc/login.defs</span><br><span class="line">-rw-r--r-- 1 root root 10550 Feb  7  2020 /etc/login.defs</span><br></pre></td></tr></table></figure>

<p>从左到右，依次为</p>
<ul>
<li>文件类型：-表示文件，d表示目录，c表示字符型文件，l表示链接文件</li>
<li>UGO权限：文件所有者、文件所有人所属组、其它人的权限，依次为读、写、执行，即RWX</li>
<li>连接计数：连接计数-2=本目录直接包含的子目录和文件总数；文件为1</li>
<li>文件所有者</li>
<li>文件所属组</li>
<li>大小，单位Byte</li>
<li>修改日期</li>
<li>文件名</li>
</ul>
<blockquote>
<p>rwx，文件和目录不一样，目录的如下</p>
<table>
<thead>
<tr>
<th>rwx 权限</th>
<th>对目录的作用</th>
</tr>
</thead>
<tbody><tr>
<td>读权限（r）</td>
<td>表示具有读取目录结构列表的权限，也就是说，可以看到目录中有哪些文件和子目录。一旦对目录拥有 r 权限，就可以在此目录下执行 ls 命令，查看目录中的内容。</td>
</tr>
<tr>
<td>写权限（w）</td>
<td>对于目录来说，w 权限是最高权限。对目录拥有 w 权限，表示可以对目录做以下操作：在此目录中建立新的文件或子目录；删除已存在的文件和目录（无论子文件或子目录的权限是怎样的）；对已存在的文件或目录做更名操作；移动此目录下的文件和目录的位置。一旦对目录拥有 w 权限，就可以在目录下执行 touch、rm、cp、mv 等命令。</td>
</tr>
<tr>
<td>执行权限（x）</td>
<td>目录是不能直接运行的，对目录赋予 x 权限，代表用户可以进入目录，也就是说，赋予 x 权限的用户或群组可以使用 cd 命令。</td>
</tr>
</tbody></table>
</blockquote>
<blockquote>
<p>如果对rwx不了解，可以网上搜索，一搜一大堆</p>
</blockquote>
<h4 id="chmod"><a href="#chmod" class="headerlink" title="chmod"></a>chmod</h4><p>修改文件或目录权限</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">chmod +x hello.sh # 为hello.sh添加执行权限</span><br></pre></td></tr></table></figure>

<p>所有可能的权限为<code>[ugoa]*([-+=]([rwxXst]*|[ugo]))+|[-+=][0-7]+</code></p>
<h4 id="chown"><a href="#chown" class="headerlink" title="chown"></a>chown</h4><p>修改文件所有者，贴两个示例感受一下</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">chown root /u        Change the owner of /u to &quot;root&quot;.</span><br><span class="line">chown root:staff /u  Likewise, but also change its group to &quot;staff&quot;.</span><br><span class="line">chown -hR root /u    Change the owner of /u and subfiles to &quot;root&quot;.</span><br></pre></td></tr></table></figure>

<h2 id="其它"><a href="#其它" class="headerlink" title="其它"></a>其它</h2><h3 id="决定用户是否能sudo"><a href="#决定用户是否能sudo" class="headerlink" title="决定用户是否能sudo"></a>决定用户是否能sudo</h3><p>通过文件<code>/etc/sudoers</code>控制。文件不长，可以完整看一看</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"></span></span><br><span class="line"><span class="bash"><span class="comment"># This file MUST be edited with the &#x27;visudo&#x27; command as root.</span></span></span><br><span class="line"><span class="meta">#</span><span class="bash"></span></span><br><span class="line"><span class="bash"><span class="comment"># Please consider adding local content in /etc/sudoers.d/ instead of</span></span></span><br><span class="line"><span class="meta">#</span><span class="bash"> directly modifying this file.</span></span><br><span class="line"><span class="meta">#</span><span class="bash"></span></span><br><span class="line"><span class="bash"><span class="comment"># See the man page for details on how to write a sudoers file.</span></span></span><br><span class="line"><span class="meta">#</span><span class="bash"></span></span><br><span class="line"><span class="bash"><span class="comment"># 使用sudo时，会重置环境变量</span></span></span><br><span class="line">Defaults        env_reset</span><br><span class="line">Defaults        mail_badpass</span><br><span class="line">Defaults        secure_path=&quot;/usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/sbin:/bin:/snap/bin&quot;</span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">#</span><span class="bash"> Host <span class="built_in">alias</span> specification</span></span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">#</span><span class="bash"> User <span class="built_in">alias</span> specification</span></span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">#</span><span class="bash"> Cmnd <span class="built_in">alias</span> specification</span></span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">#</span><span class="bash"> User privilege specification</span></span><br><span class="line">root    ALL=(ALL:ALL) ALL</span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">#</span><span class="bash"> Members of the admin group may gain root privileges</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> admin组下的所有用户能够sudo</span></span><br><span class="line"><span class="meta">%</span><span class="bash">admin ALL=(ALL) ALL</span></span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">#</span><span class="bash"> Allow members of group sudo to execute any <span class="built_in">command</span></span></span><br><span class="line"><span class="meta">#</span><span class="bash"> sudo组下的所有用户能够sudo</span></span><br><span class="line"><span class="meta">%</span><span class="bash">sudo   ALL=(ALL:ALL) ALL</span></span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">#</span><span class="bash"> See sudoers(5) <span class="keyword">for</span> more information on <span class="string">&quot;#include&quot;</span> directives:</span></span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">#</span><span class="bash">includedir /etc/sudoers.d</span></span><br><span class="line">lighthouse ALL=(ALL) NOPASSWD: ALL</span><br><span class="line"><span class="meta">#</span><span class="bash"> 用户ubuntu可以在所有主机上，切换到所有用户和组上，在不用输密码的情况下，执行所有命令</span></span><br><span class="line">ubuntu  ALL=(ALL:ALL) NOPASSWD: ALL</span><br></pre></td></tr></table></figure>

<p>配置用户的sudo权限：<strong>授权用户/组 主机=[(切换到哪些用户或组)] [是否需要输入密码验证] 命令1,命令2,…</strong></p>
<blockquote>
<p>结合这个文件的Defaults，可以了解到，使用sudo执行命令时，当前用户shell的环境变量会被重置。</p>
</blockquote>
<h3 id="决定用户是否能远程ssh"><a href="#决定用户是否能远程ssh" class="headerlink" title="决定用户是否能远程ssh"></a>决定用户是否能远程ssh</h3><p>如果需要禁止一个用户ssh登录怎么办。方法有两类</p>
<ul>
<li><p>进制该用户登录</p>
<ul>
<li>锁定账号<code>usermod -L guodong</code></li>
<li>修改用户shell为不可登录<code>/sbin/nologin</code></li>
</ul>
</li>
<li><p>修改<code>/etc/ssh/sshd_config</code></p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 禁止root用户登录</span></span><br><span class="line">PermitRootLogin no</span><br><span class="line"><span class="meta">#</span><span class="bash"> 拒绝用户</span></span><br><span class="line">DenyUsers guodong</span><br></pre></td></tr></table></figure></li>
</ul>
<blockquote>
<p>补充一个知识点：我们可以限制ssh的账号密码登录</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 禁止guodong和root使用账号密码登录，其它允许</span></span><br><span class="line">Match User guodong,root</span><br><span class="line">  PasswordAuthentication no</span><br><span class="line">Match all</span><br><span class="line">  PasswordAuthentication yes</span><br></pre></td></tr></table></figure>
</blockquote>
<h2 id="权限控制与软件安装"><a href="#权限控制与软件安装" class="headerlink" title="权限控制与软件安装"></a>权限控制与软件安装</h2><p>软件安装，本质上就是将软件包的各个部分放到适当的位置，即在不同目录下创建文件或目录，有几个点比较重要</p>
<ul>
<li><p>软件的安装位置，会安装到用户的家目录吗？</p>
</li>
<li><p>新创建的文件或目录所有人、所有组是谁？这决定了那些人能够访问新安装的软件</p>
</li>
</ul>
<h3 id="软件安装位置"><a href="#软件安装位置" class="headerlink" title="软件安装位置"></a>软件安装位置</h3><p><code>apt insall</code>、<code>yum insall</code>、<code>dpkg -i </code>、<code>自由安装</code>的软件，它们最终到了哪个目录下？关于这个，了解两个点</p>
<ol>
<li>linux目录众多，但某些目录一般是有专门用途的</li>
<li>apt、yum等安装软件时软件文件存放的位置，不是由安装器自己决定的，而是软件维护者决定，所以不能一概而论</li>
</ol>
<p>对于第一点，首先了解你操作系统的PATH</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">root@VM-20-5-ubuntu:~# env | grep PATH</span><br><span class="line">PATH=/usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/sbin:/bin:/usr/games:/usr/local/games:/snap/bin</span><br></pre></td></tr></table></figure>

<blockquote>
<p>PATH的作用，默认操作提供到PATH指定的目录中查找命令</p>
</blockquote>
<p>关于文件夹管理这玩意儿，其实<a href="https://www.linuxbase.org/betaspecs/fhs/fhs/index.html">Linux还有个标准</a>。</p>
<p>常见的与软件安装有关的目录有</p>
<table>
<thead>
<tr>
<th>路径</th>
<th>作用</th>
</tr>
</thead>
<tbody><tr>
<td>/usr/local/sbin</td>
<td>自己编译的、根用户才能访问的命令</td>
</tr>
<tr>
<td>/usr/local/bin</td>
<td>自己编译的、大家都能访问的命令</td>
</tr>
<tr>
<td>/usr/sbin、/sbin（只是/usr/sbin的链接，至少ubuntu是如此）</td>
<td>系统的或安装的、根用户才能访问的命令</td>
</tr>
<tr>
<td>/usr/bin、/bin（它只是/usr/bin的链接，至少ubuntu是如此）</td>
<td>系统的或安装的、大家都能访问的命令</td>
</tr>
<tr>
<td>/usr/share</td>
<td>存放一些共享数据，如文档等</td>
</tr>
<tr>
<td>/usr/lib</td>
<td>存放软件所需的库文件</td>
</tr>
<tr>
<td>/etc</td>
<td>存放配置文件</td>
</tr>
<tr>
<td>/opt</td>
<td>一些可选的软件会安装在这里。<br />可选就是用户自己安装的一些无足轻重与系统无关的应用<br />比如tomcat</td>
</tr>
</tbody></table>
<p>要点1：区分<code>bin和sbin</code>、<code>/usr和/usr/local</code>，可以看看<a href="https://www.zhihu.com/question/21265424?sort=created">知乎</a></p>
<p>要点2：我们可以查看一下usr下目录的权限，可以看到所有人都是root，只有root能够写，但是其它用户具有读和执行权限。那么可以猜测，将软件安装到这些目录，需要root权限。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">ubuntu@VM-20-5-ubuntu:~$ ls -l /usr</span><br><span class="line">total 136</span><br><span class="line">drwxr-xr-x   2 root root 57344 Dec 18 11:26 bin</span><br><span class="line">drwxr-xr-x   2 root root  4096 Dec 18 10:56 config</span><br><span class="line">drwxr-xr-x   2 root root  4096 Apr 15  2020 games</span><br><span class="line">drwxr-xr-x  10 root root 16384 Dec 18 10:33 include</span><br><span class="line">drwxr-xr-x  94 root root  4096 Dec 18 11:26 lib</span><br><span class="line">drwxr-xr-x   2 root root  4096 Apr 23  2020 lib32</span><br><span class="line">drwxr-xr-x   2 root root  4096 Jun  5  2021 lib64</span><br><span class="line">drwxr-xr-x   4 root root  4096 Dec 18 12:29 libexec</span><br><span class="line">drwxr-xr-x   2 root root  4096 Apr 23  2020 libx32</span><br><span class="line">drwxr-xr-x  12 root root  4096 Dec 18 10:33 local</span><br><span class="line">drwxr-xr-x   2 root root 20480 Jan 12 10:50 sbin</span><br><span class="line">drwxr-xr-x 159 root root  4096 Dec 18 11:09 share</span><br><span class="line">drwxr-xr-x   4 root root  4096 Nov  9 21:41 src</span><br></pre></td></tr></table></figure>

<h3 id="安装人的影响"><a href="#安装人的影响" class="headerlink" title="安装人的影响"></a>安装人的影响</h3><p>为什么有些安装需要sudo，sudo就是以root用户的身份执行此条命令。所有部分命令的执行如果需要访问root用户才有权限修改的文件或目录，则需要sudo。</p>
<p>另一个问题，一个普通用户安装的软件，另一个普通用户能用吗？这要看情况，如果将软件正常安装到上述目录中，则所有用户都能访问。但理论上可以进行不规范操作，在用户自己的家目录下安装软件，并加入PATH，则其它用户无法访问。</p>
<p>所以，这还是一个文件权限管理的问题。</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>Linux的权限，归根结底管理的是文件，搞清楚文件权限、用户和组之间的关系，掌握几个关键命令，应对日常维护问题不大。</p>
]]></content>
      <categories>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>Linux</tag>
      </tags>
  </entry>
  <entry>
    <title>OAuth2.0详解</title>
    <url>/2021/12/23/OAuth2.0/</url>
    <content><![CDATA[<p>本文深入OAuth2.0协议，以及基于其上的OpenID Connect身份认证协议。前者解决授权第三方服务访问资源的问题；后者解决身份认证的问题。主要资料来源是官方协议手册：<a href="https://www.rfc-editor.org/rfc/pdfrfc/rfc6749.txt.pdf">RFC6749</a>、<a href="https://openid.net/specs/openid-connect-core-1_0.html">OpenID Connect Specification</a>。</p>
<p>当然还有更多其它说的好的第三方资源，比如<a href="https://www.ruanyifeng.com/blog/2014/05/oauth_2_0.html">阮一峰这个</a>，它的优点是只针对协议讲解，没有举那些无助于理解的复杂例子。</p>
<span id="more"></span>

<blockquote>
<p>考虑到文章的长度，OpenID Connect移到下篇文章再说</p>
</blockquote>
<p>OAuth2.0解决了授权的问题。在只有客户端和资源服务器的简单架构中，资源服务器仅有简单的权限验证功能，如果一个用户想要授权第三方客户端访问自己位于资源服务器上的资源，能够做的方式唯有提供自己的账号密码。这样无疑会有很大问题</p>
<ul>
<li>首先账号密码是不安全的</li>
<li>其次由于资源服务器没有复杂的权限验证功能，因此无法实现权限的精细化控制，被授权方能够很容易地获取过大的权力</li>
<li>并且账号密码是全局的，收回权限的方式是改密码，但是改密码会影响到所有使用该账号密码的用户及第三方服务</li>
</ul>
<p>OAuth就是为了解决该问题被提出，它引入一个授权层，即将权限管理独立出来，专门管理。目前OAuth最新版为2.0，2.0与1.0不兼容。授权层的作用是经过用户同意后，向第三方发放权限受限的访问凭证，即access token，该凭证约束了访问范围、生命周期（即过期时间）等。</p>
<p>协议规定了参与角色、各方之间交流的模式、凭证的规范等。</p>
<h1 id="参与方"><a href="#参与方" class="headerlink" title="参与方"></a>参与方</h1><p>传统的授权，只有三个参与方：用户（资源所有者）、资源服务、客户端（第三方服务）。OAuth2.0增加了授权服务，总计四个参与方。其中，资源服务和授权服务只是逻辑上的独立概念，实现上他们可以是一个，即一个服务同时扮演授权鉴权和资源分发的角色。</p>
<p>这其中尤其需要注意客户端。</p>
<ul>
<li>定义了两种客户端：可信的、公开的。前者能够自己保护密码，如后端应用；后者不能，如前端应用</li>
<li>客户端可能由不同部分组成，如一个客户端同时拥有前端和后端</li>
</ul>
<h1 id="工作模式"><a href="#工作模式" class="headerlink" title="工作模式"></a>工作模式</h1><img src="https://gdz.oss-cn-shenzhen.aliyuncs.com/local/image-20211221222733051.png" alt="image-20211221222733051" style="zoom:80%;" />

<p>协议的通用工作模式总体来说如上图，分为三个步骤</p>
<ul>
<li>客户端向用户请求授权凭证（Authorization Grant）</li>
<li>客户端使用得到的授权凭证向授权服务器请求访问凭证</li>
<li>客户端使用访问凭证访问最终的资源</li>
</ul>
<p>在获取access token之后的逻辑都是一样的，但获取access token的实际应用情况有很多种，具体分成了四种具体的工作模式</p>
<ul>
<li>授权码模式（Authorization Code）：最常用的，安全性最高。适合在客户端有后端服务的情况，前端只能够接触到授权码，后端存储access token。</li>
<li>隐藏(授权码)模式（Implicit）：适用于客户端只有前端的情况。只有前端，就不需要中间凭证（授权码）了。</li>
<li>用户密码模式（Resource Owner Password Credentials）：客户端直接使用用户的账号密码向服务器要access token，前两者不可用时，用它</li>
<li>客户端凭证模式（Client Credentials）：客户端自己向授权服务器索要，用户不参与，不知道这种模式存在的意义，我们忽略</li>
</ul>
<h2 id="授权码模式"><a href="#授权码模式" class="headerlink" title="授权码模式"></a>授权码模式</h2><img src="https://gdz.oss-cn-shenzhen.aliyuncs.com/local/image-20211222212026728.png" alt="image-20211222212026728" style="zoom:67%;" />

<p>该模式流程图如上，大家可以联想平时自己在第三方网站上如何通过微信授权登录的</p>
<ul>
<li><p>A: 客户端将用户的UA导向<strong>授权端点</strong>，授权端点由授权服务器提供；导向授权端点时，客户端会带上自己的标识、请求的范围、自定义状态以及一个用于授权完成后充定向的地址</p>
<p>该步骤客户端向授权服务发出的请求包含参数</p>
<table>
<thead>
<tr>
<th>字段</th>
<th>是否必须</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>response_type</td>
<td>必须</td>
<td>写死 code</td>
</tr>
<tr>
<td>client_id</td>
<td>必须</td>
<td>客户端唯一标识，需要提前在授权服务器注册</td>
</tr>
<tr>
<td>redirect_uri</td>
<td>可选</td>
<td>重定向地址</td>
</tr>
<tr>
<td>scope</td>
<td>可选</td>
<td>请求授权的范围</td>
</tr>
<tr>
<td>state</td>
<td>推荐要有</td>
<td>一个不透明的值，用于在回调时进行比对，防止跨域攻击</td>
</tr>
</tbody></table>
<p>举例</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">GET /authorize?response_type=code&amp;client_id=s6BhdRkqt3&amp;state=xyz&amp;redirect_uri=https%3A%2F%2Fclient%2Eexample%2Ecom%2Fcb HTTP/1.1</span><br><span class="line">Host: server.example.com</span><br></pre></td></tr></table></figure></li>
<li><p>B: 授权服务器通过UA对用户进行验证，并确认用户是否同意授权给客户端。可能的方式是授权服务将上述接口重定向到自己提供的用户登录页，用户登录确认后再将信息收集到授权服务，这个操作由授权服务自己完成，所以都归在了这个步骤中。</p>
</li>
<li><p>C: 如果用户同意授权，授权服务器将用户的UA重定向回客户端，依据的URI是A步骤给的。重定向的URI会将授权码带在参数，同时带上的还有A步骤给的自定义状态</p>
<p>重定向UA时，带的参数如下</p>
<table>
<thead>
<tr>
<th>字段</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>code</td>
<td>授权码，Authorization Code</td>
</tr>
<tr>
<td>state</td>
<td>步骤A有时，这就会有</td>
</tr>
</tbody></table>
<p>举例</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">HTTP/1.1 302 Found</span><br><span class="line">Location: https://client.example.com/cb?code=SplxlOBeZQQYbYS6WxSbIA&amp;state=xyz</span><br></pre></td></tr></table></figure></li>
<li><p>D: 客户端使用C步骤得到的授权码、A步骤提供的重定向地址，向<strong>token发放端点</strong>换取access token</p>
<p>该步骤的请求参数如下</p>
<table>
<thead>
<tr>
<th>字段</th>
<th>是否必须</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>grant_type</td>
<td>必须</td>
<td>写死 authorization_code</td>
</tr>
<tr>
<td>code</td>
<td>必须</td>
<td>C步骤得到的授权码</td>
</tr>
<tr>
<td>redirect_uri</td>
<td>必须</td>
<td>和A步骤给的参数一样</td>
</tr>
<tr>
<td>client_id</td>
<td>必须</td>
<td>客户端标识</td>
</tr>
</tbody></table>
<p>举例</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">POST /token HTTP/1.1</span><br><span class="line">Host: server.example.com</span><br><span class="line">Content-Type: application/x-www-form-urlencoded</span><br><span class="line"></span><br><span class="line">grant_type=authorization_code&amp;code=SplxlOBeZQQYbYS6WxSbIA&amp;redirect_uri=https%3A%2F%2Fclient%2Eexample%2Ecom%2Fcb</span><br></pre></td></tr></table></figure></li>
<li><p>E: 授权服务器对收到的授权码进行验证，比对收到的重定向地址和A步骤给的是否一致，如果通过，则发放access token，并且可选地发放refresh token</p>
<p>这个响应包含的参数如下</p>
<table>
<thead>
<tr>
<th>字段</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>access_token</td>
<td>即发放的访问凭证</td>
</tr>
<tr>
<td>token_type</td>
<td>token的类型，只有在客户端理解了token的类型后才能正确使用<br />比如bearer、mac等，一般由授权服务器指定</td>
</tr>
<tr>
<td>expires_in</td>
<td>token过期时间</td>
</tr>
<tr>
<td>refresh_token</td>
<td>用来换取新access_token的token</td>
</tr>
<tr>
<td>scope</td>
<td>如果响应的scope和A步骤请求的scope一致，则可给可不给，否则，一定要给</td>
</tr>
</tbody></table>
<p>举例</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">HTTP/1.1 200 OK</span><br><span class="line">Content-Type: application/json;charset=UTF-8</span><br><span class="line">Cache-Control: no-store</span><br><span class="line">Pragma: no-cache</span><br><span class="line">&#123;</span><br><span class="line">  &quot;access_token&quot;:&quot;2YotnFZFEjr1zCsicMWpAA&quot;,</span><br><span class="line">  &quot;token_type&quot;:&quot;example&quot;,</span><br><span class="line">  &quot;expires_in&quot;:3600,</span><br><span class="line">  &quot;refresh_token&quot;:&quot;tGzv3JOkF0XG5Qx2TlKWIA&quot;,</span><br><span class="line">  &quot;example_parameter&quot;:&quot;example_value&quot;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<p><strong>等等，上面几个步骤看起来很奇怪不是吗？为什么要向客户端发送授权码，客户端再用授权码去更换访问凭证？而不是直接发访问凭证，</strong>不是多此一举吗？</p>
<p>其实上面的D步骤有一点没说，即在兑换access token时，要求授权服务对客户端进行鉴权，即保证客户端是可信的。而实际应用中保证可信的方式是前后端分离，即客户端由前端和后端组成，授权码发给前端，前端再将授权码传给自己的后端，后端再用来兑换access_token并保存。前端暴露在UA中，不可信，因此授权码一般生命周期很短，以微信为例，只能使用一次；后端可信，因此能够持有最终的access_token。这样看，authorization code和access token分开发就不多余了。</p>
<p>如果并没有分前后端，authorization code + access token的方式确实多此一举，因此针对这种情况，把授权码去掉了，就有了隐藏授权码模式。</p>
<h2 id="隐藏-授权码-模式"><a href="#隐藏-授权码-模式" class="headerlink" title="隐藏(授权码)模式"></a>隐藏(授权码)模式</h2><p>这种模式经常只用在只有纯客户端的情况。其流程如下</p>
<img src="https://gdz.oss-cn-shenzhen.aliyuncs.com/local/image-20211222221933160.png" alt="image-20211222221933160" style="zoom:67%;" />

<ul>
<li><p>A：客户端将用户导向授权端点，导入时带上客户端标识、scope、state、重定向URI</p>
<p>请求包含的参数</p>
<table>
<thead>
<tr>
<th>字段</th>
<th>是否必须</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>response_type</td>
<td>必须</td>
<td>写死 token</td>
</tr>
<tr>
<td>client_id</td>
<td>必须</td>
<td>客户端唯一标识，需要提前在授权服务器注册</td>
</tr>
<tr>
<td>redirect_uri</td>
<td>可选</td>
<td>重定向地址</td>
</tr>
<tr>
<td>scope</td>
<td>可选</td>
<td>请求授权的范围</td>
</tr>
<tr>
<td>state</td>
<td>推荐要有</td>
<td>一个不透明的值，用于在回调时进行比对，防止跨域攻击</td>
</tr>
</tbody></table>
</li>
<li><p>B：授权服务器通过UA对用户进行验证，并确认用户是否同意授权给客户端。</p>
</li>
<li><p>C：如果用户同意，在重定向回客户端，在URI中带上access token，注意四在URI中带，而不是在参数中。</p>
<p>响应包含的参数</p>
<table>
<thead>
<tr>
<th>字段</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>access_token</td>
<td>即发放的访问凭证</td>
</tr>
<tr>
<td>token_type</td>
<td>token的类型，只有在客户端理解了token的类型后才能正确使用<br />比如bearer、mac等，一般由授权服务器指定</td>
</tr>
<tr>
<td>expires_in</td>
<td>token过期时间</td>
</tr>
<tr>
<td>refresh_token</td>
<td>用来换取新access_token的token</td>
</tr>
<tr>
<td>scope</td>
<td>如果响应的scope和A步骤请求的scope一致，则可给可不给，否则，一定要给</td>
</tr>
</tbody></table>
<p>举例</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">HTTP/1.1 302 Found</span><br><span class="line">Location: http://example.com/cb#access_token=2YotnFZFEjr1zCsicMWpAA&amp;state=xyz&amp;token_type=example&amp;expires_in=3600</span><br></pre></td></tr></table></figure></li>
<li><p>D：UA将访问凭证存在本地，然后向客户端方的资源服务器请求</p>
</li>
<li><p>E：资源服务器响应一个能够从URI中解析出访问凭证的脚本</p>
</li>
<li><p>F：UA执行该脚本，提取出访问凭证</p>
</li>
<li><p>G：将访问平衡提供给客户端</p>
</li>
</ul>
<blockquote>
<p>可以看到，隐藏模式相比授权码模式，有两处改动：省掉了授权码；增加了获取解析访问凭证的脚本的步骤</p>
<p>不过，这种模式并没有见过实际应用，所以不大能理解。尤其是步骤D\E请求获取凭证的脚本那一步，并看不出必要性在哪里。</p>
</blockquote>
<h2 id="用户密码模式"><a href="#用户密码模式" class="headerlink" title="用户密码模式"></a>用户密码模式</h2><img src="https://gdz.oss-cn-shenzhen.aliyuncs.com/local/image-20211222230023551.png" alt="image-20211222230023551" style="zoom:67%;" />

<ul>
<li>A：用户向客户端提供用户名和密码</li>
<li>B：客户端使用得到的用户名和密码向授权服务发起请求，同时带上自己的访问凭证</li>
<li>C：授权服务对客户端进行鉴权，同时验证用户的用户名和密码，如果通过，则发放access token</li>
</ul>
<p>这种情况下，用户要非常信任客户端才可以。</p>
<h1 id="关于Refresh-Token"><a href="#关于Refresh-Token" class="headerlink" title="关于Refresh Token"></a>关于Refresh Token</h1><p>为什么有了Access Token，还要Refresh Token？如果发放Refresh Token，岂不是用户可以拥有永不过期的访问凭证？这样安全吗？</p>
<p>协议上只规定了两个点</p>
<ul>
<li>Refresh Token由授权服务器颁发给客户端，用于在当前Access Token失效或过期时获取新的访问令牌，或者获取具有相同或更窄范围的附加访问令牌。</li>
<li>Refresh Token是可选的</li>
</ul>
<p>我想，可以从两方面理解</p>
<ul>
<li>首先是用户体验，Access Token有效期一般不会特别长，过期时，有两种方式重新获得它：再执行一次授权逻辑；或提供一种能够直接获取Access Token的方式，即Refresh Token。前者会影响用户体验，后者肯定更好。</li>
<li>其次是安全性，同样是Token，Access Token和Refresh Token泄露带来的风险其实差不了太多，泄露后都丧失了对资源的保护；唯一的差别是Refresh Token的有效期会更长。但是一旦检测到凭证丢失，授权服务都能使他们失效。而且我们可以通过刷新时撤销Refresh Token的方式检测丢失</li>
</ul>
<h1 id="安全考量"><a href="#安全考量" class="headerlink" title="安全考量"></a>安全考量</h1><ul>
<li><p>授权码、访问凭证的传输必须走HTTPS</p>
</li>
<li><p>授权码阶段的防范</p>
<ul>
<li>防止篡改RedirectURI，篡改重定向地址可以让授权服务把授权码导向其它地址，因此授权服务需要在客户端注册时指定RedirectURI，后续步骤需要比对</li>
<li>授权码可能丢失，因此必须是短失效的。并且，授权服务在发放授权码时需要对客户端进行认证</li>
<li>隐藏模式中，访问凭证放在URI中，可能泄露出去，使用时要注意</li>
</ul>
</li>
<li><p>访问凭证发放阶段的防范</p>
<ul>
<li><p>授权服务器处理来自客户端的scope请求时，需要根据客户端的可信程度决定是否采纳其scope请求建议</p>
</li>
<li><p>访问凭证和刷新凭证需要无规律，不可推测</p>
</li>
<li><p>授权服务器处理来自客户端的scope请求时，需要根据客户端的可信程度决定是否采纳其scope请求建议</p>
</li>
<li><p>Refresh Token很重要，授权服务只能发放给跑在后端的服务和Native应用，如IOS应用。基于浏览器的应用不能签发</p>
<p>并且，它只能在客户端和授权服务之间流通，不能放到别处</p>
</li>
<li><p>Refresh Token的撤销，可以在刷新Token时同时撤销原来的Refresh Token，这样如果Refresh Token泄露并且被用过一次，则正常用户的Refresh Token会失效报错，就能识别到该系列的Refresh Token失效。</p>
</li>
</ul>
</li>
<li><p>防止CSRF攻击，授权请求时携带state参数，可以防止跨域攻击</p>
</li>
<li><p>防范钓鱼攻击，这个就只能加强用户教育了</p>
</li>
</ul>
]]></content>
      <categories>
        <category>后端</category>
      </categories>
      <tags>
        <tag>OAuth2.0</tag>
      </tags>
  </entry>
  <entry>
    <title>OpenID Connect 1.0详解</title>
    <url>/2021/12/23/OpenID/</url>
    <content><![CDATA[<p>OpenID Connect 1.0是建立在OAuth 2.0上的一个身份验证机制，它允许客户端通过授权服务对用户进行认证并获取简单的用户信息。</p>
<blockquote>
<p>前置知识：读者需要了解OAuth2.0的授权码模式和隐藏模式两种工作流程，要了解JWT、JWE、JWS等概念。这在我的前两篇文章都有详细讲解</p>
</blockquote>
<span id="more"></span>

<h2 id="概览"><a href="#概览" class="headerlink" title="概览"></a>概览</h2><h3 id="名词解释"><a href="#名词解释" class="headerlink" title="名词解释"></a>名词解释</h3><ul>
<li><p>OP：OpenID Provider，即OAuth2.0中的授权服务，用于对用户鉴权</p>
</li>
<li><p>RP：Relying Part，依赖方，即OAuth2.0中的客户端，它从OP除获取对用户的鉴权和用户信息</p>
</li>
<li><p>ID Token：是一个JWT，包含本次授权的基本信息。具体包含字段如下</p>
<table>
<thead>
<tr>
<th>字段</th>
<th>必须？</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>iss</td>
<td>是</td>
<td>发布者，一个https开头的地址</td>
</tr>
<tr>
<td>sub</td>
<td>是</td>
<td>主体，OP对用户的唯一标识，不超过255个ASCII字符</td>
</tr>
<tr>
<td>aud</td>
<td>是</td>
<td>客户，即使用者。值为OAuth2.0协议中客户端注册的client_id</td>
</tr>
<tr>
<td>exp</td>
<td>是</td>
<td>过期时间，遵从RFC 3339协议，即epoch seconds</td>
</tr>
<tr>
<td>iat</td>
<td>是</td>
<td>签发时间，同上</td>
</tr>
<tr>
<td>auth_time</td>
<td>可选</td>
<td>鉴权时间</td>
</tr>
<tr>
<td>nonce</td>
<td></td>
<td>随机值。两个作用<br />一是RP发送时带上，OP响应时带上，用于RP对比<br />二是防重放攻击</td>
</tr>
<tr>
<td>acr</td>
<td>可选</td>
<td>Authentication Context Class Reference，暂不知义，忽略</td>
</tr>
<tr>
<td>amr</td>
<td>可选</td>
<td>Authentication Methods References，暂不知义，忽略</td>
</tr>
<tr>
<td>azp</td>
<td>可选</td>
<td>Authorized party，暂不知义，忽略</td>
</tr>
</tbody></table>
</li>
</ul>
<h3 id="总体流程"><a href="#总体流程" class="headerlink" title="总体流程"></a>总体流程</h3><p>类似OAuth2.0，有一个总体流程和若干细分模式的流程，OpenID Connect协议总体流程为：RP发起请求 -&gt; OP对用户鉴权并获取授权 -&gt; OP响应RP并带上ID Token和Access Token -&gt; RP通过访问凭证向OP请求用户信息 -&gt; OP返回用户信息给RP</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">+--------+                                   +--------+</span><br><span class="line">|        |                                   |        |</span><br><span class="line">|        |---------(1) AuthN Request--------&gt;|        |</span><br><span class="line">|        |                                   |        |</span><br><span class="line">|        |  +--------+                       |        |</span><br><span class="line">|        |  |        |                       |        |</span><br><span class="line">|        |  |  End-  |&lt;--(2) AuthN &amp; AuthZ--&gt;|        |</span><br><span class="line">|        |  |  User  |                       |        |</span><br><span class="line">|   RP   |  |        |                       |   OP   |</span><br><span class="line">|        |  +--------+                       |        |</span><br><span class="line">|        |                                   |        |</span><br><span class="line">|        |&lt;--------(3) AuthN Response--------|        |</span><br><span class="line">|        |                                   |        |</span><br><span class="line">|        |---------(4) UserInfo Request-----&gt;|        |</span><br><span class="line">|        |                                   |        |</span><br><span class="line">|        |&lt;--------(5) UserInfo Response-----|        |</span><br><span class="line">|        |                                   |        |</span><br><span class="line">+--------+                                   +--------+</span><br></pre></td></tr></table></figure>

<h2 id="客户鉴权"><a href="#客户鉴权" class="headerlink" title="客户鉴权"></a>客户鉴权</h2><p>客户鉴权即OP对客户端进行鉴权，然后将鉴权结果返回给RP。鉴权流程有三种方式：授权码模式、隐藏模式、混合模式。如果了解OAuth2.0，对前两个模式一定不会模式，OpenID流程类似，而混合模式则是前两种模式的结合。具体OP采用什么模式，取决于RP请求时<code>response_type</code>给的值。</p>
<table>
<thead>
<tr>
<th>response_type</th>
<th>采用的模式</th>
</tr>
</thead>
<tbody><tr>
<td>code</td>
<td>授权码模式</td>
</tr>
<tr>
<td>id_token</td>
<td>隐藏模式</td>
</tr>
<tr>
<td>Id_token token</td>
<td>隐藏模式</td>
</tr>
<tr>
<td>code id_token</td>
<td>混合模式</td>
</tr>
<tr>
<td>code token</td>
<td>混合模式</td>
</tr>
<tr>
<td>code id_token token</td>
<td>混合模式</td>
</tr>
</tbody></table>
<blockquote>
<p>规律：id_token和token等同：只有id_token或/和token的使用隐藏模式，只有code的使用授权码模式i，同时存在他们的则使用混合模式</p>
</blockquote>
<h3 id="授权码模式"><a href="#授权码模式" class="headerlink" title="授权码模式"></a>授权码模式</h3><p>总计八个步骤</p>
<ol>
<li>RP准备用于鉴权请求的参数</li>
<li>RP发送请求，给OP</li>
<li>OP对用户鉴权</li>
<li>OP手机用户的鉴权信息和授权信息</li>
<li>OP发送授权码给RP</li>
<li>RP使用授权码向一个端点换取访问凭证。协议称之为Token端点，但没说这个端点是不是由OP提供的。不过一般来说是</li>
<li>RP收到访问凭证，包含ID Token、Access Token</li>
<li>客户端验证ID Token，并从中提取用户的唯一标识。前面说过这是一个JWT，唯一标识就是subject identifier</li>
</ol>
<p><strong>授权码的请求与响应</strong></p>
<p>其中RP准备的请求参数包含OAuth2.0规定的所有字段，也包含一些额外的字段</p>
<table>
<thead>
<tr>
<th>参数</th>
<th>必须？</th>
<th>来自OAuth2.0？</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>scope</td>
<td>是</td>
<td>是</td>
<td>写死，openid</td>
</tr>
<tr>
<td>response_type</td>
<td>是</td>
<td>是</td>
<td>写死，code</td>
</tr>
<tr>
<td>client_id</td>
<td>是</td>
<td>是</td>
<td>RP在OP处注册得到的唯一标识</td>
</tr>
<tr>
<td>redirect_uri</td>
<td>是</td>
<td>是</td>
<td>用于OP鉴权成功后的回调地址，RP在OP处注册时提供</td>
</tr>
<tr>
<td>state</td>
<td>推荐</td>
<td>是</td>
<td>请求来回中包含的不透明值，用户防范CSRF攻击</td>
</tr>
<tr>
<td>response_mode</td>
<td>否</td>
<td>是</td>
<td>OP返回数据的模式</td>
</tr>
<tr>
<td>nonce</td>
<td>否</td>
<td>否</td>
<td>会被放在ID Token的nonce字段，用于防重放攻击</td>
</tr>
<tr>
<td>display</td>
<td>否</td>
<td>否</td>
<td>定义OP通过什么方式展示用户鉴权界面<br />page：完整的网页<br />popup：弹窗<br />touch：触摸设备<br />wap：”feature phone” type display</td>
</tr>
<tr>
<td>prompt</td>
<td>否</td>
<td>否</td>
<td>定义OP通过什么方式对用户二次鉴权<br />none：不进行二次鉴权<br />login：重新登录<br />consent：获取用户同意使用上次采集到的结果即可<br />select_account：选择用户账户</td>
</tr>
<tr>
<td>max_age</td>
<td>否</td>
<td>否</td>
<td>本次鉴权的有效期。超过该时间后，OP必须对用户再次进行鉴权</td>
</tr>
<tr>
<td>ui_locales</td>
<td>否</td>
<td>否</td>
<td>用户使用的区域信息</td>
</tr>
<tr>
<td>Id_token_hint</td>
<td>否</td>
<td>否</td>
<td>忽略</td>
</tr>
<tr>
<td>login_hint</td>
<td>否</td>
<td>否</td>
<td>忽略</td>
</tr>
<tr>
<td>acr_values</td>
<td>否</td>
<td>否</td>
<td>忽略</td>
</tr>
</tbody></table>
<p>如果授权成功，得到的返回会包含code、state等参数，举个例子</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">HTTP/1.1 302 Found</span><br><span class="line">Location: https://client.example.org/cb?code=SplxlOBeZQQYbYS6WxSbIA&amp;state=af0ifjsldkj</span><br></pre></td></tr></table></figure>

<p>如果授权失败，也会有相应的错误码，具体<a href="https://openid.net/specs/openid-connect-core-1_0.html#toc">参考手册</a>的3.1.2.6</p>
<p><strong>凭证的请求与响应</strong></p>
<p>这个就完全和OAuth2.0一样了。</p>
<p>请求上主要包含：<code>grant_type</code>写死<code>authorization_code</code>、<code>code</code>填上一步获取的授权码、<code>redirect_uri</code>填上一步的重定向地址，举个例子</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">POST /token HTTP/1.1</span><br><span class="line">Host: server.example.com</span><br><span class="line">Content-Type: application/x-www-form-urlencoded</span><br><span class="line"><span class="meta">#</span><span class="bash"> 你可能注意到这里有个Basic鉴权，这是因为Client也是需要被验证的</span></span><br><span class="line">Authorization: Basic czZCaGRSa3F0MzpnWDFmQmF0M2JW</span><br><span class="line"></span><br><span class="line">grant_type=authorization_code&amp;code=SplxlOBeZQQYbYS6WxSbIA&amp;redirect_uri=https%3A%2F%2Fclient.example.org%2Fcb</span><br></pre></td></tr></table></figure>

<p>响应上多出一个<code>id_token</code>字段，举例如下</p>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line">HTTP/<span class="number">1.1</span> <span class="number">200</span> OK</span><br><span class="line">Content-Type: application/json</span><br><span class="line">Cache-Control: no-store</span><br><span class="line">Pragma: no-cache</span><br><span class="line"></span><br><span class="line">&#123;</span><br><span class="line">  <span class="attr">&quot;access_token&quot;</span>: <span class="string">&quot;SlAV32hkKG&quot;</span>,</span><br><span class="line">  <span class="attr">&quot;token_type&quot;</span>: <span class="string">&quot;Bearer&quot;</span>,</span><br><span class="line">  <span class="attr">&quot;refresh_token&quot;</span>: <span class="string">&quot;8xLOxBtZp8&quot;</span>,</span><br><span class="line">  <span class="attr">&quot;expires_in&quot;</span>: <span class="number">3600</span>,</span><br><span class="line">  <span class="attr">&quot;id_token&quot;</span>: <span class="string">&quot;eyJhbGciOiJSUzI1NiIsImtpZCI6IjFlOWdkazcifQ.ewogImlzc</span></span><br><span class="line"><span class="string">    yI6ICJodHRwOi8vc2VydmVyLmV4YW1wbGUuY29tIiwKICJzdWIiOiAiMjQ4Mjg5</span></span><br><span class="line"><span class="string">    NzYxMDAxIiwKICJhdWQiOiAiczZCaGRSa3F0MyIsCiAibm9uY2UiOiAibi0wUzZ</span></span><br><span class="line"><span class="string">    fV3pBMk1qIiwKICJleHAiOiAxMzExMjgxOTcwLAogImlhdCI6IDEzMTEyODA5Nz</span></span><br><span class="line"><span class="string">    AKfQ.ggW8hZ1EuVLuxNuuIJKX_V8a_OMXzR0EHR9R6jgdqrOOF4daGU96Sr_P6q</span></span><br><span class="line"><span class="string">    Jp6IcmD3HP99Obi1PRs-cwh3LO-p146waJ8IhehcwL7F09JdijmBqkvPeB2T9CJ</span></span><br><span class="line"><span class="string">    NqeGpe-gccMg4vfKjkM8FcGvnzZUN4_KSP0aAp1tOJ1zZwgjxqGByKHiOtX7Tpd</span></span><br><span class="line"><span class="string">    QyHE5lcMiKPXfEIQILVq0pc_E2DzL7emopWoaoZTF_m0_N0YzFC6g6EJbOEoRoS</span></span><br><span class="line"><span class="string">    K5hoDalrcvRYLSrQAZZKflyuVCyixEoV9GfNQC3_osjzw2PAithfubEEBLuVVk4</span></span><br><span class="line"><span class="string">    XUVrWOLrLl0nx7RkKU8NXNHq-rvKMzqg&quot;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>在上面的每一方，比如OP收到请求、RP收到响应，都会对得到的数据进行验证，我们都忽略了，不过这里重点将RP收到ID Token后的验证逻辑列出来</p>
<ol>
<li>依据JWT协议解密该Token</li>
<li>iss字段必须匹配RP提前获取到的OP的issuer值</li>
<li>aud字段必须是RP在OP处注册时填写的client_id</li>
<li>如果包含多个aud字段，则还要验证azp字段</li>
<li>如果azp字段存在，则它的值必须是RP在OP处注册时填写的client_id</li>
<li>如果ID Token是RP直接从OP处获取，没有走授权码这一步（比如走隐藏模式的流程），必须走JWS流程验证该JWT的签名</li>
<li>alg的值要么为默认的RS256，要么是RP在OP处注册时通过id_token_signed_response_alg字段指定的算法</li>
<li>exp所展示的时间必须比当前时间晚</li>
<li>iat可以用来识别签发时间过久的JWT，太久的可以拒掉，多久算久，这个取决于RP自己</li>
<li>nonce必须和请求授权码时对应上</li>
<li>acr必须和请求授权码时对应上</li>
<li>接和auth_time、max_age，可以判断举例上一次时间是不是太久，从而决定是否需要重新发起鉴权请求</li>
</ol>
</blockquote>
<h3 id="隐藏模式"><a href="#隐藏模式" class="headerlink" title="隐藏模式"></a>隐藏模式</h3><p>这个模式就比较简单了</p>
<ol>
<li>RP准备请求参数</li>
<li>RP发送请求</li>
<li>OP认证用户</li>
<li>OP获取用户的认证和授权信息</li>
<li>OP发送ID Token，可能还有Access Token给RP</li>
<li>RP验证ID Token，提取用户的标识</li>
</ol>
<p><strong>请求</strong></p>
<p>请求参数和授权码模式基本一样，这里列出差别</p>
<ul>
<li>response_type：id_token，或者<code>id_token token</code>，差别是，如果加上token，步骤5会返回Access Token，否则就么有</li>
<li>redirect_uri：处于安全考虑，这个地方必须使用HTTPS传输</li>
<li>nonce：这个变成了必须的</li>
</ul>
<p><strong>响应</strong></p>
<p>给个例子就好了</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">HTTP/1.1 302 Found</span><br><span class="line">Location: https://client.example.org/cb#</span><br><span class="line">  access_token=SlAV32hkKG</span><br><span class="line">  &amp;token_type=bearer</span><br><span class="line">  &amp;id_token=eyJ0 ... NiJ9.eyJ1c ... I6IjIifX0.DeWt4Qu ... ZXso</span><br><span class="line">  &amp;expires_in=3600</span><br><span class="line">  &amp;state=af0ifjsldkj</span><br></pre></td></tr></table></figure>

<blockquote>
<p>与前面不同的是，这里会多一个Access Token的验证，它要结合ID Token中的at_hash字段验证</p>
<ul>
<li>使用ID Token中头部alg字段指定的算法对Access Token进行哈希</li>
<li>对哈希值进行base64url编码，取左半边</li>
<li>上一步得到的值必须和ID Token中的at_hash字段指定的值匹配</li>
</ul>
</blockquote>
<h3 id="混合模式"><a href="#混合模式" class="headerlink" title="混合模式"></a>混合模式</h3><ol>
<li>RP准备请求</li>
<li>RP发送请求给OP</li>
<li>OP对用户鉴权</li>
<li>OP采集用户的鉴权和授权信息</li>
<li>OP发送给RP授权码，同时根据请求时指定的<code>response_type</code>，发送额外的参数</li>
<li>RP通过授权码向OP请求</li>
<li>RP从OP处得到ID Token和Access Token</li>
<li>RP验证ID Token，解析用户的唯一标识</li>
</ol>
<p><strong>授权码请求</strong></p>
<p>混合模式在response_type上做文章，允许的值包括：<code>code id_token</code>、<code>code token</code>、<code>code id_token token</code>。可以看出，在授权码请求这一步，可能会返回授权码、ID Token、Access Token。下面是一个返回授权码和ID Token的例子</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">HTTP/1.1 302 Found</span><br><span class="line">Location: https://client.example.org/cb#</span><br><span class="line">code=SplxlOBeZQQYbYS6WxSbIA</span><br><span class="line">&amp;id_token=eyJ0 ... NiJ9.eyJ1c ... I6IjIifX0.DeWt4Qu ... ZXso</span><br><span class="line">&amp;state=af0ifjsldkj</span><br></pre></td></tr></table></figure>

<blockquote>
<p>如果返回值有ID Token，它会包含授权码的签名，对应其c_hash字段，计算方式和隐藏模式的Access Token验证差不多。</p>
</blockquote>
<p>至此，混合模式看起来很奇怪，体现在两处</p>
<ul>
<li>ID Token既能在授权码请求时返回，也能在Access Token请求时返回</li>
<li>Access Token也有上面的情况</li>
</ul>
<p>这样做有什么意义呢？</p>
<h3 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h3><p>ID Token的意义，主要在于以安全的方式分发用户的唯一标识，Access Token才是用来作为访问凭证的。</p>
<h2 id="获取用户信息"><a href="#获取用户信息" class="headerlink" title="获取用户信息"></a>获取用户信息</h2><p>上面介绍了获取访问凭证之前的动作，这里介绍使用访问凭证访问ID Token指定的用户的信息的问题。</p>
<h3 id="能获得什么"><a href="#能获得什么" class="headerlink" title="能获得什么"></a>能获得什么</h3><p>获得的内容和请求访问凭证时传的scope有关，具体如下。</p>
<table>
<thead>
<tr>
<th>字段</th>
<th>scope</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>sub</td>
<td>-</td>
<td>唯一标识，对应JWT的sub</td>
</tr>
<tr>
<td>name</td>
<td>profile</td>
<td>用户全名</td>
</tr>
<tr>
<td>given_name</td>
<td>profile</td>
<td>名</td>
</tr>
<tr>
<td>family_name</td>
<td>profile</td>
<td>姓</td>
</tr>
<tr>
<td>middle_name</td>
<td>profile</td>
<td>中间名，这个某些文化有关</td>
</tr>
<tr>
<td>nickname</td>
<td>profile</td>
<td>昵称</td>
</tr>
<tr>
<td>perferred_username</td>
<td>profile</td>
<td>用户希望展示给RP的名字</td>
</tr>
<tr>
<td>profile</td>
<td>profile</td>
<td>用户的概览信息的页面URI</td>
</tr>
<tr>
<td>picture</td>
<td>profile</td>
<td>用户图片的URI</td>
</tr>
<tr>
<td>website</td>
<td>profile</td>
<td>用户的网站或者博客URI</td>
</tr>
<tr>
<td>email</td>
<td>email</td>
<td>用户邮箱</td>
</tr>
<tr>
<td>email_verified</td>
<td>email</td>
<td>邮箱是否通过验证。如果没有，这可能是用户随便填写的一个邮箱</td>
</tr>
<tr>
<td>gender</td>
<td>profile</td>
<td>性别</td>
</tr>
<tr>
<td>birthdate</td>
<td>profile</td>
<td>生日</td>
</tr>
<tr>
<td>zoneinfo</td>
<td>profile</td>
<td>用户所处时区信息</td>
</tr>
<tr>
<td>locale</td>
<td>profile</td>
<td>用户所处地域，语言环境</td>
</tr>
<tr>
<td>phone_number</td>
<td>phone</td>
<td>电话号码</td>
</tr>
<tr>
<td>phone_number_verified</td>
<td>phone</td>
<td>电话号码是否通过验证</td>
</tr>
<tr>
<td>address</td>
<td>address</td>
<td>地址，这是一个JSON对象</td>
</tr>
<tr>
<td>updated_at</td>
<td>profile</td>
<td>用户的这些信息最后一次被更新的时间，epoch seconds</td>
</tr>
</tbody></table>
<blockquote>
<p>scope可以指定多个值，得到的结果就是并集。比如<code>scope=profile email phone address</code></p>
</blockquote>
<p>一个成功的例子</p>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line">HTTP/<span class="number">1.1</span> <span class="number">200</span> OK</span><br><span class="line">Content-Type: application/json</span><br><span class="line"></span><br><span class="line">&#123;</span><br><span class="line">  <span class="attr">&quot;sub&quot;</span>: <span class="string">&quot;248289761001&quot;</span>,</span><br><span class="line">  <span class="attr">&quot;name&quot;</span>: <span class="string">&quot;Jane Doe&quot;</span>,</span><br><span class="line">  <span class="attr">&quot;given_name&quot;</span>: <span class="string">&quot;Jane&quot;</span>,</span><br><span class="line">  <span class="attr">&quot;family_name&quot;</span>: <span class="string">&quot;Doe&quot;</span>,</span><br><span class="line">  <span class="attr">&quot;preferred_username&quot;</span>: <span class="string">&quot;j.doe&quot;</span>,</span><br><span class="line">  <span class="attr">&quot;email&quot;</span>: <span class="string">&quot;janedoe@example.com&quot;</span>,</span><br><span class="line">  <span class="attr">&quot;picture&quot;</span>: <span class="string">&quot;http://example.com/janedoe/me.jpg&quot;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="另类获取信息的方式-claims"><a href="#另类获取信息的方式-claims" class="headerlink" title="另类获取信息的方式 - claims"></a>另类获取信息的方式 - claims</h3><p>可以在请求时加上claims参数，指定能够从用户信息端点或者在ID Token中包含什么信息，它是一个类似json schema的东西，如下是例子：要求给的字段，以及字段是否必要。</p>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="attr">&quot;userinfo&quot;</span>:</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="attr">&quot;given_name&quot;</span>: &#123;<span class="attr">&quot;essential&quot;</span>: <span class="literal">true</span>&#125;,</span><br><span class="line">    <span class="attr">&quot;nickname&quot;</span>: <span class="literal">null</span>,</span><br><span class="line">    <span class="attr">&quot;email&quot;</span>: &#123;<span class="attr">&quot;essential&quot;</span>: <span class="literal">true</span>&#125;,</span><br><span class="line">    <span class="attr">&quot;email_verified&quot;</span>: &#123;<span class="attr">&quot;essential&quot;</span>: <span class="literal">true</span>&#125;,</span><br><span class="line">    <span class="attr">&quot;picture&quot;</span>: <span class="literal">null</span>,</span><br><span class="line">    <span class="attr">&quot;http://example.info/claims/groups&quot;</span>: <span class="literal">null</span></span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="attr">&quot;id_token&quot;</span>:</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="attr">&quot;auth_time&quot;</span>: &#123;<span class="attr">&quot;essential&quot;</span>: <span class="literal">true</span>&#125;,</span><br><span class="line">    <span class="attr">&quot;acr&quot;</span>: &#123;<span class="attr">&quot;values&quot;</span>: [<span class="string">&quot;urn:mace:incommon:iap:silver&quot;</span>] &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>理解了OAuth2.0的工作流程，再理解OpenID Connect就很容易了，相较而言，它的特点如下</p>
<ul>
<li>OP = 授权服务+资源服务，资源服务的唯一作用就是分发用户信息</li>
<li>规定了用户信息包含的内容</li>
<li>Token响应中多了ID Token，它用来指定用户ID，以便在访问用户信息时作为标识</li>
<li>ID Token使用了JWT</li>
<li>多了混合模式</li>
</ul>
]]></content>
      <categories>
        <category>后端</category>
      </categories>
      <tags>
        <tag>OpenID Connect</tag>
      </tags>
  </entry>
  <entry>
    <title>PostgreSQL - 一文看懂explain</title>
    <url>/2020/08/01/PostgreSQL%20-%20%E4%B8%80%E6%96%87%E7%9C%8B%E6%87%82explain-postgresql-yi-wen-kan-dong-explain/</url>
    <content><![CDATA[<blockquote>
<p>explain是SQL优化的前提。但explain的结果，无论是官方手册，还是别人写的博客，看完后点头如捣蒜，但往往看到自己SQL的执行计划时，并不很确定要优化的点在哪里。很大一部分原因是不知道各计划节点的具体含义，更确切地说，是不明白SQL执行的原理。比如，我们并不能很好地回答以下问题</p>
<ul>
<li>index scan、index only scan、bitmap index scan 有啥区别？</li>
<li>为什么明明有建立索引，但PG就是不用呢？</li>
<li>执行计划中有子查询就一定不好吗？</li>
<li>hash join、merge join、nestloop join有啥区别？</li>
<li>。。。。。。</li>
</ul>
<p>本文的目的，是让大家看懂SQL执行计划。毕竟，看懂了，才谈得上优化。</p>
</blockquote>
<span id="more"></span>

<p>只有在了解数据库针对SQL做了哪些优化，才能制定出合理策略，利用优化器本身的特性达到最终优化整个SQL的最终目的，因此我们首先会介绍SQL优化器的原理；而本文的目的是让大家看懂explain，因此会介绍执行计划中最核心的部分——扫描节点和连接节点，大部分的优化思路都来自于此；文章的最后介绍explain命令得到的结果每一部分的具体含义，并介绍方便查看复杂计划的可视化工具。</p>
<h2 id="查询优化器原理"><a href="#查询优化器原理" class="headerlink" title="查询优化器原理"></a>查询优化器原理</h2><p>在介绍执行计划前，先了解一下执行计划生成的原理。一条SQL从输入到执行完毕，大致会经历如下三个步骤</p>
<ol>
<li>语法分析：词法分析、语法分析、语义分析</li>
<li><strong>查询优化：基于规则的优化、基于代价的优化</strong></li>
<li>查询执行、数据存取</li>
</ol>
<p>explain的输出，是查询优化的最终结果。而查询优化又被分为两个步骤</p>
<ul>
<li><p>基于规则的优化：即逻辑优化，通过对关系代数表达式进行逻辑上的等价变换，以获得性能更好的计划，比如谓词下推（将上层的过滤条件下推到下层）。</p>
</li>
<li><p>基于代价的优化：即物理优化，逻辑优化后，实际的查询路径还是有很多种，PG建立了代价计算模型，计算所有可能路径的代价，选出最优路径。</p>
<p>比如<code>select * from users where id = 1</code>，在扫描方式上，有顺序扫描、索引扫描等。在不同的数据量情况下，按顺序扫描和索引扫描的代价可能是不一样的，因此它的执行计划可能会随数据量的变化而变化。</p>
</li>
</ul>
<h3 id="逻辑优化（基于规则的优化）"><a href="#逻辑优化（基于规则的优化）" class="headerlink" title="逻辑优化（基于规则的优化）"></a>逻辑优化（基于规则的优化）</h3><p>基于逻辑的等价变换，可对原始的SQL语句进行优化。逻辑优化的基本原则——将复杂逻辑变为简单逻辑。具体做的工作，大致是提升子查询、表达式预处理、having子句条件下推、group by冗余字段消除、谓词（过滤条件）下推、外连接消除等。</p>
<h4 id="子查询提升"><a href="#子查询提升" class="headerlink" title="子查询提升"></a>子查询提升</h4><p>子查询可分为如下两类</p>
<ul>
<li><p>相关子查询：子查询中引用外层表的列属性，导致外层表的每一条记录，子查询都需要重新执行一次</p>
</li>
<li><p>非相关子查询：子查询是独立的，与外层表没有直接的关联，子查询单独执行一次，外层表可以重复利用其结果</p>
</li>
</ul>
<p>通常来说，相关子查询会被提升，非相关子查询由于其本来就只执行一次，因此没有太大必要提升。</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="comment">-- 相关子查询举例</span></span><br><span class="line">explain <span class="keyword">select</span> <span class="operator">*</span>, (<span class="keyword">select</span> label_id <span class="keyword">from</span> content_to_label <span class="keyword">where</span> content_id <span class="operator">=</span> content.id) <span class="keyword">as</span> label_id <span class="keyword">from</span> content;</span><br><span class="line">HotSpotIntrinsicCandidate</span><br><span class="line">Seq Scan <span class="keyword">on</span> content  (cost<span class="operator">=</span><span class="number">0.00</span>.<span class="number">.3694</span><span class="number">.61</span> <span class="keyword">rows</span><span class="operator">=</span><span class="number">1151</span> width<span class="operator">=</span><span class="number">743</span>)</span><br><span class="line">  SubPlan <span class="number">1</span></span><br><span class="line">    <span class="operator">-</span><span class="operator">&gt;</span>  Seq Scan <span class="keyword">on</span> content_to_label  (cost<span class="operator">=</span><span class="number">0.00</span>.<span class="number">.3</span><span class="number">.10</span> <span class="keyword">rows</span><span class="operator">=</span><span class="number">3</span> width<span class="operator">=</span><span class="number">4</span>)</span><br><span class="line">          <span class="keyword">Filter</span>: (content_id <span class="operator">=</span> content.id)</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 非相关子查询举例</span></span><br><span class="line">explain <span class="keyword">select</span> <span class="operator">*</span>, (<span class="keyword">select</span> label_id <span class="keyword">from</span> content_to_label limit <span class="number">1</span>) <span class="keyword">as</span> label_id <span class="keyword">from</span> content;</span><br><span class="line"></span><br><span class="line">Seq Scan <span class="keyword">on</span> content  (cost<span class="operator">=</span><span class="number">0.02</span>.<span class="number">.126</span><span class="number">.53</span> <span class="keyword">rows</span><span class="operator">=</span><span class="number">1151</span> width<span class="operator">=</span><span class="number">743</span>)</span><br><span class="line">  InitPlan <span class="number">1</span> (<span class="keyword">returns</span> $<span class="number">0</span>)</span><br><span class="line">    <span class="operator">-</span><span class="operator">&gt;</span>  Limit  (cost<span class="operator">=</span><span class="number">0.00</span>.<span class="number">.0</span><span class="number">.02</span> <span class="keyword">rows</span><span class="operator">=</span><span class="number">1</span> width<span class="operator">=</span><span class="number">4</span>)</span><br><span class="line">          <span class="operator">-</span><span class="operator">&gt;</span>  Seq Scan <span class="keyword">on</span> content_to_label  (cost<span class="operator">=</span><span class="number">0.00</span>.<span class="number">.2</span><span class="number">.68</span> <span class="keyword">rows</span><span class="operator">=</span><span class="number">168</span> width<span class="operator">=</span><span class="number">4</span>)</span><br></pre></td></tr></table></figure>

<p>相关子查询又可以依据子查询出现的位置分为如下两种——子查询和子连接，他们都能够被提升。</p>
<ul>
<li><p>子查询语句：出现在FROM关键字后的是子查询语句</p>
</li>
<li><p>子连接语句：出现在WHERE/ON等约束条件或SELECT子句中的是子连接语句</p>
</li>
</ul>
<p><strong>提升子连接</strong></p>
<p>子连接是子查询的一种特殊情况，由于它常出现在条件中，因此通常伴随ANY、EXISTS、NOT EXISTS、IN、NOT IN等关键字，PG会对他们尝试做提升，比如</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="comment">-- 查询那些打过标签的文章</span></span><br><span class="line">explain <span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> content <span class="keyword">where</span> <span class="keyword">exists</span>(<span class="keyword">select</span> <span class="number">1</span> <span class="keyword">from</span> content_to_label <span class="keyword">where</span> content_id <span class="operator">=</span> content.id);</span><br><span class="line"><span class="comment">-- 在不优化的情况下，exists子查询会像上面所示，真的是子查询。但这里优化器将子查询做了提升，提升后变成连接，通过将内表hash化，降低算法复杂度</span></span><br><span class="line">Hash <span class="keyword">Join</span>  (cost<span class="operator">=</span><span class="number">4.43</span>.<span class="number">.134</span><span class="number">.62</span> <span class="keyword">rows</span><span class="operator">=</span><span class="number">59</span> width<span class="operator">=</span><span class="number">739</span>)</span><br><span class="line">  Hash Cond: (content.id <span class="operator">=</span> content_to_label.content_id)</span><br><span class="line">  <span class="operator">-</span><span class="operator">&gt;</span>  Seq Scan <span class="keyword">on</span> content  (cost<span class="operator">=</span><span class="number">0.00</span>.<span class="number">.126</span><span class="number">.51</span> <span class="keyword">rows</span><span class="operator">=</span><span class="number">1151</span> width<span class="operator">=</span><span class="number">739</span>)</span><br><span class="line">  <span class="operator">-</span><span class="operator">&gt;</span>  Hash  (cost<span class="operator">=</span><span class="number">3.69</span>.<span class="number">.3</span><span class="number">.69</span> <span class="keyword">rows</span><span class="operator">=</span><span class="number">59</span> width<span class="operator">=</span><span class="number">4</span>)</span><br><span class="line">        <span class="operator">-</span><span class="operator">&gt;</span>  HashAggregate  (cost<span class="operator">=</span><span class="number">3.10</span>.<span class="number">.3</span><span class="number">.69</span> <span class="keyword">rows</span><span class="operator">=</span><span class="number">59</span> width<span class="operator">=</span><span class="number">4</span>)</span><br><span class="line">              <span class="keyword">Group</span> Key: content_to_label.content_id</span><br><span class="line">              <span class="operator">-</span><span class="operator">&gt;</span>  Seq Scan <span class="keyword">on</span> content_to_label  (cost<span class="operator">=</span><span class="number">0.00</span>.<span class="number">.2</span><span class="number">.68</span> <span class="keyword">rows</span><span class="operator">=</span><span class="number">168</span> width<span class="operator">=</span><span class="number">4</span>)</span><br></pre></td></tr></table></figure>

<p>能够被提升还有一个前提条件是子查询必须足够简单，上面同样的SQL，子查询投影改成聚集函数，就无法提升</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">explain <span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> content <span class="keyword">where</span> <span class="keyword">exists</span>(<span class="keyword">select</span> <span class="built_in">sum</span>(content_id) <span class="keyword">from</span> content_to_label <span class="keyword">where</span> content_id <span class="operator">=</span> content.id);</span><br><span class="line"></span><br><span class="line">Seq Scan <span class="keyword">on</span> content  (cost<span class="operator">=</span><span class="number">0.00</span>.<span class="number">.3714</span><span class="number">.75</span> <span class="keyword">rows</span><span class="operator">=</span><span class="number">576</span> width<span class="operator">=</span><span class="number">739</span>)</span><br><span class="line">  <span class="keyword">Filter</span>: (SubPlan <span class="number">1</span>)</span><br><span class="line">  SubPlan <span class="number">1</span></span><br><span class="line">    <span class="operator">-</span><span class="operator">&gt;</span>  Aggregate  (cost<span class="operator">=</span><span class="number">3.11</span>.<span class="number">.3</span><span class="number">.12</span> <span class="keyword">rows</span><span class="operator">=</span><span class="number">1</span> width<span class="operator">=</span><span class="number">8</span>)</span><br><span class="line">          <span class="operator">-</span><span class="operator">&gt;</span>  Seq Scan <span class="keyword">on</span> content_to_label  (cost<span class="operator">=</span><span class="number">0.00</span>.<span class="number">.3</span><span class="number">.10</span> <span class="keyword">rows</span><span class="operator">=</span><span class="number">3</span> width<span class="operator">=</span><span class="number">4</span>)</span><br><span class="line">                <span class="keyword">Filter</span>: (content_id <span class="operator">=</span> content.id)</span><br></pre></td></tr></table></figure>

<p><strong>提升子查询</strong></p>
<p>出现在表位置的子查询，也能够提升，如下</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">explain <span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> content <span class="keyword">left</span> <span class="keyword">join</span> (<span class="keyword">select</span> <span class="operator">*</span>, <span class="number">1</span> <span class="keyword">from</span> content_to_label) ctl <span class="keyword">on</span> content.id <span class="operator">=</span> ctl.content_id;</span><br><span class="line"></span><br><span class="line">Hash <span class="keyword">Right</span> <span class="keyword">Join</span>  (cost<span class="operator">=</span><span class="number">140.90</span>.<span class="number">.144</span><span class="number">.02</span> <span class="keyword">rows</span><span class="operator">=</span><span class="number">1151</span> width<span class="operator">=</span><span class="number">759</span>)</span><br><span class="line">  Hash Cond: (content_to_label.content_id <span class="operator">=</span> content.id)</span><br><span class="line">  <span class="operator">-</span><span class="operator">&gt;</span>  Seq Scan <span class="keyword">on</span> content_to_label  (cost<span class="operator">=</span><span class="number">0.00</span>.<span class="number">.2</span><span class="number">.68</span> <span class="keyword">rows</span><span class="operator">=</span><span class="number">168</span> width<span class="operator">=</span><span class="number">20</span>)</span><br><span class="line">  <span class="operator">-</span><span class="operator">&gt;</span>  Hash  (cost<span class="operator">=</span><span class="number">126.51</span>.<span class="number">.126</span><span class="number">.51</span> <span class="keyword">rows</span><span class="operator">=</span><span class="number">1151</span> width<span class="operator">=</span><span class="number">739</span>)</span><br><span class="line">        <span class="operator">-</span><span class="operator">&gt;</span>  Seq Scan <span class="keyword">on</span> content  (cost<span class="operator">=</span><span class="number">0.00</span>.<span class="number">.126</span><span class="number">.51</span> <span class="keyword">rows</span><span class="operator">=</span><span class="number">1151</span> width<span class="operator">=</span><span class="number">739</span>)</span><br></pre></td></tr></table></figure>

<h4 id="预处理表达式"><a href="#预处理表达式" class="headerlink" title="预处理表达式"></a>预处理表达式</h4><p>即将能够事先处理的表达式处理掉，比如常量结算、约束条件的逻辑简化等</p>
<ul>
<li><p>常量简化</p>
<p>即直接计算出SQL中的常量表达式</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="comment">-- 可以直接计算出101</span></span><br><span class="line">explain <span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> content <span class="keyword">where</span> id <span class="operator">&lt;</span> <span class="number">1</span> <span class="operator">+</span> <span class="number">100</span></span><br><span class="line"></span><br><span class="line">Bitmap Heap Scan <span class="keyword">on</span> content  (cost<span class="operator">=</span><span class="number">5.08</span>.<span class="number">.123</span><span class="number">.47</span> <span class="keyword">rows</span><span class="operator">=</span><span class="number">104</span> width<span class="operator">=</span><span class="number">739</span>)</span><br><span class="line">  Recheck Cond: (id <span class="operator">&lt;</span> <span class="number">101</span>)</span><br><span class="line">  <span class="operator">-</span><span class="operator">&gt;</span>  Bitmap Index Scan <span class="keyword">on</span> content_pkey  (cost<span class="operator">=</span><span class="number">0.00</span>.<span class="number">.5</span><span class="number">.06</span> <span class="keyword">rows</span><span class="operator">=</span><span class="number">104</span> width<span class="operator">=</span><span class="number">0</span>)</span><br><span class="line">        Index Cond: (id <span class="operator">&lt;</span> <span class="number">101</span>)</span><br></pre></td></tr></table></figure></li>
<li><p>谓词规范化（规约、拉平、提取公共项）</p>
<p>对无用的约束条件去除</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="comment">-- false对于或运算是没用的，会被优化器直接去除</span></span><br><span class="line">explain <span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> content <span class="keyword">where</span> id <span class="operator">&lt;</span> <span class="number">100</span> <span class="keyword">or</span> <span class="literal">false</span></span><br><span class="line"></span><br><span class="line">Bitmap Heap Scan <span class="keyword">on</span> content  (cost<span class="operator">=</span><span class="number">5.08</span>.<span class="number">.123</span><span class="number">.45</span> <span class="keyword">rows</span><span class="operator">=</span><span class="number">103</span> width<span class="operator">=</span><span class="number">739</span>)</span><br><span class="line">  Recheck Cond: (id <span class="operator">&lt;</span> <span class="number">100</span>)</span><br><span class="line">  <span class="operator">-</span><span class="operator">&gt;</span>  Bitmap Index Scan <span class="keyword">on</span> content_pkey  (cost<span class="operator">=</span><span class="number">0.00</span>.<span class="number">.5</span><span class="number">.05</span> <span class="keyword">rows</span><span class="operator">=</span><span class="number">103</span> width<span class="operator">=</span><span class="number">0</span>)</span><br><span class="line">        Index Cond: (id <span class="operator">&lt;</span> <span class="number">100</span>)</span><br></pre></td></tr></table></figure>

<p>约束条件会被拉平</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="comment">-- 约束条件进行了无谓的括号，会被拉平</span></span><br><span class="line">explain <span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> content <span class="keyword">where</span> id <span class="operator">&lt;</span> <span class="number">100</span> <span class="keyword">or</span> (id <span class="operator">&lt;</span> <span class="number">1000</span> <span class="keyword">or</span> id <span class="operator">&gt;</span> <span class="number">2000</span>)</span><br><span class="line"></span><br><span class="line">Seq Scan <span class="keyword">on</span> content  (cost<span class="operator">=</span><span class="number">0.00</span>.<span class="number">.135</span><span class="number">.14</span> <span class="keyword">rows</span><span class="operator">=</span><span class="number">978</span> width<span class="operator">=</span><span class="number">739</span>)</span><br><span class="line">  <span class="keyword">Filter</span>: ((id <span class="operator">&lt;</span> <span class="number">100</span>) <span class="keyword">OR</span> (id <span class="operator">&lt;</span> <span class="number">1000</span>) <span class="keyword">OR</span> (id <span class="operator">&gt;</span> <span class="number">2000</span>))</span><br></pre></td></tr></table></figure>

<p>约束条件经过逻辑运算后，会被提取公共项</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="comment">-- 约束条件提取公共项，只剩下id &gt; 1 and id &lt; 2</span></span><br><span class="line">explain <span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> content <span class="keyword">where</span> (id <span class="operator">&gt;</span> <span class="number">1</span> <span class="keyword">and</span> id <span class="operator">&lt;</span> <span class="number">2</span> <span class="keyword">and</span> id <span class="operator">&lt;</span> <span class="number">100</span>) <span class="keyword">or</span> (id <span class="operator">&gt;</span> <span class="number">1</span> <span class="keyword">and</span> id <span class="operator">&lt;</span> <span class="number">2</span>);</span><br><span class="line"></span><br><span class="line">Index Scan <span class="keyword">using</span> content_pkey <span class="keyword">on</span> content  (cost<span class="operator">=</span><span class="number">0.28</span>.<span class="number">.8</span><span class="number">.30</span> <span class="keyword">rows</span><span class="operator">=</span><span class="number">1</span> width<span class="operator">=</span><span class="number">739</span>)</span><br><span class="line">  Index Cond: ((id <span class="operator">&gt;</span> <span class="number">1</span>) <span class="keyword">AND</span> (id <span class="operator">&lt;</span> <span class="number">2</span>))</span><br></pre></td></tr></table></figure></li>
</ul>
<h4 id="处理HAVING子句"><a href="#处理HAVING子句" class="headerlink" title="处理HAVING子句"></a>处理HAVING子句</h4><p>HAVING子句的优化主要是将部分条件转变为普通的过滤条件，从而减少原始数据的大小。</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="comment">-- 统计发过发过10篇以上内容且用户id&gt;10的用户</span></span><br><span class="line">explain <span class="keyword">select</span> &quot;authorId&quot; <span class="keyword">from</span> content <span class="keyword">group</span> <span class="keyword">by</span> &quot;authorId&quot; <span class="keyword">having</span> <span class="built_in">count</span>(<span class="number">1</span>) <span class="operator">&gt;</span> <span class="number">10</span> <span class="keyword">and</span> &quot;authorId&quot; <span class="operator">&gt;</span> <span class="number">100</span>;</span><br><span class="line"></span><br><span class="line">HashAggregate  (cost<span class="operator">=</span><span class="number">132.85</span>.<span class="number">.133</span><span class="number">.50</span> <span class="keyword">rows</span><span class="operator">=</span><span class="number">65</span> width<span class="operator">=</span><span class="number">4</span>)</span><br><span class="line">  <span class="keyword">Group</span> Key: &quot;authorId&quot;</span><br><span class="line">  <span class="keyword">Filter</span>: (<span class="built_in">count</span>(<span class="number">1</span>) <span class="operator">&gt;</span> <span class="number">10</span>)</span><br><span class="line">  <span class="operator">-</span><span class="operator">&gt;</span>  Seq Scan <span class="keyword">on</span> content  (cost<span class="operator">=</span><span class="number">0.00</span>.<span class="number">.129</span><span class="number">.39</span> <span class="keyword">rows</span><span class="operator">=</span><span class="number">692</span> width<span class="operator">=</span><span class="number">4</span>)</span><br><span class="line">        <span class="keyword">Filter</span>: (&quot;authorId&quot; <span class="operator">&gt;</span> <span class="number">100</span>)</span><br></pre></td></tr></table></figure>

<h4 id="GroupBy键值消除"><a href="#GroupBy键值消除" class="headerlink" title="GroupBy键值消除"></a>GroupBy键值消除</h4><p>GroupBy子句需要借助排序或哈希实现，如果能减少它后面的字段，就能降低损耗。典型的是如果group by中出现了一个主键和多个不相关的字段，则仅保留主键即可，因为主键唯一不可重复，没有必要再对其他字段进行排序或hash操作了</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">explain <span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> content <span class="keyword">group</span> <span class="keyword">by</span> id, type, &quot;authorId&quot;;</span><br><span class="line"></span><br><span class="line">HashAggregate  (cost<span class="operator">=</span><span class="number">129.39</span>.<span class="number">.140</span><span class="number">.90</span> <span class="keyword">rows</span><span class="operator">=</span><span class="number">1151</span> width<span class="operator">=</span><span class="number">739</span>)</span><br><span class="line">  <span class="keyword">Group</span> Key: id</span><br><span class="line">  <span class="operator">-</span><span class="operator">&gt;</span>  Seq Scan <span class="keyword">on</span> content  (cost<span class="operator">=</span><span class="number">0.00</span>.<span class="number">.126</span><span class="number">.51</span> <span class="keyword">rows</span><span class="operator">=</span><span class="number">1151</span> width<span class="operator">=</span><span class="number">739</span>)</span><br></pre></td></tr></table></figure>

<h4 id="谓词下推"><a href="#谓词下推" class="headerlink" title="谓词下推"></a>谓词下推</h4><p>谓词即筛选条件，将上层的条件下推到基层进行扫描，会带来性能上的提升。</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="comment">-- 过滤条件下推</span></span><br><span class="line">explain <span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> content <span class="keyword">left</span> <span class="keyword">join</span> content_to_label ctl <span class="keyword">on</span> content.id <span class="operator">=</span> ctl.content_id <span class="keyword">where</span> content.id <span class="operator">&lt;</span> <span class="number">100</span>;</span><br><span class="line"></span><br><span class="line">Hash <span class="keyword">Right</span> <span class="keyword">Join</span>  (cost<span class="operator">=</span><span class="number">125.48</span>.<span class="number">.128</span><span class="number">.60</span> <span class="keyword">rows</span><span class="operator">=</span><span class="number">103</span> width<span class="operator">=</span><span class="number">755</span>)</span><br><span class="line">  Hash Cond: (ctl.content_id <span class="operator">=</span> content.id)</span><br><span class="line">  <span class="operator">-</span><span class="operator">&gt;</span>  Seq Scan <span class="keyword">on</span> content_to_label ctl  (cost<span class="operator">=</span><span class="number">0.00</span>.<span class="number">.2</span><span class="number">.68</span> <span class="keyword">rows</span><span class="operator">=</span><span class="number">168</span> width<span class="operator">=</span><span class="number">16</span>)</span><br><span class="line">  <span class="operator">-</span><span class="operator">&gt;</span>  Hash  (cost<span class="operator">=</span><span class="number">124.19</span>.<span class="number">.124</span><span class="number">.19</span> <span class="keyword">rows</span><span class="operator">=</span><span class="number">103</span> width<span class="operator">=</span><span class="number">739</span>)</span><br><span class="line">        <span class="operator">-</span><span class="operator">&gt;</span>  Bitmap Heap Scan <span class="keyword">on</span> content  (cost<span class="operator">=</span><span class="number">5.08</span>.<span class="number">.124</span><span class="number">.19</span> <span class="keyword">rows</span><span class="operator">=</span><span class="number">103</span> width<span class="operator">=</span><span class="number">739</span>)</span><br><span class="line">              Recheck Cond: (id <span class="operator">&lt;</span> <span class="number">100</span>)</span><br><span class="line">              <span class="operator">-</span><span class="operator">&gt;</span>  Bitmap Index Scan <span class="keyword">on</span> content_pkey  (cost<span class="operator">=</span><span class="number">0.00</span>.<span class="number">.5</span><span class="number">.05</span> <span class="keyword">rows</span><span class="operator">=</span><span class="number">103</span> width<span class="operator">=</span><span class="number">0</span>)</span><br><span class="line">                    Index Cond: (id <span class="operator">&lt;</span> <span class="number">100</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 连接条件下推</span></span><br><span class="line">explain <span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> content <span class="keyword">left</span> <span class="keyword">join</span> content_to_label ctl <span class="keyword">on</span> ctl.content_id <span class="operator">&lt;</span> <span class="number">100</span>;</span><br><span class="line"></span><br><span class="line">Nested Loop <span class="keyword">Left</span> <span class="keyword">Join</span>  (cost<span class="operator">=</span><span class="number">0.00</span>.<span class="number">.145</span><span class="number">.23</span> <span class="keyword">rows</span><span class="operator">=</span><span class="number">1161</span> width<span class="operator">=</span><span class="number">755</span>)</span><br><span class="line">  <span class="operator">-</span><span class="operator">&gt;</span>  Seq Scan <span class="keyword">on</span> content  (cost<span class="operator">=</span><span class="number">0.00</span>.<span class="number">.127</span><span class="number">.61</span> <span class="keyword">rows</span><span class="operator">=</span><span class="number">1161</span> width<span class="operator">=</span><span class="number">739</span>)</span><br><span class="line">  <span class="operator">-</span><span class="operator">&gt;</span>  Materialize  (cost<span class="operator">=</span><span class="number">0.00</span>.<span class="number">.3</span><span class="number">.10</span> <span class="keyword">rows</span><span class="operator">=</span><span class="number">1</span> width<span class="operator">=</span><span class="number">16</span>)</span><br><span class="line">        <span class="operator">-</span><span class="operator">&gt;</span>  Seq Scan <span class="keyword">on</span> content_to_label ctl  (cost<span class="operator">=</span><span class="number">0.00</span>.<span class="number">.3</span><span class="number">.10</span> <span class="keyword">rows</span><span class="operator">=</span><span class="number">1</span> width<span class="operator">=</span><span class="number">16</span>)</span><br><span class="line">              <span class="keyword">Filter</span>: (content_id <span class="operator">&lt;</span> <span class="number">100</span>)</span><br></pre></td></tr></table></figure>

<h4 id="外连接消除"><a href="#外连接消除" class="headerlink" title="外连接消除"></a>外连接消除</h4><p>如果两个表是内连接，则他们之间的顺序可以任意交换，会方便谓词下推。而对于外连接，则不会那么方便。如果能够将外连接转换为内连接，则查询过程会简化。能够被转换为内连接的情况如下</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="comment">-- 常规左外连接</span></span><br><span class="line">explain <span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> content <span class="keyword">left</span> <span class="keyword">outer</span> <span class="keyword">join</span> content_to_label ctl <span class="keyword">on</span> content.id <span class="operator">=</span> ctl.content_id;</span><br><span class="line"></span><br><span class="line">Hash <span class="keyword">Right</span> <span class="keyword">Join</span>  (cost<span class="operator">=</span><span class="number">140.90</span>.<span class="number">.144</span><span class="number">.02</span> <span class="keyword">rows</span><span class="operator">=</span><span class="number">1151</span> width<span class="operator">=</span><span class="number">755</span>)</span><br><span class="line">  Hash Cond: (ctl.content_id <span class="operator">=</span> content.id)</span><br><span class="line">  <span class="operator">-</span><span class="operator">&gt;</span>  Seq Scan <span class="keyword">on</span> content_to_label ctl  (cost<span class="operator">=</span><span class="number">0.00</span>.<span class="number">.2</span><span class="number">.68</span> <span class="keyword">rows</span><span class="operator">=</span><span class="number">168</span> width<span class="operator">=</span><span class="number">16</span>)</span><br><span class="line">  <span class="operator">-</span><span class="operator">&gt;</span>  Hash  (cost<span class="operator">=</span><span class="number">126.51</span>.<span class="number">.126</span><span class="number">.51</span> <span class="keyword">rows</span><span class="operator">=</span><span class="number">1151</span> width<span class="operator">=</span><span class="number">739</span>)</span><br><span class="line">        <span class="operator">-</span><span class="operator">&gt;</span>  Seq Scan <span class="keyword">on</span> content  (cost<span class="operator">=</span><span class="number">0.00</span>.<span class="number">.126</span><span class="number">.51</span> <span class="keyword">rows</span><span class="operator">=</span><span class="number">1151</span> width<span class="operator">=</span><span class="number">739</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 做左外连接，条件上限制可空侧的表格，消除外连接</span></span><br><span class="line">explain <span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> content <span class="keyword">left</span> <span class="keyword">outer</span> <span class="keyword">join</span> content_to_label ctl <span class="keyword">on</span> content.id <span class="operator">=</span> ctl.content_id <span class="keyword">where</span> ctl.content_id <span class="keyword">is</span> <span class="keyword">not</span> <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">Hash <span class="keyword">Join</span>  (cost<span class="operator">=</span><span class="number">140.90</span>.<span class="number">.144</span><span class="number">.02</span> <span class="keyword">rows</span><span class="operator">=</span><span class="number">168</span> width<span class="operator">=</span><span class="number">755</span>)</span><br><span class="line">  Hash Cond: (ctl.content_id <span class="operator">=</span> content.id)</span><br><span class="line">  <span class="operator">-</span><span class="operator">&gt;</span>  Seq Scan <span class="keyword">on</span> content_to_label ctl  (cost<span class="operator">=</span><span class="number">0.00</span>.<span class="number">.2</span><span class="number">.68</span> <span class="keyword">rows</span><span class="operator">=</span><span class="number">168</span> width<span class="operator">=</span><span class="number">16</span>)</span><br><span class="line">        <span class="keyword">Filter</span>: (content_id <span class="keyword">IS</span> <span class="keyword">NOT</span> <span class="keyword">NULL</span>)</span><br><span class="line">  <span class="operator">-</span><span class="operator">&gt;</span>  Hash  (cost<span class="operator">=</span><span class="number">126.51</span>.<span class="number">.126</span><span class="number">.51</span> <span class="keyword">rows</span><span class="operator">=</span><span class="number">1151</span> width<span class="operator">=</span><span class="number">739</span>)</span><br><span class="line">        <span class="operator">-</span><span class="operator">&gt;</span>  Seq Scan <span class="keyword">on</span> content  (cost<span class="operator">=</span><span class="number">0.00</span>.<span class="number">.126</span><span class="number">.51</span> <span class="keyword">rows</span><span class="operator">=</span><span class="number">1151</span> width<span class="operator">=</span><span class="number">739</span>)</span><br></pre></td></tr></table></figure>

<h4 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h4><p>逻辑优化的具体项目当然不止上面列举这几项，但从这几项中也能够看出逻辑优化的思路，即消除多余的逻辑操作，尽量从逻辑上降低实际查询时需要处理的数据量。同时我们也能够看到，子查询不一定不好，只要能够被合理提升、或是非关联子查询，对性能的影响不一定会很大；而你写的哪些看起来有些多余的部分，只要合理，也可能会被在逻辑优化中消除。</p>
<h3 id="物理优化（基于代价的优化）"><a href="#物理优化（基于代价的优化）" class="headerlink" title="物理优化（基于代价的优化）"></a>物理优化（基于代价的优化）</h3><p>逻辑优化后得到新的查询树，PG会针对查询树生成各种不同的查询路径，并通过查询代价模型计算比较并得出查询代价最低的路径作为最终的查询计划。</p>
<h4 id="cost计算模型"><a href="#cost计算模型" class="headerlink" title="cost计算模型"></a>cost计算模型</h4><p>再数据库运行的实际环境中，用户的硬件环境天差地别，CPU频率、内存大小、磁盘介质等都会直接影响实际执行效率，因此代价估算无法十分准确。比较实际的是依据一套基本靠谱的模型，选出出各路径中代价相对最小的那一个作为最终结果。PG设定了一个相对单位1作为查询预估的最小单位，针对每种路径节点给与不同的单位数量，最终计算总代价的单位数量。</p>
<p>具体来说，代价计算要考虑的点主要如下</p>
<ul>
<li><p>IO基准代价</p>
<p>从磁盘中读取数据以page为单位，而顺序读取比随机读取省时。PG默认顺序读取一个页面的代价为1，随机读取一个页面的代价为4</p>
</li>
<li><p>CPU基准代价</p>
<ul>
<li>从页面中提取出具体的记录</li>
<li>对投影和约束条件中的表达式的计算成本</li>
</ul>
</li>
</ul>
<p>在PG中相关参数如下</p>
<ul>
<li>seq_page_cost：顺序扫描一个页面的IO成本，默认1.0</li>
<li>random_page_cost：随即扫描一个页面的IO成本，默认4.0</li>
<li>cpu_tuple_cost：获取一个元组（即记录）的CPU成本，默认0.01</li>
<li>cpu_index_tuple_cost：通过索引获取一个元组的CPU成本，默认0.005</li>
<li>cpu_operator_cost：执行一个表达式运算的CPU成本，默认0.0025</li>
<li>parallel_setup_cost：并行查询时进程间通讯的初始化成本，默认1000.0</li>
<li>parallel_tuple_cost：并行查询进行间投递元组的成本，默认0.1</li>
</ul>
<h4 id="选择率"><a href="#选择率" class="headerlink" title="选择率"></a>选择率</h4><p>pg_statistic表记录了各数据表字段的统计信息，比如表占据页面数量、表记录数量、字段null率、字段不重复记录的比率等内容，优化器会通过表的统计信息，根据SQL的筛选条件，得到针对该表的选择率（选中的记录数/总的记录数），选择率结合代价计算模型，得出最终的估算成本。</p>
<h4 id="小结-1"><a href="#小结-1" class="headerlink" title="小结"></a>小结</h4><p>成本估算是个非常复杂的工作，影响因素很多。于代价计算模型，除了那几个成本参数，还会考虑缓存对代价计算的影响，而缓存又有内存缓存和磁盘缓存；于选择率，由于统计表中的信息并不十分准确，随之造成选择率可能出现偏差，且针对联合投影的选择率计算又不一样，都会对最终查询路径的选择造成直接影响。因此尽管很多书籍和资料都有展示一个SQL的cost数字如何计算，但我认为实际的计算过程不应该轻易出现，一篇文章应有自己的定位，本文的目的是让大家看懂explain，而看懂explain只需要知道代价计算的原理，对各类扫描和计算成本的量级有基本的认识即可。没有强大的上下文介绍而直接上代价计算模型，对读者只会起到反作用（这是我看别人博客的切身感受）。</p>
<h2 id="查询树介绍"><a href="#查询树介绍" class="headerlink" title="查询树介绍"></a>查询树介绍</h2><p>查询优化器最终输出的计划，以树的形式体现，树节点主要有控制节点、扫描节点、连接节点等。其中，所有叶子节点都是扫描节点，执行器按照从低到高的顺序逐层执行。下图是根据本文最后一个示例（见下文）的执行计划所绘制：三个叶子节点分别是对comments、notification、content的顺序扫描，其中comments和content扫描后进行创建了hash表，notification扫描结果和content扫描的hash结果做hash连接，得到的结果再和comments扫描的hash结果做hash连接，完成最终的运算。</p>
<p><img src="https://img-blog.csdnimg.cn/20200801125412784.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3pvdTg5NDQ=,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>
<p>下面介绍核心的三种扫描类型和三种连接类型</p>
<h3 id="扫描"><a href="#扫描" class="headerlink" title="扫描"></a>扫描</h3><ul>
<li><p>顺序扫描</p>
<p>即数据从头到尾扫描，适合连续的数据读取；不适合分布随机的数据。</p>
</li>
<li><p>索引扫描</p>
<ul>
<li><p>Index Scan</p>
<p>先扫描索引，再根据得到的key获取具体数据，涉及到随机读，因此如果索引扫描得到的数据量过大时，<strong>大量随机读也会带来很大的性能损失</strong>。</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="comment">-- 通过索引获取少量数据</span></span><br><span class="line">explain <span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> content <span class="keyword">where</span> id <span class="operator">=</span> <span class="number">100</span>;</span><br><span class="line"></span><br><span class="line">Index Scan <span class="keyword">using</span> content_pkey <span class="keyword">on</span> content  (cost<span class="operator">=</span><span class="number">0.28</span>.<span class="number">.8</span><span class="number">.29</span> <span class="keyword">rows</span><span class="operator">=</span><span class="number">1</span> width<span class="operator">=</span><span class="number">739</span>)</span><br><span class="line">  Index Cond: (id <span class="operator">=</span> <span class="number">100</span>)</span><br></pre></td></tr></table></figure></li>
<li><p>Index Only Scan</p>
<p>获取的目标字段就是索引的字段，因此仅扫描索引即可，即所谓的索引覆盖</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="comment">-- 直接获取索引的列</span></span><br><span class="line">explain <span class="keyword">select</span> id <span class="keyword">from</span> content <span class="keyword">where</span> id <span class="operator">=</span> <span class="number">100</span>;</span><br><span class="line"></span><br><span class="line">Index <span class="keyword">Only</span> Scan <span class="keyword">using</span> content_pkey <span class="keyword">on</span> content  (cost<span class="operator">=</span><span class="number">0.28</span>.<span class="number">.8</span><span class="number">.29</span> <span class="keyword">rows</span><span class="operator">=</span><span class="number">1</span> width<span class="operator">=</span><span class="number">4</span>)</span><br><span class="line">  Index Cond: (id <span class="operator">=</span> <span class="number">100</span>)</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li><p>位图扫描</p>
<p>针对Index Scan产生的随机读的优化，将索引读取到的key映射到位图，再扫描位图获取连续的key，将随机读变成连续读。出现位图扫描的地方一般会被分为两个步骤：索引映射到位图、通过位图扫描堆，即如下两个节点同时出现</p>
<ul>
<li>BitmapHeap Scan</li>
<li>BitmapIndex Scan</li>
</ul>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="comment">-- 通过索引获取较多数据</span></span><br><span class="line">explain <span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> content <span class="keyword">where</span> id <span class="operator">&lt;</span> <span class="number">100</span>;</span><br><span class="line"></span><br><span class="line">Bitmap Heap Scan <span class="keyword">on</span> content  (cost<span class="operator">=</span><span class="number">5.08</span>.<span class="number">.124</span><span class="number">.19</span> <span class="keyword">rows</span><span class="operator">=</span><span class="number">103</span> width<span class="operator">=</span><span class="number">739</span>)</span><br><span class="line">  Recheck Cond: (id <span class="operator">&lt;</span> <span class="number">100</span>)</span><br><span class="line">  <span class="operator">-</span><span class="operator">&gt;</span>  Bitmap Index Scan <span class="keyword">on</span> content_pkey  (cost<span class="operator">=</span><span class="number">0.00</span>.<span class="number">.5</span><span class="number">.05</span> <span class="keyword">rows</span><span class="operator">=</span><span class="number">103</span> width<span class="operator">=</span><span class="number">0</span>)</span><br><span class="line">        Index Cond: (id <span class="operator">&lt;</span> <span class="number">100</span>)</span><br></pre></td></tr></table></figure>

<p>上面的查询首先扫描索引，存储到位图（Bitmap Index），然后再通过位图扫描堆（Bitmap Head Scan），扫描时会再次检查条件（Recheck）</p>
</li>
<li><p>哪种扫描好</p>
<p>一般来说索引覆盖 &gt; 索引扫描 &gt; 索引+位图 &gt; 顺序扫描，但也并非绝对。如果优化器认为序列扫描的代价小于索引扫描，肯定是使用索引。比如同一个语句，根据条件范围的不同，也会选择不同的扫描方式。上面展示了id=100时使用索引扫描；id&lt;100时使用索引+位图扫描；这里展示id&gt;100时的结果</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="comment">-- 由于表中数据量超过500，这里的约束条件选择了绝大多数记录，因此使用顺序扫描会更划算（索引扫描带来的随机读抵消了它带来的优点）</span></span><br><span class="line">explain <span class="keyword">select</span> id <span class="keyword">from</span> content <span class="keyword">where</span> id <span class="operator">&gt;</span> <span class="number">100</span>;</span><br><span class="line"></span><br><span class="line">Seq Scan <span class="keyword">on</span> content  (cost<span class="operator">=</span><span class="number">0.00</span>.<span class="number">.130</span><span class="number">.51</span> <span class="keyword">rows</span><span class="operator">=</span><span class="number">1058</span> width<span class="operator">=</span><span class="number">4</span>)</span><br><span class="line">  <span class="keyword">Filter</span>: (id <span class="operator">&gt;</span> <span class="number">100</span>)</span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="连接"><a href="#连接" class="headerlink" title="连接"></a>连接</h3><ul>
<li><p>Nestlooped Join</p>
<p>即最普通的连接，笛卡尔积，算法复杂度为O(MxN)，M和N是待连接表的记录数</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">explain <span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> content, content_to_label ctl;</span><br><span class="line"></span><br><span class="line">Nested Loop  (cost<span class="operator">=</span><span class="number">0.00</span>.<span class="number">.2568</span><span class="number">.81</span> <span class="keyword">rows</span><span class="operator">=</span><span class="number">195048</span> width<span class="operator">=</span><span class="number">755</span>)</span><br><span class="line">  <span class="operator">-</span><span class="operator">&gt;</span>  Seq Scan <span class="keyword">on</span> content  (cost<span class="operator">=</span><span class="number">0.00</span>.<span class="number">.127</span><span class="number">.61</span> <span class="keyword">rows</span><span class="operator">=</span><span class="number">1161</span> width<span class="operator">=</span><span class="number">739</span>)</span><br><span class="line">  <span class="operator">-</span><span class="operator">&gt;</span>  Materialize  (cost<span class="operator">=</span><span class="number">0.00</span>.<span class="number">.3</span><span class="number">.52</span> <span class="keyword">rows</span><span class="operator">=</span><span class="number">168</span> width<span class="operator">=</span><span class="number">16</span>)</span><br><span class="line">        <span class="operator">-</span><span class="operator">&gt;</span>  Seq Scan <span class="keyword">on</span> content_to_label ctl  (cost<span class="operator">=</span><span class="number">0.00</span>.<span class="number">.2</span><span class="number">.68</span> <span class="keyword">rows</span><span class="operator">=</span><span class="number">168</span> width<span class="operator">=</span><span class="number">16</span>)</span><br></pre></td></tr></table></figure></li>
<li><p>Hash Join</p>
<p>对内表先提取一个hash表，对外表的每条记录，都通过hash很快地找到内表记录，从而加快连接速度。哈希连接复杂度为O(M+N)</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">explain <span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> content, content_to_label ctl <span class="keyword">where</span> content.id <span class="operator">=</span> ctl.content_id;</span><br><span class="line"></span><br><span class="line">Hash <span class="keyword">Join</span>  (cost<span class="operator">=</span><span class="number">142.12</span>.<span class="number">.145</span><span class="number">.24</span> <span class="keyword">rows</span><span class="operator">=</span><span class="number">168</span> width<span class="operator">=</span><span class="number">755</span>)</span><br><span class="line">  Hash Cond: (ctl.content_id <span class="operator">=</span> content.id)</span><br><span class="line">  <span class="operator">-</span><span class="operator">&gt;</span>  Seq Scan <span class="keyword">on</span> content_to_label ctl  (cost<span class="operator">=</span><span class="number">0.00</span>.<span class="number">.2</span><span class="number">.68</span> <span class="keyword">rows</span><span class="operator">=</span><span class="number">168</span> width<span class="operator">=</span><span class="number">16</span>)</span><br><span class="line">  <span class="operator">-</span><span class="operator">&gt;</span>  Hash  (cost<span class="operator">=</span><span class="number">127.61</span>.<span class="number">.127</span><span class="number">.61</span> <span class="keyword">rows</span><span class="operator">=</span><span class="number">1161</span> width<span class="operator">=</span><span class="number">739</span>)</span><br><span class="line">        <span class="operator">-</span><span class="operator">&gt;</span>  Seq Scan <span class="keyword">on</span> content  (cost<span class="operator">=</span><span class="number">0.00</span>.<span class="number">.127</span><span class="number">.61</span> <span class="keyword">rows</span><span class="operator">=</span><span class="number">1161</span> width<span class="operator">=</span><span class="number">739</span>)</span><br></pre></td></tr></table></figure>

<p>该计划将content当作内表，先顺序扫描，再提取hash（Hash），将content_to_label当作外表，最后进行哈希连接，连接时会检查连接条件</p>
</li>
<li><p>Merge Join</p>
<p>即归并连接，仅当两个候选表有序时才会使用归并连接。</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">explain <span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> (<span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> content <span class="keyword">order</span> <span class="keyword">by</span> id) content, (<span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> content_to_label <span class="keyword">order</span> <span class="keyword">by</span> content_id) ctl <span class="keyword">where</span> content.id <span class="operator">=</span> ctl.content_id <span class="keyword">order</span> <span class="keyword">by</span> ctl.content_id;</span><br><span class="line"></span><br><span class="line"><span class="keyword">Merge</span> <span class="keyword">Join</span>  (cost<span class="operator">=</span><span class="number">201.57</span>.<span class="number">.217</span><span class="number">.40</span> <span class="keyword">rows</span><span class="operator">=</span><span class="number">168</span> width<span class="operator">=</span><span class="number">755</span>)</span><br><span class="line">  <span class="keyword">Merge</span> Cond: (content.id <span class="operator">=</span> content_to_label.content_id)</span><br><span class="line">  <span class="operator">-</span><span class="operator">&gt;</span>  Sort  (cost<span class="operator">=</span><span class="number">186.71</span>.<span class="number">.189</span><span class="number">.61</span> <span class="keyword">rows</span><span class="operator">=</span><span class="number">1161</span> width<span class="operator">=</span><span class="number">739</span>)</span><br><span class="line">        Sort Key: content.id</span><br><span class="line">        <span class="operator">-</span><span class="operator">&gt;</span>  Seq Scan <span class="keyword">on</span> content  (cost<span class="operator">=</span><span class="number">0.00</span>.<span class="number">.127</span><span class="number">.61</span> <span class="keyword">rows</span><span class="operator">=</span><span class="number">1161</span> width<span class="operator">=</span><span class="number">739</span>)</span><br><span class="line">  <span class="operator">-</span><span class="operator">&gt;</span>  Materialize  (cost<span class="operator">=</span><span class="number">8.89</span>.<span class="number">.11</span><span class="number">.41</span> <span class="keyword">rows</span><span class="operator">=</span><span class="number">168</span> width<span class="operator">=</span><span class="number">16</span>)</span><br><span class="line">        <span class="operator">-</span><span class="operator">&gt;</span>  Sort  (cost<span class="operator">=</span><span class="number">8.89</span>.<span class="number">.9</span><span class="number">.31</span> <span class="keyword">rows</span><span class="operator">=</span><span class="number">168</span> width<span class="operator">=</span><span class="number">16</span>)</span><br><span class="line">              Sort Key: content_to_label.content_id</span><br><span class="line">              <span class="operator">-</span><span class="operator">&gt;</span>  Seq Scan <span class="keyword">on</span> content_to_label  (cost<span class="operator">=</span><span class="number">0.00</span>.<span class="number">.2</span><span class="number">.68</span> <span class="keyword">rows</span><span class="operator">=</span><span class="number">168</span> width<span class="operator">=</span><span class="number">16</span>)</span><br></pre></td></tr></table></figure>

<p>如上，先对两个备选表排序，然后将排序key作为连接条件，优化器选择了归并连接。</p>
</li>
<li><p>哪种连接好？</p>
<p>如果待连接表本来就有序，那Merge Join会更好，否则Hash Join好，出现NestLoop Join是绝对要避免的。</p>
</li>
</ul>
<h3 id="其它"><a href="#其它" class="headerlink" title="其它"></a>其它</h3><ul>
<li><p>Materialize</p>
<p>即物化，常出现在带有子查询的语句中，当子查询结果较少时，PG会将其存储起来，这也是提升性能的一种方式</p>
</li>
<li><p>CTE</p>
<p>通用表达式对应的是WITH语句，它的作用和子查询类似，但具有一次求值，多次使用的特点，并不会多次执行，因此一般不会被优化。</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">explain <span class="keyword">with</span> contentt <span class="keyword">as</span> (<span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> content) <span class="keyword">select</span> id <span class="keyword">from</span> contentt;</span><br><span class="line"></span><br><span class="line">CTE Scan <span class="keyword">on</span> contentt  (cost<span class="operator">=</span><span class="number">127.61</span>.<span class="number">.150</span><span class="number">.83</span> <span class="keyword">rows</span><span class="operator">=</span><span class="number">1161</span> width<span class="operator">=</span><span class="number">4</span>)</span><br><span class="line">  CTE contentt</span><br><span class="line">    <span class="operator">-</span><span class="operator">&gt;</span>  Seq Scan <span class="keyword">on</span> content  (cost<span class="operator">=</span><span class="number">0.00</span>.<span class="number">.127</span><span class="number">.61</span> <span class="keyword">rows</span><span class="operator">=</span><span class="number">1161</span> width<span class="operator">=</span><span class="number">739</span>)</span><br></pre></td></tr></table></figure>

<p>SQL中存在CTE，其级别仅相当于执行一次的子查询。</p>
</li>
<li><p>Param</p>
<p>部分子查询的计划树中我们会看到<code>returns $0</code>这样的内容。其原理是：子查询每次执行结果都会返回并存储在一个Param中，父查询通过向Param传参启动子查询，如果发现之前同样的参数已经执行过了，则直接获取之前执行获得的结果，从而节省运行时间。即，Param具有缓存作用。</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">Seq Scan <span class="keyword">on</span> content  (cost<span class="operator">=</span><span class="number">0.02</span>.<span class="number">.126</span><span class="number">.53</span> <span class="keyword">rows</span><span class="operator">=</span><span class="number">1151</span> width<span class="operator">=</span><span class="number">743</span>)</span><br><span class="line">  InitPlan <span class="number">1</span> (<span class="keyword">returns</span> $<span class="number">0</span>)</span><br><span class="line">    <span class="operator">-</span><span class="operator">&gt;</span>  Limit  (cost<span class="operator">=</span><span class="number">0.00</span>.<span class="number">.0</span><span class="number">.02</span> <span class="keyword">rows</span><span class="operator">=</span><span class="number">1</span> width<span class="operator">=</span><span class="number">4</span>)</span><br><span class="line">          <span class="operator">-</span><span class="operator">&gt;</span>  Seq Scan <span class="keyword">on</span> content_to_label  (cost<span class="operator">=</span><span class="number">0.00</span>.<span class="number">.2</span><span class="number">.68</span> <span class="keyword">rows</span><span class="operator">=</span><span class="number">168</span> width<span class="operator">=</span><span class="number">4</span>)</span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="小结-2"><a href="#小结-2" class="headerlink" title="小结"></a>小结</h3><p>执行计划的节点总类是非常多的，但核心的无非扫描和连接，再其次是子查询，这也是我们进行SQL优化重心所在：比如创建索引可以为优化器多提供一条选择路径；Nestloop Join出现时通常会带来较差的性能；子查询尽量优化为非相关的或连接操作。那遇到其他类型的节点怎么办？——当然是去查资料呀！</p>
<h2 id="Explain怎么看-直接看"><a href="#Explain怎么看-直接看" class="headerlink" title="Explain怎么看 - 直接看"></a>Explain怎么看 - 直接看</h2><p>通过<a href="https://www.postgresql.org/docs/10/using-explain.html">explain命令</a>查看，常用explain + analyze同时查看计划成本和实际执行时间，注意analyze会导致SQL的确实执行。由于参数越多，出现的噪音越大，因此我的常用的习惯是先explain，再加上analyze查看具体情况。优化的思路是先找有没有一眼就看起来低效的节点，如Nestloop Join，无索引导致的Seq Scan等，其次重点关注cost耗费较多的节点。如下方性能损耗最大的是对content表的顺序扫描。</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">explain <span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> notification</span><br><span class="line"><span class="keyword">left</span> <span class="keyword">join</span> content <span class="keyword">on</span> notification.target_content_id <span class="operator">=</span> content.id</span><br><span class="line"><span class="keyword">left</span> <span class="keyword">join</span> comments <span class="keyword">on</span> notification.target_comment_id <span class="operator">=</span> comments.id</span><br><span class="line"><span class="keyword">where</span> (notification.target_content_id <span class="keyword">is</span> <span class="keyword">not</span> <span class="keyword">null</span> <span class="keyword">and</span> content.state <span class="operator">=</span> <span class="string">&#x27;normal&#x27;</span>)</span><br><span class="line">   <span class="keyword">or</span> (notification.target_comment_id <span class="keyword">is</span> <span class="keyword">not</span> <span class="keyword">null</span> <span class="keyword">and</span> comments.state <span class="operator">=</span> <span class="string">&#x27;normal&#x27;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">-- explain的命令执行结果如下：一棵树的文本输出形式</span></span><br><span class="line">Hash <span class="keyword">Left</span> <span class="keyword">Join</span>  (cost<span class="operator">=</span><span class="number">147.29</span>.<span class="number">.175</span><span class="number">.52</span> <span class="keyword">rows</span><span class="operator">=</span><span class="number">437</span> width<span class="operator">=</span><span class="number">928</span>)</span><br><span class="line">  Hash Cond: (notification.target_comment_id <span class="operator">=</span> comments.id)</span><br><span class="line">  <span class="operator">-</span><span class="operator">&gt;</span>  Hash <span class="keyword">Join</span>  (cost<span class="operator">=</span><span class="number">139.84</span>.<span class="number">.166</span><span class="number">.91</span> <span class="keyword">rows</span><span class="operator">=</span><span class="number">437</span> width<span class="operator">=</span><span class="number">855</span>)</span><br><span class="line">        Hash Cond: (notification.target_content_id <span class="operator">=</span> content.id)</span><br><span class="line">        <span class="operator">-</span><span class="operator">&gt;</span>  Seq Scan <span class="keyword">on</span> notification  (cost<span class="operator">=</span><span class="number">0.00</span>.<span class="number">.25</span><span class="number">.22</span> <span class="keyword">rows</span><span class="operator">=</span><span class="number">701</span> width<span class="operator">=</span><span class="number">116</span>)</span><br><span class="line">              <span class="keyword">Filter</span>: (target_content_id <span class="keyword">IS</span> <span class="keyword">NOT</span> <span class="keyword">NULL</span>)</span><br><span class="line">        <span class="operator">-</span><span class="operator">&gt;</span>  Hash  (cost<span class="operator">=</span><span class="number">130.51</span>.<span class="number">.130</span><span class="number">.51</span> <span class="keyword">rows</span><span class="operator">=</span><span class="number">746</span> width<span class="operator">=</span><span class="number">739</span>)</span><br><span class="line">              <span class="operator">-</span><span class="operator">&gt;</span>  Seq Scan <span class="keyword">on</span> content  (cost<span class="operator">=</span><span class="number">0.00</span>.<span class="number">.130</span><span class="number">.51</span> <span class="keyword">rows</span><span class="operator">=</span><span class="number">746</span> width<span class="operator">=</span><span class="number">739</span>)</span><br><span class="line">                    <span class="keyword">Filter</span>: (state <span class="operator">=</span> <span class="string">&#x27;normal&#x27;</span>::state_enum)</span><br><span class="line">  <span class="operator">-</span><span class="operator">&gt;</span>  Hash  (cost<span class="operator">=</span><span class="number">4.98</span>.<span class="number">.4</span><span class="number">.98</span> <span class="keyword">rows</span><span class="operator">=</span><span class="number">198</span> width<span class="operator">=</span><span class="number">73</span>)</span><br><span class="line">        <span class="operator">-</span><span class="operator">&gt;</span>  Seq Scan <span class="keyword">on</span> comments  (cost<span class="operator">=</span><span class="number">0.00</span>.<span class="number">.4</span><span class="number">.98</span> <span class="keyword">rows</span><span class="operator">=</span><span class="number">198</span> width<span class="operator">=</span><span class="number">73</span>)</span><br></pre></td></tr></table></figure>

<p>配上解说的版本</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="comment">-- 左连接，连接方式为hash，（代价估计：开始-结束为149.58..178.62，预估结果行数530，宽度为928）</span></span><br><span class="line">Hash <span class="keyword">Left</span> <span class="keyword">Join</span>  (cost<span class="operator">=</span><span class="number">147.29</span>.<span class="number">.175</span><span class="number">.52</span> <span class="keyword">rows</span><span class="operator">=</span><span class="number">437</span> width<span class="operator">=</span><span class="number">928</span>)</span><br><span class="line"><span class="comment">-- 该层的连接条件</span></span><br><span class="line">  Hash Cond: (notification.target_comment_id <span class="operator">=</span> comments.id)</span><br><span class="line">  <span class="comment">-- 哈希连接</span></span><br><span class="line">  <span class="operator">-</span><span class="operator">&gt;</span>  Hash <span class="keyword">Join</span>  (cost<span class="operator">=</span><span class="number">139.84</span>.<span class="number">.166</span><span class="number">.91</span> <span class="keyword">rows</span><span class="operator">=</span><span class="number">437</span> width<span class="operator">=</span><span class="number">855</span>)</span><br><span class="line">  <span class="comment">--    该层的连接条件</span></span><br><span class="line">        Hash Cond: (notification.target_content_id <span class="operator">=</span> content.id)</span><br><span class="line">        <span class="comment">-- 对notification顺序奥妙</span></span><br><span class="line">        <span class="operator">-</span><span class="operator">&gt;</span>  Seq Scan <span class="keyword">on</span> notification  (cost<span class="operator">=</span><span class="number">0.00</span>.<span class="number">.25</span><span class="number">.22</span> <span class="keyword">rows</span><span class="operator">=</span><span class="number">701</span> width<span class="operator">=</span><span class="number">116</span>)</span><br><span class="line">        <span class="comment">--    扫描条件为target_content_id不为null</span></span><br><span class="line">              <span class="keyword">Filter</span>: (target_content_id <span class="keyword">IS</span> <span class="keyword">NOT</span> <span class="keyword">NULL</span>)</span><br><span class="line">        <span class="comment">-- 对下层结果做hash</span></span><br><span class="line">        <span class="operator">-</span><span class="operator">&gt;</span>  Hash  (cost<span class="operator">=</span><span class="number">130.51</span>.<span class="number">.130</span><span class="number">.51</span> <span class="keyword">rows</span><span class="operator">=</span><span class="number">746</span> width<span class="operator">=</span><span class="number">739</span>)</span><br><span class="line">        	  <span class="comment">-- 顺序扫描content</span></span><br><span class="line">              <span class="operator">-</span><span class="operator">&gt;</span>  Seq Scan <span class="keyword">on</span> content  (cost<span class="operator">=</span><span class="number">0.00</span>.<span class="number">.130</span><span class="number">.51</span> <span class="keyword">rows</span><span class="operator">=</span><span class="number">746</span> width<span class="operator">=</span><span class="number">739</span>)</span><br><span class="line">              <span class="comment">--    顺序扫描的过滤条件</span></span><br><span class="line">                    <span class="keyword">Filter</span>: (state <span class="operator">=</span> <span class="string">&#x27;normal&#x27;</span>::state_enum)</span><br><span class="line">  <span class="comment">-- 对下层结果做hash</span></span><br><span class="line">  <span class="operator">-</span><span class="operator">&gt;</span>  Hash  (cost<span class="operator">=</span><span class="number">4.98</span>.<span class="number">.4</span><span class="number">.98</span> <span class="keyword">rows</span><span class="operator">=</span><span class="number">198</span> width<span class="operator">=</span><span class="number">73</span>)</span><br><span class="line"> 		<span class="comment">-- 顺序扫描comments</span></span><br><span class="line">        <span class="operator">-</span><span class="operator">&gt;</span>  Seq Scan <span class="keyword">on</span> comments  (cost<span class="operator">=</span><span class="number">0.00</span>.<span class="number">.4</span><span class="number">.98</span> <span class="keyword">rows</span><span class="operator">=</span><span class="number">198</span> width<span class="operator">=</span><span class="number">73</span>)</span><br></pre></td></tr></table></figure>

<p>加上analyze的版本，可以发现多了每个步骤实际执行的时间、各步骤的实际情况（如hash所生成的bucket数量、内存消耗等）</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">Hash <span class="keyword">Left</span> <span class="keyword">Join</span>  (cost<span class="operator">=</span><span class="number">147.29</span>.<span class="number">.175</span><span class="number">.52</span> <span class="keyword">rows</span><span class="operator">=</span><span class="number">437</span> width<span class="operator">=</span><span class="number">928</span>) (actual <span class="type">time</span><span class="operator">=</span><span class="number">0.734</span>.<span class="number">.1</span><span class="number">.287</span> <span class="keyword">rows</span><span class="operator">=</span><span class="number">571</span> loops<span class="operator">=</span><span class="number">1</span>)</span><br><span class="line">  Hash Cond: (notification.target_comment_id <span class="operator">=</span> comments.id)</span><br><span class="line">  <span class="operator">-</span><span class="operator">&gt;</span>  Hash <span class="keyword">Join</span>  (cost<span class="operator">=</span><span class="number">139.84</span>.<span class="number">.166</span><span class="number">.91</span> <span class="keyword">rows</span><span class="operator">=</span><span class="number">437</span> width<span class="operator">=</span><span class="number">855</span>) (actual <span class="type">time</span><span class="operator">=</span><span class="number">0.626</span>.<span class="number">.0</span><span class="number">.999</span> <span class="keyword">rows</span><span class="operator">=</span><span class="number">571</span> loops<span class="operator">=</span><span class="number">1</span>)</span><br><span class="line">        Hash Cond: (notification.target_content_id <span class="operator">=</span> content.id)</span><br><span class="line">        <span class="operator">-</span><span class="operator">&gt;</span>  Seq Scan <span class="keyword">on</span> notification  (cost<span class="operator">=</span><span class="number">0.00</span>.<span class="number">.25</span><span class="number">.22</span> <span class="keyword">rows</span><span class="operator">=</span><span class="number">701</span> width<span class="operator">=</span><span class="number">116</span>) (actual <span class="type">time</span><span class="operator">=</span><span class="number">0.009</span>.<span class="number">.0</span><span class="number">.159</span> <span class="keyword">rows</span><span class="operator">=</span><span class="number">727</span> loops<span class="operator">=</span><span class="number">1</span>)</span><br><span class="line">              <span class="keyword">Filter</span>: (target_content_id <span class="keyword">IS</span> <span class="keyword">NOT</span> <span class="keyword">NULL</span>)</span><br><span class="line">              <span class="keyword">Rows</span> Removed <span class="keyword">by</span> <span class="keyword">Filter</span>: <span class="number">21</span></span><br><span class="line">        <span class="operator">-</span><span class="operator">&gt;</span>  Hash  (cost<span class="operator">=</span><span class="number">130.51</span>.<span class="number">.130</span><span class="number">.51</span> <span class="keyword">rows</span><span class="operator">=</span><span class="number">746</span> width<span class="operator">=</span><span class="number">739</span>) (actual <span class="type">time</span><span class="operator">=</span><span class="number">0.609</span>.<span class="number">.0</span><span class="number">.609</span> <span class="keyword">rows</span><span class="operator">=</span><span class="number">732</span> loops<span class="operator">=</span><span class="number">1</span>)</span><br><span class="line">              Buckets: <span class="number">1024</span>  Batches: <span class="number">1</span>  Memory Usage: <span class="number">573</span>kB</span><br><span class="line">              <span class="operator">-</span><span class="operator">&gt;</span>  Seq Scan <span class="keyword">on</span> content  (cost<span class="operator">=</span><span class="number">0.00</span>.<span class="number">.130</span><span class="number">.51</span> <span class="keyword">rows</span><span class="operator">=</span><span class="number">746</span> width<span class="operator">=</span><span class="number">739</span>) (actual <span class="type">time</span><span class="operator">=</span><span class="number">0.003</span>.<span class="number">.0</span><span class="number">.351</span> <span class="keyword">rows</span><span class="operator">=</span><span class="number">732</span> loops<span class="operator">=</span><span class="number">1</span>)</span><br><span class="line">                    <span class="keyword">Filter</span>: (state <span class="operator">=</span> <span class="string">&#x27;normal&#x27;</span>::state_enum)</span><br><span class="line">                    <span class="keyword">Rows</span> Removed <span class="keyword">by</span> <span class="keyword">Filter</span>: <span class="number">423</span></span><br><span class="line">  <span class="operator">-</span><span class="operator">&gt;</span>  Hash  (cost<span class="operator">=</span><span class="number">4.98</span>.<span class="number">.4</span><span class="number">.98</span> <span class="keyword">rows</span><span class="operator">=</span><span class="number">198</span> width<span class="operator">=</span><span class="number">73</span>) (actual <span class="type">time</span><span class="operator">=</span><span class="number">0.101</span>.<span class="number">.0</span><span class="number">.101</span> <span class="keyword">rows</span><span class="operator">=</span><span class="number">232</span> loops<span class="operator">=</span><span class="number">1</span>)</span><br><span class="line">        Buckets: <span class="number">1024</span>  Batches: <span class="number">1</span>  Memory Usage: <span class="number">31</span>kB</span><br><span class="line">        <span class="operator">-</span><span class="operator">&gt;</span>  Seq Scan <span class="keyword">on</span> comments  (cost<span class="operator">=</span><span class="number">0.00</span>.<span class="number">.4</span><span class="number">.98</span> <span class="keyword">rows</span><span class="operator">=</span><span class="number">198</span> width<span class="operator">=</span><span class="number">73</span>) (actual <span class="type">time</span><span class="operator">=</span><span class="number">0.003</span>.<span class="number">.0</span><span class="number">.034</span> <span class="keyword">rows</span><span class="operator">=</span><span class="number">232</span> loops<span class="operator">=</span><span class="number">1</span>)</span><br><span class="line">Planning <span class="type">time</span>: <span class="number">0.402</span> ms</span><br><span class="line">Execution <span class="type">time</span>: <span class="number">1.368</span> ms</span><br></pre></td></tr></table></figure>

<h2 id="Explain怎么看-可视化"><a href="#Explain怎么看-可视化" class="headerlink" title="Explain怎么看 - 可视化"></a>Explain怎么看 - 可视化</h2><p>pgAdmin提供了可视化explain的功能，支持将解释内容以图形的形式展示，使得更加方便地展示主干节点之间的关系和节点的意义，非常适合用来学习</p>
<p>比如同样描述上面的explain信息，图示如下<br><img src="https://img-blog.csdnimg.cn/20200801125451984.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3pvdTg5NDQ=,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>
<p>pgAdmin4的使用方式，点击explain按钮即可<br><img src="https://img-blog.csdnimg.cn/20200801125514710.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3pvdTg5NDQ=,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>本文简单介绍了PostgreSQL的查询优化器工作原理、执行计划核心节点的原理，以及explain输出结果该如何查看，并从自己的视角介绍了执行计划中需要关注的点。写本文之前，作者对执行计划的了解主要来自PG官方手册及网上零零散散的博文，总感觉不得要领。而为了完成本文，阅读了《Postgresql技术内幕——查询优化深度探索》全本、《PostgreSQL指南——内幕探索》查询优化章节、《数据库系统概念》连接概念部分，收获颇丰，算是初步系统地了解了查询优化的原理，回过头再看explain的执行计划，豁然开朗；而最令自己的惊喜的发现是《数据库系统概念》，该书作为经典书籍，对构建自身的数据库系统基础知识很有益处。由于作者文笔水平有限，表述不一定清晰准确，如读者有时间有精力，参考资料一栏文章和书籍，都是值得一读的。</p>
<h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><ol>
<li><a href="https://www.postgresql.org/docs/10/using-explain.html">使用EXPLAIN </a></li>
<li><a href="http://www.postgresonline.com/journal/archives/78-Why-is-my-index-not-being-used.html">为何我的索引没有被使用</a></li>
<li><a href="http://mysql.taobao.org/monthly/2018/11/06/">EXPLAIN 使用浅析</a></li>
<li><a href="http://www.postgres.cn/docs/9.4/catalog-pg-statistic.html">PG_STATISTIC</a></li>
<li>《数据库系统概念 - 第六版》（参考连接部分）</li>
<li>《PostgreSQL技术内幕——查询优化深度探索》</li>
<li>《PostgreSQL指南——内幕探索》</li>
<li><a href="http://www.postgresonline.com/journal/archives/27-Reading-PgAdmin-Graphical-Explain-Plans.html">PGADMIN查看EXPLAIN结果</a></li>
</ol>
]]></content>
      <categories>
        <category>数据库</category>
      </categories>
      <tags>
        <tag>PostgreSQL</tag>
      </tags>
  </entry>
  <entry>
    <title>Postgresql的Listen-Notify机制</title>
    <url>/2020/06/06/Postgresql%E7%9A%84Listen-Notify%E6%9C%BA%E5%88%B6-postgresql%E7%9A%84listen-notify%E6%9C%BA%E5%88%B6/</url>
    <content><![CDATA[<p>Postgresql提供 监听 - 通知 的订阅服务，使得数据库客户端向服务端的指定通道注册为监听客户端，服务端在发出Notify通知时，所有已注册的监听客户端将能够收到该通知。</p>
<span id="more"></span>

<h1 id="使用示例"><a href="#使用示例" class="headerlink" title="使用示例"></a>使用示例</h1><p><strong>服务端</strong></p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="comment">-- 不带消息的通知</span></span><br><span class="line">users<span class="operator">=</span><span class="operator">&gt;</span> NOTIFY test_channel;</span><br><span class="line">NOTIFY</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 带消息的通知</span></span><br><span class="line">users<span class="operator">=</span><span class="operator">&gt;</span> NOTIFY test_channel, <span class="string">&#x27;I am payload&#x27;</span>;</span><br><span class="line">NOTIFY</span><br></pre></td></tr></table></figure>

<p><strong>客户端</strong></p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="comment">-- 不带消息的通知</span></span><br><span class="line">users<span class="operator">=</span><span class="operator">&gt;</span> LISTEN test_channel;</span><br><span class="line">LISTEN</span><br><span class="line">Asynchronous notification &quot;test_channel&quot; received <span class="keyword">from</span> server process <span class="keyword">with</span> PID <span class="number">9501.</span></span><br><span class="line"></span><br><span class="line"><span class="comment">-- 带消息的通知</span></span><br><span class="line">users<span class="operator">=</span><span class="operator">&gt;</span> LISTEN test_channel;</span><br><span class="line">LISTEN</span><br><span class="line">Asynchronous notification &quot;test_channel&quot; <span class="keyword">with</span> payload &quot;I am payload&quot; received <span class="keyword">from</span> server process <span class="keyword">with</span> PID <span class="number">9501.</span></span><br></pre></td></tr></table></figure>

<p><strong>注意</strong></p>
<ul>
<li>上面的例子看起来并不像发布-订阅，因为客户端LISTEN后并不会被主动通知，而是每次要服务端NOTIFY后，客户端再去LISTEN，这其实是误会——Postgresql客户端检测通知事件的方式取决于该客户端底层应用的编程接口。支持同步轮询异步通知两种方式。很多第三方库是支持异步通知的。</li>
<li>通道名可以使任意有效字符串，通道不需要预先创建。</li>
</ul>
<h1 id="命令介绍"><a href="#命令介绍" class="headerlink" title="命令介绍"></a>命令介绍</h1><h2 id="LISTEN"><a href="#LISTEN" class="headerlink" title="LISTEN"></a>LISTEN</h2><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">LISTEN channel （channel值任意）</span><br></pre></td></tr></table></figure>

<ul>
<li><p>命令干了啥</p>
<p>将当前会话注册为一个channel的监听者，如果当前会话已经注册，则啥都不干</p>
</li>
<li><p>何时被通知</p>
<p>无论何时当命令 NOTIFY channel 被调用时，注册在该channel上的所有监听者都会被通知。</p>
</li>
<li><p>合适终止监听</p>
<p>当调用UNLISTEN或会话关闭时，监听终止</p>
</li>
<li><p>监听原理</p>
<p>客户端检测通知事件使用的方法取决于它使用的 PostgreSQL 应用程序编程接口。</p>
<ul>
<li>如果使用libpq库，只是相当于定期执行SQL命令调用PQnotifies方法查询是否有新的通知</li>
<li>其它接口如libpgtcl提供更高级的方法来处理通知</li>
</ul>
</li>
<li><p>事务相关性</p>
<p>LISTEN命令在事务提交时生效，如果执行LISTEN的事务最终回滚了，则LISTEN不会生效。</p>
</li>
</ul>
<h2 id="NOTIFY"><a href="#NOTIFY" class="headerlink" title="NOTIFY"></a>NOTIFY</h2><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">NOTIFY channel [, payload] （payload默认要求小于<span class="number">8000</span>字节, 且必须是常量）</span><br></pre></td></tr></table></figure>

<ul>
<li><p>命令干了啥</p>
<p>NOTIFY向每一个在channel上注册的客户端发送通知，通知可附带可选的字符串载荷payload。通知对所有用户都是可见的。</p>
</li>
<li><p>通知信息包括</p>
<ul>
<li>通知的channel名</li>
<li>发出通知的服务端的进程PID</li>
<li>可选的payload字符串，没有时则为空字符串</li>
</ul>
</li>
<li><p>channel命名规则</p>
<p>channel没有具体的命名规则。一般来说，channel会和某个表名一致，这样对该channel发出通知在语义上表示“我修改了这个表，看看有什么新内容吧”（配套的是将这样的NOTIFY语句放入表更新的触发器中）。不过还是要具体情况具体分析</p>
</li>
<li><p>事务相关性</p>
<p>如果NOTIFY用于事务中，则只有当事务提交时才会真正执行通知，如果事务取消则压根不会通知。</p>
<p>如果一个待接收通知的监听会话正处于事务中，则通知事件会等到它的事务处结束后在发送到它。这是合理的，因为通知发送了就不能取消，如果在事务中发送或接收，遇到想要取消通知的情况就没办法了。</p>
<p>这样的缺点导致了实时性不好，因此如果要求实时性高，就要把事务写短一点。</p>
</li>
<li><p>通知折叠规则</p>
<ul>
<li>一个事务中对同一个channel发送多个paylaod一样的通知，可能会被折叠成一个通知</li>
<li>一个事务中对同一个channel发送不同的payload通知，不会执行折叠操作</li>
<li>不同事务，无论channel和payload是否重复，都不会执行折叠操作</li>
</ul>
</li>
<li><p>顺序</p>
<p>NOTIFY保证顺序</p>
<ul>
<li>同一事务中，通知发出的顺序按NOTIFY声明的顺序进行</li>
<li>不同事务，通知发出的顺序按事务提交的顺序走</li>
</ul>
</li>
<li><p>避免额外的工作</p>
<p>在一个客户端上发送NOTIFY命令，同时该客户端监听同样的channel，会出现通知发给自己的情况，此时可以通过通知中带的进程PID发现发送者就是自己，从而忽略本来要执行的逻辑，节省性能。</p>
</li>
<li><p>队列</p>
<p>有一个队列用于存储已经NOTIFY但还没被所有注册的客户端获取的通知，如果队列满了，则NOTIFY在提交时会失败。</p>
<p>该队列默认大小为8GB，足够大多数情况。</p>
<p>如果一个监听会话长时间处于事务中，则对应通知会持续累积，当队列满了一半时，会打出警告日志。</p>
<p>pg_notification_queue_usage函数可以查看用了多少。</p>
</li>
<li><p>pg_notify(channel, payload)</p>
<p>该方法执行同样的事情，好处是payload不再要求必须是常量，可以通过变量运算得到。</p>
</li>
</ul>
<h2 id="UNLISTEN"><a href="#UNLISTEN" class="headerlink" title="UNLISTEN"></a>UNLISTEN</h2><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">UNLISTEN &#123; channel <span class="operator">|</span> <span class="operator">*</span>)&#125;</span><br></pre></td></tr></table></figure>

<p>用于将当前会话移除出channel的监听列表，*表示移除当前会话监听的所有channel。</p>
<p>在会话期间，使用UNLISTEN channel的方式移除监听</p>
<p>在会话结束时，会自动执行UNLISTEN *</p>
<h1 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h1><ul>
<li><p><a href="https://www.postgresql.org/docs/10/sql-listen.html">Postgresql-10官方手册 - LISTEN</a></p>
</li>
<li><p><a href="https://www.postgresql.org/docs/10/sql-notify.html">Postgresql-10官方手册 - NOTIFY</a></p>
</li>
<li><p><a href="https://www.postgresql.org/docs/10/sql-unlisten.html">Postgresql-10官方手册 - UNLISTEN</a></p>
</li>
<li><p><a href="https://www.postgresql.org/docs/10/libpq-notify.html">Postgresql-10官方手册 - Asynchronous Notification</a></p>
</li>
</ul>
]]></content>
      <categories>
        <category>数据库</category>
      </categories>
      <tags>
        <tag>PostgreSQL</tag>
      </tags>
  </entry>
  <entry>
    <title>PostgreSQL权限管理</title>
    <url>/2021/11/24/PostgreSQL%E6%9D%83%E9%99%90%E7%AE%A1%E7%90%86/</url>
    <content><![CDATA[<p>本文介绍<code>PostgreSQL</code>中如何管理用户和权限，这些是正确管理<code>PostgreSQL</code>权限必备的前置知识。</p>
<span id="more"></span>

<h2 id="角色-ROLE"><a href="#角色-ROLE" class="headerlink" title="角色 - ROLE"></a>角色 - <a href="https://www.postgresql.org/docs/13/user-manag.html">ROLE</a></h2><p>PG中，围绕角色进行权限的管理。它可以被看做是一个user，或一组user。区分role、user、group。user和group是PG 8.1之前的两个实体，role是那之后唯一存在的实体，现在user和role，等价。</p>
<h3 id="初始角色"><a href="#初始角色" class="headerlink" title="初始角色"></a>初始角色</h3><p>数据库刚创建时，会自动创建一个超级用户的角色：postgres。任何操作都是从该用户开始的。</p>
<h3 id="创建角色"><a href="#创建角色" class="headerlink" title="创建角色"></a>创建角色</h3><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">CRAETE ROLE &#123;角色名&#125; [LOGIN] [SUPERUSER] [CREATEDB] [CREATEROLE] [REPLICATION] [INHERIT] [<span class="keyword">WITH</span> ENCRYPTED PASSWORD <span class="string">&#x27;密码&#x27;</span>]</span><br></pre></td></tr></table></figure>

<ul>
<li><code>LOGIN</code>：允许登录</li>
<li><code>SUPERUSER</code>：拥有超级用户权限</li>
<li><code>CREATEDB</code>：允许创建database</li>
<li><code>CREATEROLE</code>：允许创建角色</li>
<li><code>REPLICATION</code>：允许备份</li>
<li><code>INHERIT</code>：是否继承权限，权限来是其它角色，通过<code>GRANT</code>将其它角色赋予该角色</li>
<li><code>PASSWORD</code>：指定密码</li>
</ul>
<blockquote>
<p>注意事项1：如下两句话等价</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> ROLE &#123;角色名&#125; LOGIN</span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">USER</span> &#123;角色名&#125;</span><br></pre></td></tr></table></figure>
</blockquote>
<blockquote>
<p>注意事项2：不要使用超级用户，而是创建一个具有<code>CREATEDB</code>、<code>CREATEROLE</code>的角色进行日常管理，以避免误操作带来的危险。</p>
</blockquote>
<blockquote>
<p>注意事项3：创建database、创建角色算是特殊的权限，要与后文介绍的可授予的权限区分开来</p>
</blockquote>
<h3 id="建立角色关系"><a href="#建立角色关系" class="headerlink" title="建立角色关系"></a>建立角色关系</h3><p>PG中并没有组的概念，各个角色之间都是平级的，但并不妨碍他们组成逻辑上的组，这通过<code>GRANT</code>语句达成。它能够将角色A赋予角色B，使得角色B成为角色A的成员，此后，赋予角色A的权限，角色B也将得到。</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">GRANT</span> rolea <span class="keyword">TO</span> roleb;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>创建角色时有指定<code>INHERIT</code>参数，如果有，则角色B将会自动继承来自角色A的权限；如果没有，则只有将角色B手动切换到角色A时，才具有其权限</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="comment">-- 切换到角色A</span></span><br><span class="line"><span class="keyword">SET</span> ROLE rolea;</span><br><span class="line"><span class="comment">-- 充值角色到它自己，即回到角色B</span></span><br><span class="line">RESET ROLE；</span><br></pre></td></tr></table></figure>
</blockquote>
<h3 id="默认角色"><a href="#默认角色" class="headerlink" title="默认角色"></a>默认角色</h3><p>下面这些角色是预创建的，相当于一堆权限集合，可以将其赋予我们的角色，达到快速授权的目的。</p>
<table>
<thead>
<tr>
<th>Role</th>
<th>Allowed Access</th>
</tr>
</thead>
<tbody><tr>
<td>pg_read_all_settings</td>
<td>Read all configuration variables, even those normally visible only to superusers.</td>
</tr>
<tr>
<td>pg_read_all_stats</td>
<td>Read all pg_stat_* views and use various statistics related extensions, even those normally visible only to superusers.</td>
</tr>
<tr>
<td>pg_stat_scan_tables</td>
<td>Execute monitoring functions that may take <code>ACCESS SHARE</code> locks on tables, potentially for a long time.</td>
</tr>
<tr>
<td>pg_monitor</td>
<td>Read/execute various monitoring views and functions. This role is a member of <code>pg_read_all_settings</code>, <code>pg_read_all_stats</code> and <code>pg_stat_scan_tables</code>.</td>
</tr>
<tr>
<td>pg_signal_backend</td>
<td>Signal another backend to cancel a query or terminate its session.</td>
</tr>
<tr>
<td>pg_read_server_files</td>
<td>Allow reading files from any location the database can access on the server with COPY and other file-access functions.</td>
</tr>
<tr>
<td>pg_write_server_files</td>
<td>Allow writing to files in any location the database can access on the server with COPY and other file-access functions.</td>
</tr>
<tr>
<td>pg_execute_server_program</td>
<td>Allow executing programs on the database server as the user the database runs as with COPY and other functions which allow executing a server-side program.</td>
</tr>
</tbody></table>
<h3 id="关于ROLE的命令"><a href="#关于ROLE的命令" class="headerlink" title="关于ROLE的命令"></a>关于ROLE的命令</h3><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="comment">-- 创建ROLE</span></span><br><span class="line"><span class="keyword">CREATE</span> ROLE bosslist LOGIN INHERIT;</span><br><span class="line">createuser bosslist;</span><br><span class="line"><span class="comment">-- 删除ROLE</span></span><br><span class="line"><span class="keyword">DROP</span> ROLE bosslist;</span><br><span class="line">dropuser bosslist;</span><br><span class="line"><span class="comment">-- 查看现有的角色</span></span><br><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">from</span> pg_roles;</span><br><span class="line">\du</span><br></pre></td></tr></table></figure>

<p>对于查看角色，从<code>pg_roles</code>中查询和<code>\du</code>得到的结果一样，只不过呈现方式不同。</p>
<p><code>\du</code>将角色的属性以字符串的形式展现</p>
<p><img src="https://gdz.oss-cn-shenzhen.aliyuncs.com/local/image-20211124192250160.png" alt="image-20211124192250160"></p>
<p><code>pg_roles</code>查询结果如下，将每个属性都列出，可以使用SQL的形式查询、排序等。</p>
<p><img src="https://gdz.oss-cn-shenzhen.aliyuncs.com/local/image-20211124192304590.png" alt="image-20211124192304590"></p>
<h2 id="权限-PRIVILEGES"><a href="#权限-PRIVILEGES" class="headerlink" title="权限 - PRIVILEGES"></a>权限 - <a href="">PRIVILEGES</a></h2><p>角色有了，决定角色能够执行哪些数据库操作，则需要权限进行管理。PG将权限分为了两部分。这里所说的权限，主要指第二部分</p>
<ul>
<li>能否登录、创建database、创建role，这类重要权限，在创建role时指定；在<code>pg_roles</code>表中可查看</li>
<li>对数据库对象的各类操作的权限，通过<code>GRANT</code>手动授予；在<code>information_schema.xxx_privileges</code>表中可查看，比如<code>information_schema.table_privileges</code></li>
</ul>
<h3 id="权限的组成"><a href="#权限的组成" class="headerlink" title="权限的组成"></a>权限的组成</h3><p>一个完整的权限描述：角色A对表table1具有<code>SELECT</code>权限，有三部分组成</p>
<ul>
<li>角色：A</li>
<li>授权目标：table1</li>
<li>权限：<code>SELECT</code></li>
</ul>
<h3 id="权限列举"><a href="#权限列举" class="headerlink" title="权限列举"></a>权限列举</h3><table>
<thead>
<tr>
<th>权限</th>
<th>授权目标</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td><code>SELECT</code></td>
<td>表和视图的所有列、指定的列；序列</td>
<td>读取</td>
</tr>
<tr>
<td><code>INSERT</code></td>
<td>表和视图的所有列、指定的列</td>
<td>插入，指定列时，插入语句只能出现指定的列</td>
</tr>
<tr>
<td><code>UPDATE</code></td>
<td>表和视图的所有列、指定的列；序列</td>
<td>更新，指定列时，更新语句只能出现指定的列<br />依赖SELECT权限定位</td>
</tr>
<tr>
<td><code>DELETE</code></td>
<td>表和视图的所有列，即一整行</td>
<td>删除<br />依赖SELECT权限定位</td>
</tr>
<tr>
<td><code>TRUNCATE</code></td>
<td>表</td>
<td>清空整张表</td>
</tr>
<tr>
<td><code>REFERENCES</code></td>
<td>表的所有列、指定的列</td>
<td>创建外键</td>
</tr>
<tr>
<td><code>TRIGGER</code></td>
<td>表、视图</td>
<td>在表或视图上创建触发器</td>
</tr>
<tr>
<td><code>CREATE</code></td>
<td>database<br />schema<br />tablespace</td>
<td>database: 允许创建schema、publications、安装插件<br />schema: 创建新的对象；如果要修改已有对象，你必须是该对象的owner，并且拥有schema的CREATE权限<br />tablespace: 允许创建表、索引、临时文件；允许创建默认表空间为该表空间子的database</td>
</tr>
<tr>
<td><code>CONNECT</code></td>
<td>database</td>
<td>允许连接指定的database，这是pg_hba.conf之后，额外的检查</td>
</tr>
<tr>
<td><code>TEMPORARY</code></td>
<td>临时表</td>
<td>允许创建临时表</td>
</tr>
<tr>
<td><code>EXECUTE</code></td>
<td>函数、存储过程</td>
<td>允许执行函数或存储过程</td>
</tr>
<tr>
<td><code>USAGE</code></td>
<td>schema<br />序列<br />类型</td>
<td>schema：允许使用该schema内的对象<br />序列：允许使用<code>currval</code>和<code>nextval</code>函数<br />类型：允许使用该类型</td>
</tr>
</tbody></table>
<h3 id="特殊的权限"><a href="#特殊的权限" class="headerlink" title="特殊的权限"></a>特殊的权限</h3><ul>
<li><p>owner拥有特权</p>
<p>当一个数据库对象被创建后，它会被自动分配一个owner，一般来说是执行创建语句的那个角色。大多数情况下，owner及其成员能够对该对象做任何事，如果其他人想要操作它，则需要<code>GRANT</code>授权。</p>
<p>可修改owner，超级用户、对象原本的owner、owner的成员都能够调整对象的owner</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">alter</span> <span class="keyword">table</span> table_name owner <span class="keyword">to</span> new_owner;</span><br></pre></td></tr></table></figure></li>
<li><p><code>PUBLIC</code></p>
<p><code>PUBLIC</code>并不是一个真正的角色，确切地说，它应该算一个关键字，当授权的目标是它时，表示：授予系统中的所有角色，包括今后定义的角色。</p>
<p><code>PUBLIC</code>默认是拥有以下权限</p>
<ul>
<li>本地登录</li>
<li>对public的<code>USAGE</code>权限</li>
<li>对public的<code>CREATE</code>权限</li>
</ul>
<p>字面意思理解，相当于将该权限公开。</p>
</li>
</ul>
<h2 id="授权-GRANT"><a href="#授权-GRANT" class="headerlink" title="授权 - GRANT"></a>授权 - <a href="https://www.postgresql.org/docs/13/sql-grant.html">GRANT</a></h2><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="comment">-- 授予权限</span></span><br><span class="line"><span class="keyword">GRANT</span> &#123;权限&#125; <span class="keyword">ON</span> &#123;授权目标&#125; <span class="keyword">TO</span> &#123;被授权角色&#125; [<span class="keyword">WITH</span> <span class="keyword">GRANT</span> OPTION]</span><br><span class="line"><span class="comment">-- 授予角色</span></span><br><span class="line">GRATE &#123;角色&#125; <span class="keyword">TO</span> &#123;被授权角色&#125; [<span class="keyword">WITH</span> ADMIN OPTION] [GRANTED <span class="keyword">BY</span> 角色]</span><br></pre></td></tr></table></figure>

<h3 id="权限"><a href="#权限" class="headerlink" title="权限"></a>权限</h3><table>
<thead>
<tr>
<th>权限</th>
<th>缩写</th>
<th>授权目标类型</th>
</tr>
</thead>
<tbody><tr>
<td><code>SELECT</code></td>
<td><code>r</code> (“read”)</td>
<td><code>LARGE OBJECT</code>, <code>SEQUENCE</code>, <code>TABLE</code> (and table-like objects), table column</td>
</tr>
<tr>
<td><code>INSERT</code></td>
<td><code>a</code> (“append”)</td>
<td><code>TABLE</code>, table column</td>
</tr>
<tr>
<td><code>UPDATE</code></td>
<td><code>w</code> (“write”)</td>
<td><code>LARGE OBJECT</code>, <code>SEQUENCE</code>, <code>TABLE</code>, table column</td>
</tr>
<tr>
<td><code>DELETE</code></td>
<td><code>d</code></td>
<td><code>TABLE</code></td>
</tr>
<tr>
<td><code>TRUNCATE</code></td>
<td><code>D</code></td>
<td><code>TABLE</code></td>
</tr>
<tr>
<td><code>REFERENCES</code></td>
<td><code>x</code></td>
<td><code>TABLE</code>, table column</td>
</tr>
<tr>
<td><code>TRIGGER</code></td>
<td><code>t</code></td>
<td><code>TABLE</code></td>
</tr>
<tr>
<td><code>CREATE</code></td>
<td><code>C</code></td>
<td><code>DATABASE</code>, <code>SCHEMA</code>, <code>TABLESPACE</code></td>
</tr>
<tr>
<td><code>CONNECT</code></td>
<td><code>c</code></td>
<td><code>DATABASE</code></td>
</tr>
<tr>
<td><code>TEMPORARY</code></td>
<td><code>T</code></td>
<td><code>DATABASE</code></td>
</tr>
<tr>
<td><code>EXECUTE</code></td>
<td><code>X</code></td>
<td><code>FUNCTION</code>, <code>PROCEDURE</code></td>
</tr>
<tr>
<td><code>USAGE</code></td>
<td><code>U</code></td>
<td><code>DOMAIN</code>, <code>FOREIGN DATA WRAPPER</code>, <code>FOREIGN SERVER</code>, <code>LANGUAGE</code>, <code>SCHEMA</code>, <code>SEQUENCE</code>, <code>TYPE</code></td>
</tr>
</tbody></table>
<blockquote>
<p>这里指定的缩写，在执行<code>\dp 表名</code>时会有用。</p>
</blockquote>
<p>除上面指定的，还有如下权限体</p>
<ul>
<li><code>ALL PRELEGES</code>：它是针对一个授权目标的所有权限的总和，不同目标有不同的权限，参见下面那张表。</li>
</ul>
<h3 id="授权目标"><a href="#授权目标" class="headerlink" title="授权目标"></a>授权目标</h3><table>
<thead>
<tr>
<th>对象类型</th>
<th>All Privileges包含</th>
<th>Default <code>PUBLIC</code> Privileges</th>
<th>psql Command</th>
</tr>
</thead>
<tbody><tr>
<td><code>DATABASE</code></td>
<td><code>CTc</code></td>
<td><code>Tc</code></td>
<td><code>\l</code></td>
</tr>
<tr>
<td><code>DOMAIN</code></td>
<td><code>U</code></td>
<td><code>U</code></td>
<td><code>\dD+</code></td>
</tr>
<tr>
<td><code>FUNCTION</code> or <code>PROCEDURE</code></td>
<td><code>X</code></td>
<td><code>X</code></td>
<td><code>\df+</code></td>
</tr>
<tr>
<td><code>FOREIGN DATA WRAPPER</code></td>
<td><code>U</code></td>
<td>none</td>
<td><code>\dew+</code></td>
</tr>
<tr>
<td><code>FOREIGN SERVER</code></td>
<td><code>U</code></td>
<td>none</td>
<td><code>\des+</code></td>
</tr>
<tr>
<td><code>LANGUAGE</code></td>
<td><code>U</code></td>
<td><code>U</code></td>
<td><code>\dL+</code></td>
</tr>
<tr>
<td><code>LARGE OBJECT</code></td>
<td><code>rw</code></td>
<td>none</td>
<td></td>
</tr>
<tr>
<td><code>SCHEMA</code></td>
<td><code>UC</code></td>
<td>none</td>
<td><code>\dn+</code></td>
</tr>
<tr>
<td><code>SEQUENCE</code></td>
<td><code>rwU</code></td>
<td>none</td>
<td><code>\dp</code></td>
</tr>
<tr>
<td><code>TABLE</code> (and table-like objects)</td>
<td><code>arwdDxt</code></td>
<td>none</td>
<td><code>\dp</code></td>
</tr>
<tr>
<td>Table column</td>
<td><code>arwx</code></td>
<td>none</td>
<td><code>\dp</code></td>
</tr>
<tr>
<td><code>TABLESPACE</code></td>
<td><code>C</code></td>
<td>none</td>
<td><code>\db+</code></td>
</tr>
<tr>
<td><code>TYPE</code></td>
<td><code>U</code></td>
<td><code>U</code></td>
<td><code>\dT+</code></td>
</tr>
</tbody></table>
<h3 id="被授权人"><a href="#被授权人" class="headerlink" title="被授权人"></a>被授权人</h3><table>
<thead>
<tr>
<th>被授权人</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td><code>PUBLIC</code></td>
<td>授予系统中的所有角色，包括今后定义的角色</td>
</tr>
<tr>
<td><code>role_name</code></td>
<td>授予指定的角色，角色中的所有成员将会继承该权限</td>
</tr>
<tr>
<td><code>CURRENT_USER</code></td>
<td>当前用户</td>
</tr>
</tbody></table>
<h3 id="WITH-GRANT-OPTION"><a href="#WITH-GRANT-OPTION" class="headerlink" title="WITH GRANT OPTION"></a>WITH GRANT OPTION</h3><p>表示被授权人能够将该权限授予其他人，不能对PUBLIC使用该选项。</p>
<h3 id="授予角色而不是权限"><a href="#授予角色而不是权限" class="headerlink" title="授予角色而不是权限"></a>授予角色而不是权限</h3><p>第二条语句是将一个角色授予另一个角色，作用是将一个角色的成员授予其它角色。前文“建立角色关系”已描述过了。</p>
<p><code>WITH ADMIN OPTION</code>：授权传递，被授权的角色，可以传递授权</p>
<h3 id="关于授权的命令"><a href="#关于授权的命令" class="headerlink" title="关于授权的命令"></a>关于授权的命令</h3><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="comment">-- 授予database的所有操作给一个角色</span></span><br><span class="line"><span class="keyword">GRANT</span> <span class="keyword">ALL</span> PRIVILEGES <span class="keyword">ON</span> DATABASE bosslist <span class="keyword">TO</span> bosslist;</span><br><span class="line"><span class="comment">-- 授权当前database的指定schema的所有表的只读权限给一个角色</span></span><br><span class="line"><span class="keyword">GRANT</span> <span class="keyword">SELECT</span> <span class="keyword">ON</span> <span class="keyword">ALL</span> TABLES <span class="keyword">IN</span> SCHEMA public <span class="keyword">TO</span> bosslist;</span><br><span class="line"><span class="comment">-- 将mytable.col1的SELECT、UPDATE赋予miriam_rw</span></span><br><span class="line"><span class="keyword">GRANT</span> <span class="keyword">SELECT</span> (col1), UPDATE (col1) <span class="keyword">ON</span> mytable <span class="keyword">TO</span> miriam_rw;</span><br><span class="line"><span class="comment">-- 查看一个表的权限详情</span></span><br><span class="line">\dp <span class="operator">&lt;</span>表名<span class="operator">&gt;</span></span><br></pre></td></tr></table></figure>

<p>比如，如下查询结果表示：resource表，mylog用户拥有所有权限；mylogs_r拥有SELECT权限，都是mylog用户授予的。</p>
<p><img src="https://gdz.oss-cn-shenzhen.aliyuncs.com/local/image-20211124193136549.png" alt="image-20211124193136549"></p>
<p>如果这里看到的<code>Access privileges</code>为空，则该表适用于如下权限</p>
<ul>
<li>其owner对该表有完整的权限</li>
<li>如果针对<code>PUBLIC</code>角色有设置关于该表的权限，则会予以应用</li>
</ul>
<h2 id="默认权限-DEFAULT-PRIVILEGES"><a href="#默认权限-DEFAULT-PRIVILEGES" class="headerlink" title="默认权限 - DEFAULT PRIVILEGES"></a>默认权限 - <a href="https://www.postgresql.org/docs/13/sql-alterdefaultprivileges.html">DEFAULT PRIVILEGES</a></h2><p>当一个数据库对象刚被创建时，满足条件的默认权限会自动应用。</p>
<p>通过<code>\ddp</code>可以查看适用当前schema的默认权限（默认啥都没有）。</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">ALTER</span> <span class="keyword">DEFAULT</span> PRIVILEGES [<span class="keyword">FOR</span> &#123;目标角色&#125;] [<span class="keyword">IN</span> SCHEMA &#123;schemaname&#125;] &#123;<span class="keyword">GRANT</span>或<span class="keyword">REVOKE</span>语句&#125;</span><br></pre></td></tr></table></figure>

<p>举几个例子</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">ALTER</span> <span class="keyword">DEFAULT</span> PRIVILEGES <span class="keyword">IN</span> SCHEMA myschema <span class="keyword">GRANT</span> <span class="keyword">SELECT</span> <span class="keyword">ON</span> TABLES <span class="keyword">TO</span> PUBLIC;</span><br><span class="line"><span class="keyword">ALTER</span> <span class="keyword">DEFAULT</span> PRIVILEGES <span class="keyword">IN</span> SCHEMA myschema <span class="keyword">GRANT</span> <span class="keyword">INSERT</span> <span class="keyword">ON</span> TABLES <span class="keyword">TO</span> webuser;</span><br></pre></td></tr></table></figure>

<p><code>\ddp</code>的例子</p>
<p><img src="https://gdz.oss-cn-shenzhen.aliyuncs.com/local/image-20211124193049403.png" alt="image-20211124193049403"></p>
<h2 id="撤权-REVOKE"><a href="#撤权-REVOKE" class="headerlink" title="撤权 - REVOKE"></a>撤权 - <a href="https://www.postgresql.org/docs/13/sql-revoke.html">REVOKE</a></h2><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="comment">-- 取消权限</span></span><br><span class="line"><span class="keyword">REVOKE</span> [<span class="keyword">GRANT</span> OPTION <span class="keyword">FOR</span>] &#123;权限&#125; <span class="keyword">ON</span> &#123;授权目标&#125; <span class="keyword">FROM</span> &#123;被授权人&#125; [CASCADE <span class="operator">|</span> RESTRICT]</span><br><span class="line"><span class="comment">-- 取消角色</span></span><br><span class="line"><span class="keyword">REVOKE</span> [ADMIN OPTION <span class="keyword">FOR</span>] &#123;角色&#125; <span class="keyword">FROM</span> &#123;被授权角色&#125; [CASCADE <span class="operator">|</span> RESTRICT]</span><br></pre></td></tr></table></figure>

<p>各部分和GRANT一样，区别在于</p>
<ul>
<li><code>GRANT OPTION FOR</code>：取消权限的授予权限，而不是权限本身；没有这一项就同时取消权限和授权权限</li>
<li><code>CASCADE</code>：递归取消，适用于带有授权选项的用户将权限授予了其它用户，带上它则会将这些权限递归取消</li>
<li><code>RESTRICT</code>：区别于<code>CASCADE</code>，不会递归取消，<strong>这是默认选项</strong></li>
</ul>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p><code>PostgreSQL</code>中，权限有两种，一种是创建角色时指定的那几个大类；一种就是所谓的<code>PRIVILEGES</code>，搞清楚这一点，一切都好办很多。</p>
<h3 id="自问自答"><a href="#自问自答" class="headerlink" title="自问自答"></a>自问自答</h3><ul>
<li><p>谁能发起<code>GRANT </code>?</p>
<p><code>GRANT</code>本身并不是一种权限，任何角色都能<code>GRANT</code>，但要分为两种情况</p>
<ul>
<li>角色的某个权限是别的角色授权过来的，如果对方授权时未指定<code>WITH GRANT OPTION</code>，则它无权将该权限授权给其它角色</li>
<li>角色是某个对象的owner，则该角色能将该对象的权限授予其它角色</li>
</ul>
<p>只要我们堵死这两条路，一个角色就无法授权给别人。前面那条路好说，后面这条路，就要求角色不能拥有创建对象的能力，我们可以通过<code>ALTER USER SET default_transaction_read_only=on</code>达成。</p>
</li>
<li><p>新创建的角色拥有什么样的权限 ?</p>
<p>依据角色创建语句决定它是否拥有创建角色或database的权限；<code>PRIVILEGES</code>则包含所有授予<code>PUBLIC</code>的角色。</p>
</li>
<li><p>如何查看<code>PUBLIC</code>拥有哪些权限？</p>
<p>目前没找到查看的方式</p>
</li>
<li><p>如何查看某个角色是否对schema具有<code>CREATE</code>权限？其它类推？</p>
<p>待查</p>
</li>
</ul>
<h2 id="彩蛋-客户端鉴权"><a href="#彩蛋-客户端鉴权" class="headerlink" title="彩蛋 - 客户端鉴权"></a>彩蛋 - 客户端鉴权</h2><p>角色创建后好，并不能直接通过网络连接到PG服务端，<code>pg_hba.conf</code>文件要配置一下。一个典型的配置如下</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> Allow any user on the <span class="built_in">local</span> system to connect to any database with</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> any database user name using Unix-domain sockets (the default <span class="keyword">for</span> <span class="built_in">local</span></span></span><br><span class="line"><span class="meta">#</span><span class="bash"> connections).</span></span><br><span class="line"><span class="meta">#</span><span class="bash"></span></span><br><span class="line"><span class="bash"><span class="comment"># TYPE  DATABASE        USER            ADDRESS                 METHOD</span></span></span><br><span class="line">local   all             all                                     trust</span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">#</span><span class="bash"> The same using <span class="built_in">local</span> loopback TCP/IP connections.</span></span><br><span class="line"><span class="meta">#</span><span class="bash"></span></span><br><span class="line"><span class="bash"><span class="comment"># TYPE  DATABASE        USER            ADDRESS                 METHOD</span></span></span><br><span class="line">host    all             all             127.0.0.1/32            trust</span><br></pre></td></tr></table></figure>

<p>组成部分</p>
<ul>
<li><p><code>TYPE</code></p>
<ul>
<li>local：本地连接</li>
<li>host：使用TCP/IP连接</li>
</ul>
</li>
<li><p><code>DATABASE</code></p>
<p>允许连接的database</p>
</li>
<li><p><code>USER</code></p>
<p>允许连接的角色</p>
</li>
<li><p><code>ADDRESS</code></p>
<p>允许的客户端地址，<code>0.0.0.0/0</code>表示允许所以客户端连接</p>
</li>
<li><p><code>METHOD</code></p>
<p>鉴权方式</p>
<ul>
<li><code>trust</code>：无条件允许连接</li>
<li><code>reject</code>：无条件拒绝</li>
<li><code>password</code>：要求客户端提供未加密的密码进行身份验证，密码在网络上以明文形式传输，如果使用SSL，可以加密传输</li>
<li><code>scram-sha-256</code>：执行 SCRAM-SHA-256 身份验证，这是一种质询响应机制，这是目前最安全的方式，不过有的数据库客户端可能不支持。</li>
<li><code>md5</code>：也是一种质询响应机制</li>
<li><code>peer</code>：获取客户端操作系统的用户名，如果和请求连接的用户名一样。这只有在本地连接时才有用。</li>
<li><code>xxx</code>：都是其它的鉴权方式，参考<a href="https://www.postgresql.org/docs/13/auth-pg-hba-conf.html">官方文档</a></li>
</ul>
</li>
</ul>
<h2 id="最佳实践1-创建只读用户"><a href="#最佳实践1-创建只读用户" class="headerlink" title="最佳实践1 - 创建只读用户"></a>最佳实践1 - 创建只读用户</h2><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="comment">-- 创建用户doki</span></span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">USER</span> doki PASSWORD <span class="string">&#x27;password&#x27;</span>;</span><br><span class="line"><span class="comment">-- 更新用户的默认事务为只读的（这意味着它只能执行读操作，不能CUD）</span></span><br><span class="line"><span class="keyword">ALTER</span> <span class="keyword">USER</span> doki <span class="keyword">set</span> default_transaction_read_only<span class="operator">=</span><span class="keyword">on</span>;</span><br><span class="line"><span class="comment">-- 授权连接</span></span><br><span class="line"><span class="keyword">GRANT</span> <span class="keyword">CONNECT</span> <span class="keyword">ON</span> DATABASE doki_database <span class="keyword">TO</span> doki;</span><br><span class="line"><span class="comment">-- 授权public的使用</span></span><br><span class="line"><span class="keyword">GRANT</span> USAGE <span class="keyword">ON</span> SCHEMA PUBLIC <span class="keyword">TO</span> doki;</span><br><span class="line"><span class="comment">-- 切换到doki_database</span></span><br><span class="line">\c doki_database</span><br><span class="line"><span class="comment">-- 授予doki_database下public下所有表、序列、函数</span></span><br><span class="line"><span class="keyword">GRANT</span> <span class="keyword">SELECT</span> <span class="keyword">ON</span> <span class="keyword">ALL</span> TABLES <span class="keyword">IN</span> SCHEMA public <span class="keyword">TO</span> doki;</span><br><span class="line"><span class="keyword">GRANT</span> <span class="keyword">SELECT</span> <span class="keyword">ON</span> <span class="keyword">ALL</span> SEQUENCES <span class="keyword">IN</span> SCHEMA public <span class="keyword">TO</span> doki;</span><br><span class="line"><span class="keyword">GRANT</span> <span class="keyword">EXECUTE</span> <span class="keyword">ON</span> <span class="keyword">ALL</span> FUNCTIONS <span class="keyword">IN</span> SCHEMA public <span class="keyword">TO</span> doki;</span><br><span class="line"><span class="comment">-- 对于新建的对象，也授予上面三个权限</span></span><br><span class="line"><span class="keyword">ALTER</span> <span class="keyword">DEFAULT</span> PRIVILEGES <span class="keyword">FOR</span> ddl_user <span class="keyword">IN</span> SCHEMA public <span class="keyword">GRANT</span> <span class="keyword">SELECT</span> <span class="keyword">ON</span> TABLES <span class="keyword">TO</span> doki;</span><br><span class="line"><span class="keyword">ALTER</span> <span class="keyword">DEFAULT</span> PRIVILEGES <span class="keyword">FOR</span> ddl_user <span class="keyword">IN</span> SCHEMA public <span class="keyword">GRANT</span> <span class="keyword">SELECT</span> <span class="keyword">ON</span> SEQUENCES <span class="keyword">TO</span> doki;</span><br><span class="line"><span class="keyword">ALTER</span> <span class="keyword">DEFAULT</span> PRIVILEGES <span class="keyword">FOR</span> ddl_user <span class="keyword">IN</span> SCHEMA public <span class="keyword">GRANT</span> <span class="keyword">EXECUTE</span> <span class="keyword">ON</span> FUNCTIONS <span class="keyword">TO</span> doki;</span><br></pre></td></tr></table></figure>

<p>修改<code>pg_hba.conf</code>，添加如下一行（注意这是危险的，因为0.0.0.0/0），如果已经有符合要求的行，也可以不添加。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">host all all 0.0.0.0/0 md5</span><br></pre></td></tr></table></figure>

<p>使用psql从远端测试访问</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">psql -h &lt;数据库地址&gt; -p &lt;数据库端口，默认5432&gt; -U doki -d doki_database</span><br></pre></td></tr></table></figure>

<h2 id="最佳实践2-重新为用户授权"><a href="#最佳实践2-重新为用户授权" class="headerlink" title="最佳实践2 - 重新为用户授权"></a>最佳实践2 - 重新为用户授权</h2><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="comment">-- 切换到doki_database下</span></span><br><span class="line">\c doki_database</span><br><span class="line"><span class="comment">-- 收回用户在public下所有表的所有权限</span></span><br><span class="line"><span class="keyword">REVOKE</span> <span class="keyword">ALL</span> PRIVILEGES <span class="keyword">ON</span> <span class="keyword">ALL</span> TABLES <span class="keyword">IN</span> SCHEMA public <span class="keyword">FROM</span> doki</span><br><span class="line"><span class="comment">-- 为doki赋予doki_database下的所有权限</span></span><br><span class="line"><span class="keyword">GRANT</span> <span class="keyword">ALL</span> PRIVILEGES <span class="keyword">ON</span> <span class="keyword">ALL</span> TABLES <span class="keyword">IN</span> SCHEMA public <span class="keyword">TO</span> doki;</span><br><span class="line"><span class="keyword">GRANT</span> <span class="keyword">ALL</span> PRIVILEGES <span class="keyword">ON</span> <span class="keyword">ALL</span> SEQUENCES <span class="keyword">IN</span> SCHEMA public <span class="keyword">TO</span> doki;</span><br></pre></td></tr></table></figure>

<p>注意，如果我们要收回某个database下所有权限，是无法通过如下语句达成的，参考“授权目标”那张表，对于<code>DATABASE</code>,<code>ALL PRIVILEGES</code>代表<code>CTc</code>，即<code>CREATE TEMPORY CONNECT</code>，即创建<code>schema</code>、安装插件、创建临时文件、连接，收回的也只是这几个权限而已，要收回全部权限，还是得一个一个目标地做。</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">REVOKE</span> <span class="keyword">ALL</span> PRIVILEGES <span class="keyword">ON</span> DATABASE doki_database <span class="keyword">FROM</span> doki;</span><br></pre></td></tr></table></figure>

<h2 id="好文推荐"><a href="#好文推荐" class="headerlink" title="好文推荐"></a>好文推荐</h2><ul>
<li><a href="https://wiki.postgresql.org/images/d/d1/Managing_rights_in_postgresql.pdf">Managing rights in postgresql</a></li>
</ul>
]]></content>
  </entry>
  <entry>
    <title>Python - 日志</title>
    <url>/2020/03/07/Python%20-%20%E6%97%A5%E5%BF%97-python-%E6%97%A5%E5%BF%97/</url>
    <content><![CDATA[<p>我的Python是从使用开始的，因此很多Python基础理论并不是很足，之前在使用Celery时，因为日志无法正常打印而排查了一天。所以，为了节省时间，同时知其所以然，是时候系统梳理一下Python中日志的使用方法了。</p>
<span id="more"></span>

<h1 id="基础"><a href="#基础" class="headerlink" title="基础"></a>基础</h1><p>Python日志位于logging包，其中仅包含两个module。在不进行任何额外配置的情况下，可以按照如下方式使用</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> logging</span><br><span class="line"></span><br><span class="line">logging.warn(<span class="string">&quot;Hello World!!!&quot;</span>)</span><br></pre></td></tr></table></figure>

<p>输出</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">WARNING:root:hello</span><br></pre></td></tr></table></figure>

<p>接着来详细了解其使用方式。</p>
<h2 id="日志级别"><a href="#日志级别" class="headerlink" title="日志级别"></a>日志级别</h2><p>在很多Java日志框架中，将日志由严重要普通，依次为  Fatal -&gt; Error -&gt; Warning -&gt; Info -&gt; Debug。在Python中，也一行，只不过Fatal不叫Fatal，叫Critical，所以是 Fatal -&gt; Error -&gt; Warning -&gt; Info -&gt; Debug。使用场景也是一样，如下</p>
<table>
<thead>
<tr>
<th align="left"><code>DEBUG</code></th>
<th align="left">细节信息，仅当诊断问题时适用。</th>
</tr>
</thead>
<tbody><tr>
<td align="left"><code>INFO</code></td>
<td align="left">确认程序按预期运行</td>
</tr>
<tr>
<td align="left"><code>WARNING</code></td>
<td align="left">表明有已经或即将发生的意外（例如：磁盘空间不足）。程序仍按预期进行</td>
</tr>
<tr>
<td align="left"><code>ERROR</code></td>
<td align="left">由于严重的问题，程序的某些功能已经不能正常执行</td>
</tr>
<tr>
<td align="left"><code>CRITICAL</code></td>
<td align="left">严重的错误，表明程序已不能继续执行</td>
</tr>
</tbody></table>
<p>Python默认的日志级别是Warning，默认输出到控制台。这意味着，<strong>默认情况下，Info和Debug日志是不会输出的</strong>。</p>
<blockquote>
<p>小贴士：日志的输出级别，确切地说应该是日志的输出阈值，即指定级别及以下级别的日志会输出，其上的不会输出。比如设置日志级别为Warning，则除Info、Debug外其它日志都会输出。</p>
</blockquote>
<h2 id="简单配置"><a href="#简单配置" class="headerlink" title="简单配置"></a>简单配置</h2><h3 id="命令行"><a href="#命令行" class="headerlink" title="命令行"></a>命令行</h3><p>可以在使用命令启动python时指定logging的执行级别</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 执行脚本hello.py，日志级别设置为INFO</span></span><br><span class="line">python hello.py --log=INFO</span><br></pre></td></tr></table></figure>

<h3 id="basicConfig方法"><a href="#basicConfig方法" class="headerlink" title="basicConfig方法"></a>basicConfig方法</h3><p>一般来说，logging的配置都可以在logging.basicConfig()方法完成，如下展示了常用的配置</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 设置日志输出到文件，日志级别设为debug，默认为追加模式</span></span><br><span class="line">logging.basicConfig(filename=<span class="string">&#x27;celery.log&#x27;</span>, level=logging.DEBUG)</span><br><span class="line"><span class="comment"># 输出到文件，覆盖模式</span></span><br><span class="line">logging.basicConfig(filename=<span class="string">&#x27;celery.log&#x27;</span>, filemode=<span class="string">&#x27;w&#x27;</span>, level=logging.DEBUG)</span><br></pre></td></tr></table></figure>

<blockquote>
<p>小贴士：<code>logging.basicConfig</code>方法被设置为只能调用一次，因此针对他的第一次调用是有效的，但以后的调用不会生效。这也是很多问题的发源地：你可能不自觉地多次调用了<code>basicConfig()</code></p>
</blockquote>
<h3 id="日志格式"><a href="#日志格式" class="headerlink" title="日志格式"></a>日志格式</h3><p>还是在<code>basicConfig()</code>中，我们可以配置日志输出格式，通过format参数进行设置</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 输出格式为asc时间+空格+消息内容</span></span><br><span class="line">logging.basicConfig(<span class="built_in">format</span>=<span class="string">&#x27;%(asctime)s %(message)s&#x27;</span>)</span><br></pre></td></tr></table></figure>

<p>日志格式中可以详细设置的内容可以在<a href="https://docs.python.org/zh-cn/3.8/library/logging.html#logrecord-attributes">这里</a>找到，我们列出几个看似很有用的</p>
<table>
<thead>
<tr>
<th>属性名</th>
<th>使用格式</th>
<th>作用</th>
</tr>
</thead>
<tbody><tr>
<td>asctime</td>
<td><code>%(asctime)s</code></td>
<td>日志输出时间，对阅读友好的</td>
</tr>
<tr>
<td>filename</td>
<td><code>%(filename)s</code></td>
<td>输出日志的文件</td>
</tr>
<tr>
<td>funcName</td>
<td><code>%(funcName)s</code></td>
<td>输出日志的方法</td>
</tr>
<tr>
<td>levelname</td>
<td><code>%(levelname)s</code></td>
<td>级别名称，如DEBUG、LEVEL</td>
</tr>
<tr>
<td>lineno</td>
<td><code>%(lineno)d</code></td>
<td>输出日志的源码行号</td>
</tr>
<tr>
<td>message</td>
<td><code>%(message)s</code></td>
<td>输出的消息</td>
</tr>
<tr>
<td>process</td>
<td><code>%(process)d</code></td>
<td>进程ID</td>
</tr>
<tr>
<td>thread</td>
<td><code>%(thread)d</code></td>
<td>线程ID</td>
</tr>
</tbody></table>
<h1 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h1><p>上面所介绍的内容仅解决了记录的问题，并不能满足许多实际项目的需求。比如希望针对不同的日志级别将日志输出到不同的位置、当出现ERROR日志时通过邮件报警、自动记录ERROR log的个数等。要做到这些需求，我们需要更加深入Python日志系统，了解其基本工作原理。</p>
<blockquote>
<p>这里有一点忌讳的是，在不了解Python日志基本构成的情况下，直接使用网上搜索的方式进行复杂的日志配置。这样成功的概率不高，且出问题时往往面临束手无策的尴尬境地。</p>
</blockquote>
<p>Python日志库采用模块化方法，通过几类组件协同工作，完成日志从发起到输出终点的全流程。如下</p>
<ul>
<li>Logger - 记录器：用户暴露接口给用户直接调用。它产生LogRecord对象传递给下一个组件。</li>
<li>Handler - 处理器：处理Logger产生的LogRecord</li>
<li>Filter - 过滤器：更加精确地控制日志的输出</li>
<li>Formatter - 格式化器：用户将日志处理成最终输出的样子</li>
</ul>
<p>其中，Logger是层次结构的，有父子关系。几个组件的协同处理流程如下图所示</p>
<p><img src="https://www.tapd.cn/tfl/pictures/202003/tapd_61207716_1583592896_17.png" alt="image-20200307190901858"></p>
<h2 id="Logger"><a href="#Logger" class="headerlink" title="Logger"></a>Logger</h2><p>Logger类，即记录器，用于暴露接口给用户调用，其简单创建和使用方法如下</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> logging</span><br><span class="line"></span><br><span class="line">logger = logging.getLogger(__name__)</span><br><span class="line">logger.warning(<span class="string">&#x27;Hello, World!!!&#x27;</span>)</span><br></pre></td></tr></table></figure>

<p>创建Logger使用<code>logging.getLogger(&#39;name&#39;)</code>方法，当Logger实例已存在，则直接返回，不存在则创建。</p>
<p>Logger具有层次结构，主要通过名称体现，以.分隔。如名为root的Logger实例是名为root.hello、root.world的Logger实例的父级。</p>
<p>层级结构的好处在于减少配置的冗余，以及消息的冒泡传递：在子Logger没有声明级别的情况下，使用父Logger的级别，以此类推，如果都没有设置级别，则会使用root的Warning级别；日志输出时，除了执行当前Logger的所有逻辑外，还可以传递给父Logger，如上图所示。</p>
<p>接口方面，Logger主要提供配置和消息创建两类接口</p>
<ul>
<li><p>配置</p>
<ul>
<li>Logger.setLevel() 设置当前Logger的日志级别</li>
<li>Logger.addHandler()/removeHandler() 添加/删除处理器</li>
<li>Logger.addFilter()/removeFilter 添加/删除过滤器</li>
</ul>
</li>
<li><p>创建消息</p>
<ul>
<li>Logger.debug()/info()/warning()/error()/critical() 创建不同级别的日志</li>
<li>Logger.exception() 输出ERROR级别的日志，不同的是还附带堆栈信息</li>
<li>Logger.log() 显式自定义日志输出级别并创建日志信息</li>
</ul>
</li>
</ul>
<h2 id="Handler"><a href="#Handler" class="headerlink" title="Handler"></a>Handler</h2><p>Handler类，即处理器。决定如何处理Logger发送的消息对象，即将消息对象发送到哪个目标</p>
<p>Handler暴露给用户的接口如下</p>
<ul>
<li>Handler.setLevel() 设置当前Handler的日志级别。这意味着，Logger能够处理的日志级别和Handler的日志级别可以不同，即Handler可以选择性处理日志消息</li>
<li>Handler.setFormatter() 指定格式化器</li>
<li>Handler.addFilter()/revmoFilter() 添加/删除过滤器</li>
</ul>
<p>Python内建了很多处理器，如下。通过这些Handler，可将日志输出到文件、内存、邮件、网络</p>
<p><img src="https://www.tapd.cn/tfl/pictures/202003/tapd_61207716_1583592919_91.png" alt="image-20200307193416476"></p>
<h2 id="Filter"><a href="#Filter" class="headerlink" title="Filter"></a>Filter</h2><p>Filter类，即过滤器。Python只定义了一个Filter基类，该类构造器接收一个name参数，其过滤逻辑为：仅允许与Logger同级或子级的LogRecord通过，其余被滤出。如Filter名为A.B，则名称为A.B、A.B.C、A.B.D的Logger创建的LogRecord均可通过，A.F的Logger创建的LogRecord将被滤出。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="built_in">filter</span> = logging.Filter(<span class="string">&#x27;hello&#x27;</span>)</span><br></pre></td></tr></table></figure>

<p>要实现自定义的Filter，集成<code>logging.Filter</code>类，并重写其<code>filter()</code>方法即可</p>
<h2 id="Formatter"><a href="#Formatter" class="headerlink" title="Formatter"></a>Formatter</h2><p>Formatter类，即格式化器。决定了日志输出格式，用户只需要创建它并扔给Handler就好。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">formatter = logging.Formatter(fmt=<span class="string">&#x27;%(filename)s %(funcName)s %(message)s&#x27;</span>, datefmt=<span class="literal">None</span>, style=<span class="string">&#x27;%&#x27;</span>)</span><br></pre></td></tr></table></figure>

<p>参数解释如下</p>
<ul>
<li><p>fmt - 格式设置，和基础部分一样。能够输出<a href="https://docs.python.org/zh-cn/3.8/library/logging.html#logrecord-attributes">LogRecord对象的所有属性</a>。如果临时忘了，在Formatter类定义注释中，有详细的说明。</p>
</li>
<li><p>datefmt - 指定日期的格式化，举例</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="string">&#x27;%m/%d/%Y %I:%M:%S %p&#x27;</span></span><br></pre></td></tr></table></figure></li>
<li><p>style - 格式化风格，%和$二选一，两个风格区别如下。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># %风格</span></span><br><span class="line"><span class="string">&quot;%s %s&quot;</span> % (<span class="string">&#x27;hello&#x27;</span>, <span class="string">&#x27;world&#x27;</span>)</span><br><span class="line"><span class="comment"># $风格</span></span><br><span class="line"><span class="string">&quot;&#123;&#125; &#123;&#125;&quot;</span>.<span class="built_in">format</span>(<span class="string">&#x27;hello&#x27;</span>, <span class="string">&#x27;world&#x27;</span>)</span><br></pre></td></tr></table></figure></li>
</ul>
<h2 id="LogRecord"><a href="#LogRecord" class="headerlink" title="LogRecord"></a>LogRecord</h2><p>LogRecord类，用户每调用一次Logger的输出接口，就会创建一个LogRecord类实例，该实例作为在日志系统各组件的最小单位。基于其重要性，这里单独提了出来。</p>
<h1 id="配置"><a href="#配置" class="headerlink" title="配置"></a>配置</h1><p>Python提供了三种配置日志的方式</p>
<ul>
<li>使用各组件提供的配置方法手动配置</li>
<li>按照指定格式创建配置文件，然后使用<code>logging.config.fileConfig()</code>读取</li>
<li>按照指定格式创建配置字典，然后使用<code>logging.config.dictConfig()</code>读取</li>
</ul>
<p>下面直接搬运官方文档给出的三种方式</p>
<h2 id="代码配置"><a href="#代码配置" class="headerlink" title="代码配置"></a>代码配置</h2><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> logging</span><br><span class="line"></span><br><span class="line"><span class="comment"># create logger</span></span><br><span class="line">logger = logging.getLogger(<span class="string">&#x27;simpleExample&#x27;</span>)</span><br><span class="line">logger.setLevel(logging.DEBUG)</span><br><span class="line"></span><br><span class="line"><span class="comment"># create console handler and set level to debug</span></span><br><span class="line">ch = logging.StreamHandler()</span><br><span class="line">ch.setLevel(logging.DEBUG)</span><br><span class="line"></span><br><span class="line"><span class="comment"># create formatter</span></span><br><span class="line">formatter = logging.Formatter(<span class="string">&#x27;%(asctime)s - %(name)s - %(levelname)s - %(message)s&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># add formatter to ch</span></span><br><span class="line">ch.setFormatter(formatter)</span><br><span class="line"></span><br><span class="line"><span class="comment"># add ch to logger</span></span><br><span class="line">logger.addHandler(ch)</span><br></pre></td></tr></table></figure>

<h2 id="文件配置"><a href="#文件配置" class="headerlink" title="文件配置"></a>文件配置</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">[loggers]</span><br><span class="line">keys=root,simpleExample</span><br><span class="line"></span><br><span class="line">[handlers]</span><br><span class="line">keys=consoleHandler</span><br><span class="line"></span><br><span class="line">[formatters]</span><br><span class="line">keys=simpleFormatter</span><br><span class="line"></span><br><span class="line">[logger_root]</span><br><span class="line">level=DEBUG</span><br><span class="line">handlers=consoleHandler</span><br><span class="line"></span><br><span class="line">[logger_simpleExample]</span><br><span class="line">level=DEBUG</span><br><span class="line">handlers=consoleHandler</span><br><span class="line">qualname=simpleExample</span><br><span class="line">propagate=0</span><br><span class="line"></span><br><span class="line">[handler_consoleHandler]</span><br><span class="line">class=StreamHandler</span><br><span class="line">level=DEBUG</span><br><span class="line">formatter=simpleFormatter</span><br><span class="line">args=(sys.stdout,)</span><br><span class="line"></span><br><span class="line">[formatter_simpleFormatter]</span><br><span class="line">format=%(asctime)s - %(name)s - %(levelname)s - %(message)s</span><br><span class="line">datefmt=</span><br></pre></td></tr></table></figure>

<p>文件配置内容格式具有自解释作用，这里不做讲解。</p>
<p>唯一需要注意的是，在指定处理器的class时，类名称是相对于Python的日志记录模块（注意是Python的日志模块，即logging的位置），或按照导入机制能够正常导入的绝对import路径。</p>
<p>如StreamHandler，因它在logging模块中定义，因此可以直接写StreamHandler即可。</p>
<p>再如com.github.zou.HelloHandler，属于自定义，因此需要全路径。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> logging</span><br><span class="line"><span class="keyword">import</span> logging.config</span><br><span class="line"></span><br><span class="line"><span class="comment"># 上面的文件名为logging.conf</span></span><br><span class="line">logging.config.fileConfig(<span class="string">&#x27;logging.conf&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># create logger</span></span><br><span class="line">logger = logging.getLogger(<span class="string">&#x27;simpleExample&#x27;</span>)</span><br></pre></td></tr></table></figure>

<h2 id="dict配置"><a href="#dict配置" class="headerlink" title="dict配置"></a>dict配置</h2><figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">version:</span> <span class="number">1</span></span><br><span class="line"><span class="attr">formatters:</span></span><br><span class="line">  <span class="attr">simple:</span></span><br><span class="line">    <span class="attr">format:</span> <span class="string">&#x27;%(asctime)s - %(name)s - %(levelname)s - %(message)s&#x27;</span></span><br><span class="line"><span class="attr">handlers:</span></span><br><span class="line">  <span class="attr">console:</span></span><br><span class="line">    <span class="attr">class:</span> <span class="string">logging.StreamHandler</span></span><br><span class="line">    <span class="attr">level:</span> <span class="string">DEBUG</span></span><br><span class="line">    <span class="attr">formatter:</span> <span class="string">simple</span></span><br><span class="line">    <span class="attr">stream:</span> <span class="string">ext://sys.stdout</span></span><br><span class="line"><span class="attr">loggers:</span></span><br><span class="line">  <span class="attr">simpleExample:</span></span><br><span class="line">    <span class="attr">level:</span> <span class="string">DEBUG</span></span><br><span class="line">    <span class="attr">handlers:</span> [<span class="string">console</span>]</span><br><span class="line">    <span class="attr">propagate:</span> <span class="literal">no</span></span><br><span class="line"><span class="attr">root:</span></span><br><span class="line">  <span class="attr">level:</span> <span class="string">DEBUG</span></span><br><span class="line">  <span class="attr">handlers:</span> [<span class="string">console</span>]</span><br></pre></td></tr></table></figure>

<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> logging</span><br><span class="line"><span class="keyword">import</span> logging.config</span><br><span class="line"><span class="keyword">import</span> yaml</span><br><span class="line"></span><br><span class="line"><span class="comment"># 将yaml文件读取为dict，再进行配置</span></span><br><span class="line">config = yaml.load(<span class="built_in">open</span>(<span class="string">&#x27;logging.yml&#x27;</span>), Loader=yaml.FullLoader)</span><br><span class="line">logging.config.dictConfig(<span class="string">&#x27;logging.yml&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># create logger</span></span><br><span class="line">logger = logging.getLogger(<span class="string">&#x27;simpleExample&#x27;</span>)</span><br></pre></td></tr></table></figure>

<h2 id="有坑"><a href="#有坑" class="headerlink" title="有坑"></a>有坑</h2><h3 id="配置覆盖问题"><a href="#配置覆盖问题" class="headerlink" title="配置覆盖问题"></a>配置覆盖问题</h3><p>使用<code>fileConfig()</code>时，<strong>带有默认参数<code>disable_existing_logger=True</code>，因此之前的除root之外的所有Logger全都会被禁用</strong>，这一点要非常注意。如果不希望如此，可手动将其设置为False</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">fileConfig</span>(<span class="params">fname, defaults=<span class="literal">None</span>, disable_existing_loggers=<span class="literal">True</span></span>):</span></span><br><span class="line">    <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">    Read the logging configuration from a ConfigParser-format file.</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    This can be called several times from an application, allowing an end user</span></span><br><span class="line"><span class="string">    the ability to select from various pre-canned configurations (if the</span></span><br><span class="line"><span class="string">    developer provides a mechanism to present the choices and load the chosen</span></span><br><span class="line"><span class="string">    configuration).</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line">. . . . . .</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="无配置注意事项"><a href="#无配置注意事项" class="headerlink" title="无配置注意事项"></a>无配置注意事项</h3><p>如果对应的Logger没有进行配置，会出现找不到对应处理器来处理消息的情况。根据版本不同会有如下表现</p>
<p>Python版本&lt;3.2时</p>
<ul>
<li>若logging.raiseException为False，则静默丢弃消息</li>
<li>若logging.raiseException为True，则打印“无法找到记录器的处理程序”</li>
</ul>
<p>Python版本&gt;=3.2时</p>
<ul>
<li>使用logging.lastResort中存储的处理器进行输出。该处理器与任何Logger都没有关联，直接将描述信息写入sys.sterr，并且信息不会被格式化，输出级别为Warning</li>
<li>如果我们将logging.lastResort手动设置为None，其表现将和3.2之前的版本一致。</li>
</ul>
<h1 id="参考文档"><a href="#参考文档" class="headerlink" title="参考文档"></a>参考文档</h1><ol>
<li><a href="https://docs.python.org/zh-cn/3.8/howto/logging.html">Python日志教程</a></li>
<li><a href="https://docs.python.org/zh-cn/3.8/howto/logging-cookbook.html#logging-cookbook">日志操作手册</a></li>
<li><a href="https://docs.python.org/zh-cn/3.8/library/logging.html#logrecord-attributes">日志格式化内容</a></li>
</ol>
]]></content>
      <categories>
        <category>编程语言</category>
      </categories>
      <tags>
        <tag>日志</tag>
      </tags>
  </entry>
  <entry>
    <title>Kubernetes的鉴权</title>
    <url>/2022/02/17/RBAC%E7%9C%8B%E4%B8%80%E6%B3%A2/</url>
    <content><![CDATA[<p>前面介绍过Kubernetes的结构组成，其中API Server用于与外界的交互，我们常用的命令行工具kubectl、UI工具lens、云服务商提供的WebUI，最终都是通过Restfule API的形式，走HTTP协议，到达API Server。此时就带来权限控制问题。</p>
<span id="more"></span>

<img src="https://gdz.oss-cn-shenzhen.aliyuncs.com/local/image-20211203153658776.png" alt="image-20211203153658776" style="zoom:80%;" />

<p>如上图，对来自外部的请求，Api Server会经过三个组件</p>
<ul>
<li>Authentication：认证，验证用户的合法性，并从中提取出用户信息，如用户名、组等</li>
<li>Authorization：鉴权，鉴定该用户是否有权限访问指定资源</li>
<li>Admission：准入，它可以修改或拒绝请求</li>
</ul>
<h2 id="认证"><a href="#认证" class="headerlink" title="认证"></a>认证</h2><p>与用户相关的概念，有用户、组、ServiceAccount，但只有ServiceAccount才在Kubernetes中以资源的形式存在，用户、组并不会以资源的形式存在，它们只是一个字符串，在使用的地方如RoleBinding时被引用，理解这一点很重要。</p>
<p>从集群内部，即pod中访问API Server时，需要ServiceAccount来标识身份；从集群外部访问API Server时，则需要走外部验证，包括：客户端证书、密码、普通令牌、引导令牌。</p>
<h3 id="ServiceAccount"><a href="#ServiceAccount" class="headerlink" title="ServiceAccount"></a>ServiceAccount</h3><p>每个命名空间都会有一个默认的ServiceAccount。一个典型的ServiceAccount如下</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">gd % kubectl --kubeconfig ~/.kube/config-test get sa -o yaml</span><br><span class="line">apiVersion: v1</span><br><span class="line">items:</span><br><span class="line">- apiVersion: v1</span><br><span class="line">  imagePullSecrets:</span><br><span class="line">  - name: acr-credential-560b66540f01e51c18524b09ad7f575f</span><br><span class="line">  - name: acr-credential-6731ef77d88edc24b279ebf20860f30f</span><br><span class="line">  - name: acr-credential-5dee66918cdf5d93de4aa5cd90247f73</span><br><span class="line">  - name: acr-credential-be55512166dd26eda658d0706de5a06a</span><br><span class="line">  - name: acr-credential-bab42ef118a2913b05cd8cdb95441d70</span><br><span class="line">  kind: ServiceAccount</span><br><span class="line">  metadata:</span><br><span class="line">    creationTimestamp: &quot;2020-11-10T06:48:55Z&quot;</span><br><span class="line">    name: default</span><br><span class="line">    namespace: default</span><br><span class="line">    resourceVersion: &quot;100598603&quot;</span><br><span class="line">    selfLink: /api/v1/namespaces/default/serviceaccounts/default</span><br><span class="line">    uid: 4ef6a2d3-19ad-47cf-a2de-135f2c9d86b5</span><br><span class="line">  secrets:</span><br><span class="line">  - name: default-token-vrqk9</span><br><span class="line">kind: List</span><br><span class="line">metadata:</span><br><span class="line">  resourceVersion: &quot;&quot;</span><br><span class="line">  selfLink: &quot;&quot;</span><br></pre></td></tr></table></figure>

<p>可以看到它其实包含两部分：secrets、imagePullSecrets，其中，前者会被挂载到pod的容器内，用于在访问API Server时提供信息；后者则用于pod从私有仓库拉取镜像时使用的秘钥。也就是说，ServiceAccount的作用也就是这两部分了。本文重点关注secrets部分。</p>
<p>当一个pod创建时，它会默认拥有该ServiceAccount，这一点可以通过查看一个已经存在的pod得以验证</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">gd % kubectl --kubeconfig ~/.kube/config-test get pod app-bosslist-backend-67c59b8d94-k75kj -o yaml | grep service</span><br><span class="line">    - mountPath: /var/run/secrets/kubernetes.io/serviceaccount</span><br><span class="line">  serviceAccount: default</span><br><span class="line">  serviceAccountName: default</span><br></pre></td></tr></table></figure>

<p>而该token包含两部分信息：服务端证书、token值的BASE64编码。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">g % kubectl --kubeconfig ~/.kube/config-test get secret default-token-vrqk9 -o yaml</span><br><span class="line">apiVersion: v1</span><br><span class="line">data:</span><br><span class="line">  ca.crt: LS0tLS1CRUdJTiBDRVJUSUZJQ0FURS0tLS0tCk1JSURHakNDQWdLZ0F3SUJBZ0lCQURBTkJna3Foa2lHOXcwQkFRc0ZBREErTVNjd0ZBWURWUVFLRXcxaGJHbGkKWVdKaElHTnNiM1ZrTUE4R0ExVUVDaE1JYUdGdVozcG9iM1V4RXpBUkJnTlZCxxxxx</span><br><span class="line">  namespace: ZGVmYXVsdA==</span><br><span class="line">  token: ZXlKaGJHY2lPaUpTVXpJMU5pSXNJbXRwWkNJNklteEthMkpUUm1GbFVFZFlWRmhsUTBKcE1VTjJkbmd6TVZCRWVtSjNkSFZHUVVWU1RFWXhjak5DTlhjaWZRLmV5SnBjM01pT2lKcmRXSmxjbTVsZEdWekwzTmxjblpwWTJWaFxxxxx</span><br><span class="line">kind: Secret</span><br><span class="line">metadata:</span><br><span class="line">  annotations:</span><br><span class="line">    kubernetes.io/service-account.name: default</span><br><span class="line">    kubernetes.io/service-account.uid: 4ef6a2d3-19ad-47cf-a2de-135f2c9d86b5</span><br><span class="line">  creationTimestamp: &quot;2020-11-10T06:48:55Z&quot;</span><br><span class="line">  name: default-token-vrqk9</span><br><span class="line">  namespace: default</span><br><span class="line">  resourceVersion: &quot;38744013&quot;</span><br><span class="line">  selfLink: /api/v1/namespaces/default/secrets/default-token-vrqk9</span><br><span class="line">  uid: 64ee0b11-9919-47b1-97e9-e055f47f3732</span><br><span class="line">type: kubernetes.io/service-account-token</span><br></pre></td></tr></table></figure>

<p>token值是JWT，解码结果如下</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  &quot;iss&quot;: &quot;kubernetes/serviceaccount&quot;,</span><br><span class="line">  &quot;kubernetes.io/serviceaccount/namespace&quot;: &quot;default&quot;,</span><br><span class="line">  &quot;kubernetes.io/serviceaccount/secret.name&quot;: &quot;default-token-vrqk9&quot;,</span><br><span class="line">  &quot;kubernetes.io/serviceaccount/service-account.name&quot;: &quot;default&quot;,</span><br><span class="line">  &quot;kubernetes.io/serviceaccount/service-account.uid&quot;: &quot;4ef6a2d3-19ad-47cf-a2de-135f2c9d86b5&quot;,</span><br><span class="line">  &quot;sub&quot;: &quot;system:serviceaccount:default:default&quot;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="普通用户、组"><a href="#普通用户、组" class="headerlink" title="普通用户、组"></a>普通用户、组</h3><p>API Server都是通过客户端自声明的方式得到用户名、组等信息，自己并不会存储。而客户端提供自己身份的方式有几种：客户端证书、密码、普通令牌、引导令牌。具体官方手册有说明：<a href="https://kubernetes.io/zh/docs/reference/access-authn-authz/authentication/%E3%80%82%E6%88%91%E4%BB%AC%E9%87%8D%E7%82%B9%E5%85%B3%E6%B3%A8%E5%AE%A2%E6%88%B7%E7%AB%AF%E8%AF%81%E4%B9%A6%E7%9A%84%E6%96%B9%E5%BC%8F%E3%80%82">https://kubernetes.io/zh/docs/reference/access-authn-authz/authentication/。我们重点关注客户端证书的方式。</a></p>
<p>很重要的点是API Server将证书中的CN当做用户名，O当做组名。于是，我们要做的，就是创建自己的key、csr，在让API服务端签发证书，就能使用key+crt的方式以预期的身份合法访问API Server了。</p>
<p>具体步骤可参见下文“最佳实践 - 创建一个只能操作Deployment的用户”前两步。</p>
<h2 id="鉴权-RBAC"><a href="#鉴权-RBAC" class="headerlink" title="鉴权 - RBAC"></a>鉴权 - RBAC</h2><p>认证确认了用户的合法身份，鉴权则是根据用户的身份和访问的资源确定是否具有访问的权限。<a href="https://kubernetes.io/zh/docs/reference/access-authn-authz/authorization/">官方手册在这</a>。从以前到现在，Kubernetes支持如下几种方式:</p>
<ul>
<li>Node：节点鉴权，专门对 kubelet 发出的 API 请求进行鉴权</li>
<li>ABAC：基于属性的鉴权</li>
<li>RBAC：基于角色的鉴权</li>
<li>Webhook：即回调自定义的HTTP接口，决定是否可访问</li>
</ul>
<p>我们关注RBAC鉴权模式。</p>
<h3 id="Role和RoleBinding"><a href="#Role和RoleBinding" class="headerlink" title="Role和RoleBinding"></a>Role和RoleBinding</h3><p>Role是角色，是一堆资源操作的权限集合；RoleBinding将Role和用户绑定起来，绑定的对象可以是用户、组、ServiceAccount。看两个例子就一目了然。</p>
<p>首先是Role的定义，如下表示角色cirole允许对default命名空间下的deployment资源进行get、list、update、patch</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">apiVersion:</span> <span class="string">rbac.authorization.k8s.io/v1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">Role</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">cirole</span></span><br><span class="line">  <span class="attr">namespace:</span> <span class="string">default</span></span><br><span class="line"><span class="attr">rules:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">verbs:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">get</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">list</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">update</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">patch</span></span><br><span class="line">    <span class="attr">apiGroups:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">apps</span></span><br><span class="line">    <span class="attr">resources:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">deployments</span></span><br></pre></td></tr></table></figure>

<p>其次是RoleBinding，如下表示将角色cirole和用户ciuser进行绑定</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">apiVersion:</span> <span class="string">rbac.authorization.k8s.io/v1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">RoleBinding</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">cirolebinding</span></span><br><span class="line">  <span class="attr">namespace:</span> <span class="string">default</span></span><br><span class="line"><span class="attr">subjects:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">kind:</span> <span class="string">User</span></span><br><span class="line">    <span class="attr">apiGroup:</span> <span class="string">rbac.authorization.k8s.io</span></span><br><span class="line">    <span class="attr">name:</span> <span class="string">ciuser</span></span><br><span class="line"><span class="attr">roleRef:</span></span><br><span class="line">  <span class="attr">apiGroup:</span> <span class="string">rbac.authorization.k8s.io</span></span><br><span class="line">  <span class="attr">kind:</span> <span class="string">Role</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">cirole</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>上述两个声明应用后，就能实现ciuser对default命名空间下的deployment的操作，可以通过kubectl auth can-i命令检测权限</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 检查ciuser是否能够获取deployment</span></span><br><span class="line">gd % kubectl --kubeconfig ~/.kube/config-test auth can-i get deployments --as ciuser</span><br><span class="line">yes</span><br><span class="line"><span class="meta">#</span><span class="bash"> 检查ciuser是否能够获取secrets</span></span><br><span class="line">gd % kubectl --kubeconfig ~/.kube/config-test auth can-i get secrets --as ciuser</span><br><span class="line">no</span><br></pre></td></tr></table></figure>

<h3 id="ClusterRole和ClusterRoleBinding"><a href="#ClusterRole和ClusterRoleBinding" class="headerlink" title="ClusterRole和ClusterRoleBinding"></a>ClusterRole和ClusterRoleBinding</h3><p>Role和RoleBinding是有命名空间限制的，只能限制命名空间内的资源，有下面两个场景其无法满足</p>
<ul>
<li>一个用户需要访问多个命名空间下的资源时，按照Role的做法，需要在每个命名空间下定义Role，然后定义多个RoleBinding将用户与角色绑定，太多复杂</li>
<li>一些并不存在的资源的访问控制，仅仅是一个URL路径，比如/healthz</li>
<li>一些不属于任何命名空间的资源的访问控制，比如Node、PV等</li>
</ul>
<p>此时就需要ClusterRole，话不多说，直接看他们的定义即可</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 这里节选了drain-node的角色定义，可发现其最大的不同就是少了namespace</span></span><br><span class="line"><span class="attr">apiVersion:</span> <span class="string">rbac.authorization.k8s.io/v1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">ClusterRole</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">drain-node</span></span><br><span class="line"><span class="attr">rules:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">verbs:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">get</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">list</span></span><br><span class="line">    <span class="attr">apiGroups:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">extensions</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">apps</span></span><br><span class="line">    <span class="attr">resources:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">daemonsets</span></span><br></pre></td></tr></table></figure>

<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 节选了system:node的角色绑定</span></span><br><span class="line"><span class="attr">apiVersion:</span> <span class="string">rbac.authorization.k8s.io/v1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">ClusterRoleBinding</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">system:node</span></span><br><span class="line"><span class="attr">roleRef:</span></span><br><span class="line">  <span class="attr">apiGroup:</span> <span class="string">rbac.authorization.k8s.io</span></span><br><span class="line">  <span class="attr">kind:</span> <span class="string">ClusterRole</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">system:node</span></span><br></pre></td></tr></table></figure>

<h3 id="默认角色"><a href="#默认角色" class="headerlink" title="默认角色"></a>默认角色</h3><p>Kubernetes提供了大量默认角色和角色绑定，都是Cluster级别，我们看几个</p>
<ul>
<li>admin：管理员角色</li>
<li>view：对除了Secrets之外的资源的访问，在授权只读用户时尤其有效</li>
<li>edit：对除了角色和角色绑定之外的资源的访问和编辑，不能操作角色和角色绑定是防止授权扩张</li>
</ul>
<p>这里强烈案例一个Kubernetes可视化管理软件——<a href="https://k8slens.dev/">lens</a>，用它，去查看默认角色们吧</p>
<p><img src="https://gdz.oss-cn-shenzhen.aliyuncs.com/local/image-20211203164001619.png" alt="image-20211203164001619"></p>
<h2 id="kubeconfig文件"><a href="#kubeconfig文件" class="headerlink" title="kubeconfig文件"></a>kubeconfig文件</h2><p>使用kubectl访问API Server时，实际上是需要客户端凭证的，对于Linux系操作系统，它的位置在：~/.kube/config，关于kubeconfig，大致介绍，详细看<a href="https://kubernetes.io/zh/docs/concepts/configuration/organize-cluster-access-kubeconfig/">官方手册</a>。</p>
<p>一个config文件由四部分组成</p>
<ul>
<li>集群地址和集群CA证书，该证书用作HTTPS加密传输时用，可以有多个</li>
<li>用户凭证，使用证书认证时存的是用户证书和加密key，可以有多个</li>
<li>上下文，集群地址和用户凭证的绑定，可以有多个</li>
<li>当前上下文，决定当前处于激活状态下的上下文。即当前以哪个用户连接哪个集群地址</li>
</ul>
<p>多个config文件可合并</p>
<ul>
<li>如果设置了KUBECONFIG环境变量，指明了多个config文件，则这些文件会以一定的规则合并，这个可以在本地管理时方便使用。</li>
</ul>
<h2 id="阿里云RAM与RBAC"><a href="#阿里云RAM与RBAC" class="headerlink" title="阿里云RAM与RBAC"></a>阿里云RAM与RBAC</h2><p>阿里云的RAM，对容器服务只有管理和读取两个权限，对资源的具体权限管理需要使用RBAC，在阿里云容器服务控制台有简单的RBAC配置 —— 授权管理。</p>
<p>如下，它的最细粒度，能够管理某个子账号对指定集群的指定命名空间的指定角色的绑定管理。其实就是对角色绑定的封装。</p>
<p><img src="https://gdz.oss-cn-shenzhen.aliyuncs.com/local/image-20211203165229100.png" alt="image-20211203165229100"></p>
<p>你可能会想，子账号对应的集群内用户是什么呢？我们可以从控制台给出的连接信息看出端倪</p>
<img src="https://gdz.oss-cn-shenzhen.aliyuncs.com/local/image-20211203165546184.png" alt="image-20211203165546184" style="zoom:80%;" />

<p>对一个管理员账号的证书进行解析，可以发现它的用户名(CN)就是阿里云子账号的ID，用户组为system:users</p>
<p><img src="https://gdz.oss-cn-shenzhen.aliyuncs.com/local/image-20211203165743823.png" alt="image-20211203165743823"></p>
<p>而如果我们对某个用户指定了自定义权限，则会创建多条RoleBinding，命名规则为 <code>&lt;userid&gt;-&lt;namespace&gt;-&lt;role&gt;-rolebinding</code>，比如</p>
<p><img src="https://gdz.oss-cn-shenzhen.aliyuncs.com/local/image-20211203170002236.png" alt="image-20211203170002236"></p>
<h2 id="准入"><a href="#准入" class="headerlink" title="准入"></a>准入</h2><p>这就是一堆前置处理器，称之为准入处理器，忽略，有需要去看<a href="https://kubernetes.io/zh/docs/reference/access-authn-authz/admission-controllers/">手册</a></p>
<h2 id="最佳实践"><a href="#最佳实践" class="headerlink" title="最佳实践"></a>最佳实践</h2><h3 id="一些快速的命令"><a href="#一些快速的命令" class="headerlink" title="一些快速的命令"></a>一些快速的命令</h3><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 快速创建一个pod</span></span><br><span class="line">kubectl run podname --image=luksa/kubectl-proxy -n default</span><br><span class="line"><span class="meta">#</span><span class="bash"> 编辑一个资源的yaml文件</span></span><br><span class="line">kubectl edit pod xxx</span><br><span class="line"><span class="meta">#</span><span class="bash"> 快速创建role</span></span><br><span class="line">kubectl create role service-reader --verb=get --verb=list --resource=services -n bar</span><br><span class="line"><span class="meta">#</span><span class="bash"> 快速创建rolebinding</span></span><br><span class="line">kubectl create rolebinding test --role=service-reader --serviceaccount=foo:default -n foo</span><br><span class="line"><span class="meta">#</span><span class="bash"><span class="comment"># 快速创建clusterrole</span></span></span><br><span class="line">kubectl create clusterrole pv-reader --verb=get,list --resource=persistentvolumes</span><br><span class="line"><span class="meta">#</span><span class="bash"> 快速创建clusterrolebinding</span></span><br><span class="line">kubectl create clusterrolebinding pv-test --clusterrole=pv-reader --serviceaccount=foo:default</span><br><span class="line"><span class="meta">#</span><span class="bash"> 快速检测权限：我能在default命名空间创建deployment吗？</span></span><br><span class="line">kubectl auth can-i create deployment -n default</span><br><span class="line"><span class="meta">#</span><span class="bash"> 快速检测权限：我能在default命名空间以用户<span class="built_in">test</span>来创建deployment吗？</span></span><br><span class="line">kubectl auth can-i create deployment -n default --as test</span><br></pre></td></tr></table></figure>

<h3 id="创建一个只能操作Deployment的用户"><a href="#创建一个只能操作Deployment的用户" class="headerlink" title="创建一个只能操作Deployment的用户"></a>创建一个只能操作Deployment的用户</h3><p>以证书的方式，先在本地创建用户，再在k8s服务器签发，然后创建角色和角色绑定，最后将用户注册到本地config文件，就能访问了</p>
<ol>
<li><p>创建用户</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 生成秘钥</span></span><br><span class="line">openssl genrsa -out ciuser.key 2048</span><br><span class="line"><span class="meta">#</span><span class="bash"> 生成csr，注意CN代表用户名；O代表组名</span></span><br><span class="line">openssl req -new -key ciuser.key -out ciuser.csr -subj &quot;/CN=ciuser/O=ci&quot;</span><br><span class="line"><span class="meta">#</span><span class="bash"> 将csr做base64编码</span></span><br><span class="line">cat ciuser.csr | base64 | tr -d &quot;\n&quot;</span><br></pre></td></tr></table></figure></li>
<li><p>k8s服务器签发证书</p>
<p>创建csr请求，其中的request是第一步商城的csr做的base64编码</p>
<p>csr.yaml</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">apiVersion:</span> <span class="string">certificates.k8s.io/v1beta1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">CertificateSigningRequest</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">ciuser</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line">  <span class="attr">groups:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">system:authenticated</span></span><br><span class="line">  <span class="attr">request:</span> <span class="string">xxxxxxxxxxxxxxxxxxxxxx</span></span><br><span class="line">  <span class="attr">signerName:</span> <span class="string">kubernetes.io/kube-apiserver-client</span></span><br><span class="line">  <span class="attr">usages:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">client</span> <span class="string">auth</span></span><br></pre></td></tr></table></figure>

<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">kubectl --kubeconfig ~/.kube/config-test apply -f csr.yaml</span><br></pre></td></tr></table></figure></li>
<li><p>创建角色和角色绑定</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">kubectl --kubeconfig ~/.kube/config-test create role cirole --verb=get --verb=list --verb=update --verb=patch --resource=deployments -n default</span><br><span class="line">kubectl --kubeconfig ~/.kube/config-test create rolebinding cirolebinding --role=cirole --user=ciuser -n default</span><br></pre></td></tr></table></figure></li>
<li><p>在config文件注册用户和上下文</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 添加用户凭证； --embed-certs=<span class="literal">true</span>表示将证书写入config文件，而不是引用</span></span><br><span class="line">kubectl --kubeconfig ~/.kube/config-test config set-credentials ciuser --client-key=ciuser.key --client-certificate=ciuser.crt --embed-certs=true</span><br><span class="line"><span class="meta">#</span><span class="bash"> 添加上下文</span></span><br><span class="line">kubectl --kubeconfig ~/.kube/config-test config set-context ciuser --cluster=kubernetes --user=ciuser</span><br><span class="line"><span class="meta">#</span><span class="bash"> 切换上下文</span></span><br><span class="line">kubectl --kubeconfig ~/.kube/config-test config use-context ciuser</span><br><span class="line"><span class="meta">#</span><span class="bash"> 接下来，就按照正常操作即可</span></span><br><span class="line">kubectl --kubeconfig ~/.kube/config-test get deployments</span><br></pre></td></tr></table></figure></li>
</ol>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ol>
<li><a href="https://kubernetes.io/zh/docs/concepts/security/controlling-access/">Kubernetes API访问控制</a></li>
</ol>
]]></content>
      <categories>
        <category>运维</category>
      </categories>
      <tags>
        <tag>Kubernetes</tag>
      </tags>
  </entry>
  <entry>
    <title>SASL</title>
    <url>/2022/01/06/SASL/</url>
    <content><![CDATA[]]></content>
      <categories>
        <category>后端</category>
      </categories>
      <tags>
        <tag>SASL</tag>
      </tags>
  </entry>
  <entry>
    <title>Sign in with Apple - IOS平台服务端的处理</title>
    <url>/2020/03/28/Sign%20in%20with%20Apple%20-%20IOS%E5%B9%B3%E5%8F%B0%E6%9C%8D%E5%8A%A1%E7%AB%AF%E7%9A%84%E5%A4%84%E7%90%86-signinwithapple-ios%E5%B9%B3%E5%8F%B0%E6%9C%8D%E5%8A%A1%E7%AB%AF%E7%9A%84%E5%A4%84%E7%90%86/</url>
    <content><![CDATA[<hr>
<p>title: Sign in with Apple - IOS平台服务端的处理<br>tags:</p>
<ul>
<li>IOS<br>categories:</li>
<li>第三方登录<br>date: 2020-03-28 20:41:32</li>
</ul>
<hr>
<p>本周新做一个需求，为IOS APP接入苹果第三方登录。查看官方文档，发现其在IOS端操作描述是非常细致的，但在用户服务端的讲解实在是不知所云，让人头大。只能借助广大网友的智慧。本文并非完全原创，因为无论概念解读，还是操作方式，都是从各个文章处抄来的。本文最大的作用，在于针对自己和团队内部的开发记录，防止多次踩坑。</p>
<p>Sign in with Apple，对IOS和其它平台的处理方式是有很大差别的。本文只针对IOS平台，其它平台可以参考<a href="https://sarunw.com/posts/sign-in-with-apple-4/">这篇文章</a>，说得非常详细</p>
<span id="more"></span>

<h1 id="说明"><a href="#说明" class="headerlink" title="说明"></a>说明</h1><p>本文主要以官方文档为主线，辅以自己的理解。依赖于<a href="https://developer.apple.com/documentation/sign_in_with_apple/sign_in_with_apple_rest_api">Sign in with Apple REST API</a>页面，其分为两部分</p>
<ul>
<li><p>用户授权和验证 - Authentication and Verification of Users</p>
</li>
<li><p>获取公钥和生成&amp;验证token的API介绍</p>
</li>
</ul>
<p>IOS上的苹果登录与一般的第三方登录最大的区别，在于IOS在客户端已经获取了必要的用户信息，以加密的形式发送给服务端，服务端需要做的验证并应用即可；而一般的第三方登录流程是需要在服务端请求用户信息的。秉持这一基础认识很重要，否则会云里雾里。</p>
<h1 id="客户端"><a href="#客户端" class="headerlink" title="客户端"></a>客户端</h1><p>该部分对应 <a href="https://developer.apple.com/documentation/sign_in_with_apple/sign_in_with_apple_rest_api/authenticating_users_with_sign_in_with_apple">Authenticating Users with Sign in with Apple</a></p>
<img src="https://gdz.oss-cn-shenzhen.aliyuncs.com/notes/image-20210216221623082.png" style="zoom:150%;" />

<p>客户端授权流程如上主要有如下几步</p>
<ol>
<li>调用API发起授权请求</li>
<li>设备弹出授权框，请求用户授权</li>
<li>用户授权成功，API调用Apple ID 服务，请求用户信息</li>
<li>请求成功，Apple ID服务以返回三个字段：identity token、authorization code、user identifier</li>
</ol>
<h2 id="identity-token"><a href="#identity-token" class="headerlink" title="identity token"></a>identity token</h2><p>identity token是一个JWT，使用解析工具解开后如下，包含了基本的用户信息。</p>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">     kid: <span class="string">&quot;86D88Kf&quot;</span>,</span><br><span class="line">     alg: <span class="string">&quot;RS256&quot;</span></span><br><span class="line">&#125;.</span><br><span class="line">&#123;</span><br><span class="line">     iss: <span class="string">&quot;https://appleid.apple.com&quot;</span>,</span><br><span class="line">     aud: <span class="string">&quot;com.mampod.enlighten&quot;</span>,</span><br><span class="line">     exp: <span class="number">1585110701</span>,</span><br><span class="line">     iat: <span class="number">1585110101</span>,</span><br><span class="line">     sub: <span class="string">&quot;001230.15f855de99ef4b788a18d18b7b45b053.0400&quot;</span>,</span><br><span class="line">     nonce: <span class="string">&quot;123&quot;</span>,</span><br><span class="line">     c_hash: <span class="string">&quot;lGYaArOB6z6IFuCOx2Z64A&quot;</span>,</span><br><span class="line">     email: <span class="string">&quot;d6yuqtqhv3@privaterelay.appleid.com&quot;</span>,</span><br><span class="line">     email_verified: <span class="string">&quot;true&quot;</span>,</span><br><span class="line">     is_private_email: <span class="string">&quot;true&quot;</span>,</span><br><span class="line">     auth_time: <span class="number">1585110101</span>,</span><br><span class="line">     nonce_supported: <span class="literal">true</span></span><br><span class="line">&#125;.</span><br><span class="line">[signature]</span><br></pre></td></tr></table></figure>

<p>每个字段解读如下</p>
<p>头部：</p>
<p>kid: key id，在token验证时用于选取公钥的ID</p>
<p>alg: algorithm，算法</p>
<p>载荷部分：</p>
<ul>
<li>iss: isser的缩写，即JWT发布人</li>
<li>aud: audience的缩写，客户，对应APP的开发者。对应Apple开发者账户中的client_id</li>
<li>exp: expire的缩写，即过期时间</li>
<li>iat: issue at的缩写，即该token的发布时间</li>
<li>sub: subject，即加密对象，这是关键，<strong>它是用户的唯一标识符，很重要</strong>。</li>
<li>nonce: 即随机字符串。用于绑定客户端会话和token的字符串值，用于防止重复攻击。</li>
<li>nonce_supported: 指示对待nonce的方式<ul>
<li>true: 如果授权请求时有给nonce，但返回的token不含nonce，则说明此次请求失败</li>
<li>false: 不支持nonce，忽略nonce</li>
</ul>
</li>
<li>c_hash: authorizationCode的hash值，用于验证authorizationCode</li>
<li>email: 用户邮箱</li>
<li>email_verified: 邮箱是否经过验证，总是为true</li>
<li>is_private_email:  是否是加密邮箱，即上面说的<a href="mailto:&#120;&#120;&#x78;&#x40;&#x70;&#114;&#x69;&#x76;&#x61;&#116;&#x65;&#x72;&#101;&#x6c;&#97;&#121;&#x2e;&#97;&#x70;&#x70;&#x6c;&#x65;&#105;&#100;&#46;&#99;&#x6f;&#x6d;">&#120;&#120;&#x78;&#x40;&#x70;&#114;&#x69;&#x76;&#x61;&#116;&#x65;&#x72;&#101;&#x6c;&#97;&#121;&#x2e;&#97;&#x70;&#x70;&#x6c;&#x65;&#105;&#100;&#46;&#99;&#x6f;&#x6d;</a></li>
<li>auth_time: 请求授权的时间</li>
</ul>
<h2 id="authorization-code"><a href="#authorization-code" class="headerlink" title="authorization code"></a>authorization code</h2><p>authorization code用于和Apple ID服务交互，这里暂时用不到，忽略。</p>
<h2 id="user-identifier"><a href="#user-identifier" class="headerlink" title="user identifier"></a>user identifier</h2><p>JWT中的sub字段，对应了用户唯一标识符，即identifier，它具有如下特性</p>
<ul>
<li>唯一且稳定</li>
<li>同一个苹果开发账户的所有APP对应的同一个用户的identifier是唯一的</li>
<li>不同的开发账户的APP对应一个用户的不同identifier</li>
<li>对于用户从APP注销，再登录，identifier是不会变的</li>
<li>可以用于唯一标示用户，即应该用它而不是邮箱嵌入我们的业务数据库</li>
</ul>
<h2 id="Private-email"><a href="#Private-email" class="headerlink" title="Private email"></a>Private email</h2><p>授权时，用户可以选择隐藏真是邮箱，于是我们会获取到一个<a href="mailto:&#x78;&#120;&#120;&#64;&#x70;&#114;&#x69;&#x76;&#97;&#x74;&#x65;&#114;&#x65;&#108;&#x61;&#x79;&#46;&#x61;&#x70;&#x70;&#x6c;&#x65;&#x69;&#x64;&#46;&#x63;&#x6f;&#x6d;">&#x78;&#120;&#120;&#64;&#x70;&#114;&#x69;&#x76;&#97;&#x74;&#x65;&#114;&#x65;&#108;&#x61;&#x79;&#46;&#x61;&#x70;&#x70;&#x6c;&#x65;&#x69;&#x64;&#46;&#x63;&#x6f;&#x6d;</a>格式的用户邮箱，该邮箱具有一定限制</p>
<ul>
<li>邮箱具有全局唯一性</li>
<li>发往该邮箱的信息将会被转发到真实的用户邮箱</li>
<li>对于同一个开发者的所有APP，一个用户对应一个邮箱；对于不同开发这的不同APP，一个用户对应多个邮箱</li>
<li>该邮箱一旦生成，会一直生效，无论用户是否有登录你的APP，或已经删除APP</li>
<li>要想向该邮箱发送信息，需要在Apple注册发送邮箱的邮箱域名，否则不会发送成功。</li>
</ul>
<h2 id="客户端最后一步"><a href="#客户端最后一步" class="headerlink" title="客户端最后一步"></a>客户端最后一步</h2><p>为了将用户与我方APP服务端用户系统绑定，需要将上面获取的的identity token、authorization code、user identifier等信息发送APP服务端。</p>
<h1 id="服务端"><a href="#服务端" class="headerlink" title="服务端"></a>服务端</h1><p>这部分对应 <a href="https://developer.apple.com/documentation/sign_in_with_apple/sign_in_with_apple_rest_api/verifying_a_user">Verifying a User</a>，也是最令人头大的一部分。相同地，他也提供了一个流程图，描述如何使用authorization code换取用户信息和refresh token。对IOS登录的后台验证毫无帮助，相反会起到混淆视听的作用。请直接忽略。</p>
<p>对于IOS登录，由于IOS客户端已经通过客户端API获取了必要的用户信息：唯一标识符、name、email等，我们已经没有必要再次获取这些信息，只需要验证他们的真实性即可。</p>
<p>而对于其它平台的登录，如果你觉得看不懂这里的文档，强烈建议你按照这篇文章的方式操作——<a href="https://sarunw.com/posts/sign-in-with-apple-4/">Sign in with Apple Tutorial, Part 4: Web and Other Platforms</a></p>
<h2 id="验证identity-token"><a href="#验证identity-token" class="headerlink" title="验证identity token"></a>验证identity token</h2><p>identity token的签名是Apple ID服务使用私钥加密的，需要从<a href="https://appleid.apple.com/auth/keys">这里</a>获取公钥解密验证。取得的公钥以JWKS的形式呈现，如下。</p>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    <span class="attr">&quot;keys&quot;</span>: [</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="attr">&quot;kty&quot;</span>: <span class="string">&quot;RSA&quot;</span>,</span><br><span class="line">        <span class="attr">&quot;kid&quot;</span>: <span class="string">&quot;86D88Kf&quot;</span>,</span><br><span class="line">        <span class="attr">&quot;use&quot;</span>: <span class="string">&quot;sig&quot;</span>,</span><br><span class="line">        <span class="attr">&quot;alg&quot;</span>: <span class="string">&quot;RS256&quot;</span>,</span><br><span class="line">        <span class="attr">&quot;n&quot;</span>: <span class="string">&quot;iGaLqP6y-SJCCBq5Hv6pGDbG_SQ11MNjH7rWHcCFYz4hGwHC4lcSurTlV8u3avoVNM8jXevG1Iu1SY11qInqUvjJur--hghr1b56OPJu6H1iKulSxGjEIyDP6c5BdE1uwprYyr4IO9th8fOwCPygjLFrh44XEGbDIFeImwvBAGOhmMB2AD1n1KviyNsH0bEB7phQtiLk-ILjv1bORSRl8AK677-1T8isGfHKXGZ_ZGtStDe7Lu0Ihp8zoUt59kx2o9uWpROkzF56ypresiIl4WprClRCjz8x6cPZXU2qNWhu71TQvUFwvIvbkE1oYaJMb0jcOTmBRZA2QuYw-zHLwQ&quot;</span>,</span><br><span class="line">        <span class="attr">&quot;e&quot;</span>: <span class="string">&quot;AQAB&quot;</span></span><br><span class="line">    &#125;,</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="attr">&quot;kty&quot;</span>: <span class="string">&quot;RSA&quot;</span>,</span><br><span class="line">        <span class="attr">&quot;kid&quot;</span>: <span class="string">&quot;eXaunmL&quot;</span>,</span><br><span class="line">        <span class="attr">&quot;use&quot;</span>: <span class="string">&quot;sig&quot;</span>,</span><br><span class="line">        <span class="attr">&quot;alg&quot;</span>: <span class="string">&quot;RS256&quot;</span>,</span><br><span class="line">        <span class="attr">&quot;n&quot;</span>: <span class="string">&quot;4dGQ7bQK8LgILOdLsYzfZjkEAoQeVC_aqyc8GC6RX7dq_KvRAQAWPvkam8VQv4GK5T4ogklEKEvj5ISBamdDNq1n52TpxQwI2EqxSk7I9fKPKhRt4F8-2yETlYvye-2s6NeWJim0KBtOVrk0gWvEDgd6WOqJl_yt5WBISvILNyVg1qAAM8JeX6dRPosahRVDjA52G2X-Tip84wqwyRpUlq2ybzcLh3zyhCitBOebiRWDQfG26EH9lTlJhll-p_Dg8vAXxJLIJ4SNLcqgFeZe4OfHLgdzMvxXZJnPp_VgmkcpUdRotazKZumj6dBPcXI_XID4Z4Z3OM1KrZPJNdUhxw&quot;</span>,</span><br><span class="line">        <span class="attr">&quot;e&quot;</span>: <span class="string">&quot;AQAB&quot;</span></span><br><span class="line">    &#125;</span><br><span class="line">    ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>公钥不止一个，需要取kid字段与JWT头部的kid字段匹配的那个。</p>
<p>这里我们使用了使用人数较多的库<a href="https://github.com/auth0/java-jwt">java-jwt</a>、<a href="https://github.com/auth0/jwks-rsa-java">jwks-rsa-java</a>。</p>
<figure class="highlight scala"><table><tr><td class="code"><pre><span class="line"><span class="keyword">val</span> jwt = <span class="type">JWT</span>.decode(<span class="comment">/*客户端上传的JWT*/</span>)</span><br><span class="line"><span class="keyword">val</span> jwk = <span class="keyword">new</span> <span class="type">UrlJwkProvider</span>(<span class="string">&quot;https://appleid.apple.com/auth/keys&quot;</span>).get(jwt.getKeyId)</span><br><span class="line"><span class="keyword">val</span> algorithm = <span class="type">Algorithm</span>.<span class="type">RSA256</span>(jwk.getPublicKey.asInstanceOf[<span class="type">RSAPublicKey</span>], <span class="literal">null</span>)</span><br><span class="line"><span class="type">Try</span> &#123;</span><br><span class="line">    algorithm.verify()</span><br><span class="line">&#125; <span class="keyword">match</span> &#123;</span><br><span class="line">    <span class="keyword">case</span> <span class="type">Success</span>(_) =&gt; <span class="comment">// 验证通过</span></span><br><span class="line">    <span class="keyword">case</span> <span class="type">Failure</span>(e) =&gt; <span class="comment">// 验证不通过</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="验证其它内容"><a href="#验证其它内容" class="headerlink" title="验证其它内容"></a>验证其它内容</h2><p>根据官方手册，总计需要验证如下内容</p>
<ul>
<li>使用公钥验证JWT签名，上一步已验证</li>
<li>验证nonce，可选，这里不验证</li>
<li>验证iss，必须为apple签发，即必须包含<a href="https://appleid.apple.com字符串/">https://appleid.apple.com字符串</a></li>
<li>验证aud，必须为开发者账户的client_id</li>
<li>验证exp，即过期时间</li>
</ul>
<p>使用现成库的好处之一是可以直接获取JWT的标准字段，如下</p>
<figure class="highlight scala"><table><tr><td class="code"><pre><span class="line"><span class="type">Try</span> &#123;</span><br><span class="line">    assert(jwt.getAudience.get(<span class="number">0</span>) == clientId, <span class="string">&quot;aud incorrect&quot;</span>)</span><br><span class="line">    assert(jwt.getIssuer.contains(<span class="string">&quot;https://appleid.apple.com&quot;</span>), <span class="string">&quot;iss must contains https://appleid.apple.com&quot;</span>)</span><br><span class="line">    assert(jwt.getSubject == request.identifier, <span class="string">&quot;identifier invalid&quot;</span>)</span><br><span class="line">    assert(jwt.getExpiresAt.getTime &gt; <span class="type">System</span>.currentTimeMillis(), <span class="string">&quot;Identity token expired&quot;</span>)</span><br><span class="line">&#125; <span class="keyword">match</span> &#123;</span><br><span class="line">    <span class="keyword">case</span> <span class="type">Success</span>(_) =&gt;  <span class="comment">// 验证通过</span></span><br><span class="line">    <span class="keyword">case</span> <span class="type">Failure</span>(e) =&gt; <span class="comment">// 验证不通过</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="优化-缓存Algorithm实例"><a href="#优化-缓存Algorithm实例" class="headerlink" title="优化 - 缓存Algorithm实例"></a>优化 - 缓存Algorithm实例</h2><p>上述验证步骤中，在获取公钥和构建Algorithm实例时耗费较长时间——超过1秒</p>
<figure class="highlight scala"><table><tr><td class="code"><pre><span class="line"><span class="keyword">val</span> jwk = <span class="keyword">new</span> <span class="type">UrlJwkProvider</span>(<span class="string">&quot;https://appleid.apple.com/auth/keys&quot;</span>).get(jwt.getKeyId)</span><br><span class="line"><span class="keyword">val</span> algorithm = <span class="type">Algorithm</span>.<span class="type">RSA256</span>(jwk.getPublicKey.asInstanceOf[<span class="type">RSAPublicKey</span>], <span class="literal">null</span>)</span><br></pre></td></tr></table></figure>

<p>为了加快响应速度，可以缓存Algorithm实例，但由于apple提供的公钥可能变化，因此需要使用一定的策略兼顾效率和正确性。</p>
<p>实际操作如下</p>
<figure class="highlight scala"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">verifySignature</span></span>(force: <span class="type">Boolean</span> = <span class="literal">false</span>) = &#123;</span><br><span class="line">    <span class="keyword">if</span> (force) jwkCache.remove(jwt.getKeyId)</span><br><span class="line">    jwkCache.get(jwt.getKeyId, () =&gt; &#123;</span><br><span class="line">        <span class="keyword">val</span> jwk = <span class="keyword">new</span> <span class="type">UrlJwkProvider</span>(<span class="string">&quot;https://appleid.apple.com/auth/keys&quot;</span>).get(jwt.getKeyId)</span><br><span class="line">        <span class="type">Algorithm</span>.<span class="type">RSA256</span>(jwk.getPublicKey.asInstanceOf[<span class="type">RSAPublicKey</span>], <span class="literal">null</span>)</span><br><span class="line">    &#125;).map(algorithm =&gt; <span class="type">Try</span> &#123;</span><br><span class="line">        algorithm.verify(jwt)</span><br><span class="line">    &#125; <span class="keyword">match</span> &#123;</span><br><span class="line">        <span class="keyword">case</span> <span class="type">Success</span>(_) =&gt; <span class="type">Unit</span></span><br><span class="line">        <span class="keyword">case</span> <span class="type">Failure</span>(e) =&gt; <span class="type">Future</span>.failed(e)</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">verifySignature()</span><br><span class="line">.recoverWith[<span class="type">Any</span>] &#123; <span class="keyword">case</span> _: <span class="type">Throwable</span> =&gt; verifySignature(force = <span class="literal">true</span>) &#125;</span><br></pre></td></tr></table></figure>

<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>相对于传统第三方登录，IOS的登录流程略有不同</p>
<h2 id="一般流程"><a href="#一般流程" class="headerlink" title="一般流程"></a>一般流程</h2><p>客户端</p>
<ul>
<li>用户被导入登录服务提供商，如微信、支付宝等</li>
<li>用户扫码或输入账号密码授权</li>
<li>服务提供商将用户重定向回客户端，并附带token</li>
<li>客户端凭借该token进行登录</li>
</ul>
<p>服务端</p>
<ul>
<li>应用服务端凭借该token向服务提供商验证登录真实性并获取用户信息</li>
<li>使用获取到的用户信息绑定自建的用户系统</li>
</ul>
<h2 id="IOS登录流程"><a href="#IOS登录流程" class="headerlink" title="IOS登录流程"></a>IOS登录流程</h2><p>客户端</p>
<ul>
<li>IOS客户端上弹出授权框</li>
<li>用户刷脸授权</li>
<li>Apple同样将用户重定向回应用，附带token，但同时使用客户端API想Apple Server获取用户信息，以JWT形式提供</li>
<li>客户端将JWT发送给应用服务端</li>
</ul>
<p>服务端</p>
<ul>
<li>验证JWT</li>
<li>使用JWT附带的用户信息绑定自建的用户系统</li>
</ul>
<p>可以看到，其最主要的不同还是在于IOS客户端已经获取了用户信息，在服务端仅需要验证JWT即可，与一般流程相比，IOS登录的应用后端少了一步请求用户信息的步骤。</p>
<h2 id="没涉及的部分"><a href="#没涉及的部分" class="headerlink" title="没涉及的部分"></a>没涉及的部分</h2><p>文章到这里也只介绍了在IOS客户端接入Sign in with apple的后端操作步骤，并没有设计到IOS之外平台的处理方式，对此，可以参考<a href="https://sarunw.com/posts/sign-in-with-apple-4/">这篇文章</a>，它有很好的讲解。</p>
<h1 id="更多"><a href="#更多" class="headerlink" title="更多"></a>更多</h1><p>关于更多授权相关知识，这里列举了一些学习资源</p>
<ul>
<li><a href="https://oauth.net/2/">Oauth</a></li>
<li><a href="https://openid.net/connect/">OpenID Connect</a></li>
<li><a href="https://jwt.io/introduction/">JWT</a></li>
<li><a href="https://self-issued.info/docs/draft-ietf-jose-json-web-key.html">JWK</a></li>
</ul>
<h1 id="参考文档"><a href="#参考文档" class="headerlink" title="参考文档"></a>参考文档</h1><ol>
<li><p><a href="https://developer.apple.com/documentation/sign_in_with_apple/sign_in_with_apple_rest_api/authenticating_users_with_sign_in_with_apple">Authenticating Users with Sign in with Apple</a></p>
</li>
<li><p><a href="https://developer.apple.com/documentation/sign_in_with_apple/sign_in_with_apple_rest_api/verifying_a_user">Verifying a User</a></p>
</li>
<li><p><a href="https://developer.apple.com/documentation/sign_in_with_apple/fetch_apple_s_public_key_for_verifying_token_signature">Fetch Apple’s public key for verifying token signature</a></p>
</li>
<li><p><a href="https://juejin.im/post/5d551d11e51d4561cf15dfae#heading-15">iOS 13 苹果账号登陆与后台验证相关</a></p>
</li>
<li><p><a href="https://sarunw.com/posts/sign-in-with-apple-3/">Sign in with Apple Tutorial, Part 3: Backend – Token verification</a></p>
</li>
</ol>
]]></content>
      <categories>
        <category>后端</category>
      </categories>
      <tags>
        <tag>IOS</tag>
      </tags>
  </entry>
  <entry>
    <title>Spring STOMP发送消息时区分客户端</title>
    <url>/2021/09/16/Spring%20STOMP%E5%8F%91%E9%80%81%E6%B6%88%E6%81%AF%E6%97%B6%E5%8C%BA%E5%88%86%E5%AE%A2%E6%88%B7%E7%AB%AF-springstomp-fa-song-xiao-xi-shi-qu-fen-ke-hu-duan/</url>
    <content><![CDATA[<h2 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h2><p>现有使用Spring WebSocket库搭建的STOMP通知中心，使用Spring自带功能，能够区分到用户，向来自同一用户的多个连接（会话）广播数据。</p>
<p>这正是我们的使用场景：当用户调用服务端指定接口时，服务端向该用户所在的所有用户发送通知。</p>
<p>现有的配置，在WebSocket握手阶段验证TOKEN，解析成用户ID，存入WebSession；在接口访问时带上TOKEN，再通过SimpMessagingTemplate.convertAndSendToUser()向该用户进行广播。</p>
<span id="more"></span>

<h2 id="说明"><a href="#说明" class="headerlink" title="说明"></a>说明</h2><ul>
<li><p>X-GD-UID：客户端提供设备识别码的请求头名</p>
</li>
<li><p>X-GD-TOKEN：客户端提供TOKEN的请求头名</p>
</li>
<li><p>uid：设备识别码在服务端内部的流转名</p>
</li>
<li><p>deviceId：设备识别码在服务端内部的流转名</p>
</li>
<li><p>user：用户在服务端内部的流转名</p>
</li>
<li><p>WebSocketSession：WebSocket的Session，一般来说，一个WebSocket连接对应一个Session。该session对应的sessionId，单个服务器</p>
</li>
<li><p>STOMP Session：STOMP的Session，和WebSession等价。源码中，将来自WebSocket的消息包装成STOMP消息，可以直接看到二者的设置关系：</p>
  <figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 位置：org.springframework.web.socket.messaging.StompSubProtocolHandler#handleMessageFromClient</span></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">handleMessageFromClient</span><span class="params">(WebSocketSession session,...)</span> </span>&#123;</span><br><span class="line">	... ...</span><br><span class="line">	headerAccessor.setSessionId(session.getId());</span><br><span class="line">	... ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<h2 id="优化需求"><a href="#优化需求" class="headerlink" title="优化需求"></a>优化需求</h2><p>按照上面的方式，对一个用户广播，会通知到所有设备，即使该设备是通知触发方。逻辑上讲，通知触发方是不应该收到通知的。这正是我们需要实现的需求。</p>
<h2 id="方案"><a href="#方案" class="headerlink" title="方案"></a>方案</h2><h3 id="设备识别"><a href="#设备识别" class="headerlink" title="设备识别"></a>设备识别</h3><p>当前只能通过TOKEN识别用户。但没有识别设备的方式，我们可能有两种</p>
<ul>
<li>IP地址：不可取。网络环境复杂，经过层层转发，我们不一定能保证获取到稳定的IP地址；即时能够获取到，因为SNAT的存在，对处在同一局域网下的多台设备，也不一定能够区分。</li>
<li>设备识别码：取客户端设备的唯一识别码，这是最保险的方法。但根据“客户端不可信原则”。userId+设备识别码才是理论上最靠谱的方式。</li>
</ul>
<h3 id="放在哪"><a href="#放在哪" class="headerlink" title="放在哪"></a>放在哪</h3><p>设备识别码这个参数，比较中性，可以在其他业务上用，因此放在头部比较合适，暂定X-GD-UID。客户端所有请求，都带上该头部。</p>
<h3 id="服务端方案"><a href="#服务端方案" class="headerlink" title="服务端方案"></a>服务端方案</h3><ol>
<li>WebSocket握手时，解析user和uid，放入WebSocketSession。该WebSocketSession会在后面的每次交互中带上此两个参数。</li>
<li>在STOMP进行CONNECT时，我们能够在入方向的拦截器中获取到上一步存放的user、uid，以及新建的STOMP session，我们将他们缓存起来，以便后面使用。</li>
<li>发送STOMP通知时，指定要忽略哪个uid，我们能够在出方向上的拦截器中拦截该消息，如果发现当前通知即将发送的目标设备和指定的uid匹配，则拦截掉该通知。</li>
<li>连接断开时，清除缓存</li>
</ol>
<h3 id="缓存放哪"><a href="#缓存放哪" class="headerlink" title="缓存放哪"></a>缓存放哪</h3><p>三个地方备选，综合来看，放在Redis是比较好的选择。不过需要小心的是Redis的重启</p>
<ul>
<li>本地：多实例时会出问题</li>
<li>Redis：Redis数据库本身的声明周期和项目不一致，有可能在项目运行到一半时关闭</li>
<li>数据库：生命周期大于项目，是理论上最安全的位置，但访问速度可能会比较慢</li>
</ul>
<h2 id="实施"><a href="#实施" class="headerlink" title="实施"></a>实施</h2><p>全流程配置忽略，这里只说关键部分的代码。我们将与当前功能相关的逻辑都放在一个类中，如下。本节其它小节将会直接引用该类中的方法</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">DeviceHolder</span></span>(<span class="keyword">private</span> <span class="keyword">val</span> redisTemplate: StringRedisTemplate) &#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">removeSession</span><span class="params">(message: <span class="type">Message</span>&lt;*&gt;)</span></span> &#123;</span><br><span class="line">        SimpMessageHeaderAccessor.getSessionId(message.headers)?.let &#123;</span><br><span class="line">            redisTemplate.delete(it.toRedisKey())</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">deviceBindInterceptor</span><span class="params">()</span></span> = <span class="keyword">object</span> : ChannelInterceptor &#123;</span><br><span class="line">        <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">preSend</span><span class="params">(message: <span class="type">Message</span>&lt;*&gt;, channel: <span class="type">MessageChannel</span>)</span></span>: Message&lt;*&gt; &#123;</span><br><span class="line">            <span class="comment">// 连接时记录deviceId和当前session的关系</span></span><br><span class="line">            <span class="keyword">val</span> accessor = MessageHeaderAccessor.getAccessor(message, StompHeaderAccessor::<span class="keyword">class</span>.java)</span><br><span class="line">            <span class="keyword">if</span> (accessor != <span class="literal">null</span> &amp;&amp; StompCommand.CONNECT == accessor.command) &#123;</span><br><span class="line">                <span class="keyword">val</span> user = accessor.user ?: <span class="keyword">return</span> message</span><br><span class="line">                <span class="keyword">val</span> deviceId = accessor.sessionAttributes?.<span class="keyword">get</span>(DEVICE_ID_ATTRIBUTE)?.toString() ?: <span class="keyword">return</span> message</span><br><span class="line">                <span class="keyword">val</span> sessionId = accessor.sessionId!!</span><br><span class="line">                redisTemplate.opsForValue().<span class="keyword">set</span>(sessionId.toRedisKey(), genDeviceValue(user.name, deviceId))</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> message</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">deviceIgnoreInterceptor</span><span class="params">()</span></span> = <span class="keyword">object</span> : ChannelInterceptor &#123;</span><br><span class="line">        <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">preSend</span><span class="params">(message: <span class="type">Message</span>&lt;*&gt;, channel: <span class="type">MessageChannel</span>)</span></span>: Message&lt;*&gt;? &#123;</span><br><span class="line">            <span class="comment">// 发送时滤除指定deviceId的sessionID</span></span><br><span class="line">            <span class="keyword">val</span> accessor = MessageHeaderAccessor.getAccessor(message, SimpMessageHeaderAccessor::<span class="keyword">class</span>.java)</span><br><span class="line">            <span class="keyword">if</span> (accessor != <span class="literal">null</span> &amp;&amp; SimpMessageType.MESSAGE == accessor.messageType) &#123;</span><br><span class="line">                <span class="keyword">val</span> username = accessor.removeNativeHeader(USER_ATTRIBUTE)?.singleOrNull() ?: <span class="keyword">return</span> message</span><br><span class="line">                <span class="keyword">val</span> ignoreDeviceId = accessor.removeNativeHeader(DEVICE_ID_ATTRIBUTE)?.singleOrNull() ?: <span class="keyword">return</span> message</span><br><span class="line">                <span class="keyword">val</span> deviceValueOfMessage = redisTemplate.opsForValue().<span class="keyword">get</span>(accessor.sessionId!!.toRedisKey()) ?: <span class="keyword">return</span> message</span><br><span class="line">                <span class="keyword">if</span> (deviceValueOfMessage == genDeviceValue(username, ignoreDeviceId)) <span class="keyword">return</span> <span class="literal">null</span></span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> message</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="function"><span class="keyword">fun</span> <span class="title">genDeviceValue</span><span class="params">(username: <span class="type">String</span>, deviceId: <span class="type">String</span>)</span></span>: String = <span class="string">&quot;<span class="subst">$&#123;username&#125;</span>-<span class="variable">$deviceId</span>&quot;</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="function"><span class="keyword">fun</span> String.<span class="title">toRedisKey</span><span class="params">()</span></span> = <span class="string">&quot;MYLOGS_WEBSOCKET_DEVICE_<span class="variable">$this</span>&quot;</span></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="UID解析"><a href="#UID解析" class="headerlink" title="UID解析"></a>UID解析</h3><p>握手拦截器中解析UID</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> class <span class="title">AuthHandshakeInterceptor</span><span class="params">(val objectMapper: ObjectMapper)</span> : HandshakeInterceptor </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function">override fun <span class="title">beforeHandshake</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">        request: ServerHttpRequest,</span></span></span><br><span class="line"><span class="params"><span class="function">        response: ServerHttpResponse,</span></span></span><br><span class="line"><span class="params"><span class="function">        wsHandler: WebSocketHandler,</span></span></span><br><span class="line"><span class="params"><span class="function">        attributes: MutableMap&lt;String, Any&gt;</span></span></span><br><span class="line"><span class="params"><span class="function">    )</span>: Boolean </span>&#123;</span><br><span class="line">        val user = request.parseUser(objectMapper)</span><br><span class="line">        val deviceId = request.parseDeviceId()</span><br><span class="line">				... ...</span><br><span class="line">        <span class="keyword">if</span> (deviceId != <span class="keyword">null</span>) attributes[DEVICE_ID_ATTRIBUTE] = deviceId</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 扩展方法，从头部或query中取X-GD-UID</span></span><br><span class="line">fun ServerHttpRequest.parseDeviceId(): String? &#123;</span><br><span class="line">    val deviceIdInHeader = <span class="keyword">this</span>.headers[DEVICE_UID_HEADER]?.firstOrNull()</span><br><span class="line">    val deviceIdInQuery = lazy &#123; <span class="keyword">this</span>.uri.query?.split(<span class="string">&quot;&amp;&quot;</span>)?.find &#123; it.contains(DEVICE_UID_HEADER) &#125;?.split(<span class="string">&quot;=&quot;</span>)?.last() &#125;</span><br><span class="line">    <span class="keyword">return</span> deviceIdInHeader ?: deviceIdInQuery.value</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="UID缓存"><a href="#UID缓存" class="headerlink" title="UID缓存"></a>UID缓存</h3><p>入方向上的拦截器，取出user、uid、sessionId，放入Redis。参见DeviceHolder.deviceBindInterceptor()。</p>
<h3 id="信息拦截"><a href="#信息拦截" class="headerlink" title="信息拦截"></a>信息拦截</h3><p>出方向上的拦截器，缓存匹配，则忽略。参见DeviceHolder.deviceIgnoreInterceptor()。</p>
<h3 id="连接断开处理"><a href="#连接断开处理" class="headerlink" title="连接断开处理"></a>连接断开处理</h3><p>当STOMP连接或WebSocket连接断开时，会发送SessionDisconnectEvent事件，我们监听该事件，在连接断开时主动清理掉内存。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">DisconnectEventListener</span>(</span></span><br><span class="line"><span class="class">    <span class="title">private</span> <span class="title">val</span> <span class="title">deviceHolder</span>: <span class="title">DeviceHolder</span></span></span><br><span class="line"><span class="class">) : <span class="title">ApplicationListener</span>&lt;<span class="title">SessionDisconnectEvent</span>&gt; </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function">override fun <span class="title">onApplicationEvent</span><span class="params">(event: SessionDisconnectEvent)</span> </span>&#123;</span><br><span class="line">        deviceHolder.removeSession(event.message)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="使用方"><a href="#使用方" class="headerlink" title="使用方"></a>使用方</h3><p>使用方需传入用户名、目标地址、要忽略的设备ID、要发送的消息等。</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> SimpMessagingTemplate.<span class="title">notifyUserWithoutDevice</span><span class="params">(userId: <span class="type">Int</span>, deviceId: <span class="type">String</span>?, maxUsn: <span class="type">Long</span>)</span></span> &#123;</span><br><span class="line">    <span class="keyword">val</span> user = User.fromId(userId)</span><br><span class="line">    <span class="keyword">this</span>.convertAndSendToUser(</span><br><span class="line">				<span class="comment">// 用户名</span></span><br><span class="line">        user.name,</span><br><span class="line">				<span class="comment">// 用户地址</span></span><br><span class="line">        STOMP_USER_PULL_NOTIFICATION_TOPIC,</span><br><span class="line">				<span class="comment">// 发送的消息体</span></span><br><span class="line">        PullNotify(maxUsn),</span><br><span class="line">				<span class="comment">// 附带的额外属性。很重要，正是它们携带了用户名、设备id到出方向上的拦截器</span></span><br><span class="line">        mapOf(</span><br><span class="line">            DEVICE_ID_ATTRIBUTE to deviceId,</span><br><span class="line">            USER_ATTRIBUTE to user.name</span><br><span class="line">        )</span><br><span class="line">    )</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="要点"><a href="#要点" class="headerlink" title="要点"></a>要点</h2><ul>
<li>Spring WebSocket为我们提供的参与消息收发的方式主要有握手拦截器、握手处理器、STOMP消息入方向上的拦截器、STOMP消息出方向上的拦截器，正是利用这些特性，我们猜完成了设备识别这一需求</li>
<li>出方向的拦截器无法获取到消息所属用户，因此这里我们在用SimpMessagingTemplate发送消息时将用户放进头中，再在拦截器中取出。这种方式，并不优雅</li>
<li>单实例上的SessionId不会重复，但是多实例之间的SessionId是理论上是可能重复的，此时会存在bug。即一台实例上的session覆盖了另一台实例的缓存，造成有效缓存丢失的情况。有两个解决方案<ul>
<li>保证SessionId绝对不同</li>
<li>存储user-deviceId-sessionId三层结构，这样理论上不会出问题，毕竟同一个用户，在同一台机器上出现一样的sessionId的情况，理论上就不可能出现</li>
</ul>
</li>
</ul>
]]></content>
      <categories>
        <category>后端</category>
      </categories>
      <tags>
        <tag>Spring</tag>
        <tag>WebSocket</tag>
        <tag>STOMP</tag>
      </tags>
  </entry>
  <entry>
    <title>Spring Webflow - Action</title>
    <url>/2018/09/08/Spring%20Webflow%20-%20Action-springwebflow-action/</url>
    <content><![CDATA[<h1 id="action-state"><a href="#action-state" class="headerlink" title="action-state"></a>action-state</h1><h2 id="简单使用"><a href="#简单使用" class="headerlink" title="简单使用"></a>简单使用</h2><p>该状态只执行操作，然后根据操作的结果转移到其他state。可以有多个操作，他们依次执行</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;action-state id=&quot;moreAnswersNeeded&quot;&gt;</span><br><span class="line">	&lt;evaluate expression=&quot;interview.moreAnswersNeeded()&quot; /&gt;</span><br><span class="line">	&lt;transition on=&quot;yes&quot; to=&quot;answerQuestions&quot; /&gt;</span><br><span class="line">	&lt;transition on=&quot;no&quot; to=&quot;finish&quot; /&gt;</span><br><span class="line">&lt;/action-state&gt;</span><br></pre></td></tr></table></figure>
<h2 id="输出"><a href="#输出" class="headerlink" title="输出"></a>输出</h2><p>在action-state中调用普通java对象的方法，这些方法返回的只是一般的值，但是transition标签需要Event来触发，因此web-flow会将这个普通返回值转换为Event对象，具体转换情况如下:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">方法返回值类型			映射出来的EventId</span><br><span class="line">java.lang.String		直接以字符串的值作为id</span><br><span class="line">java.lang.Boolean		yes (for true), no (for false)</span><br><span class="line">java.lang.Enum			the Enum name</span><br><span class="line">any other type	    	success</span><br></pre></td></tr></table></figure>
<h2 id="action-state的操作"><a href="#action-state的操作" class="headerlink" title="action-state的操作"></a>action-state的操作</h2><p>action-state可以有三种方式进行执行操作</p>
<ul>
<li>调用POJO</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;evaluate expression=&quot;pojoAction.method(flowRequestContext)&quot; /&gt;</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public class PojoAction &#123;</span><br><span class="line">	public String method(RequestContext context) &#123;</span><br><span class="line">		...</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>实现Action接口，直接调用该action</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;evaluate expression=&quot;customAction&quot; /&gt;</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public class CustomAction implements Action &#123;</span><br><span class="line">	public Event execute(RequestContext context) &#123;</span><br><span class="line">		...</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>实现MultiAction接口，可以定义多个一连串的方法</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;evaluate expression=&quot;multiAction.actionMethod1&quot; /&gt;</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public class CustomMultiAction extends MultiAction &#123;</span><br><span class="line">	public Event actionMethod1(RequestContext context) &#123;</span><br><span class="line">		...</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	public Event actionMethod2(RequestContext context) &#123;</span><br><span class="line">		...</span><br><span class="line">	&#125;</span><br><span class="line">	...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="action的异常处理"><a href="#action的异常处理" class="headerlink" title="action的异常处理"></a>action的异常处理</h2><ul>
<li>POJO类action的处理方式<br>发生异常时，返回相应的字符串，会映射成Event，在transition中响应就可以了，和普通方法正常返回一样</li>
<li>MultiAction的处理方式<br>发生异常时，返回Event对象</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public class BookingAction extends MultiAction &#123;</span><br><span class="line">	public Event makeBooking(RequestContext context) &#123;</span><br><span class="line">		   try &#123;</span><br><span class="line">			   Booking booking = (Booking) context.getFlowScope().get(&quot;booking&quot;);</span><br><span class="line">			   BookingConfirmation confirmation = bookingService.make(booking);</span><br><span class="line">			   context.getFlowScope().put(&quot;confirmation&quot;, confirmation);</span><br><span class="line">			   return success();</span><br><span class="line">		   &#125; catch (RoomNotAvailableException e) &#123;</span><br><span class="line">			   context.getMessageContext().addMessage(new MessageBuilder().error().</span><br><span class="line">				   .defaultText(&quot;No room is available at this hotel&quot;).build());</span><br><span class="line">			   return error();</span><br><span class="line">		   &#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>使用<code>exception-handler</code>属性，定义异常处理器</li>
</ul>
<h2 id="decision-state"><a href="#decision-state" class="headerlink" title="decision-state"></a>decision-state</h2><p>decision-state是action-state的一种简单替代，在if/else情况时比较好用</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;decision-state id=&quot;moreAnswersNeeded&quot;&gt;</span><br><span class="line">	&lt;if test=&quot;interview.moreAnswersNeeded()&quot; then=&quot;answerQuestions&quot; else=&quot;finish&quot; /&gt;</span><br><span class="line">&lt;/decision-state&gt;</span><br></pre></td></tr></table></figure>
<h2 id="action相关标签"><a href="#action相关标签" class="headerlink" title="action相关标签"></a>action相关标签</h2><ol>
<li><code>&lt;on-start&gt;</code>    flow开始时执行</li>
<li><code>&lt;on-entry&gt;</code>    state进入时执行</li>
<li><code>&lt;on-exit&gt;</code>    state退出时执行</li>
<li><code>&lt;on-end&gt;</code>    flow结束时执行</li>
<li><code>&lt;on-render&gt;</code>view-state中使用，渲染前执行</li>
<li><code>&lt;transition&gt;</code>    在转移前执行<h2 id="命名的action"><a href="#命名的action" class="headerlink" title="命名的action"></a>命名的action</h2>如下展示了一个action-state下多个操作执行，为每个操作命名，第二个操作成功后进行转移操作</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;action-state id=&quot;doTwoThings&quot;&gt;</span><br><span class="line">	&lt;evaluate expression=&quot;service.thingOne()&quot;&gt;</span><br><span class="line">		&lt;attribute name=&quot;name&quot; value=&quot;thingOne&quot; /&gt;</span><br><span class="line">	&lt;/evaluate&gt;</span><br><span class="line">	&lt;evaluate expression=&quot;service.thingTwo()&quot;&gt;</span><br><span class="line">		&lt;attribute name=&quot;name&quot; value=&quot;thingTwo&quot; /&gt;</span><br><span class="line">	&lt;/evaluate&gt;</span><br><span class="line">	&lt;transition on=&quot;thingTwo.success&quot; to=&quot;showResults&quot; /&gt;</span><br><span class="line">&lt;/action-state&gt;</span><br></pre></td></tr></table></figure>
<h1 id="向客户端发送流信息"><a href="#向客户端发送流信息" class="headerlink" title="向客户端发送流信息"></a>向客户端发送流信息</h1><h2 id="应用场景"><a href="#应用场景" class="headerlink" title="应用场景"></a>应用场景</h2><p>客户端请求一个图片文件，此时我们需要直接操作httpresponse进行图片的响应，而不是渲染view。</p>
<h2 id="解决方案"><a href="#解决方案" class="headerlink" title="解决方案"></a>解决方案</h2><p>通过ExternalContext获取HttpResponse，将图片写入，然后操作ExternalContext对象记录response完成，这样web-flow就不会再渲染view，而是直接返回给浏览器</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public class PrintBoardingPassAction extends AbstractAction &#123;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    protected Event doExecute(RequestContext context) throws Exception &#123;</span><br><span class="line">        HttpServletResponse response = (HttpServletResponse)context.getExternalContext().getNativeResponse();</span><br><span class="line">        OutputStream os = response.getOutputStream();</span><br><span class="line">        // 在这里操作os，写入流数据</span><br><span class="line">        os.close();</span><br><span class="line">        context.getExternalContext().recordResponseComplete();</span><br><span class="line">        return success();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>后端</category>
      </categories>
      <tags>
        <tag>Spring</tag>
        <tag>Webflow</tag>
      </tags>
  </entry>
  <entry>
    <title>Spring Webflow - EL表达式</title>
    <url>/2018/09/08/Spring%20Webflow%20-%20EL%E8%A1%A8%E8%BE%BE%E5%BC%8F-springwebflow-el%E8%A1%A8%E8%BE%BE%E5%BC%8F/</url>
    <content><![CDATA[<blockquote>
<ol>
<li>文章中内容并没有全部验证，仅作为参考</li>
<li>上下文一起看，才能明白其中的意思</li>
</ol>
</blockquote>
<h1 id="Web-Flow中EL表达式作用"><a href="#Web-Flow中EL表达式作用" class="headerlink" title="Web Flow中EL表达式作用"></a>Web Flow中EL表达式作用</h1><p>web-flow使用EL表达式访问flow的model和调用方法。在web-flow中EL表达式主要有如下四种用途</p>
<ul>
<li><p>访问客户端(浏览器)数据，比如request的parameter</p>
</li>
<li><p>访问web-flow的RequestContex，比如flowScope和currentEvent等</p>
</li>
<li><p>调用Spring管理的bean的方法</p>
</li>
<li><p>解析表达式(相对于普通表达式)可以解析注入子流程id，view的名称，<br>##EL表达式分类<br>web-flow中EL表达式按照按使用形式分为两类</p>
</li>
<li><p>标准表达式<br>不需要加#{}，直接按照一般程序一样写就行了，如果硬要加#{}，则会报错</p>
</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">// 调用searchCriteria对象的nextPage()方法</span><br><span class="line">// searchCriteria对象可以是Spring中的一个bean，也可以是flow上下文中的一个变量</span><br><span class="line">&lt;evaluate expression=&quot;searchCriteria.nextPage()&quot; /&gt;</span><br></pre></td></tr></table></figure>

<ul>
<li>模板表达式<br>需要加#{}，这种表达式允许将常量和表达式写在一起，如下这种，最后的view名称是拼出来的</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;view-state id=&quot;error&quot; view=&quot;error-#&#123;externalContext.locale&#125;.xhtml&quot; /&gt;</span><br></pre></td></tr></table></figure>
<h1 id="Web-Flow支持的EL表达式"><a href="#Web-Flow支持的EL表达式" class="headerlink" title="Web Flow支持的EL表达式"></a>Web Flow支持的EL表达式</h1><p>Web Flow支持spring EL表达式，Unified表达式，以及OGNL表达式</p>
<ul>
<li>Spring EL<br>从web-flow 2.1开始就使用了Spring EL表达式，该表达式在Spring的全系列产品中都可以使用。使用它只需要在类路径下包含一个单独的jar包<code>org.springframework.expression</code>。 并且如果以前使用的EL表达式或者ognl的表达式，还需要将他们的包去除。</li>
<li>Unified EL<br>在we-flow 2.0时期默认使用的是统一EL表达式，<code>org.jboss.el</code>提供，该包还需要j2ee提供的<code>el-api</code>(一般的容器都会自动提供)。虽然目前版本的Spring EL表达式是默认和推荐使用的，但也可以手动更换为Unified EL表达式。只需加上如下配置即可</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">// 该配置方法在前面讲配置时给过示例</span><br><span class="line">&lt;webflow:flow-builder-services expression-parser=&quot;expressionParser&quot;/&gt;</span><br><span class="line">&lt;bean id=&quot;expressionParser&quot; class=&quot;org.springframework.webflow.expression.el.WebFlowELExpressionParser&quot;&gt;</span><br><span class="line">	&lt;constructor-arg&gt;</span><br><span class="line">		  &lt;bean class=&quot;org.jboss.el.ExpressionFactoryImpl&quot; /&gt;</span><br><span class="line">	&lt;/constructor-arg&gt;</span><br><span class="line">&lt;/bean&gt;</span><br></pre></td></tr></table></figure>

<ul>
<li>OGNL</li>
</ul>
<p>2.4及以后的版本中，已经非常不推荐使用OGNL表达式了。那还是在web-flow 1.0时代标配的是OGNL表达式，如果硬要使用OGNL表达式，还是可以配置，方法请参考<a href="https://docs.spring.io/spring-webflow/docs/2.4.5.RELEASE/reference/html/el.html#el-ognl">教程</a><br>##EL表达式迁移(Unified EL -&gt; Spring EL)<br>从Unified EL表达式和OGNL表达式迁移到Spring EL表达式需要注意以下几点</p>
<ul>
<li>EL表达式的符号从${ }变化成了#{ }</li>
<li>针对current Event的比较由<code>#&#123;currentEvent == &#39;submit&#39;&#125;</code> 要换成 <code>#&#123;currentEvent.id == &#39;submit&#39;&#125;</code></li>
<li>直接解析属性如<code>#&#123;currentUser.name&#125;</code> 可能造成空指针异常，以前的检查方式是：<code>#&#123;currentUser != null ? currentUser.name : null&#125;</code> ， 目前更好的方式：<code>#&#123;currentUser?.name&#125;</code></li>
</ul>
<p>更加详细的EL相关内容，看<a href="http://static.springsource.org/spring/docs/3.0.x/spring-framework-reference/html/expressions.html#expressions-language-ref">这里</a></p>
<h1 id="一些内建的Spring-EL变量"><a href="#一些内建的Spring-EL变量" class="headerlink" title="一些内建的Spring EL变量"></a>一些内建的Spring EL变量</h1><p>内建代表系统自动创建并管理，用户可以直接通过EL表达式访问</p>
<h2 id="重要原则"><a href="#重要原则" class="headerlink" title="重要原则"></a>重要原则</h2><p>只有当分配一个新的变量时才会用到默认存在的作用域变量(flowScope, viewScope, requestScope, etc), 后面使用时就不需要指定作用域变量了。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;!-- 声明modelMap变量，必须显式指定作用域 --&gt;</span><br><span class="line">&lt;evaluate expression=&quot;flowController.performSearch(searchForm)&quot; result=&quot;flashScope.modelMap&quot;/&gt;</span><br><span class="line">... ...</span><br><span class="line">&lt;!-- 使用modelMap变量不用指定作用域 --&gt;</span><br><span class="line">&lt;evaluate expression=&quot;flowController.performResult(modelMap)&quot;/&gt;</span><br></pre></td></tr></table></figure>
<h2 id="作用域"><a href="#作用域" class="headerlink" title="作用域"></a>作用域</h2><p>前面在讲变量时已经讲过作用域(看<a href="https://blog.csdn.net/zou8944/article/details/82502430">这里</a>)，这里提一下，不要忘了。</p>
<h2 id="内建变量穷举"><a href="#内建变量穷举" class="headerlink" title="内建变量穷举"></a>内建变量穷举</h2><ul>
<li>requestParameters<br>获取客户端的请求参数</li>
<li>currentEvent<br>可以获取当前的Event对象</li>
<li>currentUser<br>获取当前被授权的用户，即Principal对象</li>
<li>messageContext<br>可以访问当前的上下文，包括错误和成功的信息，详见MessageContext的javaDoc</li>
<li>resourceBundle<br>访问资源文件</li>
<li>flowRequestContext<br>访问当前flow的RequestContext对象 ，它是当前flow的请求信息对象，详见RequestContext的javaDoc</li>
<li>flowExecutionContext<br>访问FlowExecutionContext对象，存储了当前flow的状态</li>
<li>flowExecutionUrl<br>访问当前view的相对路径，可以在view-state中指定的jsp中进行使用</li>
<li>externalContext<br>可以获取客户端的环境信息，包括sessino属性，详见ExternalContext JavaDoc<br>##Spring EL查找变量的逻辑<br>当使用flow中声明的变量时，并不需要指定作用域，web flow会自动从各作用域，按照如下顺序进行查找，如果找不到，则报<code>EvaluationException</code>异常</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">requestScope -&gt; flashScope -&gt; viewScope -&gt; flowScope -&gt; conversationScope</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>后端</category>
      </categories>
      <tags>
        <tag>Spring</tag>
        <tag>Webflow</tag>
      </tags>
  </entry>
  <entry>
    <title>Spring Webflow - 基础</title>
    <url>/2018/09/07/Spring%20Webflow%20-%20%E5%9F%BA%E7%A1%80-springwebflow-%E5%9F%BA%E7%A1%80/</url>
    <content><![CDATA[<h1 id="基础"><a href="#基础" class="headerlink" title="基础"></a>基础</h1><p>Web Flow将一个流程分为若干个状态(可以理解为步骤)，每个流程由若干个状态组成，通过特性的方式在步骤之间进行跳转，协同完成整个流程。</p>
<span id="more"></span>
<p>常用标签如下</p>
<ul>
<li><code>&lt;view-state&gt;</code> - 视图状态，用于渲染视图</li>
<li><code>&lt;action-state&gt;</code> - 动作状态，用于专门执行操作</li>
<li><code>&lt;transition&gt;</code> - 转移，用于状态间转移，转移由事件触发</li>
<li><code>&lt;end-state&gt;</code> - 结束状态，流程的最后一个状态</li>
<li><code>&lt;evaluate&gt;</code> - 执行具体操作，是上述各个标签的子标签，用于所有需要执行操作的位置<br>####view-state<br>如下声明了视图状态，在该状态会绘制一个视图，view的解析依赖于具体的视图解析器</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;view-state id=&quot;result&quot; view=&quot;flow/view/result&quot;/&gt;</span><br></pre></td></tr></table></figure>
<p>可以不指定view属性，此时，会在flow文件同目录下寻找和id相同文件名的视图文件进行渲染</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;view-state id=&quot;enterBookingDetails&quot; /&gt;</span><br></pre></td></tr></table></figure>
<p>可以在声明同时指定model属性，该属性配合前端spring taglib可将表单数据绑定到model指定的bean中</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;view-state id=&quot;init&quot; view=&quot;flow/view/input&quot; model=&quot;searchForm&quot;&gt;</span><br><span class="line">    &lt;binder&gt;</span><br><span class="line">        &lt;binding property=&quot;name&quot;/&gt;</span><br><span class="line">        &lt;binding property=&quot;gender&quot;/&gt;</span><br><span class="line">    &lt;/binder&gt;</span><br><span class="line">    &lt;transition on=&quot;submit&quot; to=&quot;validate&quot;/&gt;</span><br><span class="line">&lt;/view-state&gt;</span><br><span class="line">...</span><br><span class="line">&lt;!-- 对应的JSP代码 --&gt;</span><br><span class="line">...</span><br><span class="line">&lt;sf:form action=&quot;$&#123;flowExecutionUrl&#125;&amp;_eventId=submit&quot; commandName=&quot;searchForm&quot; method=&quot;post&quot;&gt;</span><br><span class="line">    Name: &lt;sf:input path=&quot;name&quot;/&gt;&lt;br/&gt;</span><br><span class="line">    gender:</span><br><span class="line">       &lt;sf:select path=&quot;gender&quot;&gt;</span><br><span class="line">           &lt;sf:option value=&quot;&quot;&gt;- Please Select -&lt;/sf:option&gt;</span><br><span class="line">       &lt;/sf:select&gt;</span><br><span class="line">       &lt;input type=&quot;submit&quot; value=&quot;Submit&quot;&gt;</span><br><span class="line">&lt;/sf:form&gt;</span><br><span class="line">...</span><br></pre></td></tr></table></figure>

<h2 id="action-state"><a href="#action-state" class="headerlink" title="action-state"></a>action-state</h2><p>action-state将单独一个操作设置为一个状态，除了不能渲染视图外，其它功能和view-state基本一致</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;action-state id=&quot;validate&quot;&gt;</span><br><span class="line">    &lt;evaluate  expression=&quot;flowController.performValidate(searchForm)&quot;/&gt;</span><br><span class="line">    &lt;transition on=&quot;success&quot; to=&quot;result&quot;/&gt;</span><br><span class="line">    &lt;transition on=&quot;fail&quot; to=&quot;input&quot;/&gt;</span><br><span class="line">&lt;/action-state&gt;</span><br></pre></td></tr></table></figure>

<h2 id="transition"><a href="#transition" class="headerlink" title="transition"></a>transition</h2><p>transaction可以根据事件id从一个state跳转到另一个state，如下，当发生submit时间时，将跳转到id为reviewBooking的state</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;view-state id=&quot;enterBookingDetails&quot;&gt;</span><br><span class="line">  		&lt;transition on=&quot;submit&quot; to=&quot;reviewBooking&quot; /&gt;</span><br><span class="line">&lt;/view-state&gt;</span><br></pre></td></tr></table></figure>
<p>事件id定义的方式比较特殊，最典型的从view中触发事件的方式：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;!-- 该超链接被点击时，会触发submit事件 --&gt;</span><br><span class="line">&lt;a href=&quot;$&#123;flowExecutionUrl&#125;&quot;&amp;_eventId=&quot;submit&quot;&gt;Submit&lt;/a&gt;</span><br></pre></td></tr></table></figure>
<p>transition还可以作为<action-state>的子元素，此时on中的内容就是EL表达式，或者执行方法所返回的字符串</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;action-state id=&quot;validate&quot;&gt;</span><br><span class="line">    &lt;evaluate  expression=&quot;flowController.performValidate(searchForm)&quot; result=&quot;flashScope.resultMap&quot;/&gt;</span><br><span class="line">    &lt;!-- EL表达式方式,去resultMap对象中errors值得hasErrors()方法，成立时跳转 --&gt;</span><br><span class="line">    &lt;transition on=&quot;resultMap.errors.hasErrors() == true&quot; to=&quot;result&quot;/&gt;</span><br><span class="line">&lt;/action-state&gt;</span><br><span class="line">... ...</span><br><span class="line">&lt;action-state id=&quot;validate&quot;&gt;</span><br><span class="line">    &lt;evaluate  expression=&quot;flowController.performValidate(searchForm)&quot;/&gt;</span><br><span class="line">    &lt;!-- 方法返回事件id --&gt;</span><br><span class="line">    &lt;transition on=&quot;success&quot; to=&quot;result&quot;/&gt;</span><br><span class="line">    &lt;transition on=&quot;fail&quot; to=&quot;input&quot;/&gt;</span><br><span class="line">&lt;/action-state&gt;</span><br></pre></td></tr></table></figure>

<h2 id="view中触发事件的几种方式"><a href="#view中触发事件的几种方式" class="headerlink" title="view中触发事件的几种方式"></a>view中触发事件的几种方式</h2><ul>
<li>使用submit按钮</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;input type=&quot;submit&quot; name=&quot;_eventId_proceed&quot; value=&quot;Proceed&quot; /&gt;</span><br></pre></td></tr></table></figure>
<p>原理：当web-flow发现请求参数中有以_eventId_字符串开头的参数时，会把该字符串中剩余字符串当做eventId。该方法可用于一次性触发多个事件</p>
<ul>
<li>使用hidden域</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;input type=&quot;hidden&quot; name=&quot;_eventId&quot; value=&quot;proceed&quot; /&gt;</span><br></pre></td></tr></table></figure>
<p>原理：web-flow检测到请求参数中有名为_eventId的参数时，会将其值作为eventId进行触发</p>
<ul>
<li>使用url参数</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;a href=&quot;$&#123;flowExecutionUrl&#125;&amp;_eventId=cancel&quot;&gt;Cancel&lt;/a&gt;</span><br></pre></td></tr></table></figure>
<p>原理同上</p>
<ul>
<li><p>web-flow检测eventId的逻辑<br>首先检查有没有_eventId的参数，如果没有，检查有没有以_eventId_开头的参数名，都没有时，则没有事件会被触发。<br>####end-tate<br>定义流程结束状态</p>
</li>
<li><p>当该流程是子流程时，会接着下面的流程继续进行，<end-state>的id属性将会作为event id</p>
</li>
<li><p>当该流程添加了view时，该view会被渲染。还可以添加属性，使得进行重定向之类的</p>
</li>
<li><p>当不是子流程也没有指定view，则该流程结束，并且重新开启一个新的流程实例<br>####evaluate<br>Web Flow允许我们在如下几个切入点执行我们自己的业务逻辑，而执行业务逻辑使用<code>&lt;evaluate&gt;</code>标签。<strong>该标签可以调用所用Spring中管理的bean和flow中声明的变量的方法</strong>。</p>
</li>
<li><p>flow开始 - 对应<code>&lt;on-start&gt;</code>标签，定义在根标签<code>&lt;flow&gt;</code>下</p>
</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;on-start&gt;</span><br><span class="line">	&lt;!-- 仅调用方法 --&gt;</span><br><span class="line">    &lt;evaluate expression=&quot;flowController.performInit()&quot;/&gt;</span><br><span class="line">&lt;/on-start&gt;</span><br></pre></td></tr></table></figure>

<ul>
<li>state进入时 - 对应<code>&lt;on-entry&gt;</code>标签，可定义在所有<code>state</code>标签下</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;view-state id=&quot;init&quot; view=&quot;flow/view/input&quot;&gt;</span><br><span class="line">	&lt;on-entry&gt;</span><br><span class="line">		&lt;!-- 调用方法，并将方法返回的对象存在flow变量modelMap中 --&gt;</span><br><span class="line">		&lt;evaluate expression=&quot;flowController.performInit()&quot; result=&quot;flashScope.modelMap&quot;/&gt;</span><br><span class="line">	&lt;/on-entry&gt;</span><br><span class="line">    ... ...</span><br><span class="line">&lt;/view-state&gt;</span><br></pre></td></tr></table></figure>

<ul>
<li>view渲染时 - 对应<code>&lt;on-render&gt;</code>标签，定义在<code>&lt;view-state&gt;</code>下</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;view-state id=&quot;init&quot; view=&quot;flow/view/input&quot;&gt;</span><br><span class="line">	&lt;on-render&gt;</span><br><span class="line">		&lt;!-- 调用方法，并将方法返回的对象转型成目标类型，然后存储在flow变量modelMap中 --&gt;</span><br><span class="line">		&lt;evaluate expression=&quot;flowController.performInit()&quot; result=&quot;flashScope.modelMap&quot; resultType=&quot;java.util.Map&quot;/&gt;</span><br><span class="line">	&lt;/on-render&gt;</span><br><span class="line">    ... ...</span><br><span class="line">&lt;/view-state&gt;</span><br></pre></td></tr></table></figure>

<ul>
<li>transition执行时 - 对应<code>&lt;transition&gt;</code>标签</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;view-state id=&quot;init&quot; view=&quot;flow/view/input&quot;&gt;</span><br><span class="line">	&lt;transition on=&quot;submit&quot; to&quot;validate&quot;&gt;</span><br><span class="line">		&lt;evaluate expression=&quot;flowController.performTransition()&quot;/&gt;</span><br><span class="line">	&lt;/transition&gt;</span><br><span class="line">&lt;/view-state&gt;</span><br></pre></td></tr></table></figure>

<ul>
<li>state退出时 - 对应<code>&lt;on-entry&gt;</code>标签，可定义在所有state标签下</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;action-state id=&quot;validate&quot;&gt;</span><br><span class="line">    ... ...</span><br><span class="line">    &lt;on-exit&gt;</span><br><span class="line">		&lt;evaluate expression=&quot;flowController.performExit()&quot;/&gt;</span><br><span class="line">	&lt;/on-exit&gt;</span><br><span class="line">&lt;/action-state&gt;</span><br></pre></td></tr></table></figure>

<ul>
<li>flow结束时 - 对应<code>&lt;on-start&gt;</code>标签，定义在根标签<code>&lt;flow&gt;</code>下</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;on-end&gt;</span><br><span class="line">    &lt;evaluate expression=&quot;flowController.performEnd()&quot;/&gt;</span><br><span class="line">&lt;/on-end&gt;</span><br></pre></td></tr></table></figure>
<h1 id="进阶"><a href="#进阶" class="headerlink" title="进阶"></a>进阶</h1><h2 id="变量"><a href="#变量" class="headerlink" title="变量"></a>变量</h2><p>可以在流程中定义多个变量，这些变量将在流程开始被分配。被声明变量的类必须实现serializable，因为在两个state之间，变量需要被保存。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;var name=&quot;searchCriteria&quot; class=&quot;com.mycompany.myapp.hotels.search.SearchCriteria&quot;/&gt;</span><br></pre></td></tr></table></figure>
<p>####变量的分配方式</p>
<ul>
<li>直接分配</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;var name=&quot;searchCriteria&quot; class=&quot;com.mycompany.myapp.hotels.search.SearchCriteria&quot;/&gt;</span><br></pre></td></tr></table></figure>

<ul>
<li>赋值的时候分配</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;!-- 创建InitMap对象，并将方法返回的对象赋值给InitMap --&gt;</span><br><span class="line">&lt;evaluate expression=&quot;flowController.performInit()&quot; result=&quot;flowScope.InitMap&quot; /&gt;</span><br></pre></td></tr></table></figure>

<h2 id="变量的使用方法"><a href="#变量的使用方法" class="headerlink" title="变量的使用方法"></a>变量的使用方法</h2><ul>
<li>jsp中使用<br>使用jsp中的el表达式访问flow中声明的变量，如<code>$&#123;modelMap.name&#125;</code>，访问了flow变量modelMap的name属性</li>
<li>flow文件中使用<br>直接使用Spring EL表达式进行访问</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;transition on=&quot;modelMap.name == null&quot; to=&quot;result&quot;/&gt;</span><br></pre></td></tr></table></figure>

<ul>
<li>方法中使用<br>将变量传给调用方法，即可在方法中使用</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;evaluate expression=&quot;flowController.performSearch(modelMap)&quot;/&gt;</span><br></pre></td></tr></table></figure>

<h2 id="变量作用域"><a href="#变量作用域" class="headerlink" title="变量作用域"></a>变量作用域</h2><ul>
<li><code>flowScope</code>：流程开始时分配，流程结束时销毁</li>
<li><code>viewScope</code>：在<code>&lt;view-state&gt;</code>进入时创建，退出时销毁</li>
<li><code>requestScope</code>：当流程被调用时分配，流程返回时销毁。比flowScope作用域稍微大一点</li>
<li><code>flashScope</code>：在流程开始时分配，流程结束时销毁，但是在每一个view渲染后都会被清零</li>
<li><code>conversation Scope</code>：最顶层的流程开始时分配，最顶层的流程结束时销毁。该作用域的变量是存储在Session中的。</li>
</ul>
]]></content>
      <categories>
        <category>后端</category>
      </categories>
      <tags>
        <tag>Spring</tag>
        <tag>Webflow</tag>
      </tags>
  </entry>
  <entry>
    <title>RxJava初探</title>
    <url>/2019/09/08/RxJava%E5%88%9D%E6%8E%A2-rxjava%E5%88%9D%E6%8E%A2/</url>
    <content><![CDATA[<h2 id="Observable"><a href="#Observable" class="headerlink" title="Observable"></a>Observable</h2><p> ReactiveX中, 应用的是观察者模式, 一个观察者订阅一个被观察者. 然后该观察者根据被观察者释放的任何信息进行反应. 这样能够使得并发称为可能, 观察者不必阻塞等待被观察者的响应内容, 而是创建一个哨兵, 并随时准备在未来的任何时候响应被观察者释放出的内容<br> <span id="more"></span><br>Observable通过调用Observer的方法向其发送通知<br>如下图片能够展示一个被观察者释放的一系列数据, 以及对这些数据进行转换的操作</p>
<p><img src="https://gdz.oss-cn-shenzhen.aliyuncs.com/hexo/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0%20-%20RxJava/1564802038820.png" alt="1564802038820"></p>
<p>本文中称的观察者, 在别的文档中有时也被称为订阅者, 也叫作反应器. 该模型对应于 反应式模型</p>
<h3 id="建立一个Observable"><a href="#建立一个Observable" class="headerlink" title="建立一个Observable"></a>建立一个Observable</h3><ul>
<li>定义一个结果处理的方法, 该方法是观察者的一部分</li>
<li>将异步调用本身定义为被观察者</li>
<li>通过订阅的方式, 将观察者附加到被观察者身上. </li>
</ul>
<h3 id="OnNext-OnCompleted-OnError"><a href="#OnNext-OnCompleted-OnError" class="headerlink" title="OnNext, OnCompleted, OnError"></a>OnNext, OnCompleted, OnError</h3><p>这些是观察者的一部分. 三个方法被调用的时机不同</p>
<ul>
<li><p>OnNext<br>被观察者每次释放一个数据都会调用它</p>
</li>
<li><p>OnError<br>当被观察者发生错误时会调用, 调用该方法后, OnNext和OnCompleted方法都不会再被调用</p>
</li>
<li><p>OnCompleted<br>在调用最后一次OnNext时会调用OnCompleted</p>
</li>
</ul>
<p>我们管OnNext叫做释放数据, 管OnError和OnCompleted叫通知.</p>
<h3 id="观察者约定-The-Observable-Contract"><a href="#观察者约定-The-Observable-Contract" class="headerlink" title="观察者约定(The Observable Contract)"></a>观察者约定(The Observable Contract)</h3><p>该约定尝试对被观察者做一个正式的定义, 他会出现在Rx文档的很多地方</p>
<h4 id="通知"><a href="#通知" class="headerlink" title="通知"></a>通知</h4><p>一个被观察者通过如下方式和它的观察者们交流</p>
<ul>
<li>OnNext: 从被观察者向观察者传送一个item</li>
<li>OnCompleted: 表明被观察者已经成功地完成, 并且不会再释放数据</li>
<li>OnError: 表明被观察者已经被某个原因中止, 并且不会再释放数据</li>
<li>OnSubscribe(背压): 表明被观察者已经准备好接收来自观察者的请求通知</li>
</ul>
<p>一个观察者通过如下方式和它的被观察者交流</p>
<ul>
<li>Subscribe: 表明观察者已经准备好接收来自被观察者的通知</li>
<li>UnSubscribe: 表明观察者已经不想要再接收到被观察者的通知了</li>
<li>Request(背压): 表明观察者只希望接收到不超过特定数量的来自被观察者的通知(通过OnNext发送过来的)</li>
</ul>
<h4 id="约定"><a href="#约定" class="headerlink" title="约定"></a>约定</h4><p>一个被观察者可能调用0次或多次OnNext, OnCompleted和OnError只会且一定会调用其一, 且其后不得再发送任何通知</p>
<p>一个被观察者可能根本不会释放任何数据, 也可能因为永远不停止而不会发出OnCompleted和OnError. 即: 观察者可能不发出任何通知, 可能发出OnCompleted和OnError通知, 也可能仅发出OnNext通知</p>
<p>一个被观察者发送给观察者的通知必须是串行的, 他们可以在不同的线程发出, 但必须有一个先行发生原则确保其顺序</p>
<h4 id="被观察者的中止"><a href="#被观察者的中止" class="headerlink" title="被观察者的中止"></a>被观察者的中止</h4><p>如果被观察者没有发出完成或错误通知, 观察者会认为它仍然是活动的, 并且可能会给他发送通知(如unsubscribe和request通知等).<br>如果被观察者发出了完成或错误通知, 该被观察者会释放其资源, 其观察者不应试图与其有进一步的沟通<br>一个OnError通知必须包含错误原因, 就是说传入一个null的OnError是无效的<br>被观察者停止自己之前, 必须先向它的所有订阅者发出OnCompleted或OnError消息</p>
<h4 id="订阅和取消订阅"><a href="#订阅和取消订阅" class="headerlink" title="订阅和取消订阅"></a>订阅和取消订阅</h4><p>被观察者可以在收到观察者发出的Subscribe通知后马上开始向其发送通知<br>当观察者发送UnSubscribe通知给被观察者时, 被观察者会试图停止向其发送通知, 但这是不被保证的,<br>被观察者发送OnCompleted或OnError通知给观察者时, 它们的订阅关系将会自动结束. 不需要再由观察者发送UnSubscribe消息给被观察者</p>
<h4 id="多个订阅者"><a href="#多个订阅者" class="headerlink" title="多个订阅者"></a>多个订阅者</h4><p>如果第二个观察者订阅了一个已经向第一个观察者释放了一些数据的被观察者, 那么第二个观察者收到的消息可能如下</p>
<ul>
<li>从订阅开始, 所有订阅者将收到一样的消息,(即新的订阅者会收不到已经释放原来订阅者的消息)</li>
<li>重新向新的订阅者发送完全相同的数据</li>
<li>新的订阅者将会收到顺序完全不同的数据</li>
</ul>
<p>上面这些都是可能的, 具体哪一种取决于被观察者的实现. </p>
<p>没有一个通用的约定说两个多个观察者能够得到一样顺序的消息</p>
<h4 id="背压"><a href="#背压" class="headerlink" title="背压"></a>背压</h4><p>背压是可选的, 并非所有ReactiveX实现都包括背压.而且在哪些包括了背压的实现中, 也并非所有被观察者都支持背压.<br>如果一个被观察者实现了背压，并且它的观察者使用了背压，那么该被观察者不会在订阅后立即向观察者发出项目。相反，它将向观察者发出一个onsubscribe通知。<br>观察者收到onsubscribe消息后, 会发送一个请求通知给被观察者, 指定需要数据的数量, 被观察者就会释放不多于该数量的数据. 当然, 被观察者也可以主动发出OnCompleted和OnError通知, 甚至在观察者发送请求通知前发出以结束订阅.</p>
<p>对于没有实现背压的被观察者, 当它收到来自观察者的请求通知时, 应该回敬一个OnError通知, 说明自己并不支持背压</p>
<p>请求是累积的: 如果一个观察者发出了三个请求通知, 分别请求3,5,10条数据, 则被观察者将会至多发送18条数据, 不会因为说刚发了两条时马上来了一个5条的请求就把原本剩下的那一条忽略掉.<br>如果被观察者产生了多余请求数量的数据, 多出来的数据的处理方式完全看被观察者自己.</p>
<h3 id="热-冷-的被观察者"><a href="#热-冷-的被观察者" class="headerlink" title="热 , 冷 的被观察者"></a>热 , 冷 的被观察者</h3><ul>
<li>热: 指的是被观察者从一开始就释放数据, 这样观察者从订阅开始就只能从中途获取数据</li>
<li>冷: 指的是被观察者在被定于后才开始释放数据, 这样就能保证获取完整的数据</li>
<li>connectable: 这是在部分ReactiveX实现中的被观察者, 只有当connect方法被调用时才会释放数据, 而不管有没有观察者订阅他</li>
</ul>
<h3 id="被观察者操作符的组合"><a href="#被观察者操作符的组合" class="headerlink" title="被观察者操作符的组合"></a>被观察者操作符的组合</h3><p>被观察者和观察者仅仅是ReactiveX的开始, 他们本身只是标准的观察者模式的轻量级扩展, 更适合处理一连串事件, 而不是单个回调<br>其真正厉害的地方在于通过操作符转换, 组合, 运算由被观察者释放出来的一系列数据</p>
<h2 id="Operators"><a href="#Operators" class="headerlink" title="Operators"></a>Operators</h2><h3 id="操作分类"><a href="#操作分类" class="headerlink" title="操作分类"></a>操作分类</h3><h4 id="创建被观察者"><a href="#创建被观察者" class="headerlink" title="创建被观察者"></a>创建被观察者</h4><ul>
<li>create: 通知显式调用订阅者方法来创建Observable</li>
<li>defer: 观察者订阅时才创建, 不订阅就不创建, 且为每个新的观察者创建一个新的被观察者</li>
<li>interval: 创建一个每隔一段时间释放一个数据的被观察者</li>
</ul>
<h4 id="处理操作"><a href="#处理操作" class="headerlink" title="处理操作"></a>处理操作</h4><ul>
<li>buffer: 被观察者一个一个地发送数据, 该操作设定缓存个数, 缓存满了之后将整个缓存一起释放</li>
<li>flatMap: 将多个被观察者释放的数据合并到一个被观察者中</li>
<li>groupBy: 将单个被观察者切分成多个被观察者, 每次只从原被观察者处释放一组</li>
<li>scan: 对每个释放的数据应用一个函数, 将结果释放出去, 一次运算释放的值会作为下一次运算的输入</li>
</ul>
<h4 id="过滤操作"><a href="#过滤操作" class="headerlink" title="过滤操作"></a>过滤操作</h4><ul>
<li>debounce: 只释放这样的数据, 该数据被释放之后, 指定的一段时间内没有新数据的出现, 则释放该数据.否则对新释放的数据继续做此判断</li>
<li>elementAt: 只获取释放的第n个元素</li>
<li>first: 只释放第一个数据, 或满足条件的数据</li>
<li>last: 只释放最后一个数据</li>
<li>sample: 获取一段时间内被观察者释放的最后一个数据</li>
<li>take: 只获取头几个释放的数据</li>
<li>takeLast: 只获取最后几个释放的数据</li>
</ul>
<h4 id="组合操作"><a href="#组合操作" class="headerlink" title="组合操作"></a>组合操作</h4><p>将多个被观察者合并为一个被观察者</p>
<ul>
<li>combineLatest: 将一个被观察者释放的数据和另一个被观察者释放的最近的一个数据组合起来</li>
</ul>
<p><img src="https://gdz.oss-cn-shenzhen.aliyuncs.com/hexo/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0%20-%20RxJava/1564822583394.png" alt="1564822583394"></p>
<ul>
<li>join: 将两个被观察者释放的在一个时间窗中的数据进行合并</li>
</ul>
<p><img src="https://gdz.oss-cn-shenzhen.aliyuncs.com/hexo/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0%20-%20RxJava/1564823248295.png" alt="1564823248295"></p>
<ul>
<li>merge: 直接将两个释放合并</li>
</ul>
<p><img src="https://gdz.oss-cn-shenzhen.aliyuncs.com/hexo/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0%20-%20RxJava/1564823342178.png" alt="1564823342178"></p>
<ul>
<li>startWith: 在释放常规数据前, 先释放指定的数据</li>
</ul>
<p><img src="https://gdz.oss-cn-shenzhen.aliyuncs.com/hexo/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0%20-%20RxJava/1564823975876.png" alt="1564823975876"></p>
<ul>
<li>switch: 将释放数据为Observable的几个被观察者转换成一个释放所有这些数据的被观察者</li>
</ul>
<p><img src="https://gdz.oss-cn-shenzhen.aliyuncs.com/hexo/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0%20-%20RxJava/switch.c.png" alt="Switch"></p>
<ul>
<li>zip: 将多个被观察者释放的数据以一定的方法合并到一个被观察者上</li>
</ul>
<p><img src="https://gdz.oss-cn-shenzhen.aliyuncs.com/hexo/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0%20-%20RxJava/1564824218864.png" alt="1564824218864"></p>
<h4 id="错误处理操作"><a href="#错误处理操作" class="headerlink" title="错误处理操作"></a>错误处理操作</h4><ul>
<li>catch: 从错误中恢复出来, 使原被观察者继续执行</li>
<li>retry: 被观察者抛出错误时, 重新订阅它</li>
</ul>
<h4 id="被观察者的工具操作"><a href="#被观察者的工具操作" class="headerlink" title="被观察者的工具操作"></a>被观察者的工具操作</h4><ul>
<li>delay: 每个元素都延迟释放</li>
<li>doOnEach: 为每个元素执行一个操作</li>
<li>materialize: 将释放的消息和发送的通知都当做释放的消息</li>
<li>observeOn: 指定观察者将会在哪个schedudler上对被观察者进行观察</li>
<li>subscribe: 将被观察者绑定到观察者</li>
<li>timeInterval: 将一个释放普通元素的被观察者转换为释放元素之间的时间间隔的被观察者</li>
<li>timeout: 一个元素释放后的指定时间内不再释放新的元素时, 停止该被观察者</li>
<li>timestamp: 为每一个释放的元素绑定一个时间戳</li>
</ul>
<h4 id="条件和布尔操作"><a href="#条件和布尔操作" class="headerlink" title="条件和布尔操作"></a>条件和布尔操作</h4><ul>
<li>all: 判断是否释放的所有元素都满足给定条件</li>
<li>amb: 给定多个被观察者, 只获取最先释放数据的被观察者的所有数据</li>
<li>contains: 判断释放的元素是否包含指定元素</li>
<li>sequenceEqual: 判断两个被观察者是否释放了一样的数据流</li>
</ul>
<h4 id="数学和聚集操作"><a href="#数学和聚集操作" class="headerlink" title="数学和聚集操作"></a>数学和聚集操作</h4><ul>
<li>concat:  将两个被观察者连接起来, 一个被观察者释放完所有数据后, 另一个被观察者才继续释放它的所有数据</li>
<li>reduce: 对每个释放的数据应用某个函数, 并输出最终结果</li>
</ul>
<p><img src="https://gdz.oss-cn-shenzhen.aliyuncs.com/hexo/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0%20-%20RxJava/1564825542157.png" alt="1564825542157"></p>
<h4 id="背压操作"><a href="#背压操作" class="headerlink" title="背压操作"></a>背压操作</h4><p>这是用来应对生产数据快过消费数据的情况</p>
<h4 id="Connectable-Observable的操作"><a href="#Connectable-Observable的操作" class="headerlink" title="Connectable Observable的操作"></a>Connectable Observable的操作</h4><ul>
<li>connect: 开始释放数据</li>
<li>publish: 将原本的observable转换成一个Connectable Observable</li>
<li>refcount: 使Connectable Observable向一个原始Observable一样工作</li>
<li>replay: 确保所有观察者都能够看到相同顺序的数据, 即使他们在不同时刻订阅</li>
</ul>
<h4 id="Observable转换操作"><a href="#Observable转换操作" class="headerlink" title="Observable转换操作"></a>Observable转换操作</h4><ul>
<li>to:  将一个Observable转换成其它对象或数据结构</li>
</ul>
<h2 id="Single"><a href="#Single" class="headerlink" title="Single"></a>Single</h2><p>Single是Observable的一个变体, 不同于Observable是释放一系列数据, Single仅释放一个数据, 或触发一次错误.因此, Single中, 仅能使用OnSuccess与OnError同观察者交流. 当上述两个方法中任意一个被调用了, 另一个都不会再被调用, Single也停止了, 订阅关系也自动解除了.<br>也就是说, Single没有结束一说, 只有成功和错误两个时机, 因此调用doOnCompleted是不会被触发的</p>
<h3 id="Single中值得记住的方法"><a href="#Single中值得记住的方法" class="headerlink" title="Single中值得记住的方法"></a>Single中值得记住的方法</h3><ul>
<li>doOnSuccess/doOnError: 在调用OnSuccess和OnError方法时, 会同时触发该方法</li>
</ul>
<h2 id="Subject"><a href="#Subject" class="headerlink" title="Subject"></a>Subject</h2><p>Subject在某些实现中有做, 它可以看做是一个桥梁或是一个代理, 能够同时充当订阅者, 获取其它被观察者的消息, 也能够充当被观察者, 向其它观察者发送消息.</p>
<p>Subject有四种变形, 分别用在不同的场景下</p>
<h3 id="AsyncSubject"><a href="#AsyncSubject" class="headerlink" title="AsyncSubject"></a>AsyncSubject</h3><p>AsyncSubject在源Observable结束时, 释放源Observable的最后一个元素, 如果源Observable一个元素都没有释放, 则AsyncSubject也会什么都不释放, 然后结束. 如果源Observable发生错误, 则AsyncSubject会直接将该错误释放, 不会释放其它数据</p>
<h3 id="BehaviorSubject"><a href="#BehaviorSubject" class="headerlink" title="BehaviorSubject"></a>BehaviorSubject</h3><p>BehaviorSubject会释放源Observable最近释放过的数据, 如果没有最近释放过的数据, 则返回指定的默认值.</p>
<p>当源Observable发生错误时, BehaviorSubject不会释放任何数据. 而是直接释放该数据</p>
<h3 id="PublishSubject"><a href="#PublishSubject" class="headerlink" title="PublishSubject"></a>PublishSubject</h3><p>PublishSubject直接将源Observable的数据进行原样释放, 源Observable来一个它就释放一个, 这意味着较晚订阅它的订阅者会丢失订阅之前的消息</p>
<h3 id="ReplaySubject"><a href="#ReplaySubject" class="headerlink" title="ReplaySubject"></a>ReplaySubject</h3><p>ReplaySubject会将源Observable所释放的数据全部再次释放一遍.</p>
<h2 id="Scheduler"><a href="#Scheduler" class="headerlink" title="Scheduler"></a>Scheduler</h2><p>Scheduler用于做线程调度.</p>
<p>默认情况下, Observable及其操作链将会工作在subscribe调用时的线程上. 可以通过ObserveOn操作符改变该行为. 该方法指定一个线程调度器, Observable会在其上运行.</p>
<p>SubscribeOn指定了Observable将会在哪个调度器上进行操作, 即观察者所在的线程.</p>
]]></content>
      <categories>
        <category>响应式</category>
      </categories>
      <tags>
        <tag>RxJava</tag>
      </tags>
  </entry>
  <entry>
    <title>Spring Webflow - 第一个Flow</title>
    <url>/2018/09/06/Spring%20Webflow%20-%20%E7%AC%AC%E4%B8%80%E4%B8%AAFlow-springwebflow-%E7%AC%AC%E4%B8%80%E4%B8%AAflow/</url>
    <content><![CDATA[<blockquote>
<p>在学习每一门新语言时，第一个程序往往是Hello World。这里我们写一个非常简单的flow，使用常用标签，在深入讲解之前有一个感官上的认识</p>
</blockquote>
<h1 id="需求说明"><a href="#需求说明" class="headerlink" title="需求说明"></a>需求说明</h1><p>假设有如下简单流程：要求程序启动，显式输入界面，用户输入信息后，点击提交按钮，后台查询数据库，然后显式查询结果界面，中间任何步骤出错，都重新返回输入界面，并显示错误信息。流程大体如下。</p>
<span id="more"></span>
<p><img src="20180906212548121.png" alt="需求流程图"></p>
<h1 id="需求分析"><a href="#需求分析" class="headerlink" title="需求分析"></a>需求分析</h1><p>将上述需求分解：流程启动时，初始化输入界面的信息，渲染输入页面，用户点击提交按钮，后台验证输入信息的格式是否正确，验证失败则返回输入界面，验证成功则进行下一步查询数据库操作，查询完成后跳转到结果页面进行显示，流程结束。(请忽略如下流程中判断图示不标准的错误)<br><img src="20180906213226568.png" alt="逻辑流程图"></p>
<h1 id="运行前的基本配置"><a href="#运行前的基本配置" class="headerlink" title="运行前的基本配置"></a>运行前的基本配置</h1><p>首先需要将FlowRegistry，FlowExecutor，FlowHandlerAdapter，FlowHandlerMapping等项配置好。本文的采用了<a href="https://www.zouguodong.top/2018/09/05/Spring%20Webflow%20-%20%E9%85%8D%E7%BD%AE/">Spring Web Flow 学习 —— 配置 - 001</a>的配置。</p>
<h1 id="Flow文件"><a href="#Flow文件" class="headerlink" title="Flow文件"></a>Flow文件</h1><p>如下配置文件讲解: </p>
<ul>
<li>流程启动时指定flowController的performInit()方法，并返回一个ModelMap类型的对象，分配flowScope作用域下的InitMap变量，将返回的对象赋予该变量；</li>
<li>渲染/WEB-INF/jsp/flow/view/input.jsp，并将input界面中上传的参数与searchForm进行绑定，当触发submit事件时，跳转到validate状态</li>
<li>validate状态中，执行flowController的performValidate(searchForm)方法，返回success时跳转到result状态，返回fail时跳转到init状态，重新渲染input.jsp。</li>
<li>result状态，渲染result.jsp，渲染前，首先指定flowController的performSearch(searchForm)方法，该方法返回一个modelMap并分配给flashScope范围内的modelMap变量。在result界面，无论点击任何按键，只要是向flow在此提交请求，都会跳转到end状态，</li>
<li>end状态, 重定向到spring首页<br>至此，流程结束。</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;</span><br><span class="line">&lt;!-- 这是web flow 2.4.5的根标签形式，2.5.0并不一样 --&gt;</span><br><span class="line">&lt;flow xmlns=&quot;http://www.springframework.org/schema/webflow&quot;</span><br><span class="line">      xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span><br><span class="line">      xsi:schemaLocation=&quot;http://www.springframework.org/schema/webflow</span><br><span class="line">                          http://www.springframework.org/schema/webflow/spring-webflow-2.0.xsd&quot;&gt;</span><br><span class="line">    </span><br><span class="line">    &lt;var name=&quot;searchForm&quot; class=&quot;cn.floyd.pw.flow.SearchForm&quot;/&gt;</span><br><span class="line">    </span><br><span class="line">    &lt;on-start&gt;</span><br><span class="line">        &lt;evaluate expression=&quot;flowController.performInit()&quot; </span><br><span class="line">                result=&quot;flowScope.InitMap&quot; </span><br><span class="line">                result-type=&quot;org.springframework.ui.ModelMap&quot;/&gt;</span><br><span class="line">    &lt;/on-start&gt;</span><br><span class="line">    </span><br><span class="line">    &lt;view-state id=&quot;init&quot; view=&quot;flow/view/input&quot; model=&quot;searchForm&quot;&gt;</span><br><span class="line">        &lt;binder&gt;</span><br><span class="line">            &lt;binding property=&quot;name&quot;/&gt;</span><br><span class="line">            &lt;binding property=&quot;gender&quot;/&gt;</span><br><span class="line">        &lt;/binder&gt;</span><br><span class="line">        &lt;transition on=&quot;submit&quot; to=&quot;validate&quot;/&gt;</span><br><span class="line">    &lt;/view-state&gt;</span><br><span class="line"></span><br><span class="line">    &lt;action-state id=&quot;validate&quot;&gt;</span><br><span class="line">        &lt;evaluate  expression=&quot;flowController.performValidate(searchForm)&quot;/&gt;</span><br><span class="line">        &lt;transition on=&quot;success&quot; to=&quot;result&quot;/&gt;</span><br><span class="line">        &lt;transition on=&quot;fail&quot; to=&quot;input&quot;/&gt;</span><br><span class="line">    &lt;/action-state&gt;</span><br><span class="line"></span><br><span class="line">    &lt;view-state id=&quot;result&quot; view=&quot;flow/view/result&quot;&gt;</span><br><span class="line">        &lt;on-render&gt;</span><br><span class="line">            &lt;evaluate expression=&quot;flowController.performSearch(searchForm)&quot; result=&quot;flashScope.modelMap&quot;/&gt;</span><br><span class="line">        &lt;/on-render&gt;</span><br><span class="line">        &lt;transition to=&quot;end&quot;/&gt;</span><br><span class="line">    &lt;/view-state&gt;</span><br><span class="line">    </span><br><span class="line">    &lt;end-state id=&quot;end&quot; view=&quot;externalRedirect:http://springframework.org&quot;/&gt;</span><br><span class="line">&lt;/flow&gt;</span><br></pre></td></tr></table></figure>
<p>看完上面的描述，想必刚接触web flow的人是一脸懵逼<br><img src="20180906215538433.jpeg" alt="这里写图片描述"><br>解释几个概念就好了。</p>
<ul>
<li>状态：web flow将一个步骤称作一个状态(state)，有专门渲染view的view-state，也有只执行操作的action-state</li>
<li>变量：web flow是以xml的形式进行编程的，可以在该xml上下文中定义变量，该变量可以在flow上下文以及flow渲染的jsp文件(使用EL表达式调用)，调用的方法中(作为参数传入)使用。定义变量的方式主要有两种，一是通过<code>&lt;var&gt;</code>标签显式定义，二是在<code>&lt;evaluate&gt;</code>标签的<code>result</code>属性中定义(此时同时完成了分配变量和变量赋值两个操作)</li>
<li>变量作用域：规定了变量的作用范围，常见的有flashScope(当前状态有效)，flowScope(当前flow有效)等</li>
<li>事件：从一个状态到另一个状态，一般需要进行触发，而进行触发的就是事件。事件可能由view触发，也可能由方法触发，我们不用真的去定义一个事件对象。当view-state中的view返回的请求中带有_eventId的参数时，其值会被自动转换成Event，当action-state中调用的方法返回字符串时，该字符串也会被自动转换成Event</li>
<li>模型绑定：当view需要提交参数时，可以采用模型绑定的形式，web flow会自动将对应参数绑定到我们的model中，并且还可以自定义验证和转换规则。</li>
</ul>
<h1 id="相关其它文件"><a href="#相关其它文件" class="headerlink" title="相关其它文件"></a>相关其它文件</h1><h2 id="FlowController"><a href="#FlowController" class="headerlink" title="FlowController"></a>FlowController</h2><p>按照顺序列出相关文件，<code>&lt;evaluate&gt;</code>标签的<code>expression</code>属性可以通过Spring EL表达式的形式直接访问Spring管理的bean的方法或属性，也可以访问flow上下文环境中的对象的方法或属性。其中主要方法讲解如下：</p>
<ul>
<li><code>performInit()</code>初始化下拉选中的初始值，返回modelMap对象，该对象被赋值给flow中的InitMap变量</li>
<li><code>performValidate(SearchForm form)</code>将SearchForm对象传入，用于验证输入的值，这里假设全都验证通过，返回的”success”会被映射成Event</li>
<li><code>performSearch(SearchForm form)</code>根据传入form中的参数进行数据查找，这里假设已经查找完毕，并将数据放入一个ModelMap，赋值给flow中的modelMap变量</li>
</ul>
<p>该类是Spring管理的一个bean，</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">@Controller(&quot;flowController&quot;)</span><br><span class="line">public class FlowController implements Serializable&#123;</span><br><span class="line">    </span><br><span class="line">    private static final long serialVersionUID = -4439633424434338888L;</span><br><span class="line"></span><br><span class="line">    public ModelMap performInit() &#123;</span><br><span class="line">        ModelMap model = new ModelMap();</span><br><span class="line">        model.addAttribute(&quot;gender&quot;, new String[] &#123;&quot;Man&quot;, &quot;Woman&quot;&#125;);</span><br><span class="line">        return model;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    public String performValidate(SearchForm form) &#123;</span><br><span class="line">        // assume we have pass the validation</span><br><span class="line">        return &quot;success&quot;;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    public ModelMap performSearch(SearchForm form) &#123;</span><br><span class="line">        // assume we have finished the search process, and got the search result</span><br><span class="line">        ModelMap model = new ModelMap();</span><br><span class="line">        model.addAttribute(&quot;name&quot;, form.getName());</span><br><span class="line">        model.addAttribute(&quot;gender&quot;, form.getGender());</span><br><span class="line">        model.addAttribute(&quot;age&quot;, 25);</span><br><span class="line">        model.addAttribute(&quot;profession&quot;, &quot;Programmer&quot;);</span><br><span class="line">        model.addAttribute(&quot;hobbies&quot;, new String[] &#123;&quot;Basktball&quot;, &quot;Football&quot;&#125;);</span><br><span class="line">        </span><br><span class="line">        return model;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="input-jsp"><a href="#input-jsp" class="headerlink" title="input.jsp"></a>input.jsp</h2><p>输入界面，将<code>InitMap</code>中的值通过EL表达式渲染到下拉选中。通过<code>_eventId=submit</code>的GET参数方式触发submit事件。<code>$&#123;flowExecutionUrl&#125;</code>是flow中自管理变量，访问它才能使得流程继续下去</p>
<ul>
<li>尤其需要注意的一个点是，在声明form时，一定要使用spring提供的taglib，否则会出现无法跳转到下一个state，无限回到第一个state的情况。<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;%@ page language=&quot;java&quot; contentType=&quot;text/html; charset=UTF-8&quot; pageEncoding=&quot;UTF-8&quot;%&gt;</span><br><span class="line">&lt;%@ taglib uri=&quot;http://java.sun.com/jsp/jstl/core&quot; prefix=&quot;c&quot;%&gt;</span><br><span class="line">&lt;%@ taglib uri=&quot;http://java.sun.com/jsp/jstl/functions&quot; prefix=&quot;fn&quot;%&gt;</span><br><span class="line">&lt;%@ taglib uri=&quot;http://www.springframework.org/tags/form&quot; prefix=&quot;sf&quot; %&gt;</span><br><span class="line">&lt;!DOCTYPE html PUBLIC &quot;-//W3C//DTD HTML 4.01 Transitional//EN&quot; &quot;http://www.w3.org/TR/html4/loose.dtd&quot;&gt;</span><br><span class="line">&lt;html&gt;</span><br><span class="line">	&lt;head&gt;</span><br><span class="line">		&lt;meta http-equiv=&quot;Content-Type&quot; content=&quot;text/html; charset=UTF-8&quot;&gt;</span><br><span class="line">		&lt;title&gt;Input page&lt;/title&gt;</span><br><span class="line">	&lt;/head&gt;</span><br><span class="line">	&lt;body&gt;</span><br><span class="line">		&lt;!-- commandName 声明该form需要绑定的model，与flow.xml中&lt;view-state&gt;声明的model是一个东西 --&gt;</span><br><span class="line">	   &lt;sf:form action=&quot;$&#123;flowExecutionUrl&#125;&amp;_eventId=submit&quot; commandName=&quot;searchForm&quot; method=&quot;post&quot;&gt;</span><br><span class="line">	       Name: &lt;sf:input path=&quot;name&quot;/&gt;&lt;br/&gt;</span><br><span class="line">           gender:</span><br><span class="line">           &lt;sf:select path=&quot;gender&quot;&gt;</span><br><span class="line">               &lt;sf:option value=&quot;&quot;&gt;- Please Select -&lt;/sf:option&gt;</span><br><span class="line">               &lt;c:forEach items=&quot;$&#123;InitMap.gender &#125;&quot; var=&quot;gender&quot;&gt;</span><br><span class="line">                   &lt;sf:option value=&quot;$&#123;gender &#125;&quot;&gt;$&#123;gender &#125;&lt;/sf:option&gt;</span><br><span class="line">               &lt;/c:forEach&gt;</span><br><span class="line">           &lt;/sf:select&gt;</span><br><span class="line">           &lt;input type=&quot;submit&quot; value=&quot;Submit&quot;&gt;</span><br><span class="line">	   &lt;/sf:form&gt;</span><br><span class="line">	&lt;/body&gt;</span><br><span class="line">&lt;/html&gt;</span><br></pre></td></tr></table></figure></li>
</ul>
<h2 id="SearchForm"><a href="#SearchForm" class="headerlink" title="SearchForm"></a>SearchForm</h2><p>form，与input.jsp中的form参数对应，注意必须要实现序列化接口。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public class SearchForm implements Serializable &#123;</span><br><span class="line"></span><br><span class="line">    private String name;</span><br><span class="line">    private String gender;</span><br><span class="line"></span><br><span class="line">    ... ...</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="result-jsp"><a href="#result-jsp" class="headerlink" title="result.jsp"></a>result.jsp</h2><p>将flow中的<code>modelMap</code>变量渲染到页面中</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;%@ page language=&quot;java&quot; contentType=&quot;text/html; charset=UTF-8&quot; pageEncoding=&quot;UTF-8&quot;%&gt;</span><br><span class="line">&lt;%@ taglib uri=&quot;http://java.sun.com/jsp/jstl/core&quot; prefix=&quot;c&quot;%&gt;</span><br><span class="line">&lt;%@ taglib uri=&quot;http://java.sun.com/jsp/jstl/functions&quot; prefix=&quot;fn&quot;%&gt;</span><br><span class="line">&lt;!DOCTYPE html PUBLIC &quot;-//W3C//DTD HTML 4.01 Transitional//EN&quot; &quot;http://www.w3.org/TR/html4/loose.dtd&quot;&gt;</span><br><span class="line">&lt;html&gt;</span><br><span class="line">	&lt;head&gt;</span><br><span class="line">		&lt;meta http-equiv=&quot;Content-Type&quot; content=&quot;text/html; charset=UTF-8&quot;&gt;</span><br><span class="line">		&lt;title&gt;Result Page&lt;/title&gt;</span><br><span class="line">	&lt;/head&gt;</span><br><span class="line">	&lt;body&gt;</span><br><span class="line">	    Name: $&#123;modelMap.name &#125; &lt;br/&gt;</span><br><span class="line">	    Gender: $&#123;modelMap.gender &#125; &lt;br/&gt;</span><br><span class="line">	    Age: $&#123;modelMap.age &#125; &lt;br/&gt;</span><br><span class="line">	    profession: $&#123;modelMap.profession &#125; &lt;br/&gt;</span><br><span class="line">	    hobbies: </span><br><span class="line">        &lt;c:forEach items=&quot;$&#123;modelMap.hobbies &#125;&quot; var=&quot;hobby&quot;&gt;</span><br><span class="line">            $&#123;hobby &#125; &amp;ensp;</span><br><span class="line">        &lt;/c:forEach&gt;</span><br><span class="line">        &lt;br/&gt;</span><br><span class="line">	&lt;/body&gt;</span><br><span class="line">&lt;/html&gt;</span><br></pre></td></tr></table></figure>

<h1 id="调试中遇到的坑"><a href="#调试中遇到的坑" class="headerlink" title="调试中遇到的坑"></a>调试中遇到的坑</h1><ul>
<li>现象<br>点击form的submit按钮，无法跳转到下一个state，始终重新渲染input界面；定义一个<code>&lt;a href=&quot;$&#123;flowExecutionUrl&#125;&amp;_eventId=submit&quot;&gt;</code>标签，能够正常跳转到下一个state</li>
<li>原因<br>使用了原生的html标签<code>&lt;form&gt;</code>进行表单的声明，导致web flow无法继续工作，改用Spring标签即可。<br>Web Flow无法工作的具体原理尚不明晰，我是在参考公司已有项目时发现这个问题的。</li>
<li>解决方案<br>使用Spring官方提供的taglib进行form及其属性的声明。</li>
</ul>
]]></content>
      <categories>
        <category>后端</category>
      </categories>
      <tags>
        <tag>Spring</tag>
        <tag>Webflow</tag>
      </tags>
  </entry>
  <entry>
    <title>Spring Webflow - 前言</title>
    <url>/2018/09/04/Spring%20Webflow%20-%20%E5%89%8D%E8%A8%80-springwebflow-%E5%89%8D%E8%A8%80/</url>
    <content><![CDATA[<p>虽然之前没有听说过Spring Web Flow这个东西，听说之后上网查了一下又有很多人不屑于使用web flow，但自己目前工作上的项目要用到它，因此学习是很有必要的。当学习一项新技术时，最快捷的方式就是上网搜索速成教程，看了一些，总觉得有些不得要领，于是转向官方文档。又怕自己久了会忘，故此写一套学习笔记，详细地介绍使用方法。该笔记参考官方文档，自己加以整理而成。</p>
<p>什么是web flow，这里也不免俗地引用一下百度百科的内容（也基本上是官方介绍的翻译。。。）：</p>
<blockquote>
<p>Spring Web Flow (SWF) 是Spring Framework的一个脱离模块。这个模块是Spring Web应用开发模块栈的一部分，Spring Web包含Spring MVC。Spring Web Flow 的目标是成为管理Web应用页面流程的最佳方案。当你的应用需要复杂的导航控制，例如向导，在一个比较大的事务过程中去指导用户经过一连串的步骤的时候，SWF将会是一个功能强大的控制器。</p>
</blockquote>
<p>详细内容见本系列正文内容</p>
]]></content>
      <categories>
        <category>后端</category>
      </categories>
      <tags>
        <tag>Spring</tag>
        <tag>Webflow</tag>
      </tags>
  </entry>
  <entry>
    <title>Spring Webflow - 配置</title>
    <url>/2018/09/05/Spring%20Webflow%20-%20%E9%85%8D%E7%BD%AE-springwebflow-%E9%85%8D%E7%BD%AE/</url>
    <content><![CDATA[<blockquote>
<ol>
<li>本文基于Spring Web Flow 2.4.5，其它版本配置方式可能略有不同，请参考相应版本的<a href="https://projects.spring.io/spring-webflow/">官方文档</a></li>
<li>Maven依赖<br>maven库查询推荐地址：<a href="http://mvnrepository.com/">http://mvnrepository.com/</a></li>
</ol>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;dependency&gt;</span><br><span class="line">    &lt;groupId&gt;org.springframework.webflow&lt;/groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;spring-webflow&lt;/artifactId&gt;</span><br><span class="line">    &lt;version&gt;2.4.5.RELEASE&lt;/version&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br></pre></td></tr></table></figure>
<h1 id="Web-Flow嵌入到Spring-MVC工作流简介"><a href="#Web-Flow嵌入到Spring-MVC工作流简介" class="headerlink" title="Web Flow嵌入到Spring MVC工作流简介"></a>Web Flow嵌入到Spring MVC工作流简介</h1><p>请求被DispatcherServlet拦截 -&gt; 分发flow进行处理，返回view -&gt; viewResolver解析 -&gt; 返回请求</p>
<hr>
<h1 id="配置项预览"><a href="#配置项预览" class="headerlink" title="配置项预览"></a>配置项预览</h1><ul>
    <li>FlowRegistry：必须，注册流程，指明流程配置文件所在位置；指定流程id(用于请求访问标识)；指定流程属性；此外还可以传入FlowBuilderServices进行更多个性化配置</li>
    <li>FlowBuilderServices：必须，用于设定流程配置文件中EL表达式的解析器、form属性绑定时的转换器、view-state的view解析器等，很重要</li>
    <li>FlowExecutor：必须，用于执行流程，可指定执行监听器(可选，常用于流程安全和持久化)</li>
    <li>FlowHandlerAdapter：必须，用于适配Spring MVC，配置时传入FlowExecutor</li>
    <li>FlowHandlerMapping：必须，用于将请求映射到对应的flow，配置时传入FlowRegistry</li>
</ul>

<hr>
<h1 id="配置I-注册流程-FlowRegistry"><a href="#配置I-注册流程-FlowRegistry" class="headerlink" title="配置I - 注册流程 - FlowRegistry"></a>配置I - 注册流程 - FlowRegistry</h1><p>FlowRegistry用于注册流程实例，指定流程位置和流程id，并可自定义流程创建相关内容</p>
<h2 id="注册flow的各种方式"><a href="#注册flow的各种方式" class="headerlink" title="注册flow的各种方式"></a>注册flow的各种方式</h2><ul>
<li>直接指定流程位置<br>默认情况下，web-flow的id为其文件名减去后缀名，如下配置的id为booking。指定了基地址或使用了通配符时除外。<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;webflow:flow-location path=&quot;/WEB-INF/flows/booking/booking.xml&quot; /&gt;</span><br><span class="line">// 注册了一个路径为/WEB-INF/flows/booking/booking.xml的流程，其余为默认配置。</span><br></pre></td></tr></table></figure></li>
<li>自定义id</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;webflow:flow-location path=&quot;/WEB-INF/flows/booking/booking.xml&quot; id=&quot;bookHotel&quot; /&gt;</span><br></pre></td></tr></table></figure>

<ul>
<li><p> 定义流程属性<br>如下定义了一个带有属性caption，其值为”Books a hotel”的流程。属性的使用方法暂时不了解</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;webflow:flow-location path=&quot;/WEB-INF/flows/booking/booking.xml&quot;&gt;</span><br><span class="line">    &lt;webflow:flow-definition-attributes&gt;</span><br><span class="line">        &lt;webflow:attribute name=&quot;caption&quot; value=&quot;Books a hotel&quot; /&gt;</span><br><span class="line">    &lt;/webflow:flow-definition-attributes&gt;</span><br><span class="line">&lt;/webflow:flow-location&gt;</span><br></pre></td></tr></table></figure></li>
<li><p>使用通配定义流程位置</p>
</li>
</ul>
<p><strong>使用该方法并没有正确实验出id</strong>，这点作为参考</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;webflow:flow-location-pattern value=&quot;/WEB-INF/flows/**/*-flow.xml&quot; /&gt;</span><br></pre></td></tr></table></figure>

<ul>
<li>使用基地址<br>使用基地址的flow的id为其path属性减去文件名，如下配置的id为/hotels/booking；如果path中没有路径信息，只有文件名，则id为文件名减去后缀。<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;webflow:flow-registry id=&quot;flowRegistry&quot; base-path=&quot;/WEB-INF&quot;&gt;</span><br><span class="line">    &lt;webflow:flow-location path=&quot;/hotels/booking/booking.xml&quot; /&gt;</span><br><span class="line">&lt;/webflow:flow-registry&gt;</span><br></pre></td></tr></table></figure>
<h2 id="flow-id属性总结"><a href="#flow-id属性总结" class="headerlink" title="flow id属性总结"></a>flow id属性总结</h2></li>
</ul>
<ol>
<li> id的作用<br>id用于请求定位到某个确切的flow，如当请求路径为<a href="http://localhost:8090/Floyd/search-flow%EF%BC%8C%E5%85%B6%E4%B8%ADFloyd%E6%98%AF%E9%A1%B9%E7%9B%AE%E5%90%8D%EF%BC%8C%E5%A6%82%E6%9E%9C%E6%9C%89id%E4%B8%BAsearch-flow%E7%9A%84flow%E5%AD%98%E5%9C%A8%EF%BC%8C%E5%88%99%E4%BC%9A%E8%AE%BF%E9%97%AE%E8%AF%A5flow">http://localhost:8090/Floyd/search-flow，其中Floyd是项目名，如果有id为search-flow的flow存在，则会访问该flow</a></li>
<li>id的定义</li>
</ol>
<ul>
<li>没有基地址或通配符时，flow的id为文件名减去后缀，如<code>&lt;webflow:flow-location path=&quot;/WEB-INF/flows/booking/booking.xml&quot; /&gt;</code>这里的id为booking</li>
<li>有基地址时，id为path的值减去文件名，如基地址为<code>/WEB-INF</code>， path=<code>/flows/booking/booking.xml</code>时，id被确定为<code>flows/booking</code></li>
<li>有通配符时，该情况比较特殊，按照<a href="https://docs.spring.io/spring-webflow/docs/2.4.5.RELEASE/reference/html/system-setup.html#flow-registry-base-path">官方说明</a>并没有验证通过，这里略过。<br>当显式指定了id属性时，则使用指定的id。<b>推荐自定义id</b><h2 id="FlowRegistry继承"><a href="#FlowRegistry继承" class="headerlink" title="FlowRegistry继承"></a>FlowRegistry继承</h2>FlowRegistry是可以继承的，可以定义一个公用的注册器，在多个子注册器中继承该注册器</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;!-- my-system-config.xml --&gt;</span><br><span class="line">&lt;webflow:flow-registry id=&quot;flowRegistry&quot; parent=&quot;sharedFlowRegistry&quot;&gt;</span><br><span class="line">    &lt;webflow:flow-location path=&quot;/WEB-INF/flows/booking/booking.xml&quot; /&gt;</span><br><span class="line">&lt;/webflow:flow-registry&gt;</span><br><span class="line"></span><br><span class="line">&lt;!-- shared-config.xml --&gt;</span><br><span class="line">&lt;webflow:flow-registry id=&quot;sharedFlowRegistry&quot;&gt;</span><br><span class="line">    &lt;!-- Global flows shared by several applications --&gt;</span><br><span class="line">&lt;/webflow:flow-registry&gt;</span><br></pre></td></tr></table></figure>

<hr>
<h1 id="配置II-使用FlowBuilder-services"><a href="#配置II-使用FlowBuilder-services" class="headerlink" title="配置II - 使用FlowBuilder services"></a>配置II - 使用FlowBuilder services</h1><p>使用FlowBuilder Services可以在build流程时自定义服务，比如视图解析器、EL表达式解析器、类型格式化和转换服务等。如无显式设定FlowBuilder Services，系统将使用默认实现。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;webflow:flow-registry id=&quot;flowRegistry&quot; flow-builder-services=&quot;flowBuilderServices&quot;&gt;</span><br><span class="line">    &lt;webflow:flow-location path=&quot;/WEB-INF/flows/booking/booking.xml&quot; /&gt;</span><br><span class="line">&lt;/webflow:flow-registry&gt;</span><br><span class="line"></span><br><span class="line">&lt;webflow:flow-builder-services id=&quot;flowBuilderServices&quot;</span><br><span class="line">    conversion-service=&quot;conversionService&quot;</span><br><span class="line">    expression-parser=&quot;expressionParser&quot;</span><br><span class="line">    view-factory-creator=&quot;viewFactoryCreator&quot; /&gt;</span><br><span class="line"></span><br><span class="line">&lt;bean id=&quot;conversionService&quot; class=&quot;...&quot; /&gt;</span><br><span class="line">&lt;bean id=&quot;expressionParser&quot; class=&quot;...&quot; /&gt;</span><br><span class="line">&lt;bean id=&quot;viewFactoryCreator&quot; class=&quot;...&quot; /&gt;</span><br></pre></td></tr></table></figure>
<h2 id="自定义视图解析器-view-factory-creator"><a href="#自定义视图解析器-view-factory-creator" class="headerlink" title="自定义视图解析器 view-factory-creator"></a>自定义视图解析器 view-factory-creator</h2><p>view-factory-creator用于视图解析工作，默认的creator可以支持Spring MVC支持的几种视图类型：JSP, Velocity，FreeMarker等。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;webflow:flow-registry id=&quot;flowRegistry&quot; flow-builder-services=&quot;flowBuilderServices&quot;&gt;</span><br><span class="line">	&lt;webflow:location path=&quot;/WEB-INF/hotels/booking/booking.xml&quot; /&gt;</span><br><span class="line">&lt;/webflow:flow-registry&gt;</span><br><span class="line"></span><br><span class="line">&lt;!-- 尤其注意这里的development，设置为true时表示开启开发模式，该模式下会在flow定义改变时自动re-load，甚至flow中引用的resource bundle发生了变化都会热重载 --&gt;</span><br><span class="line">&lt;webflow:flow-builder-services id=&quot;flowBuilderServices&quot; view-factory-creator=&quot;mvcViewFactoryCreator&quot; development=&quot;true&quot;/&gt;</span><br><span class="line"></span><br><span class="line">&lt;bean id=&quot;mvcViewFactoryCreator&quot; class=&quot;org.springframework.webflow.mvc.builder.MvcViewFactoryCreator&quot;&gt;</span><br><span class="line">	&lt;!-- myExistingViewResolverToUseForFlows就是我们常用的视图解析器，注意这里引用的是一个列表 --&gt;</span><br><span class="line">	&lt;property name=&quot;viewResolvers&quot; ref=&quot;myExistingViewResolverToUseForFlows&quot;/&gt;</span><br><span class="line">&lt;/bean&gt;</span><br><span class="line"></span><br><span class="line">... ... </span><br><span class="line">... ...</span><br><span class="line">&lt;!-- 做验证时使用的是javaconfig的形式，这种形式并没有验证过 --&gt;</span><br><span class="line">&lt;property name=&quot;myExistingViewResolverToUseForFlows&quot;&gt;</span><br><span class="line">    &lt;list&gt;</span><br><span class="line">        &lt;ref bean=&quot;viewResolver&quot; /&gt;</span><br><span class="line">    &lt;/list&gt;</span><br><span class="line">&lt;/property&gt;</span><br><span class="line"></span><br><span class="line">&lt;bean id=&quot;viewResolver&quot; class=&quot;org.springframework.web.servlet.view.InternalResourceViewResolver&quot;&gt;</span><br><span class="line">   &lt;property name=&quot;prefix&quot; value=&quot;/WEB-INF/&quot;/&gt;</span><br><span class="line">   &lt;property name=&quot;suffix&quot; value=&quot;.jsp&quot;/&gt;</span><br><span class="line">&lt;/bean&gt;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="自定义表达式解析器-expression-parser"><a href="#自定义表达式解析器-expression-parser" class="headerlink" title="自定义表达式解析器 expression-parser"></a>自定义表达式解析器 expression-parser</h2><p>expression-parser用于定义表达式解析器，默认的解析器使用逻辑：当类路径下有Unified EL解析器时，则使用；没有时，则使用OGNL表达式解析器(官方文档在<a href="https://docs.spring.io/spring-webflow/docs/2.4.5.RELEASE/reference/html/el.html#el-unified-el">EL表达式</a>一章和<a href="https://docs.spring.io/spring-webflow/docs/2.4.5.RELEASE/reference/html/system-setup.html#builder-service-expression-parser">系统设置</a>一章关于默认表达式解析说法有出入，自己认为比较可信的是Spring Web Flow 2.1以后，默认使用Spring EL表达式解析器)。<br>下面是手动配置成Unified EL解析器的方式：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;webflow:flow-builder-services expression-parser=&quot;expressionParser&quot;/&gt;</span><br><span class="line"></span><br><span class="line">&lt;bean id=&quot;expressionParser&quot; class=&quot;org.springframework.webflow.expression.el.WebFlowELExpressionParser&quot;&gt;</span><br><span class="line">    &lt;constructor-arg&gt;</span><br><span class="line">        &lt;bean class=&quot;org.jboss.el.ExpressionFactoryImpl&quot; /&gt;</span><br><span class="line">    &lt;/constructor-arg&gt;</span><br><span class="line">&lt;/bean&gt;</span><br></pre></td></tr></table></figure>

<h2 id="自定义类型转换器-conversion-service"><a href="#自定义类型转换器-conversion-service" class="headerlink" title="自定义类型转换器 conversion-service"></a>自定义类型转换器 conversion-service</h2><p> 详细内容参见本系列视图渲染相关章节或<a href="https://docs.spring.io/spring-webflow/docs/2.4.5.RELEASE/reference/html/views.html#converter-configuration">官方文档</a></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;webflow:flow-registry id=&quot;flowRegistry&quot; flow-builder-services=&quot;flowBuilderServices&quot; ... /&gt;</span><br><span class="line"></span><br><span class="line">&lt;webflow:flow-builder-services id=&quot;flowBuilderServices&quot; conversion-service=&quot;defaultConversionService&quot; ... /&gt;</span><br><span class="line"></span><br><span class="line">&lt;bean id=&quot;defaultConversionService&quot; class=&quot;org.springframework.binding.convert.service.DefaultConversionService&quot;&gt;</span><br><span class="line">	&lt;constructor-arg ref=&quot;applicationConversionSevice&quot;/&gt;</span><br><span class="line">&lt;/bean&gt;</span><br><span class="line"></span><br><span class="line">&lt;bean id=&quot;applicationConversionService&quot; class=&quot;somepackage.ApplicationConversionServiceFactoryBean&quot;&gt;</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public class ApplicationConversionServiceFactoryBean extends FormattingConversionServiceFactoryBean &#123;</span><br><span class="line">    @Override</span><br><span class="line">    protected void installFormatters(FormatterRegistry registry) &#123;</span><br><span class="line">        // ...</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<h1 id="配置III-发布流程执行器-FlowExecutor"><a href="#配置III-发布流程执行器-FlowExecutor" class="headerlink" title="配置III - 发布流程执行器 - FlowExecutor"></a>配置III - 发布流程执行器 - FlowExecutor</h1><p>FlowExecutor用于执行flow并管理flow执行过程，常见的自定义项有：设置监听器，监听流程执行过程并作出相应，如security监听器，用于监听并控制流程的访问权限；调整flow的部分持久化选项等。</p>
<ul>
<li>注册监听器</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;!-- 这里是为特定的flow应用该监听器，当不设criteria属性时，将对所有flow应用 --&gt;</span><br><span class="line">&lt;webflow:flow-execution-listeners&gt;</span><br><span class="line">    &lt;webflow:listener ref=&quot;securityListener&quot; criteria=&quot;securedFlow1,securedFlow2&quot;/&gt;</span><br><span class="line">&lt;/webflow:flow-execution-listeners&gt;</span><br></pre></td></tr></table></figure>

<ul>
<li>调整持久化参数</li>
<li>max-executions： 设定为每个用户保留的执行数(没错，就是执行数)，当超过该数量时，最先的那个执行会被清除。(这里的执行，我认为是一个新开的且处于激活状态下的flow实例)</li>
<li>max-execution-snapshots： 设定每个执行保留的最大快照数。不允许保留时，设为0。允许无线保留时，设为-1。(快照用于浏览器的返回按钮)<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;webflow:flow-executor id=&quot;flowExecutor&quot; flow-registry=&quot;flowRegistry&quot;&gt;</span><br><span class="line">    &lt;webflow:flow-execution-repository max-executions=&quot;5&quot; max-execution-snapshots=&quot;30&quot; /&gt;</span><br><span class="line">&lt;/webflow:flow-executor&gt;</span><br><span class="line"></span><br></pre></td></tr></table></figure></li>
</ul>
<hr>
<h1 id="配置IV-Spring-MVC集成"><a href="#配置IV-Spring-MVC集成" class="headerlink" title="配置IV - Spring MVC集成"></a>配置IV - Spring MVC集成</h1><h2 id="基础配置（将请求转发给flow）"><a href="#基础配置（将请求转发给flow）" class="headerlink" title="基础配置（将请求转发给flow）"></a>基础配置（将请求转发给flow）</h2><ul>
<li>Spring MVC基础配置</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;servlet&gt;</span><br><span class="line">	&lt;servlet-name&gt;Spring MVC Dispatcher Servlet&lt;/servlet-name&gt;</span><br><span class="line">	&lt;servlet-class&gt;org.springframework.web.servlet.DispatcherServlet&lt;/servlet-class&gt;</span><br><span class="line">	&lt;init-param&gt;</span><br><span class="line">		&lt;param-name&gt;contextConfigLocation&lt;/param-name&gt;</span><br><span class="line">		&lt;param-value&gt;/WEB-INF/web-application-config.xml&lt;/param-value&gt;</span><br><span class="line">	&lt;/init-param&gt;</span><br><span class="line">&lt;/servlet&gt;</span><br><span class="line"></span><br><span class="line">&lt;servlet-mapping&gt;</span><br><span class="line">	&lt;servlet-name&gt;Spring MVC Dispatcher Servlet&lt;/servlet-name&gt;</span><br><span class="line">	&lt;!-- 不能使用类型/*的通配符进行匹配，否则会出现jsp不解析直接回发给浏览器的情况 --&gt;</span><br><span class="line">	&lt;url-pattern&gt;/&lt;/url-pattern&gt;</span><br><span class="line">&lt;/servlet-mapping&gt;</span><br></pre></td></tr></table></figure>

<hr>
<h2 id="FlowHandlerAdapter"><a href="#FlowHandlerAdapter" class="headerlink" title="FlowHandlerAdapter"></a>FlowHandlerAdapter</h2><p>该步骤是使得Web Flow能够适配Spring MVC<br>当一个对flow的请求被接收到时，FlowHandlerAdapter会决定是启动一个全新的flow还是继续之前的流程(如从一个view-state跳转到下一个state就属于继续之前的流程)，继续之前的flow是需要在请求有相关信息才行。有关这一方面，web flow默认有如下设定：<br>&emsp;&emsp;1.Http请求参数在任何情况下都是可以使用的<br>&emsp;&emsp;2.当一个flow执行结束，且结束时没有想浏览器发送最后的响应时，默认的handler会尝试在同一个request中启动一个新的flow执行<br>&emsp;&emsp;3.除了NoSuchFlowExecutionException异常外，所有其它异常都会以冒泡的方式抛到Dispatcher中。这是因为默认的handler会尝试自动从该异常中恢复过来，恢复的方式是新开一个全新的flow执行<br>针对大多数设定，都可以通过实现FlowHandlerAdapter类的子类进行自定义。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;!-- Enables FlowHandler URL mapping --&gt;</span><br><span class="line">&lt;bean class=&quot;org.springframework.webflow.mvc.servlet.FlowHandlerAdapter&quot;&gt;</span><br><span class="line">	&lt;!-- flowExecutor就是前文声明的执行器 --&gt;</span><br><span class="line">	&lt;property name=&quot;flowExecutor&quot; ref=&quot;flowExecutor&quot; /&gt;</span><br><span class="line">&lt;/bean&gt;</span><br></pre></td></tr></table></figure>

<hr>
<h1 id="配置V-FlowHandlerMapping"><a href="#配置V-FlowHandlerMapping" class="headerlink" title="配置V - FlowHandlerMapping"></a>配置V - FlowHandlerMapping</h1><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;!-- Maps request paths to flows in the flowRegistry;</span><br><span class="line">	e.g. a path of /hotels/booking looks for a flow with id &quot;hotels/booking&quot; --&gt;</span><br><span class="line">&lt;bean class=&quot;org.springframework.webflow.mvc.servlet.FlowHandlerMapping&quot;&gt;</span><br><span class="line">	&lt;!-- flowRegistry就是前文声明的注册器 --&gt;</span><br><span class="line">	&lt;property name=&quot;flowRegistry&quot; ref=&quot;flowRegistry&quot;/&gt;</span><br><span class="line">	&lt;property name=&quot;order&quot; value=&quot;0&quot;/&gt;</span><br><span class="line">&lt;/bean&gt;</span><br></pre></td></tr></table></figure>
<p>有了Flow的基本配置和这里的两个Spring MVC的集成配置，请求就能够映射到flow中了。接下来就是写Flow了。想要快速上手的可忽略本文后面的内容，转而直接看本系列其它文章。</p>
<hr>
<h1 id="配置VI-实现自定义的FlowHandler"><a href="#配置VI-实现自定义的FlowHandler" class="headerlink" title="配置VI - 实现自定义的FlowHandler"></a>配置VI - 实现自定义的FlowHandler</h1><ul>
<li>FlowHandler讲解<br>FlowHandler可用于自定义flow在HTTP Servlert环境中执行的方式，FlowHandler在FlowHandlerAdapter中被使用，主要负责如下内容：</li>
</ul>
<p> &emsp;&emsp;- 返回flow的id以用于执行该flow<br> &emsp;&emsp;- 在新流程开始时创建输入<br> &emsp;&emsp;- 在流程结束时处理流程的输出<br> &emsp;&emsp;- 在流程发生异常时，处理这些异常</p>
<p> 其主要方法如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public interface FlowHandler &#123;</span><br><span class="line"></span><br><span class="line">	public String getFlowId();</span><br><span class="line"></span><br><span class="line">	public MutableAttributeMap createExecutionInputMap(HttpServletRequest request);</span><br><span class="line"></span><br><span class="line">	public String handleExecutionOutcome(FlowExecutionOutcome outcome,</span><br><span class="line">		HttpServletRequest request, HttpServletResponse response);</span><br><span class="line"></span><br><span class="line">	public String handleException(FlowException e,</span><br><span class="line">		HttpServletRequest request, HttpServletResponse response);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p> &emsp;&emsp;该接口的直接实现为AbstractFlowHandler，当我们想要自定义某个设定时，继承该抽象类并重写其中的方法即可。</p>
<ul>
<li>发布一个FlowHandler<br>一个FlowHandler负责一个flow，发布方式是在Spring环境中声明一个bean，该bean的name必须和我们想要处理的flow的id一致，配置好后，当方位该flow的id，则会定位到新发布的FlowHandler中，我们自定义的方法也就生效了。</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;!-- 这里的BookingHandler只是一个例子，实际用时替换成我们自己的Handler --&gt;</span><br><span class="line">&lt;bean name=&quot;hotels/booking&quot; class=&quot;org.springframework.webflow.samples.booking.BookingFlowHandler&quot; /&gt;</span><br></pre></td></tr></table></figure>
<ul>
<li>着重讲一下FlowHandler中handleExecutionOutcome(…)方法<br>该方法用于处理flow结束时产生的FlowExecutionOutcome(系统自动产生)，我们常用它来在流程结束后进行重定向，比如</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public class BookingFlowHandler extends AbstractFlowHandler &#123;</span><br><span class="line">	// handlExecutionOutcome()方法返回的String代表的是重定向的地址</span><br><span class="line">	public String handleExecutionOutcome(FlowExecutionOutcome outcome,</span><br><span class="line">										HttpServletRequest request, HttpServletResponse response) &#123;</span><br><span class="line">		if (outcome.getId().equals(&quot;bookingConfirmed&quot;)) &#123;</span><br><span class="line">			return &quot;/booking/show&quot;;</span><br><span class="line">		&#125; else &#123;</span><br><span class="line">			return &quot;/hotels/index&quot;;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line">// 当flow id为bookinConfirmed时，重定向到/booking/show，否则重定向到/hotels/index</span><br></pre></td></tr></table></figure>

<p>&emsp;&emsp;默认情况下，该方法返回的地址是相关于当前Servlet的。但是我们也可以显式地指定一些前缀来扩展重定向的范围</p>
<p> &emsp;&emsp; – <code>servletRelative</code>: - 相对于当前Servlet重定向<br>&emsp;&emsp; – <code>contextRelative</code>: - 相对于当前应用重定向<br>&emsp;&emsp; – <code>serverRelative</code>: - 相对于当前服务器的基地址重定向<br>&emsp;&emsp; – <code>http:// or https://</code> - 重定向到一个完整的URI地址</p>
<p>&emsp;&emsp;相同的前缀同样适用于声明state时的view属性配上<code>externalRedirect</code>的情况</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;end-state view=&quot;externalRedirect:http://springframework.org&quot;/&gt;</span><br><span class="line">&lt;!-- 在流程结束时，跳转到spring首页 --&gt;</span><br></pre></td></tr></table></figure>

<p>—————————————————–手动分割线——————————————————————————————</p>
<h1 id="一个能用的配置-采用Java-config的方式配置"><a href="#一个能用的配置-采用Java-config的方式配置" class="headerlink" title="一个能用的配置(采用Java config的方式配置)"></a>一个能用的配置(采用Java config的方式配置)</h1><h2 id="WebInitializer（与web-xml作用类似）"><a href="#WebInitializer（与web-xml作用类似）" class="headerlink" title="WebInitializer（与web.xml作用类似）"></a>WebInitializer（与web.xml作用类似）</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public class WebInitializer extends AbstractAnnotationConfigDispatcherServletInitializer &#123;</span><br><span class="line"></span><br><span class="line">	@Override</span><br><span class="line">	protected Class&lt;?&gt;[] getRootConfigClasses() &#123;</span><br><span class="line">		return null;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	@Override</span><br><span class="line">	protected Class&lt;?&gt;[] getServletConfigClasses() &#123;</span><br><span class="line">		return new Class&lt;?&gt;[] &#123;MainConfig.class, RegisterConfig.class&#125;;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	@Override</span><br><span class="line">	protected String[] getServletMappings() &#123;</span><br><span class="line">		return new String[] &#123;&quot;/&quot;&#125;;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="MainConfig（Spring的主要配置文件）"><a href="#MainConfig（Spring的主要配置文件）" class="headerlink" title="MainConfig（Spring的主要配置文件）"></a>MainConfig（Spring的主要配置文件）</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">@Configuration</span><br><span class="line">@EnableWebMvc</span><br><span class="line">@ComponentScan(&quot;cn.floyd.pw&quot;)</span><br><span class="line">public class MainConfig extends WebMvcConfigurerAdapter&#123;</span><br><span class="line"></span><br><span class="line">	@Bean(name=&quot;viewResolver&quot;)</span><br><span class="line">	public ViewResolver getViewResolver() &#123;</span><br><span class="line">		InternalResourceViewResolver resolver = new InternalResourceViewResolver();</span><br><span class="line">		resolver.setPrefix(&quot;/WEB-INF/jsp/&quot;);</span><br><span class="line">		resolver.setSuffix(&quot;.jsp&quot;);</span><br><span class="line">		return resolver;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	@Bean</span><br><span class="line">	public MultipartResolver multipartResolver() throws IOException &#123;</span><br><span class="line">	    CommonsMultipartResolver resolver = new CommonsMultipartResolver();</span><br><span class="line">	    return resolver;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	// enable the static resource</span><br><span class="line">	@Override</span><br><span class="line">	public void configureDefaultServletHandling(DefaultServletHandlerConfigurer configurer) &#123;</span><br><span class="line">		configurer.enable();</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	@Bean</span><br><span class="line">    public FlowHandlerAdapter flowHandlerAdapter(@Autowired FlowExecutor flowExecutor) &#123;</span><br><span class="line">	    System.out.println(&quot;init flowHandlerAdapter&quot;);</span><br><span class="line">        FlowHandlerAdapter adapter = new FlowHandlerAdapter();</span><br><span class="line">        adapter.setFlowExecutor(flowExecutor);</span><br><span class="line">        </span><br><span class="line">        return adapter;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    @Bean</span><br><span class="line">    public FlowHandlerMapping flowHandlerMapping(@Autowired FlowDefinitionRegistry flowRegistry) &#123;</span><br><span class="line">        System.out.println(&quot;init flowHandlerMapping&quot;);</span><br><span class="line">        FlowHandlerMapping mapping = new FlowHandlerMapping();</span><br><span class="line">        mapping.setOrder(0);</span><br><span class="line">        mapping.setFlowRegistry(flowRegistry);</span><br><span class="line">        </span><br><span class="line">        return mapping;</span><br><span class="line">    &#125;</span><br><span class="line">	</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="RegisterConfig（配置FlowRegister和flowExecutor）"><a href="#RegisterConfig（配置FlowRegister和flowExecutor）" class="headerlink" title="RegisterConfig（配置FlowRegister和flowExecutor）"></a>RegisterConfig（配置FlowRegister和flowExecutor）</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">@Configuration</span><br><span class="line">public class RegisterConfig extends AbstractFlowConfiguration &#123;</span><br><span class="line"></span><br><span class="line">    // 用于注册flow</span><br><span class="line">    @Bean(&quot;flowRegistry&quot;)</span><br><span class="line">    public FlowDefinitionRegistry flowRegistry(@Autowired FlowBuilderServices flowBuilderServices) &#123;</span><br><span class="line">        </span><br><span class="line">        return getFlowDefinitionRegistryBuilder()</span><br><span class="line">                .setBasePath(&quot;/WEB-INF/jsp/flow&quot;)</span><br><span class="line">                .addFlowLocation(&quot;/config/search-flow.xml&quot;)</span><br><span class="line">                .setFlowBuilderServices(flowBuilderServices)</span><br><span class="line">                .build();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    @Bean</span><br><span class="line">    public FlowBuilderServices flowBuilderServices(@Autowired MvcViewFactoryCreator mvcViewFactoryCreator) &#123;</span><br><span class="line">        return getFlowBuilderServicesBuilder()</span><br><span class="line">                .setViewFactoryCreator(mvcViewFactoryCreator)</span><br><span class="line">                .build();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    @Bean</span><br><span class="line">    public MvcViewFactoryCreator mvcViewFactoryCreator(@Autowired ViewResolver viewResolver) &#123;</span><br><span class="line">        MvcViewFactoryCreator creator = new MvcViewFactoryCreator();</span><br><span class="line">        List&lt;ViewResolver&gt; list = new ArrayList&lt;ViewResolver&gt;();</span><br><span class="line">        list.add(viewResolver);</span><br><span class="line">        creator.setViewResolvers(list);</span><br><span class="line">        </span><br><span class="line">        return creator;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    @Bean</span><br><span class="line">    public FlowExecutor flowExecutor(@Autowired FlowDefinitionRegistry flowRegistry) &#123;</span><br><span class="line">        return getFlowExecutorBuilder(flowRegistry).build();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<h1 id="配置时踩过的坑"><a href="#配置时踩过的坑" class="headerlink" title="配置时踩过的坑"></a>配置时踩过的坑</h1><h2 id="flow-id的坑"><a href="#flow-id的坑" class="headerlink" title="flow id的坑"></a>flow id的坑</h2><blockquote>
<p>最开始对flow id的认识不够，导致不知道到底该如何定位到flow，其实访问方式就是  …/appName/flowId</p>
<h4 id="Web-MVC-Environment-null-not-supported"><a href="#Web-MVC-Environment-null-not-supported" class="headerlink" title="Web MVC Environment null not supported"></a>Web MVC Environment null not supported</h4><p>启动时正常，访问flow时报异常java.lang.IllegalStateException: Web MVC Environment null not supported<br> 是在创建viewFactory时出错，由于我没有采用在config中声明bean的方式创建MvcViewFactoryCreator，因此出现找不到mvc环境的问题，原来是spring在自动检测并创建bean时，会同时设置该bean的环境，因此不能自己随意采用new的方式创建这些配置类</p>
<h4 id="JSP文件不解析"><a href="#JSP文件不解析" class="headerlink" title="JSP文件不解析"></a>JSP文件不解析</h4><p>出现JSP文件不经过解析就直接传送给了浏览器的问题(对如下阐述的原理并不是很清楚)<br>url-pattern为”/*”时，能够匹配到任何路径，因此当controller返回.jsp文件时，也会被拦截，从而返回jsp源码(这里不是很理解，主要是跟自己认识的spring mvc处理流程有差别)。<br>url-pattern为”/“时，只能够匹配不带后缀的路径，因此jsp就不会被dispatcherServlet拦截，而是会被jspServlet拦截并处理。但是”/“在配置使能的情况下也能够拦截并允许静态资源的访问</p>
</blockquote>
]]></content>
      <categories>
        <category>后端</category>
      </categories>
      <tags>
        <tag>Spring</tag>
        <tag>Webflow</tag>
      </tags>
  </entry>
  <entry>
    <title>Spring Webflux初探</title>
    <url>/2021/03/15/Spring%20Webflux%E5%88%9D%E6%8E%A2-springwebflux-chu-tan/</url>
    <content><![CDATA[<blockquote>
<p>说明：文章中代码参考使用方式即可，请忽略其代表的逻辑部分</p>
</blockquote>
<h2 id="为何想要用Spring-Webflux"><a href="#为何想要用Spring-Webflux" class="headerlink" title="为何想要用Spring Webflux?"></a>为何想要用Spring Webflux?</h2><p>《每记》是一款新产品。一开始想用webflux，为什么呢？这里给出自己的几点理由</p>
<ul>
<li>Spring生态加持，想必会很好用</li>
<li>一直只闻其声不见其人，很想用用</li>
<li>原计划中的vertx-spring项目，想要做成的结果，和webflux很像；因此希望从webflux中找到一些发现</li>
</ul>
<span id="more"></span>

<h3 id="《每记》技术构成"><a href="#《每记》技术构成" class="headerlink" title="《每记》技术构成"></a>《每记》技术构成</h3><p>《每记》的主要业务逻辑都在客户端，后端只需要负责用户接口和数据备份。需要用到的技术只有两个</p>
<ul>
<li>grpc —— 用于grpc服务，如user-service，media-service</li>
<li>数据库 —— 用于数据存取</li>
</ul>
<p>grpc的官方库实现基于Netty，天然响应式，能够和webflux结合得比较好；</p>
<p>数据库方面，Spring官方提供R2DBC，但它所处的技术层级和JDBC类似，且尚不成熟，从官方手册的描述就不是很敢用于生产。</p>
<blockquote>
<p>Spring Data R2DBC aims at being conceptually easy. In order to achieve this it does NOT offer caching, lazy loading, write behind or many other features of ORM frameworks. This makes Spring Data R2DBC a simple, limited, opinionated object mapper.</p>
</blockquote>
<p>至于其他的异步数据库链接库，不成体系，使用不便。因此还是使用JDBC。</p>
<p>至于ORM框架，考虑了MyBatis plus、jooq、korm几种，还是认为MyBatis plus相对方便。</p>
<p>于是技术组成就是：</p>
<p>Spring Webflux + GRPC + MyBatis plus</p>
<p>Spring WebMVC + GRPC + Myabtis plus （作为对比）</p>
<h2 id="Webflux简介"><a href="#Webflux简介" class="headerlink" title="Webflux简介"></a>Webflux简介</h2><p>横向看，WebFlux组成大致如下</p>
<p><img src="https://gdz.oss-cn-shenzhen.aliyuncs.com/halo/tapd_61207716_1615454473_19_1616242796287.png" alt="tapd_61207716_1615454473_19"></p>
<p>这和WebMVC的结构图很像，解释一下各部分工作。</p>
<ul>
<li>容器reactor-netty：即基于netty实现的符合reactor标准的容器，Spring Boot默认使用它。其对应的关键核心接口是HttpHandler，webflux中对应的重要实现类是：WebHttpHandlerBuilder，它是整个webflux程序的入口。</li>
<li>Webfilter：过滤器</li>
<li>DispatcherHandler：核心处理器，协调如下三个核心组件工作<ul>
<li>HandleMapping：存储请求URI和处理器的对应关系</li>
<li>HandlerAdapter：封装了主要处理逻辑，处理结果封装成HandlerResult</li>
<li>HandlerResultHandler：针对上一步结果的处理器</li>
</ul>
</li>
<li>WebExceptionHandler：整个流程中抛出的任何异常，都会被它捕获，“真”全局异常处理</li>
</ul>
<p>如想了解进一步内容，请从源码挖掘。</p>
<h2 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h2><p>本节介绍Webflux的使用方式。Webflux有两种使用方式</p>
<ul>
<li>注解式</li>
<li>编程式</li>
</ul>
<p>我们选择注解式，更为方便。至于API风格，选择kotlin协程。</p>
<p>具体使用方式参见mylog的spring-webflux分支，这里列出几个关键点。</p>
<h3 id="路由"><a href="#路由" class="headerlink" title="路由"></a>路由</h3><p>使用方式和一般的MVC程序没有什么区别，除了一点</p>
<ul>
<li>方法需要是suspend方法或返回Mono/Flux</li>
</ul>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ResourceController</span></span>(</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">val</span> resourceService: ResourceService</span><br><span class="line">) &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@PostMapping(<span class="meta-string">&quot;resources/:push&quot;</span>)</span></span><br><span class="line">    <span class="keyword">suspend</span> <span class="function"><span class="keyword">fun</span> <span class="title">push</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">        <span class="meta">@RequestBody</span> pushRequest: <span class="type">PushRequest</span></span></span></span><br><span class="line"><span class="params"><span class="function">    )</span></span>: PushResponse &#123;</span><br><span class="line">        <span class="keyword">val</span> result = resourceService.validateAndSave(pushRequest.resources)</span><br><span class="line">        <span class="keyword">return</span> PushResponse(result.map &#123; it.<span class="keyword">data</span> <span class="keyword">as</span> Map&lt;String, Any&gt; &#125;)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="过滤器"><a href="#过滤器" class="headerlink" title="过滤器"></a>过滤器</h3><p>Webflux中没有拦截器这个概念，要做类似的工作需要在过滤器中完成，项目中我们用到Token验证，使用方法是注册过滤器。</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">AuthFilter</span></span>(applicationContext: ApplicationContext) : AbstractAuthFilter(applicationContext) &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Value(<span class="meta-string">&quot;\$&#123;authentication.token.name&#125;&quot;</span>)</span></span><br><span class="line">    <span class="keyword">lateinit</span> <span class="keyword">var</span> tokenName: String</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 注意这里使用了协程的grpc stub</span></span><br><span class="line">    <span class="meta">@GrpcClient(<span class="meta-string">&quot;user-service&quot;</span>)</span></span><br><span class="line">    <span class="keyword">lateinit</span> <span class="keyword">var</span> userStub: UsersServiceGrpcKt.UsersServiceCoroutineStub</span><br><span class="line"></span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">filter</span><span class="params">(exchange: <span class="type">ServerWebExchange</span>, chain: <span class="type">WebFilterChain</span>)</span></span>: Mono&lt;<span class="built_in">Void</span>&gt; = mono &#123;</span><br><span class="line">        <span class="keyword">val</span> request = exchange.request</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (request.needAuth()) &#123;</span><br><span class="line">            <span class="keyword">val</span> token = request.headers[tokenName]?.first() </span><br><span class="line">            <span class="keyword">val</span> result = userStub.verify(Token.newBuilder().setToken(token).build())</span><br><span class="line">            ... ...</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// chain.filter返回的是Mono，需要调用await方法转换为协程</span></span><br><span class="line">        chain.filter(exchange).awaitSingleOrNull()</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="全局异常处理"><a href="#全局异常处理" class="headerlink" title="全局异常处理"></a>全局异常处理</h3><p>Webflux中可以使用@ControllerAdvice注册全局异常处理器，但它仅Controller中抛出的异常生效，无法顾及到过滤器。对异常，推荐的方式是注册WebExceptionHandler。</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="meta">@Order(Ordered.HIGHEST_PRECEDENCE)</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ExceptionHandler</span> : <span class="type">ErrorWebExceptionHandler &#123;</span></span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">val</span> objectMapper = ObjectMapper()</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 对协程的支持</span></span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">handle</span><span class="params">(exchange: <span class="type">ServerWebExchange</span>, ex: <span class="type">Throwable</span>)</span></span>: Mono&lt;<span class="built_in">Void</span>&gt; &#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">val</span> errResponse = objectMapper.writeValueAsBytes(<span class="string">&quot;error message&quot;</span>)</span><br><span class="line"></span><br><span class="line">        response.headers.contentType = MediaType.APPLICATION_PROBLEM_JSON</span><br><span class="line">        response.statusCode = code.httpStatus</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> response.writeWith(Mono.just(response.bufferFactory().wrap(errResponse)))</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="同步DAO的调用"><a href="#同步DAO的调用" class="headerlink" title="同步DAO的调用"></a>同步DAO的调用</h3><p>JDBC是同步的，基于它的MyBatis也是同步的，为了不阻塞DIspatcher-Worker线程，需要将其手动调度到其他线程池。当然如下步骤也可以使用AOP实现，这样就不用为每个方法手动调mono方法。</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 注入Scheduler</span></span><br><span class="line"><span class="meta">@Autowired</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">lateinit</span> <span class="keyword">var</span> scheduler: Scheduler</span><br><span class="line"><span class="comment">// 讲同步代码注册到该scheduler</span></span><br><span class="line"><span class="keyword">protected</span> <span class="function"><span class="keyword">fun</span> <span class="type">&lt;T&gt;</span> <span class="title">mono</span><span class="params">(block: () -&gt; <span class="type">T</span>)</span></span>: Mono&lt;T&gt; &#123;</span><br><span class="line">    <span class="keyword">return</span> Mono.defer &#123; Mono.just(block()) &#125;.subscribeOn(scheduler)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 调用方式</span></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">save</span><span class="params">(modifications: <span class="type">List</span>&lt;<span class="type">Resource</span>&gt;)</span></span>: Mono&lt;List&lt;Resource&gt;&gt; = mono &#123;</span><br><span class="line">    modifications.mapNotNull &#123;</span><br><span class="line">        resourceMapper.save(it)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="Swagger"><a href="#Swagger" class="headerlink" title="Swagger"></a>Swagger</h3><p>Knife4j的增强功能无法在Webflux下使用，且当controller为suspend方法时无法正常读取到返回值，需要打如下补丁。</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> *  修复controller方法为suspend方法时，springfox无法获取返回值类型的情况</span></span><br><span class="line"><span class="comment"> *  因为suspend方法转换为字节码后返回值为null</span></span><br><span class="line"><span class="comment"> *  #issue: https://github.com/springfox/springfox/issues/3241</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="meta">@Primary</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">CustomRequestHandler</span></span>(</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">val</span> resolver: TypeResolver</span><br><span class="line">) : HandlerMethodResolver(resolver) &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">methodReturnType</span><span class="params">(handlerMethod: <span class="type">HandlerMethod</span>)</span></span>: ResolvedType &#123;</span><br><span class="line">        <span class="keyword">val</span> func = handlerMethod.beanType.kotlin.declaredFunctions.first &#123; it.javaMethod == handlerMethod.method &#125;</span><br><span class="line">        <span class="keyword">if</span> (func.returnType == <span class="built_in">Unit</span>::<span class="keyword">class</span>.starProjectedType) resolver.resolve(<span class="built_in">Void</span>.TYPE)</span><br><span class="line">        <span class="keyword">return</span> resolver.resolve(func.returnType.javaType)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="测试"><a href="#测试" class="headerlink" title="测试"></a>测试</h2><p>以一个最典型的接口resources/:pull进行压力测试，该接口逻辑如下</p>
<ul>
<li>访问user-service验证token</li>
<li>访问数据库读取数据</li>
</ul>
<p>测试工具为apache-utils，ab。</p>
<p>测试结果总结就是：相同条件下，webflux的性能表现相比webmvc并没有什么变化。</p>
<h2 id="初步结论-——-不选择"><a href="#初步结论-——-不选择" class="headerlink" title="初步结论 —— 不选择"></a>初步结论 —— 不选择</h2><h3 id="优点"><a href="#优点" class="headerlink" title="优点"></a>优点</h3><ul>
<li>本身的异步模型</li>
<li>Spring生态支持，依赖注入，注解，协程</li>
</ul>
<h3 id="缺点"><a href="#缺点" class="headerlink" title="缺点"></a>缺点</h3><ul>
<li>整体生态的缺乏，首要的是异步ORM</li>
<li>响应式的固有问题，学习曲线</li>
</ul>
<h2 id="不选择的原因"><a href="#不选择的原因" class="headerlink" title="不选择的原因"></a>不选择的原因</h2><ul>
<li>实际测试下来，性能并没有实质性的提升，反而增加了开发难度<ul>
<li>需要桥接阻塞的ORM库存</li>
<li>Springfox打补丁</li>
<li>没有拦截器，只有过滤器，做权限验证时不方便</li>
<li>其它未知的点</li>
</ul>
</li>
<li>上手成本，从近期招聘简历上看，熟悉响应式的人少之又少，我们有极大可能招聘到一个对此不熟悉的人，技术墙还是有的。</li>
</ul>
<p>综上，如果引入webflux，并没有带来好处，反而有诸多不便。因此最终决定使用webmvc。</p>
]]></content>
      <categories>
        <category>响应式</category>
      </categories>
      <tags>
        <tag>Webflux</tag>
      </tags>
  </entry>
  <entry>
    <title>Spring扫盲——Spring Data JPA</title>
    <url>/2021/09/28/Spring%E6%89%AB%E7%9B%B2%E2%80%94%E2%80%94Spring%20Data%20JPA-spring-sao-mang-springdatajpa/</url>
    <content><![CDATA[<p>震惊，查询SQL的创建居然是根据Repository的方法名来生成的。</p>
<p>对于JPA，我们只需要掌握几点。</p>
<span id="more"></span>

<h3 id="使用步骤"><a href="#使用步骤" class="headerlink" title="使用步骤"></a>使用步骤</h3><ul>
<li>配置开启JPA，提供EntityBeanFactory，提供repositories的配置包路径</li>
<li>定义Entity。不用自己写，使用IEAD的插件可以做到</li>
<li>定义Repository，提供灵活的定义方式<ul>
<li>定义查询方法，根据方法名来生成SQL的。这个叫做NamedQuery</li>
<li>自定义查询SQL，使用Query注解</li>
</ul>
</li>
<li>在需要使用的地方注入Repository</li>
</ul>
<h3 id="特色功能"><a href="#特色功能" class="headerlink" title="特色功能"></a>特色功能</h3><ul>
<li><p>Repository的查询方法有点意思，相当于直接吧SQL写成了查询方法</p>
</li>
<li><p>支持Querydsl，一种Java语言的SQL DSL，怎么说呢，如果代码过长，写起来还是不大方便吧</p>
</li>
<li><p>支持将Repository中查询方法的返回类型指定为非Entity的类，比如我们DTO</p>
</li>
<li><p>支持存储过程</p>
</li>
<li><p>如果为IDEA添加了JPA支持，在写Repository时会有提示呢，看起来还挺高级的</p>
<p>  <img src="https://gdz.oss-cn-shenzhen.aliyuncs.com/halo/%E6%88%AA%E5%B1%8F2021-09-28%20%E4%B8%8B%E5%8D%884.34.31_1632818107252.png" alt="截屏20210928 下午4.34.31.png"></p>
</li>
</ul>
<h3 id="web支持"><a href="#web支持" class="headerlink" title="web支持"></a>web支持</h3><ul>
<li>通过添加EnableSpringDataWebSupport注解，能够提供支持<ul>
<li>定义的Entity能够被web解析和编码到消息体中</li>
<li>能够正常解析Sort、Pageable等参数</li>
<li>能够解析Point、Distance等类，根据具体使用的Spring Data模块而言。如使用Spring Data Redis，可能就有Distance</li>
<li>甚至能够直接把url中的查询参数转换为Querydsl的Predicte对象，即查询条件</li>
</ul>
</li>
</ul>
<h2 id="优缺点总结"><a href="#优缺点总结" class="headerlink" title="优缺点总结"></a>优缺点总结</h2><p>优点</p>
<ol>
<li>IDEA支持好</li>
<li>使用简单，只需要配置IDEA生成Entity，然后配置Repository即可</li>
<li>对于创建规范的表格，简单的查询需求，用起来非常不错</li>
<li>一般不让我们直接写裸SQL，而是类SQL，屏蔽了数据库差异。</li>
</ol>
<p>缺点</p>
<ol>
<li>查询效率优化比较麻烦，JPA的设计思想，就是不要让你去管SQL的事情，而是专注业务</li>
<li>但正是这样，有时候生成的SQL并不是我们想要的</li>
<li>SQL能力不如MyBatis强，比如动态SQL能力。举个例子，JPA中，要做in查询，in中的个数是动态，这样怎么办呢？</li>
</ol>
<h2 id="JPA对比MyBatis"><a href="#JPA对比MyBatis" class="headerlink" title="JPA对比MyBatis"></a>JPA对比MyBatis</h2><p>下面这个回答比较中肯。两句话概括</p>
<ul>
<li>JPA面向对象，让用户不要去管SQL的事情。使用友好，但SQL优化不大行。</li>
<li>MyBatis面向SQL，可以直接写SQL。但跨数据源能力不大行。</li>
</ul>
<p><a href="https://www.zhihu.com/question/348496459/answer/842120407">SpringData JPA也能写sql，为什么还要用mybatis?</a></p>
<p>如果公司自己做业务，看重性能和优化，用MyBatis比较好，而且现在MyBatis有MybatisPlus，也支持Active Record，一定程度上算是集合了JPA和MyBatis的优势。</p>
<p>但如果公司的卖代码的，跨数据库这一点就很重要，使用JPA就很有必要。</p>
<h2 id="个人认为"><a href="#个人认为" class="headerlink" title="个人认为"></a>个人认为</h2><p>我个人的看法，首先，在代码中写复杂SQL这件事，必须PASS，这在呼啦亲子中已经实践过了，是不大可行的。JOOQ的DSL能力尚且不行，那Querydsl的SQL能力肯定是更加不能接受的。</p>
<p>其次，如果使用PG，其中有很多非典型SQL的语法，肯定是要写裸SQL的。但是JPA写裸SQL的能力，肯定是不如MyBatis的。</p>
<p>我也很喜欢JPA，但如果在一个长期维护的项目中使用JPA，很可能出现开始时写得很开心，到后面项目中充斥着大量不符合JPA设计哲学的代码。</p>
<p>所以我会选择MyBatis。</p>
<p>但是。。。如果是自己的小项目，我还是愿意尝试一下JPA。</p>
]]></content>
      <categories>
        <category>后端</category>
        <category>Spring</category>
      </categories>
      <tags>
        <tag>Spring</tag>
        <tag>JPA</tag>
      </tags>
  </entry>
  <entry>
    <title>SpringBoot源码剖析 - 配置相关注解及自动配置</title>
    <url>/2021/12/11/SpringBoot%E8%87%AA%E5%8A%A8%E9%85%8D%E7%BD%AE/</url>
    <content><![CDATA[<blockquote>
<p>截止目前，我们已经写了四篇关于Spring源码解析的文章，但它们只关注了Spring和SpringBoot的启动流程，并没有回答我们日常使用中的核心问题——自动配置的实现原理，本文进行探索</p>
</blockquote>
<span id="more"></span>

<p>在前文“Spring源码剖析 - BeanDefinition”中扫描Bean定义一节中，我们漏掉了一个关键方法调用，其调用路径如下</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">-&gt;</span><span class="bash"> org.springframework.context.annotation.AnnotationConfigApplicationContext</span></span><br><span class="line"><span class="meta">   #</span><span class="bash">AnnotationConfigApplicationContext(java.lang.Class&lt;?&gt;...)</span></span><br><span class="line"><span class="meta">-&gt;</span><span class="bash"> org.springframework.context.annotation.AnnotationConfigApplicationContext</span></span><br><span class="line"><span class="meta">   #</span><span class="bash">AnnotationConfigApplicationContext()</span></span><br><span class="line"><span class="meta">-&gt;</span><span class="bash"> org.springframework.context.annotation.AnnotatedBeanDefinitionReader</span></span><br><span class="line"><span class="meta">   #</span><span class="bash">AnnotatedBeanDefinitionReader(org.springframework.beans.factory.support.BeanDefinitionRegistry)</span></span><br><span class="line"><span class="meta">-&gt;</span><span class="bash"> org.springframework.context.annotation.AnnotatedBeanDefinitionReader</span></span><br><span class="line"><span class="meta">   #</span><span class="bash">AnnotatedBeanDefinitionReader(org.springframework.beans.factory.support.BeanDefinitionRegistry, org.springframework.core.env.Environment)</span></span><br><span class="line"><span class="meta">-&gt;</span><span class="bash"> org.springframework.context.annotation.AnnotationConfigUtils</span></span><br><span class="line"><span class="meta">   #</span><span class="bash">registerAnnotationConfigProcessors(org.springframework.beans.factory.support.BeanDefinitionRegistry)</span></span><br><span class="line"><span class="meta">-&gt;</span><span class="bash"> org.springframework.context.annotation.AnnotationConfigUtils</span></span><br><span class="line"><span class="meta">   #</span><span class="bash">registerAnnotationConfigProcessors(org.springframework.beans.factory.support.BeanDefinitionRegistry, java.lang.Object)</span></span><br></pre></td></tr></table></figure>

<p>即，在<code>AnnotationConfigApplicationContext</code>执行构造方法时，调用<code>AnnotationConfigUtils.registerAnnotationConfigProcessors()</code>，注册了一系列注解处理器，具体来说，有</p>
<ul>
<li><p><code>ConfigurationClassPostProcessor</code></p>
<p>用于处理配置相关的各种注解</p>
</li>
<li><p><code>AutowiredAnnotationBeanPostProcessor</code></p>
<p>用于处理自动注入相关的注解，如<code>@Autowired</code>、<code>@Value</code>、<code>@Inject</code></p>
</li>
<li><p><code>CommonAnnotationBeanPostProcessor</code></p>
<p>用于处理一些通用注解，比如<code>@Lazy</code>、<code>@Primary</code>、<code>PreDestroy</code>等</p>
</li>
<li><p><code>PersistenceAnnotationBeanPostProcessor</code></p>
<p>用于处理JPA相关注解</p>
</li>
<li><p><code>EventListenerMethodProcessor</code></p>
<p>用于处理<code>@EventListener</code>，即把方法注册成监听器</p>
</li>
<li><p><code>DefaultEventListenerFactory</code></p>
<p>结合<code>EventListenerMethodProcessor</code>使用，该工厂输入方法，可创建出一个<code>ApplicationListener</code>类</p>
</li>
</ul>
<p>本文我们重点关注配置相关的注解</p>
<h2 id="概览"><a href="#概览" class="headerlink" title="概览"></a>概览</h2><p><img src="https://gdz.oss-cn-shenzhen.aliyuncs.com/local/image-20211210152720643.png" alt="image-20211210152720643"></p>
<p><code>ConfigurationClassPostProcessor</code>继承结构如上，属于容器构建阶段的处理器，我们再复习一下它的两个父接口的作用</p>
<ul>
<li><p><code>BeanFactoryPostProcessor</code>：在容器初始化之后，对容器做一些自定义操作。具体时机是：<code>BeanDefinition</code>加载完成之后，<code>Bean</code>实例化之前。</p>
</li>
<li><p><code>BeanDefinitionRegistryPostProcessor</code>：在容器初始化完成之后，<code>BeanFactoryPostProcessor</code>执行之前对容器做一些自定义操作。</p>
</li>
</ul>
<p>而<code>ConfigurationClassPostProcessor</code>在这两个时机分别做了两件事</p>
<ul>
<li><p>容器初始化完成后，<code>BeanFactoryPostProcessor</code>调用前，从<code>@Configuration</code>注解的类中加载Bean定义，然后向容器注册。</p>
<p>这一点是本文的重点 ，逻辑位于<code>org.springframework.context.annotation.ConfigurationClassPostProcessor#processConfigBeanDefinitions</code>，进一步的确切逻辑位于</p>
<ul>
<li><p>注解解析：<br> -&gt; <code>org.springframework.context.annotation.ConfigurationClassParser#parse(java.util.Set&lt;org.springframework.beans.factory.config.BeanDefinitionHolder&gt;)</code></p>
<p>-&gt; <code>org.springframework.context.annotation.ConfigurationClassParser#doProcessConfigurationClass</code></p>
</li>
<li><p><code>BeanDefinition</code>注册</p>
<p>-&gt; <code>org.springframework.context.annotation.ConfigurationClassBeanDefinitionReader#loadBeanDefinitions</code>。</p>
</li>
<li><p>其它逻辑无助于理解，一概忽略</p>
</li>
</ul>
</li>
<li><p>容器初始化完成后，对所有<code>@Configuration</code>注解标识的<code>BeanDefinition</code>进行增强</p>
<p>这一点不是重点，大概描述一下：使用的是CGLib的Enhancer API。添加了如下几个增强回调</p>
<ul>
<li><code>BeanMethodInterceptor</code>：拦截所有<code>@Bean</code>注解的方法</li>
<li><code>BeanFactoryAwareMethodInterceptor</code>：拦截所有实现了<code>BeanFactoryAware</code>的<code>@Configuration</code>类的<code>setBeanFactory()</code>方法，目的是将容器注入</li>
</ul>
</li>
</ul>
<h2 id="注解解析"><a href="#注解解析" class="headerlink" title="注解解析"></a>注解解析</h2><p>我们从<code>ConfigurationClassParser.doProcessConfigurationClass</code>的解析逻辑中，分析如下几个注解的工作原理。</p>
<h3 id="Conditional"><a href="#Conditional" class="headerlink" title="@Conditional"></a>@Conditional</h3><p>该注解用于条件配置，即满足条件时才生效，否则被忽略，它的实现由<code>ConditionEvaluator</code>完成。使用的地方包括</p>
<ul>
<li><code>ConfigurationClassParser.processConfigurationClass()</code>，对配置类有效。</li>
<li><code>ConfigurationClassBeanDefinitionReader#loadBeanDefinitionsForBeanMethod</code>，加载Bean时有效，即作用在<code>@Bean</code>注解的方法上</li>
</ul>
<p>逻辑落地在<code>ConditionEvaluator.shouldSkip()</code></p>
<ol>
<li>如果没有被<code>@Conditional</code>注解，则不应被跳过</li>
<li>获取<code>@Conditional</code>注解的属性值，即其指定的<code>Condition</code>类，可能有多个</li>
<li>依次调用这些<code>Condition</code>类的<code>matches()</code>方法，只要有一个匹配，则判定为应该被跳过，可见，多条件是与的关系</li>
</ol>
<p>SpringBoot还定义了<code>ConditionalOnClass</code>、<code>ConditionalOnMissingBean</code>之类的注解，其实看一眼他们的定义就知道。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Target(&#123; ElementType.TYPE, ElementType.METHOD &#125;)</span></span><br><span class="line"><span class="meta">@Retention(RetentionPolicy.RUNTIME)</span></span><br><span class="line"><span class="meta">@Documented</span></span><br><span class="line"><span class="meta">@Conditional(OnClassCondition.class)</span></span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> ConditionalOnClass &#123;</span><br><span class="line"></span><br><span class="line">	Class&lt;?&gt;[] value() <span class="keyword">default</span> &#123;&#125;;</span><br><span class="line"></span><br><span class="line">	String[] name() <span class="keyword">default</span> &#123;&#125;;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>比如上面这个注解，它是<code>@Conditional</code>注解加上<code>OnClassCondition</code>这个条件构成的。而在<code>OnClassCondition</code>的匹配方法的逻辑如下（有继承关系，<code>matches()</code>方法在父类，这里只给出核心逻辑）：类加载器能加载出来就匹配，否则就不匹配</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> ConditionOutcome <span class="title">getMatchOutcome</span><span class="params">(ConditionContext context, AnnotatedTypeMetadata metadata)</span> </span>&#123;</span><br><span class="line">  ClassLoader classLoader = context.getClassLoader();</span><br><span class="line">  ConditionMessage matchMessage = ConditionMessage.empty();</span><br><span class="line">  <span class="comment">// 获取ConditionalOnClass指定的那些类名</span></span><br><span class="line">  List&lt;String&gt; onClasses = getCandidates(metadata, ConditionalOnClass.class);</span><br><span class="line">  <span class="keyword">if</span> (onClasses != <span class="keyword">null</span>) &#123;</span><br><span class="line">    <span class="comment">// 用ClassLoader加载指定的类名，加载不出来则说明缺失</span></span><br><span class="line">    List&lt;String&gt; missing = filter(onClasses, ClassNameFilter.MISSING, classLoader);</span><br><span class="line">    <span class="comment">// 缺失就报不匹配</span></span><br><span class="line">    <span class="keyword">if</span> (!missing.isEmpty()) &#123;</span><br><span class="line">      <span class="keyword">return</span> ConditionOutcome.noMatch(ConditionMessage.forCondition(ConditionalOnClass.class)</span><br><span class="line">                                      .didNotFind(<span class="string">&quot;required class&quot;</span>, <span class="string">&quot;required classes&quot;</span>).items(Style.QUOTE, missing));</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 否则就是匹配</span></span><br><span class="line">  <span class="keyword">return</span> ConditionOutcome.match(matchMessage);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="PropertySource"><a href="#PropertySource" class="headerlink" title="@PropertySource"></a>@PropertySource</h3><p>该注解能够将指定的properties文件加载到容器的Environment中，<a href="https://www.baeldung.com/properties-with-spring">使用参考</a>。</p>
<p>通过源码解读可以看出它的逻辑</p>
<ul>
<li>读取<code>@PropertySource</code>的value值，作为配置文件的位置location</li>
<li>解析<code>location</code>中的占位符，这意味着location中可以存在动态字段</li>
<li>使用<code>resourceLoader</code>将location解析成<code>Resource</code>对象</li>
<li>使用<code>PropertySourceFactory</code>创建<code>PropertySource</code>对象，并加入<code>Environment</code></li>
</ul>
<p>这里有一个能够自定义的东西：属性源工厂，如果我们指定自己的属性源工厂，则能够按照自己的需求解析，因此我们能够自定义出解析yaml文件的逻辑。默认是<code>DefaultPropertySourceFactory</code>，它创建的是一个<code>ResourcePropertySource</code>。</p>
<p>我们大致看一下它的核心逻辑</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 解析注解的属性：name、encoding、value、ignoreResourceNotFound、factory</span></span><br><span class="line">String name = propertySource.getString(<span class="string">&quot;name&quot;</span>);</span><br><span class="line">... ...</span><br><span class="line">String encoding = propertySource.getString(<span class="string">&quot;encoding&quot;</span>);</span><br><span class="line">... ...</span><br><span class="line">String[] locations = propertySource.getStringArray(<span class="string">&quot;value&quot;</span>);</span><br><span class="line">... ...</span><br><span class="line"><span class="keyword">boolean</span> ignoreResourceNotFound = propertySource.getBoolean(<span class="string">&quot;ignoreResourceNotFound&quot;</span>);</span><br><span class="line">Class&lt;? extends PropertySourceFactory&gt; factoryClass = propertySource.getClass(<span class="string">&quot;factory&quot;</span>);</span><br><span class="line"><span class="comment">// 如果有指定factory，构建该工厂对象，否则，使用默认的工厂</span></span><br><span class="line">PropertySourceFactory factory = (factoryClass == PropertySourceFactory.class ? DEFAULT_PROPERTY_SOURCE_FACTORY : BeanUtils.instantiateClass(factoryClass));</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (String location : locations) &#123;</span><br><span class="line">  ... ...</span><br><span class="line">  <span class="comment">// 解析location中的占位符</span></span><br><span class="line">  String resolvedLocation = <span class="keyword">this</span>.environment.resolveRequiredPlaceholders(location);</span><br><span class="line">  <span class="comment">// 从文件系统中加载出来</span></span><br><span class="line">  Resource resource = <span class="keyword">this</span>.resourceLoader.getResource(resolvedLocation);</span><br><span class="line">  <span class="comment">// factory创建出属性源，加入environment</span></span><br><span class="line">  addPropertySource(factory.createPropertySource(name, <span class="keyword">new</span> EncodedResource(resource, encoding)));</span><br><span class="line">  ... ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="ComponentScan"><a href="#ComponentScan" class="headerlink" title="@ComponentScan"></a>@ComponentScan</h3><p>该注解用于扫描指定包、类所属的包下的Bean定义，其核心逻辑挂在<code>ComponentScanAnnotationParser.parse()</code>上，如下</p>
<ul>
<li><p>构建<code>ClassPathBeanDefinitionScanner</code>扫描器，用于执行Bean定义扫描</p>
</li>
<li><p>读取<code>@ComponentScan</code>的各类属性，写入扫描器，属性包括</p>
<ul>
<li><code>nameGenerator</code>：Bean名生成器</li>
<li><code>scopedProxy</code>：scopedProxy的方式：不代理、JDK代理、cglib代理，关于scopedProxy，可以<a href="https://stackoverflow.com/questions/14371335/spring-scoped-proxy-bean">参考这里</a>。大致来说，就是当scope范围更宽的bean1引用scope范围较小的bean2时，由于他们的作用范围不一致，导致bean1的生存时间大于bean2的生存时间，直接引用会发生问题，此时可以将bean2用一个代理包装起来，由代理负责引用实际的Bean，每当bean2的生命结束时，由代理自动创建新的实例，对bean1做到透明。</li>
<li><code>scopeResolver</code>：Scope解析器</li>
<li><code>resourcePattern</code>：扫描目标文件的通配符，如<code>*/**/class</code></li>
<li><code>includeFilters</code>：过滤器</li>
<li><code>excludeFilters</code>：过滤器</li>
<li><code>lazyInit</code>：延迟加载</li>
<li><code>basePackages</code>：基包</li>
<li><code>basePackageClasses</code>：基类</li>
</ul>
</li>
<li><p>调用扫描器的扫描方法，这个在前面介绍扫描BeanDefinition时有描述过，这里不再赘述。</p>
</li>
</ul>
<p>源码也简单，只要注意一点：如果没有指定基包或基类，就是用当前配置类所在的包作为扫描位置</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> Set&lt;BeanDefinitionHolder&gt; <span class="title">parse</span><span class="params">(AnnotationAttributes componentScan, <span class="keyword">final</span> String declaringClass)</span> </span>&#123;</span><br><span class="line">  ClassPathBeanDefinitionScanner scanner = <span class="keyword">new</span> ClassPathBeanDefinitionScanner(<span class="keyword">this</span>.registry, componentScan.getBoolean(<span class="string">&quot;useDefaultFilters&quot;</span>), <span class="keyword">this</span>.environment, <span class="keyword">this</span>.resourceLoader);</span><br><span class="line"></span><br><span class="line">  Class&lt;? extends BeanNameGenerator&gt; generatorClass = componentScan.getClass(<span class="string">&quot;nameGenerator&quot;</span>);</span><br><span class="line">  <span class="keyword">boolean</span> useInheritedGenerator = (BeanNameGenerator.class == generatorClass);</span><br><span class="line">  scanner.setBeanNameGenerator(useInheritedGenerator ? <span class="keyword">this</span>.beanNameGenerator : BeanUtils.instantiateClass(generatorClass));</span><br><span class="line"></span><br><span class="line">  ScopedProxyMode scopedProxyMode = componentScan.getEnum(<span class="string">&quot;scopedProxy&quot;</span>);</span><br><span class="line">  <span class="keyword">if</span> (scopedProxyMode != ScopedProxyMode.DEFAULT) &#123;</span><br><span class="line">    scanner.setScopedProxyMode(scopedProxyMode);</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    Class&lt;? extends ScopeMetadataResolver&gt; resolverClass = componentScan.getClass(<span class="string">&quot;scopeResolver&quot;</span>);</span><br><span class="line">    scanner.setScopeMetadataResolver(BeanUtils.instantiateClass(resolverClass));</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  scanner.setResourcePattern(componentScan.getString(<span class="string">&quot;resourcePattern&quot;</span>));</span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span> (AnnotationAttributes filter : componentScan.getAnnotationArray(<span class="string">&quot;includeFilters&quot;</span>)) &#123;</span><br><span class="line">    <span class="keyword">for</span> (TypeFilter typeFilter : typeFiltersFor(filter)) &#123;</span><br><span class="line">      scanner.addIncludeFilter(typeFilter);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">for</span> (AnnotationAttributes filter : componentScan.getAnnotationArray(<span class="string">&quot;excludeFilters&quot;</span>)) &#123;</span><br><span class="line">    <span class="keyword">for</span> (TypeFilter typeFilter : typeFiltersFor(filter)) &#123;</span><br><span class="line">      scanner.addExcludeFilter(typeFilter);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">boolean</span> lazyInit = componentScan.getBoolean(<span class="string">&quot;lazyInit&quot;</span>);</span><br><span class="line">  <span class="keyword">if</span> (lazyInit) &#123;</span><br><span class="line">    scanner.getBeanDefinitionDefaults().setLazyInit(<span class="keyword">true</span>);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  Set&lt;String&gt; basePackages = <span class="keyword">new</span> LinkedHashSet&lt;&gt;();</span><br><span class="line">  String[] basePackagesArray = componentScan.getStringArray(<span class="string">&quot;basePackages&quot;</span>);</span><br><span class="line">  <span class="keyword">for</span> (String pkg : basePackagesArray) &#123;</span><br><span class="line">    String[] tokenized = StringUtils.tokenizeToStringArray(<span class="keyword">this</span>.environment.resolvePlaceholders(pkg),</span><br><span class="line">                                                           ConfigurableApplicationContext.CONFIG_LOCATION_DELIMITERS);</span><br><span class="line">    Collections.addAll(basePackages, tokenized);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">for</span> (Class&lt;?&gt; clazz : componentScan.getClassArray(<span class="string">&quot;basePackageClasses&quot;</span>)) &#123;</span><br><span class="line">    basePackages.add(ClassUtils.getPackageName(clazz));</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 如果没有指定基包或基类，就是用当前配置类所在的包作为扫描位置</span></span><br><span class="line">  <span class="keyword">if</span> (basePackages.isEmpty()) &#123;</span><br><span class="line">    basePackages.add(ClassUtils.getPackageName(declaringClass));</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  scanner.addExcludeFilter(<span class="keyword">new</span> AbstractTypeHierarchyTraversingFilter(<span class="keyword">false</span>, <span class="keyword">false</span>) &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">boolean</span> <span class="title">matchClassName</span><span class="params">(String className)</span> </span>&#123;</span><br><span class="line">      <span class="keyword">return</span> declaringClass.equals(className);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;);</span><br><span class="line">  <span class="keyword">return</span> scanner.doScan(StringUtils.toStringArray(basePackages));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="Import"><a href="#Import" class="headerlink" title="@Import"></a>@Import</h3><p>该配置用于导入其它配置，定义如下</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Target(ElementType.TYPE)</span></span><br><span class="line"><span class="meta">@Retention(RetentionPolicy.RUNTIME)</span></span><br><span class="line"><span class="meta">@Documented</span></span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> Import &#123;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">	 * &#123;<span class="doctag">@link</span> Configuration <span class="doctag">@Configuration</span>&#125;, &#123;<span class="doctag">@link</span> ImportSelector&#125;,</span></span><br><span class="line"><span class="comment">	 * &#123;<span class="doctag">@link</span> ImportBeanDefinitionRegistrar&#125;, or regular component classes to import.</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">  Class&lt;?&gt;[] value();</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如注释所言，支持导入的对象有四种</p>
<ul>
<li><p>被<code>@Configuration</code>注解的类，即一个普通的配置类，这是最常用的。对它的处理方式就是，再当做配置类执行一遍<code>processConfigurationClass()</code>方法逻辑</p>
</li>
<li><p><code>ImportSelector</code>，顾名思义，导入选择器，这是一个接口，定义了要导入的资源，导入的资源依旧是这四类，但最终会是普通的注解类。</p>
<p>对于该类对象的处理方式，是找出其选择的导入对象，递归执行导入逻辑</p>
</li>
<li><p><code>ImportBeanDefinitionRegistrar</code>，顾名思义，用于导入<code>BeanDefinition</code>注册器，其逻辑是向<code>ConfigurationClassBeanDefinitionReader</code>中注入该注册器，后面在加载<code>BeanDefinition</code>时会用到它。</p>
</li>
</ul>
<h4 id="导入选择器"><a href="#导入选择器" class="headerlink" title="导入选择器"></a>导入选择器</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (candidate.isAssignable(ImportSelector.class)) &#123;</span><br><span class="line">  <span class="comment">// Candidate class is an ImportSelector -&gt; delegate to it to determine imports</span></span><br><span class="line">  Class&lt;?&gt; candidateClass = candidate.loadClass();</span><br><span class="line">  <span class="comment">// 初始化选择器</span></span><br><span class="line">  ImportSelector selector = ParserStrategyUtils.instantiateClass(candidateClass, ImportSelector.class,</span><br><span class="line">                                                                 <span class="keyword">this</span>.environment, <span class="keyword">this</span>.resourceLoader, <span class="keyword">this</span>.registry);</span><br><span class="line">  <span class="comment">// 排除过滤器</span></span><br><span class="line">  Predicate&lt;String&gt; selectorFilter = selector.getExclusionFilter();</span><br><span class="line">  ... ...</span><br><span class="line">  <span class="comment">// 调用选择器的关键方法selectImports，实际上就是一个类名数组</span></span><br><span class="line">  String[] importClassNames = selector.selectImports(currentSourceClass.getMetadata());</span><br><span class="line">  <span class="comment">// 类名封装一下</span></span><br><span class="line">  Collection&lt;SourceClass&gt; importSourceClasses = asSourceClasses(importClassNames, exclusionFilter);</span><br><span class="line">  <span class="comment">// 递归执行processImports()</span></span><br><span class="line">  processImports(configClass, currentSourceClass, importSourceClasses, exclusionFilter, <span class="keyword">false</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>所以如果导入对象是<code>ImportSelector</code>，它所做的工作其实只有选择待导入的配置对象。</p>
<h4 id="导入BeanDefinition集合"><a href="#导入BeanDefinition集合" class="headerlink" title="导入BeanDefinition集合"></a>导入BeanDefinition集合</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (candidate.isAssignable(ImportBeanDefinitionRegistrar.class)) &#123;</span><br><span class="line">  <span class="comment">// Candidate class is an ImportBeanDefinitionRegistrar -&gt;</span></span><br><span class="line">  <span class="comment">// delegate to it to register additional bean definitions</span></span><br><span class="line">  Class&lt;?&gt; candidateClass = candidate.loadClass();</span><br><span class="line">  <span class="comment">// 构建对象</span></span><br><span class="line">  ImportBeanDefinitionRegistrar registrar = </span><br><span class="line">    ParserStrategyUtils.instantiateClass(candidateClass, ImportBeanDefinitionRegistrar.class,</span><br><span class="line">                                         <span class="keyword">this</span>.environment, <span class="keyword">this</span>.resourceLoader, <span class="keyword">this</span>.registry);</span><br><span class="line">  <span class="comment">// 将其当做属性加入配置类</span></span><br><span class="line">  configClass.addImportBeanDefinitionRegistrar(registrar, currentSourceClass.getMetadata());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在读取Bean定期时是有调用的，在<code>ConfigurationClassBeanDefinitionReader</code>中可以看到，它的调用在概览中有描述，在下一节也会描述</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 在类ConfigurationClassBeanDefinitionReader中</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">loadBeanDefinitionsForConfigurationClass</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">  ... ...</span></span></span><br><span class="line"><span class="params"><span class="function">  loadBeanDefinitionsFromImportedResources(configClass.getImportedResources()</span>)</span>;</span><br><span class="line">  loadBeanDefinitionsFromRegistrars(configClass.getImportBeanDefinitionRegistrars());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="导入普通配置"><a href="#导入普通配置" class="headerlink" title="导入普通配置"></a>导入普通配置</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line">  <span class="comment">// 递归调用processConfigurationClass()，很好理解</span></span><br><span class="line">  processConfigurationClass(candidate.asConfigClass(configClass), exclusionFilter);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h4><p>总的来说，<code>@Import</code>原理上其实非常简单，最终目的是导入其它配置类或<code>BeanDefinition</code>集合。</p>
<h3 id="ImportResource"><a href="#ImportResource" class="headerlink" title="@ImportResource"></a>@ImportResource</h3><p>该注解用于指定导入源，Spring会将这些源当做配置源进行读取，他们可以是xml、groovy，这是根据资源文件的后缀自动决定的。接口定义如下</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Retention(RetentionPolicy.RUNTIME)</span></span><br><span class="line"><span class="meta">@Target(ElementType.TYPE)</span></span><br><span class="line"><span class="meta">@Documented</span></span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> ImportResource &#123;</span><br><span class="line"></span><br><span class="line">	<span class="meta">@AliasFor(&quot;locations&quot;)</span></span><br><span class="line">	String[] value() <span class="keyword">default</span> &#123;&#125;;</span><br><span class="line"></span><br><span class="line">	<span class="meta">@AliasFor(&quot;value&quot;)</span></span><br><span class="line">	String[] locations() <span class="keyword">default</span> &#123;&#125;;</span><br><span class="line"></span><br><span class="line">	Class&lt;? extends BeanDefinitionReader&gt; reader() <span class="keyword">default</span> BeanDefinitionReader.class;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在注解扫描阶段，对它只是进行了读取</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">AnnotationAttributes importResource = AnnotationConfigUtils.attributesFor(sourceClass.getMetadata(), ImportResource.class);</span><br><span class="line"><span class="keyword">if</span> (importResource != <span class="keyword">null</span>) &#123;</span><br><span class="line">  <span class="comment">// 获取位置信息</span></span><br><span class="line">  String[] resources = importResource.getStringArray(<span class="string">&quot;locations&quot;</span>);</span><br><span class="line">  <span class="comment">// 获取读取器</span></span><br><span class="line">  Class&lt;? extends BeanDefinitionReader&gt; readerClass = importResource.getClass(<span class="string">&quot;reader&quot;</span>);</span><br><span class="line">  <span class="keyword">for</span> (String resource : resources) &#123;</span><br><span class="line">    <span class="comment">// 解析位置信息中的占位符</span></span><br><span class="line">    String resolvedResource = <span class="keyword">this</span>.environment.resolveRequiredPlaceholders(resource);</span><br><span class="line">    <span class="comment">// 注册到configClass</span></span><br><span class="line">    configClass.addImportedResource(resolvedResource, readerClass);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>什么时候执行呢？和前面说的<code>BeanDefinition</code>集合一样，都是在加载阶段，后文详述。</p>
<h3 id="Bean"><a href="#Bean" class="headerlink" title="@Bean"></a>@Bean</h3><p>该注解用在方法上，将方法的返回值构建成一个新的Bean定义，解析阶段只是向configClass注册了待加载的方法，解析阶段后文详述。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 从类中加载出所有被Bean注解的方法</span></span><br><span class="line">Set&lt;MethodMetadata&gt; beanMethods = retrieveBeanMethodMetadata(sourceClass);</span><br><span class="line"><span class="keyword">for</span> (MethodMetadata methodMetadata : beanMethods) &#123;</span><br><span class="line">  <span class="comment">// 把它们加入configClass</span></span><br><span class="line">  configClass.addBeanMethod(<span class="keyword">new</span> BeanMethod(methodMetadata, configClass));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>此外，如果配置类实现的接口的方法有被<code>@Bean</code>注解，且该配置类实现了该方法，则该方法也会被加载为Bean。</p>
<h2 id="BeanDefinition注册"><a href="#BeanDefinition注册" class="headerlink" title="BeanDefinition注册"></a>BeanDefinition注册</h2><p>我们从<code>ConfigurationClassBeanDefinitionReader.loadBeanDefinitions</code>大致看一下加载过程中做了什么事情。</p>
<p>核心逻辑位于：<code>org.springframework.context.annotation.ConfigurationClassBeanDefinitionReader#loadBeanDefinitionsForConfigurationClass</code></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">loadBeanDefinitionsForConfigurationClass</span><span class="params">(ConfigurationClass configClass, TrackedConditionEvaluator trackedConditionEvaluator)</span> </span>&#123;</span><br><span class="line">	... ...</span><br><span class="line">  <span class="keyword">if</span> (configClass.isImported()) &#123;</span><br><span class="line">    registerBeanDefinitionForImportedConfigurationClass(configClass);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">for</span> (BeanMethod beanMethod : configClass.getBeanMethods()) &#123;</span><br><span class="line">    loadBeanDefinitionsForBeanMethod(beanMethod);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  loadBeanDefinitionsFromImportedResources(configClass.getImportedResources());</span><br><span class="line">  loadBeanDefinitionsFromRegistrars(configClass.getImportBeanDefinitionRegistrars());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>如果配置类是被导入的，则先将该配置类注册成为一个Bean定义</li>
<li>将所有被<code>@Bean</code>注解的方法构建成Bean定义</li>
<li>从<code>@ImportResource</code>指定的资源中加载Bean定义</li>
<li>从<code>@Import</code>导入的<code>BeanDefinitionRegistrar</code>中导入Bean定义</li>
</ul>
<h3 id="注册配置类本身"><a href="#注册配置类本身" class="headerlink" title="注册配置类本身"></a>注册配置类本身</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">registerBeanDefinitionForImportedConfigurationClass</span><span class="params">(ConfigurationClass configClass)</span> </span>&#123;</span><br><span class="line">  AnnotationMetadata metadata = configClass.getMetadata();</span><br><span class="line">  AnnotatedGenericBeanDefinition configBeanDef = <span class="keyword">new</span> AnnotatedGenericBeanDefinition(metadata);</span><br><span class="line">	<span class="comment">// 解析scope</span></span><br><span class="line">  ScopeMetadata scopeMetadata = scopeMetadataResolver.resolveScopeMetadata(configBeanDef);</span><br><span class="line">  configBeanDef.setScope(scopeMetadata.getScopeName());</span><br><span class="line">  <span class="comment">// 解析beanName</span></span><br><span class="line">  String configBeanName = <span class="keyword">this</span>.importBeanNameGenerator.generateBeanName(configBeanDef, <span class="keyword">this</span>.registry);</span><br><span class="line">  <span class="comment">// 处理通用注解</span></span><br><span class="line">  AnnotationConfigUtils.processCommonDefinitionAnnotations(configBeanDef, metadata);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 搞定收工</span></span><br><span class="line">  BeanDefinitionHolder definitionHolder = <span class="keyword">new</span> BeanDefinitionHolder(configBeanDef, configBeanName);</span><br><span class="line">  definitionHolder = AnnotationConfigUtils.applyScopedProxyMode(scopeMetadata, definitionHolder, <span class="keyword">this</span>.registry);</span><br><span class="line">  <span class="keyword">this</span>.registry.registerBeanDefinition(definitionHolder.getBeanName(), definitionHolder.getBeanDefinition());</span><br><span class="line">  configClass.setBeanName(configBeanName);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如上，比较简单，不过这里有个值得说的点：处理通用注解<code>AnnotationConfigUtils.processCommonDefinitionAnnotations()</code>，它主要用于处理如下注解</p>
<ul>
<li><code>Lazy</code></li>
<li><code>Primary</code></li>
<li><code>DependsOn</code></li>
<li><code>Role</code></li>
<li><code>Description</code></li>
</ul>
<p>都不需要怎么解释，看一下代码就能了解</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">processCommonDefinitionAnnotations</span><span class="params">(AnnotatedBeanDefinition abd, AnnotatedTypeMetadata metadata)</span> </span>&#123;</span><br><span class="line">  AnnotationAttributes lazy = attributesFor(metadata, Lazy.class);</span><br><span class="line">  <span class="keyword">if</span> (lazy != <span class="keyword">null</span>) &#123;</span><br><span class="line">    abd.setLazyInit(lazy.getBoolean(<span class="string">&quot;value&quot;</span>));</span><br><span class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span> (abd.getMetadata() != metadata) &#123;</span><br><span class="line">    lazy = attributesFor(abd.getMetadata(), Lazy.class);</span><br><span class="line">    <span class="keyword">if</span> (lazy != <span class="keyword">null</span>) &#123;</span><br><span class="line">      abd.setLazyInit(lazy.getBoolean(<span class="string">&quot;value&quot;</span>));</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (metadata.isAnnotated(Primary.class.getName())) &#123;</span><br><span class="line">    abd.setPrimary(<span class="keyword">true</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  AnnotationAttributes dependsOn = attributesFor(metadata, DependsOn.class);</span><br><span class="line">  <span class="keyword">if</span> (dependsOn != <span class="keyword">null</span>) &#123;</span><br><span class="line">    abd.setDependsOn(dependsOn.getStringArray(<span class="string">&quot;value&quot;</span>));</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  AnnotationAttributes role = attributesFor(metadata, Role.class);</span><br><span class="line">  <span class="keyword">if</span> (role != <span class="keyword">null</span>) &#123;</span><br><span class="line">    abd.setRole(role.getNumber(<span class="string">&quot;value&quot;</span>).intValue());</span><br><span class="line">  &#125;</span><br><span class="line">  AnnotationAttributes description = attributesFor(metadata, Description.class);</span><br><span class="line">  <span class="keyword">if</span> (description != <span class="keyword">null</span>) &#123;</span><br><span class="line">    abd.setDescription(description.getString(<span class="string">&quot;value&quot;</span>));</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="Bean-1"><a href="#Bean-1" class="headerlink" title="@Bean"></a>@Bean</h3><p>关于Bean方法的处理，看起来一长串，其实就两个关键的逻辑</p>
<ul>
<li>使用<code>ConfigurationClassBeanDefinition</code>作为Bean定义，它将被注解的方法注册成了Bean定义的工厂方法。这样在Bean创建时走的完全是正常的创建流程</li>
<li>以代理的方式创建，代理模式为CGLIB</li>
</ul>
<p>具体参考<code>ConfigurationClassBeanDefinitionReader#loadBeanDefinitionsForBeanMethod</code>，这里也没必要列出来源码。</p>
<h3 id="ImportResource-1"><a href="#ImportResource-1" class="headerlink" title="@ImportResource"></a>@ImportResource</h3><p>创建指定的<code>BeanDefinitionReader</code>实例，然后读取指定的location即可。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">loadBeanDefinitionsFromImportedResources</span><span class="params">(Map&lt;String, Class&lt;? extends BeanDefinitionReader&gt;&gt; importedResources)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  Map&lt;Class&lt;?&gt;, BeanDefinitionReader&gt; readerInstanceCache = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line"></span><br><span class="line">  importedResources.forEach((resource, readerClass) -&gt; &#123;</span><br><span class="line">    <span class="comment">// 决定要使用的BeanDefinitionReader</span></span><br><span class="line">    <span class="comment">// Default reader selection necessary?</span></span><br><span class="line">    <span class="keyword">if</span> (BeanDefinitionReader.class == readerClass) &#123;</span><br><span class="line">      <span class="keyword">if</span> (StringUtils.endsWithIgnoreCase(resource, <span class="string">&quot;.groovy&quot;</span>)) &#123;</span><br><span class="line">        <span class="comment">// When clearly asking for Groovy, that&#x27;s what they&#x27;ll get...</span></span><br><span class="line">        readerClass = GroovyBeanDefinitionReader.class;</span><br><span class="line">      &#125; <span class="keyword">else</span> <span class="keyword">if</span> (shouldIgnoreXml) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> UnsupportedOperationException(<span class="string">&quot;XML support disabled&quot;</span>);</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// Primarily &quot;.xml&quot; files but for any other extension as well</span></span><br><span class="line">        readerClass = XmlBeanDefinitionReader.class;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    BeanDefinitionReader reader = readerInstanceCache.get(readerClass);</span><br><span class="line">    <span class="comment">// 创建Reader</span></span><br><span class="line">    <span class="keyword">if</span> (reader == <span class="keyword">null</span>) &#123;</span><br><span class="line">      <span class="comment">// Instantiate the specified BeanDefinitionReader</span></span><br><span class="line">      reader = readerClass.getConstructor(BeanDefinitionRegistry.class).newInstance(<span class="keyword">this</span>.registry);</span><br><span class="line">      <span class="comment">// Delegate the current ResourceLoader to it if possible</span></span><br><span class="line">      <span class="keyword">if</span> (reader <span class="keyword">instanceof</span> AbstractBeanDefinitionReader) &#123;</span><br><span class="line">        AbstractBeanDefinitionReader abdr = ((AbstractBeanDefinitionReader) reader);</span><br><span class="line">        abdr.setResourceLoader(<span class="keyword">this</span>.resourceLoader);</span><br><span class="line">        abdr.setEnvironment(<span class="keyword">this</span>.environment);</span><br><span class="line">      &#125;</span><br><span class="line">      readerInstanceCache.put(readerClass, reader);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// reader读，走你</span></span><br><span class="line">    reader.loadBeanDefinitions(resource);</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="BeanDefinitionRegistrar"><a href="#BeanDefinitionRegistrar" class="headerlink" title="BeanDefinitionRegistrar"></a>BeanDefinitionRegistrar</h3><p>更简单，在第一篇Spring源码剖析的文章中我们提到过<code>Registry</code>和<code>Registrar</code>的区别，前者是注册器，用于接收资源的注册并持有；而后者只是一个资源集合，持有一堆资源，一般调用方式是传入<code>Registry</code>，向其中倾泻自己持有的资源。</p>
<p>这里的<code>BeanDefinitionRegistrar</code>就是如此，持有一堆<code>BeanDefinition</code>集合，在本阶段向注册器中注册</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">loadBeanDefinitionsFromRegistrars</span><span class="params">(Map&lt;ImportBeanDefinitionRegistrar, AnnotationMetadata&gt; registrars)</span> </span>&#123;</span><br><span class="line">  registrars.forEach((registrar, metadata) -&gt;</span><br><span class="line">                     registrar.registerBeanDefinitions(metadata, <span class="keyword">this</span>.registry, <span class="keyword">this</span>.importBeanNameGenerator));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="自动配置怎么实现"><a href="#自动配置怎么实现" class="headerlink" title="自动配置怎么实现"></a>自动配置怎么实现</h2><p>上一篇介绍SpringBoot启动流程的文章中，我们知道了<code>SpringApplication</code>在快速启动中做了什么，这其中，最最重要的是通过<code>META/spring.factories</code>加载指定类的实现的机制，即<code>SpringFactoriesLoader.loadFactory()</code>方法。但上一篇文章并没有介绍自动配置的原理，因为还缺少<code>@Import</code>注解的说明。</p>
<p>本文我们补上了这一点，于是可以探索<code>@SpringBootApplication</code>这一SpringBoot的另一核心的原理，其定义如下</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Target(ElementType.TYPE)</span></span><br><span class="line"><span class="meta">@Retention(RetentionPolicy.RUNTIME)</span></span><br><span class="line"><span class="meta">@Documented</span></span><br><span class="line"><span class="meta">@Inherited</span></span><br><span class="line"><span class="meta">@SpringBootConfiguration</span></span><br><span class="line"><span class="meta">@EnableAutoConfiguration</span></span><br><span class="line"><span class="meta">@ComponentScan(excludeFilters = &#123; @Filter(type = FilterType.CUSTOM, classes = TypeExcludeFilter.class),</span></span><br><span class="line"><span class="meta">		@Filter(type = FilterType.CUSTOM, classes = AutoConfigurationExcludeFilter.class) &#125;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> SpringBootApplication &#123;</span><br><span class="line">  ... ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>层层深入，可以发现它最终落在三个注解上</p>
<ul>
<li><code>@Configuration</code>：表明这是一个配置类</li>
<li><code>@Import(AutoConfigurationImportSelector.class)</code> + <code>@Import(AutoConfigurationPackages.Registrar.class)</code>：导入配置</li>
<li><code>@ComponentScan</code>：表明从当前类的包的子包下扫描</li>
</ul>
<p>进一步，重点落在<code>AutoConfigurationImportSelector</code>和<code>AutoConfigurationPackages.Registrar</code>上，重点看前者，后者与自动配置无关，暂且忽略。</p>
<h3 id="AutoConfigurationImportSelector"><a href="#AutoConfigurationImportSelector" class="headerlink" title="AutoConfigurationImportSelector"></a>AutoConfigurationImportSelector</h3><p>该选择器，调用了<code>SpringFactoriesLoader.loadFactory()</code>，从spring.factories文件中加载键为<code>org.springframework.boot.autoconfigure.EnableAutoConfiguration</code>所对应的值，核心逻辑追踪如下</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">-&gt;</span><span class="bash"> org.springframework.boot.autoconfigure.AutoConfigurationImportSelector<span class="comment">#selectImports</span></span></span><br><span class="line"><span class="meta">-&gt;</span><span class="bash"> org.springframework.boot.autoconfigure.AutoConfigurationImportSelector<span class="comment">#getAutoConfigurationEntry</span></span></span><br><span class="line"><span class="meta">-&gt;</span><span class="bash"> org.springframework.boot.autoconfigure.AutoConfigurationImportSelector<span class="comment">#getCandidateConfigurations</span></span></span><br><span class="line"><span class="meta">-&gt;</span><span class="bash"> org.springframework.boot.autoconfigure.AutoConfigurationImportSelector<span class="comment">#getSpringFactoriesLoaderFactoryClass</span></span></span><br></pre></td></tr></table></figure>

<p>再看最后这个方法的实现，显而易见了</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">protected</span> Class&lt;?&gt; getSpringFactoriesLoaderFactoryClass() &#123;</span><br><span class="line">  <span class="keyword">return</span> EnableAutoConfiguration.class;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="看看自动配置"><a href="#看看自动配置" class="headerlink" title="看看自动配置"></a>看看自动配置</h3><p>官方的<code>spring-boot-autoconfigure</code>下的<code>META-INF/spring.factories</code>中，定义了非常多的自动配置类</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"># Auto Configure</span><br><span class="line">org.springframework.boot.autoconfigure.EnableAutoConfiguration=\</span><br><span class="line">org.springframework.boot.autoconfigure.admin.SpringApplicationAdminJmxAutoConfiguration,\</span><br><span class="line">org.springframework.boot.autoconfigure.aop.AopAutoConfiguration,\</span><br><span class="line">org.springframework.boot.autoconfigure.amqp.RabbitAutoConfiguration,\</span><br><span class="line">org.springframework.boot.autoconfigure.batch.BatchAutoConfiguration,\</span><br><span class="line">org.springframework.boot.autoconfigure.cache.CacheAutoConfiguration,\</span><br><span class="line">org.springframework.boot.autoconfigure.cassandra.CassandraAutoConfiguration,\</span><br><span class="line">... ...</span><br></pre></td></tr></table></figure>

<p>我们选取一个比较熟的<code>org.springframework.boot.autoconfigure.websocket.servlet.WebSocketServletAutoConfiguration</code>，浏览一下其代码。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Configuration(proxyBeanMethods = false)</span></span><br><span class="line"><span class="meta">@ConditionalOnClass(&#123; Servlet.class, ServerContainer.class &#125;)</span></span><br><span class="line"><span class="meta">@ConditionalOnWebApplication(type = Type.SERVLET)</span></span><br><span class="line"><span class="meta">@AutoConfigureBefore(ServletWebServerFactoryAutoConfiguration.class)</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">WebSocketServletAutoConfiguration</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="meta">@Configuration(proxyBeanMethods = false)</span></span><br><span class="line">	<span class="meta">@ConditionalOnClass(&#123; Tomcat.class, WsSci.class &#125;)</span></span><br><span class="line">	<span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">TomcatWebSocketConfiguration</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">		<span class="meta">@Bean</span></span><br><span class="line">		<span class="meta">@ConditionalOnMissingBean(name = &quot;websocketServletWebServerCustomizer&quot;)</span></span><br><span class="line">		<span class="function">TomcatWebSocketServletWebServerCustomizer <span class="title">websocketServletWebServerCustomizer</span><span class="params">()</span> </span>&#123;</span><br><span class="line">			<span class="keyword">return</span> <span class="keyword">new</span> TomcatWebSocketServletWebServerCustomizer();</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="meta">@Configuration(proxyBeanMethods = false)</span></span><br><span class="line">	<span class="meta">@ConditionalOnClass(WebSocketServerContainerInitializer.class)</span></span><br><span class="line">	<span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">JettyWebSocketConfiguration</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">		<span class="meta">@Bean</span></span><br><span class="line">		<span class="meta">@ConditionalOnMissingBean(name = &quot;websocketServletWebServerCustomizer&quot;)</span></span><br><span class="line">		<span class="function">JettyWebSocketServletWebServerCustomizer <span class="title">websocketServletWebServerCustomizer</span><span class="params">()</span> </span>&#123;</span><br><span class="line">			<span class="keyword">return</span> <span class="keyword">new</span> JettyWebSocketServletWebServerCustomizer();</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="meta">@Configuration(proxyBeanMethods = false)</span></span><br><span class="line">	<span class="meta">@ConditionalOnClass(io.undertow.websockets.jsr.Bootstrap.class)</span></span><br><span class="line">	<span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">UndertowWebSocketConfiguration</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">		<span class="meta">@Bean</span></span><br><span class="line">		<span class="meta">@ConditionalOnMissingBean(name = &quot;websocketServletWebServerCustomizer&quot;)</span></span><br><span class="line">		<span class="function">UndertowWebSocketServletWebServerCustomizer <span class="title">websocketServletWebServerCustomizer</span><span class="params">()</span> </span>&#123;</span><br><span class="line">			<span class="keyword">return</span> <span class="keyword">new</span> UndertowWebSocketServletWebServerCustomizer();</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>通过<code>spring.factories</code>机制和<code>@Import + ImportSelector</code>的形式，SpringBoot为实现自动注解提供了最基础的能力，但根据各个具体不同的场景，Spring还在上面提到的基本注解之上构建了非常多具体的注解，比如条件注解就好多。一个个看是不现实的，但我们了解了本文提到的基础知识，再去看就很好理解了。</p>
]]></content>
      <categories>
        <category>Spring</category>
      </categories>
      <tags>
        <tag>Spring</tag>
      </tags>
  </entry>
  <entry>
    <title>Spring源码剖析 - SpringBoot启动流程</title>
    <url>/2021/12/07/SpringBoot/</url>
    <content><![CDATA[<blockquote>
<p>在Spring源码剖析的前三篇文章，我们介绍了ApplicationContext、Bean相关内容、BeanPostProcessor的内容；但从普遍反馈和自己事后阅读的体验来看，文章过长，没有重点，条理并不是特别清楚。想必是写作方式出了问题，最突出的莫过于流水账式写法，虽然写作的目的并不一定是写出好的文章，而是主要服务自己，但时间一长，自己也是个普通的读者，同样会看不大懂。</p>
<p>因此，写作方法是需要变更了：要突出条理和重点，如需大段源码讲解，可在文章最后增加源码解析一节，读者可选读。也就是说，长度还是那么长，但可读性增强了很多。</p>
</blockquote>
<span id="more"></span>

<p>本文我们关注SpringBoot启动时做了什么，这是理解自动注解的基础，下一篇文章我们将探索自动注解的实现方式。</p>
<p>一个最简单的SpringBoot应用，可以是这样</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="meta">@SpringBootApplication</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyApplication</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">(args: <span class="type">Array</span>&lt;<span class="type">String</span>&gt;)</span></span> &#123;</span><br><span class="line">    SpringApplication(MyApplication::<span class="keyword">class</span>.java).run(*args)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>那么重点落在<code>SpringApplication</code>类和其run方法上。</p>
<h2 id="SpringApplication"><a href="#SpringApplication" class="headerlink" title="SpringApplication"></a>SpringApplication</h2><p>SpringApplication是一个大类，包含了所有应用启动流程。包含的主要步骤如下</p>
<ul>
<li>创建<code>ApplicationContext</code></li>
<li>注册<code>CommandLinePropertySource</code>到<code>Environment</code>，用于将命令行参数暴露成容器中的属性值</li>
<li>刷新容器，即调用容器的<code>refresh()</code>方法</li>
<li>创建<code>CommandLineRunner</code>并调用其<code>run()</code>方法</li>
</ul>
<h3 id="关键点"><a href="#关键点" class="headerlink" title="关键点"></a>关键点</h3><ul>
<li><p>SpringApplication能够启动三种类型的应用</p>
<ul>
<li>普通的Servlet应用</li>
<li>响应式的Reactive应用</li>
<li>普通的非Web应用</li>
</ul>
<p>不同的应用，会创建对应的ApplciationContext实现类，在ApplicationContext源码分析那一节有所描述</p>
</li>
<li><p>SpringApplication引入了一个新的临时容器，<code>Bootstrapper</code>、<code>BootstrapRegistry</code>，用于在创建出<code>ApplicationContext</code>实例之前管理启动阶段的Bean</p>
</li>
<li><p>SpringApplication提供<code>ApplicationContextInitializer</code>接口，用于在<code>ApplicationContext</code>刷新前修改它，这为我们提供了一个自定义<code>ApplicationContext</code>的扩展点。</p>
<p>向SpringApplication注册它的方式有两个</p>
<ul>
<li>调用<code>SpringApplication.addInitializers()</code>方法手动注册，手写代码时候可用</li>
<li>放在<code>META-INF/spring.factories</code>中，自定义starter时可用</li>
</ul>
</li>
<li><p>SpringApplication的核心 —— <code>META-INF/spring.factories</code>，启动时，会从所有jar包的该文件中搜寻指定factory类型的实现，SpringBoot的诸多特性，比如自动配置，都是依赖于该机制实现。加载该文件有专门的类——<code>SpringFactoriesLoader</code>。在SpringApplication中，加载的类有四种</p>
<ul>
<li><code>Bootstrapper</code>：SpringBoot启动阶段用</li>
<li><code>ApplicationContextInitializer</code>：Spring上下文初始化器</li>
<li><code>SpringApplicationRunListener</code>：SpringApplication启动时候的监听器</li>
<li><code>ApplicationListener</code>：Spring事件监听器</li>
</ul>
<p>这其中最重要的当属<code>ApplicationContextInitializer</code>，考虑到其能力，SpringBoot的诸多功能应该都是由其子类实现。</p>
<p>如果我们要查看哪些初始化器生效了，可以去对应jar包的spring.factories下查看。比如要看自动配置，去spring-boot-autoconfigure包下的spring.factories文件下查看（我们将在下一篇文章研究这个）</p>
</li>
</ul>
<h3 id="SpringApplication提供的自定义点"><a href="#SpringApplication提供的自定义点" class="headerlink" title="SpringApplication提供的自定义点"></a>SpringApplication提供的自定义点</h3><p>SpringApplication启动时也支持高级写法，可自定义更多内容，再<code>run</code>，比如</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">(args: <span class="type">Array</span>&lt;<span class="type">String</span>&gt;)</span></span> &#123;</span><br><span class="line">  <span class="comment">// 先创建SpringApplication实例，再设置该实例，自定义一些内容</span></span><br><span class="line">  springApplicationContext = SpringApplication(MylogApplication::<span class="keyword">class</span>.java).run &#123;</span><br><span class="line">    addInitializers(MylogApplication())</span><br><span class="line">    run(*args)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这是除了spring.factories外，Spring为我们提供了的额外定义方法，主要可自定义如下内容：</p>
<ul>
<li>主类</li>
<li><code>WebApplicationType</code></li>
<li>是否允许Bean覆盖</li>
<li>Bean是否延迟加载</li>
<li>Banner的模式：不显示、显示在控制台、显示在日志中</li>
<li>命令行参数否写入Spring环境</li>
<li>是否将<code>ApplicationConversionService</code>添加到<code>ApplicationContext</code>的转换服务中</li>
<li>添加<code>Bootstrapper</code></li>
<li>添加<code>BootstrapRegistryInitializer</code></li>
<li>设置默认属性，会被添加到环境变量中</li>
<li>设置额外的profile</li>
<li>设置<code>BeanNameGenerator</code></li>
<li>设置<code>ConfigurableEnvironment</code></li>
<li>添加其它需要被添加到容器的资源，主要是指Configuration的资源</li>
<li>设置<code>ResourceLoader</code></li>
<li>设置环境变量前缀，当从系统中获取环境变量时，将会应用该前缀</li>
<li>设置<code>ConfigurableApplicationContext</code>，相当于手动指定容器的类型了</li>
<li>设置<code>ApplicationContextFactory</code></li>
<li>设置<code>ApplicationContextInitializer</code>，即添加自定义的初始化器</li>
<li>添加<code>ApplicationListener</code>，即事件监听器</li>
<li>设置<code>ApplicationStartup</code>，该类并没有什么用，仅日志输出用</li>
</ul>
<h3 id="还缺啥"><a href="#还缺啥" class="headerlink" title="还缺啥"></a>还缺啥</h3><p>如上，加上后面的源码分析，我们只看到了<code>SpringApplication</code>的启动流程，貌似并没有看到关键之所在</p>
<ul>
<li><code>application.properties</code>配置文件的加载原理</li>
<li>自动配置加载的原理</li>
</ul>
<p>这些其实在<code>spring-boot.jar</code>和<code>spring-boot-autoconfigure.jar</code>中的<code>META-INF/spring.factories</code>有指定，出于篇幅，我们下篇文章再讨论。</p>
<h2 id="源码分析"><a href="#源码分析" class="headerlink" title="源码分析"></a>源码分析</h2><p>这次源码分析我们单独放在一边</p>
<h3 id="构造方法"><a href="#构造方法" class="headerlink" title="构造方法"></a>构造方法</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">SpringApplication</span><span class="params">(Class&lt;?&gt;... primarySources)</span> </span>&#123;</span><br><span class="line">  <span class="comment">// 传入的类叫做主要源，这也说明了它的重要性</span></span><br><span class="line">  <span class="keyword">this</span>(<span class="keyword">null</span>, primarySources);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">SpringApplication</span><span class="params">(ResourceLoader resourceLoader, Class&lt;?&gt;... primarySources)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">this</span>.resourceLoader = resourceLoader;</span><br><span class="line">  Assert.notNull(primarySources, <span class="string">&quot;PrimarySources must not be null&quot;</span>);</span><br><span class="line">  <span class="keyword">this</span>.primarySources = <span class="keyword">new</span> LinkedHashSet&lt;&gt;(Arrays.asList(primarySources));</span><br><span class="line">  <span class="comment">// 检测应用类型”响应式、Servlet、普通应用</span></span><br><span class="line">  <span class="keyword">this</span>.webApplicationType = WebApplicationType.deduceFromClasspath();</span><br><span class="line">  <span class="comment">// 设置启动器</span></span><br><span class="line">  <span class="keyword">this</span>.bootstrappers = <span class="keyword">new</span> ArrayList&lt;&gt;(getSpringFactoriesInstances(Bootstrapper.class));</span><br><span class="line">  <span class="comment">// 设置初始化器</span></span><br><span class="line">  setInitializers((Collection) getSpringFactoriesInstances(ApplicationContextInitializer.class));</span><br><span class="line">  <span class="comment">// 设置监听器</span></span><br><span class="line">  setListeners((Collection) getSpringFactoriesInstances(ApplicationListener.class));</span><br><span class="line">  <span class="comment">// 检测主类</span></span><br><span class="line">  <span class="keyword">this</span>.mainApplicationClass = deduceMainApplicationClass();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="新出现的类"><a href="#新出现的类" class="headerlink" title="新出现的类"></a>新出现的类</h4><ul>
<li><p><code>WebApplicationType</code>：一个枚举，包含三个值：<code>SERVLET</code>、<code>REACTIVE</code>、<code>NONE</code>。用于决定应用是否需要启动特定类型的web服务器</p>
</li>
<li><p><code>Bootstrapper</code>：用于初始化<code>BootstrapRegistry</code></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Bootstrapper</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">   <span class="comment">/**</span></span><br><span class="line"><span class="comment">    * Initialize the given &#123;<span class="doctag">@link</span> BootstrapRegistry&#125; with any required registrations.</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@param</span> registry the registry to initialize</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">   <span class="function"><span class="keyword">void</span> <span class="title">intitialize</span><span class="params">(BootstrapRegistry registry)</span></span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p><code>BootstrapRegistry</code>：启动注册器，在服务启动阶段到<code>ApplicationContext</code>准备好这段时间有效；作用有两个：创建创建过程比较复杂的Bean、创建需要在<code>ApplicationContext</code>准备好之前共享的Bean。可以理解为预加载容器，即<code>SpringBoot</code>启动阶段使用的容器。</p>
</li>
<li><p><code>ApplicationContextInitializer</code>：用于初始化<code>ApplicationContext</code>，调用时机在<code>AbstractApplicationContext.refresh()</code>之前。</p>
<p>也就是说，在SpringBoot中，可以添加自己的<code>ApplicationContextInitializer</code>在容器初始化时修改内容。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">ApplicationContextInitializer</span>&lt;<span class="title">C</span> <span class="keyword">extends</span> <span class="title">ConfigurableApplicationContext</span>&gt; </span>&#123;</span><br><span class="line"></span><br><span class="line">   <span class="comment">/**</span></span><br><span class="line"><span class="comment">    * Initialize the given application context.</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@param</span> applicationContext the application to configure</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">   <span class="function"><span class="keyword">void</span> <span class="title">initialize</span><span class="params">(C applicationContext)</span></span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<h4 id="获取工厂对象-getSpringFactoriesInstances"><a href="#获取工厂对象-getSpringFactoriesInstances" class="headerlink" title="获取工厂对象 - getSpringFactoriesInstances"></a>获取工厂对象 - getSpringFactoriesInstances</h4><p>听这个方法，像是抽象工厂模式，但总体看下来不大像，如果我们只是把它们当成一种插件机制，会更加方便理解。</p>
<p><code>getSpringFactoriesInstances()</code>是贯穿SpringBoot启动的静态方法，用于加载指定类型的实例，来源是所有包下的<code>META-INF/spring.factories</code>文件中指定的类型。其作用就是获取指定类型的所有实现类的实例。</p>
<p>我们首先温习一下<code>spring.factories</code>文件长啥样</p>
<figure class="highlight properties"><table><tr><td class="code"><pre><span class="line"><span class="meta">org.springframework.boot.env.EnvironmentPostProcessor</span>=<span class="string">\</span></span><br><span class="line"><span class="string">  com.baomidou.mybatisplus.autoconfigure.SafetyEncryptProcessor</span></span><br><span class="line"><span class="meta">org.springframework.boot.autoconfigure.EnableAutoConfiguration</span>=<span class="string">\</span></span><br><span class="line"><span class="string">  com.baomidou.mybatisplus.autoconfigure.MybatisPlusLanguageDriverAutoConfiguration,\</span></span><br><span class="line"><span class="string">  com.baomidou.mybatisplus.autoconfigure.MybatisPlusAutoConfiguration</span></span><br></pre></td></tr></table></figure>

<p>然后再来看这个方法</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> &lt;T&gt; <span class="function">Collection&lt;T&gt; <span class="title">getSpringFactoriesInstances</span><span class="params">(Class&lt;T&gt; type, Class&lt;?&gt;[] parameterTypes, Object... args)</span> </span>&#123;</span><br><span class="line">  ClassLoader classLoader = getClassLoader();</span><br><span class="line">  <span class="comment">// 获取指定类型的完整类名</span></span><br><span class="line">  Set&lt;String&gt; names = <span class="keyword">new</span> LinkedHashSet&lt;&gt;(SpringFactoriesLoader.loadFactoryNames(type, classLoader));</span><br><span class="line">  <span class="comment">// 创建它们</span></span><br><span class="line">  List&lt;T&gt; instances = createSpringFactoriesInstances(type, parameterTypes, classLoader, args, names);</span><br><span class="line">  <span class="comment">// 按照@Order注解排序</span></span><br><span class="line">  AnnotationAwareOrderComparator.sort(instances);</span><br><span class="line">  <span class="keyword">return</span> instances;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 直接调用了反射创建实例</span></span><br><span class="line"><span class="keyword">private</span> &lt;T&gt; <span class="function">List&lt;T&gt; <span class="title">createSpringFactoriesInstances</span><span class="params">(Class&lt;T&gt; type, Class&lt;?&gt;[] parameterTypes, ClassLoader classLoader, Object[] args, Set&lt;String&gt; names)</span> </span>&#123;</span><br><span class="line">  List&lt;T&gt; instances = <span class="keyword">new</span> ArrayList&lt;&gt;(names.size());</span><br><span class="line">  <span class="keyword">for</span> (String name : names) &#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">      Class&lt;?&gt; instanceClass = ClassUtils.forName(name, classLoader);</span><br><span class="line">      Assert.isAssignable(type, instanceClass);</span><br><span class="line">      Constructor&lt;?&gt; constructor = instanceClass.getDeclaredConstructor(parameterTypes);</span><br><span class="line">      T instance = (T) BeanUtils.instantiateClass(constructor, args);</span><br><span class="line">      instances.add(instance);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Throwable ex) &#123;</span><br><span class="line">      <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">&quot;Cannot instantiate &quot;</span> + type + <span class="string">&quot; : &quot;</span> + name, ex);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> instances;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>理解上面那段代码的重点，又落在了<code>SpringFactoriesLoader.loadFactoryNames(type, classLoader)</code>上。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 注意这个spring.factories的位置</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> String FACTORIES_RESOURCE_LOCATION = <span class="string">&quot;META-INF/spring.factories&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> &lt;T&gt; <span class="function">List&lt;T&gt; <span class="title">loadFactories</span><span class="params">(Class&lt;T&gt; factoryType, <span class="meta">@Nullable</span> ClassLoader classLoader)</span> </span>&#123;</span><br><span class="line">  Assert.notNull(factoryType, <span class="string">&quot;&#x27;factoryType&#x27; must not be null&quot;</span>);</span><br><span class="line">  ClassLoader classLoaderToUse = classLoader;</span><br><span class="line">  <span class="keyword">if</span> (classLoaderToUse == <span class="keyword">null</span>) &#123;</span><br><span class="line">    classLoaderToUse = SpringFactoriesLoader.class.getClassLoader();</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 关键方法，根据指定的工厂类型，获取其实现类们的名字</span></span><br><span class="line">  List&lt;String&gt; factoryImplementationNames = loadFactoryNames(factoryType, classLoaderToUse);</span><br><span class="line">  <span class="keyword">if</span> (logger.isTraceEnabled()) &#123;</span><br><span class="line">    logger.trace(<span class="string">&quot;Loaded [&quot;</span> + factoryType.getName() + <span class="string">&quot;] names: &quot;</span> + factoryImplementationNames);</span><br><span class="line">  &#125;</span><br><span class="line">  List&lt;T&gt; result = <span class="keyword">new</span> ArrayList&lt;&gt;(factoryImplementationNames.size());</span><br><span class="line">  <span class="keyword">for</span> (String factoryImplementationName : factoryImplementationNames) &#123;</span><br><span class="line">    <span class="comment">// 反射实例化这些工厂实现类</span></span><br><span class="line">    result.add(instantiateFactory(factoryImplementationName, factoryType, classLoaderToUse));</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 按照Order和Priority注解排序</span></span><br><span class="line">  AnnotationAwareOrderComparator.sort(result);</span><br><span class="line">  <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Load the fully qualified class names of factory implementations of the</span></span><br><span class="line"><span class="comment"> * given type from &#123;<span class="doctag">@value</span> #FACTORIES_RESOURCE_LOCATION&#125;, using the given</span></span><br><span class="line"><span class="comment"> * class loader.</span></span><br><span class="line"><span class="comment"> * &lt;p&gt;As of Spring Framework 5.3, if a particular implementation class name</span></span><br><span class="line"><span class="comment"> * is discovered more than once for the given factory type, duplicates will</span></span><br><span class="line"><span class="comment"> * be ignored.</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> factoryType the interface or abstract class representing the factory</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> classLoader the ClassLoader to use for loading resources; can be</span></span><br><span class="line"><span class="comment"> * &#123;<span class="doctag">@code</span> null&#125; to use the default</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@throws</span> IllegalArgumentException if an error occurs while loading factory names</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@see</span> #loadFactories</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> List&lt;String&gt; <span class="title">loadFactoryNames</span><span class="params">(Class&lt;?&gt; factoryType, <span class="meta">@Nullable</span> ClassLoader classLoader)</span> </span>&#123;</span><br><span class="line">  ClassLoader classLoaderToUse = classLoader;</span><br><span class="line">  <span class="keyword">if</span> (classLoaderToUse == <span class="keyword">null</span>) &#123;</span><br><span class="line">    classLoaderToUse = SpringFactoriesLoader.class.getClassLoader();</span><br><span class="line">  &#125;</span><br><span class="line">  String factoryTypeName = factoryType.getName();</span><br><span class="line">  <span class="keyword">return</span> loadSpringFactories(classLoaderToUse).getOrDefault(factoryTypeName, Collections.emptyList());</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> Map&lt;String, List&lt;String&gt;&gt; loadSpringFactories(ClassLoader classLoader) &#123;</span><br><span class="line">  Map&lt;String, List&lt;String&gt;&gt; result = cache.get(classLoader);</span><br><span class="line">  <span class="keyword">if</span> (result != <span class="keyword">null</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  result = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">  <span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="comment">// 获取所有包下的 META-INF/spring.factories 文件</span></span><br><span class="line">    Enumeration&lt;URL&gt; urls = classLoader.getResources(FACTORIES_RESOURCE_LOCATION);</span><br><span class="line">    <span class="keyword">while</span> (urls.hasMoreElements()) &#123;</span><br><span class="line">      URL url = urls.nextElement();</span><br><span class="line">      UrlResource resource = <span class="keyword">new</span> UrlResource(url);</span><br><span class="line">      <span class="comment">// 将spring.factories文件的内容加载成属性</span></span><br><span class="line">      Properties properties = PropertiesLoaderUtils.loadProperties(resource);</span><br><span class="line">      <span class="keyword">for</span> (Map.Entry&lt;?, ?&gt; entry : properties.entrySet()) &#123;</span><br><span class="line">        String factoryTypeName = ((String) entry.getKey()).trim();</span><br><span class="line">        <span class="comment">// 值按逗号拆分</span></span><br><span class="line">        String[] factoryImplementationNames = StringUtils.commaDelimitedListToStringArray((String) entry.getValue());</span><br><span class="line">        <span class="comment">// 组装成key-list的形式</span></span><br><span class="line">        <span class="keyword">for</span> (String factoryImplementationName : factoryImplementationNames) &#123;</span><br><span class="line">          result.computeIfAbsent(factoryTypeName, key -&gt; <span class="keyword">new</span> ArrayList&lt;&gt;())</span><br><span class="line">            .add(factoryImplementationName.trim());</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Replace all lists with unmodifiable lists containing unique elements</span></span><br><span class="line">    result.replaceAll((factoryType, implementations) -&gt; implementations.stream().distinct()</span><br><span class="line">                      .collect(Collectors.collectingAndThen(Collectors.toList(), Collections::unmodifiableList)));</span><br><span class="line">    cache.put(classLoader, result);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">catch</span> (IOException ex) &#123;</span><br><span class="line">    ... ...</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> &lt;T&gt; <span class="function">T <span class="title">instantiateFactory</span><span class="params">(String factoryImplementationName, Class&lt;T&gt; factoryType, ClassLoader classLoader)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">try</span> &#123;</span><br><span class="line">    Class&lt;?&gt; factoryImplementationClass = ClassUtils.forName(factoryImplementationName, classLoader);</span><br><span class="line">    <span class="comment">// 反射实例化</span></span><br><span class="line">    <span class="keyword">return</span> (T) ReflectionUtils.accessibleConstructor(factoryImplementationClass).newInstance();</span><br><span class="line">  &#125; <span class="keyword">catch</span> (Throwable ex) &#123;</span><br><span class="line">    ... ...</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="检测WebApplicationType"><a href="#检测WebApplicationType" class="headerlink" title="检测WebApplicationType"></a>检测WebApplicationType</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String[] SERVLET_INDICATOR_CLASSES = &#123; <span class="string">&quot;javax.servlet.Servlet&quot;</span>, <span class="string">&quot;org.springframework.web.context.ConfigurableWebApplicationContext&quot;</span> &#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String WEBMVC_INDICATOR_CLASS = <span class="string">&quot;org.springframework.web.servlet.DispatcherServlet&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String WEBFLUX_INDICATOR_CLASS = <span class="string">&quot;org.springframework.web.reactive.DispatcherHandler&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String JERSEY_INDICATOR_CLASS = <span class="string">&quot;org.glassfish.jersey.servlet.ServletContainer&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 要么是响应式应用、要么是Servlet应用、要么是普通应用</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> WebApplicationType <span class="title">deduceFromClasspath</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (ClassUtils.isPresent(WEBFLUX_INDICATOR_CLASS, <span class="keyword">null</span>) &amp;&amp; !ClassUtils.isPresent(WEBMVC_INDICATOR_CLASS, <span class="keyword">null</span>) &amp;&amp; !ClassUtils.isPresent(JERSEY_INDICATOR_CLASS, <span class="keyword">null</span>)) &#123;</span><br><span class="line">    <span class="keyword">return</span> WebApplicationType.REACTIVE;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">for</span> (String className : SERVLET_INDICATOR_CLASSES) &#123;</span><br><span class="line">    <span class="keyword">if</span> (!ClassUtils.isPresent(className, <span class="keyword">null</span>)) &#123;</span><br><span class="line">      <span class="keyword">return</span> WebApplicationType.NONE;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> WebApplicationType.SERVLET;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>检测逻辑</p>
<ul>
<li>类路径中只有<code>org.springframework.web.reactive.DispatcherHandler</code>时，是响应式应用</li>
<li>类路径中同时存在<code>javax.servlet.Servlet</code>、<code>org.springframework.web.context.ConfigurableWebApplicationContext</code>时，是Servlet应用</li>
<li>否则，是普通应用</li>
</ul>
<blockquote>
<p>WebApplicationType有什么用</p>
<ul>
<li>创建environment时决定创建什么类型的Environment：<code>private ConfigurableEnvironment getOrCreateEnvironment()</code></li>
<li>创建ApplicationContext时指定具体类型</li>
</ul>
</blockquote>
<h4 id="检测主类"><a href="#检测主类" class="headerlink" title="检测主类"></a>检测主类</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> Class&lt;?&gt; deduceMainApplicationClass() &#123;</span><br><span class="line">  <span class="keyword">try</span> &#123;</span><br><span class="line">    StackTraceElement[] stackTrace = <span class="keyword">new</span> RuntimeException().getStackTrace();</span><br><span class="line">    <span class="keyword">for</span> (StackTraceElement stackTraceElement : stackTrace) &#123;</span><br><span class="line">      <span class="keyword">if</span> (<span class="string">&quot;main&quot;</span>.equals(stackTraceElement.getMethodName())) &#123;</span><br><span class="line">        <span class="keyword">return</span> Class.forName(stackTraceElement.getClassName());</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125; <span class="keyword">catch</span> (ClassNotFoundException ex) &#123;</span><br><span class="line">    <span class="comment">// Swallow and continue</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>检测逻辑：从当前调用栈中，寻找main方法那一层，其所属类就是主类</p>
<h3 id="run方法"><a href="#run方法" class="headerlink" title="run方法"></a>run方法</h3><p>这是应用启动的主要逻辑之所在</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> ConfigurableApplicationContext <span class="title">run</span><span class="params">(String... args)</span> </span>&#123;</span><br><span class="line">  <span class="comment">// 秒表，仅作为启动时间记录用</span></span><br><span class="line">  StopWatch stopWatch = <span class="keyword">new</span> StopWatch();</span><br><span class="line">  stopWatch.start();</span><br><span class="line">  <span class="comment">// 创建默认的BootstrapContext，前面说了它是启动阶段的临时容器</span></span><br><span class="line">  DefaultBootstrapContext bootstrapContext = createBootstrapContext();</span><br><span class="line">  ConfigurableApplicationContext context = <span class="keyword">null</span>;</span><br><span class="line">  <span class="comment">// SpringApplicationRunListener，专为SpringApplication启动的各个阶段准备的监听器</span></span><br><span class="line">  <span class="comment">// 其实只有一个实现类EventPublishingRunListener，用于创建启动中的事件并广播出去</span></span><br><span class="line">  SpringApplicationRunListeners listeners = getRunListeners(args);</span><br><span class="line">  listeners.starting(bootstrapContext, <span class="keyword">this</span>.mainApplicationClass);</span><br><span class="line">  <span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="comment">// 命令行参数封装起来</span></span><br><span class="line">    ApplicationArguments applicationArguments = <span class="keyword">new</span> DefaultApplicationArguments(args);</span><br><span class="line">    <span class="comment">// 准备环境</span></span><br><span class="line">    ConfigurableEnvironment environment = prepareEnvironment(listeners, bootstrapContext, applicationArguments);</span><br><span class="line">    <span class="comment">// 打印banner</span></span><br><span class="line">    Banner printedBanner = printBanner(environment);</span><br><span class="line">    <span class="comment">// 创建容器</span></span><br><span class="line">    context = createApplicationContext();</span><br><span class="line">    context.setApplicationStartup(<span class="keyword">this</span>.applicationStartup);</span><br><span class="line">    <span class="comment">// 准备容器</span></span><br><span class="line">    prepareContext(bootstrapContext, context, environment, listeners, applicationArguments, printedBanner);</span><br><span class="line">    <span class="comment">// 刷新容器</span></span><br><span class="line">    refreshContext(context);</span><br><span class="line">    <span class="comment">// 刷新容器的善后处理：默认为空</span></span><br><span class="line">    afterRefresh(context, applicationArguments);</span><br><span class="line">    stopWatch.stop();</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">this</span>.logStartupInfo) &#123;</span><br><span class="line">      <span class="keyword">new</span> StartupInfoLogger(<span class="keyword">this</span>.mainApplicationClass).logStarted(getApplicationLog(), stopWatch);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 广播已开始事件</span></span><br><span class="line">    listeners.started(context);</span><br><span class="line">    callRunners(context, applicationArguments);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">catch</span> (Throwable ex) &#123;</span><br><span class="line">    handleRunFailure(context, ex, listeners);</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(ex);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="comment">// 广播运行中事件</span></span><br><span class="line">    listeners.running(context);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">catch</span> (Throwable ex) &#123;</span><br><span class="line">    handleRunFailure(context, ex, <span class="keyword">null</span>);</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(ex);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> context;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="获取SpringApplicationRunListener"><a href="#获取SpringApplicationRunListener" class="headerlink" title="获取SpringApplicationRunListener"></a>获取SpringApplicationRunListener</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> SpringApplicationRunListeners <span class="title">getRunListeners</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">  Class&lt;?&gt;[] types = <span class="keyword">new</span> Class&lt;?&gt;[] &#123; SpringApplication.class, String[].class &#125;;</span><br><span class="line">  <span class="comment">// 从sprin.factories中获取SpringApplicationRunListener子类</span></span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> SpringApplicationRunListeners(logger,getSpringFactoriesInstances(SpringApplicationRunListener.class, types, <span class="keyword">this</span>, args), <span class="keyword">this</span>.applicationStartup);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="准备环境"><a href="#准备环境" class="headerlink" title="准备环境"></a>准备环境</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> ConfigurableEnvironment <span class="title">prepareEnvironment</span><span class="params">(SpringApplicationRunListeners listeners, DefaultBootstrapContext bootstrapContext, ApplicationArguments applicationArguments)</span> </span>&#123;</span><br><span class="line">  <span class="comment">// 创建environment对象</span></span><br><span class="line">  ConfigurableEnvironment environment = getOrCreateEnvironment();</span><br><span class="line">  <span class="comment">// 配置环境对象：添加conversionService和命令行参数</span></span><br><span class="line">  configureEnvironment(environment, applicationArguments.getSourceArgs());</span><br><span class="line">  <span class="comment">// 向环境中添加属性源：ConfigurationPropertySource</span></span><br><span class="line">  ConfigurationPropertySources.attach(environment);</span><br><span class="line">  <span class="comment">// 广播环境准备好的消息</span></span><br><span class="line">  listeners.environmentPrepared(bootstrapContext, environment);</span><br><span class="line">  <span class="comment">// 将默认属性移到属性源的最末尾，属性源的顺序很重要</span></span><br><span class="line">  DefaultPropertiesPropertySource.moveToEnd(environment);</span><br><span class="line">  <span class="comment">// 将类中的profile加入environment的activeProfiles中，使得该profile生效</span></span><br><span class="line">  configureAdditionalProfiles(environment);</span><br><span class="line">  ... ...</span><br><span class="line">  <span class="keyword">return</span> environment;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 不同的应用类型，需要创建不同的环境对象，前面分析ApplicationContext时说过不同环境对象的区别</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> ConfigurableEnvironment <span class="title">getOrCreateEnvironment</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (<span class="keyword">this</span>.environment != <span class="keyword">null</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>.environment;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">switch</span> (<span class="keyword">this</span>.webApplicationType) &#123;</span><br><span class="line">    <span class="keyword">case</span> SERVLET:</span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">new</span> StandardServletEnvironment();</span><br><span class="line">    <span class="keyword">case</span> REACTIVE:</span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">new</span> StandardReactiveWebEnvironment();</span><br><span class="line">    <span class="keyword">default</span>:</span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">new</span> StandardEnvironment();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">configureEnvironment</span><span class="params">(ConfigurableEnvironment environment, String[] args)</span> </span>&#123;</span><br><span class="line">  <span class="comment">// 处理ConversionService，前面分析ApplicationContext时说过该对象的作用，用于类型转换</span></span><br><span class="line">  <span class="keyword">if</span> (<span class="keyword">this</span>.addConversionService) &#123;</span><br><span class="line">    ConversionService conversionService = ApplicationConversionService.getSharedInstance();</span><br><span class="line">    environment.setConversionService((ConfigurableConversionService) conversionService);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 配置属性源：将命令行参数加入属性源</span></span><br><span class="line">  configurePropertySources(environment, args);</span><br><span class="line">  <span class="comment">// 没用</span></span><br><span class="line">  configureProfiles(environment, args);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="创建ApplicationContext"><a href="#创建ApplicationContext" class="headerlink" title="创建ApplicationContext"></a>创建ApplicationContext</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> ConfigurableApplicationContext <span class="title">createApplicationContext</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">this</span>.applicationContextFactory.create(<span class="keyword">this</span>.webApplicationType);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 不言自明</span></span><br><span class="line">ApplicationContextFactory DEFAULT = (webApplicationType) -&gt; &#123;</span><br><span class="line">  <span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="keyword">switch</span> (webApplicationType) &#123;</span><br><span class="line">      <span class="keyword">case</span> SERVLET:</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> AnnotationConfigServletWebServerApplicationContext();</span><br><span class="line">      <span class="keyword">case</span> REACTIVE:</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> AnnotationConfigReactiveWebServerApplicationContext();</span><br><span class="line">      <span class="keyword">default</span>:</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> AnnotationConfigApplicationContext();</span><br><span class="line">    &#125;</span><br><span class="line">  &#125; <span class="keyword">catch</span> (Exception ex) &#123;</span><br><span class="line">    ... ...</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h4 id="准备容器"><a href="#准备容器" class="headerlink" title="准备容器"></a>准备容器</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">prepareContext</span><span class="params">(DefaultBootstrapContext bootstrapContext, ConfigurableApplicationContext context,</span></span></span><br><span class="line"><span class="params"><span class="function">                            ConfigurableEnvironment environment, SpringApplicationRunListeners listeners,</span></span></span><br><span class="line"><span class="params"><span class="function">                            ApplicationArguments applicationArguments, Banner printedBanner)</span> </span>&#123;</span><br><span class="line">  <span class="comment">// 注入environment</span></span><br><span class="line">  context.setEnvironment(environment);</span><br><span class="line">  <span class="comment">// 注入resourceLoader、classLoader、beanNameGenerator、conversionService</span></span><br><span class="line">  postProcessApplicationContext(context);</span><br><span class="line">  <span class="comment">// 应用所有在构造方法中和set注入的ApplicationContextInitializer</span></span><br><span class="line">  applyInitializers(context);</span><br><span class="line">  <span class="comment">// 广播事件</span></span><br><span class="line">  listeners.contextPrepared(context);</span><br><span class="line">  <span class="comment">// 临时容器工作完成，关闭</span></span><br><span class="line">  bootstrapContext.close(context);</span><br><span class="line">  <span class="comment">// 下面添加一些与SpringBoot相关的一些Bean</span></span><br><span class="line">  ConfigurableListableBeanFactory beanFactory = context.getBeanFactory();</span><br><span class="line">  beanFactory.registerSingleton(<span class="string">&quot;springApplicationArguments&quot;</span>, applicationArguments);</span><br><span class="line">  <span class="keyword">if</span> (printedBanner != <span class="keyword">null</span>) &#123;</span><br><span class="line">    beanFactory.registerSingleton(<span class="string">&quot;springBootBanner&quot;</span>, printedBanner);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> (beanFactory <span class="keyword">instanceof</span> DefaultListableBeanFactory) &#123;</span><br><span class="line">    ((DefaultListableBeanFactory) beanFactory).setAllowBeanDefinitionOverriding(<span class="keyword">this</span>.allowBeanDefinitionOverriding);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> (<span class="keyword">this</span>.lazyInitialization) &#123;</span><br><span class="line">    context.addBeanFactoryPostProcessor(<span class="keyword">new</span> LazyInitializationBeanFactoryPostProcessor());</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 获取加载源，即配置类所在源</span></span><br><span class="line">  Set&lt;Object&gt; sources = getAllSources();</span><br><span class="line">  Assert.notEmpty(sources, <span class="string">&quot;Sources must not be empty&quot;</span>);</span><br><span class="line">  <span class="comment">// 从源加载Bean定义到容器中</span></span><br><span class="line">  load(context, sources.toArray(<span class="keyword">new</span> Object[<span class="number">0</span>]));</span><br><span class="line">  <span class="comment">// 广播事件：Bean定义加载完成</span></span><br><span class="line">  listeners.contextLoaded(context);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="其它-注解排序"><a href="#其它-注解排序" class="headerlink" title="其它 - 注解排序"></a>其它 - 注解排序</h3><p>为组件排序的方法，我们发现哪儿都有它，这里关照一下：<code>AnnotationAwareOrderComparator.sort()</code>。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AnnotationAwareOrderComparator</span> <span class="keyword">extends</span> <span class="title">OrderComparator</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> AnnotationAwareOrderComparator INSTANCE = <span class="keyword">new</span> AnnotationAwareOrderComparator();</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">sort</span><span class="params">(List&lt;?&gt; list)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (list.size() &gt; <span class="number">1</span>) &#123;</span><br><span class="line">      <span class="comment">// 将当前单例当做比较器传入</span></span><br><span class="line">      list.sort(INSTANCE);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 这个在OrderComparator会调用到</span></span><br><span class="line">  <span class="function"><span class="keyword">protected</span> Integer <span class="title">findOrder</span><span class="params">(Object obj)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 调用父类的方法获取order：实现Ordered接口就给出值</span></span><br><span class="line">    Integer order = <span class="keyword">super</span>.findOrder(obj);</span><br><span class="line">    <span class="keyword">if</span> (order != <span class="keyword">null</span>) &#123;</span><br><span class="line">      <span class="keyword">return</span> order;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 否则从注解中找</span></span><br><span class="line">    <span class="keyword">return</span> findOrderFromAnnotation(obj);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Nullable</span></span><br><span class="line">  <span class="function"><span class="keyword">private</span> Integer <span class="title">findOrderFromAnnotation</span><span class="params">(Object obj)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 从@Order注解中取得排序值</span></span><br><span class="line">    AnnotatedElement element = (obj <span class="keyword">instanceof</span> AnnotatedElement ? (AnnotatedElement) obj : obj.getClass());</span><br><span class="line">    MergedAnnotations annotations = MergedAnnotations.from(element, SearchStrategy.TYPE_HIERARCHY);</span><br><span class="line">    Integer order = OrderUtils.getOrderFromAnnotations(element, annotations);</span><br><span class="line">    <span class="keyword">if</span> (order == <span class="keyword">null</span> &amp;&amp; obj <span class="keyword">instanceof</span> DecoratingProxy) &#123;</span><br><span class="line">      <span class="keyword">return</span> findOrderFromAnnotation(((DecoratingProxy) obj).getDecoratedClass());</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> order;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>所以，重点肯定在<code>OrderComparator</code>的<code>compare()</code>方法上。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">compare</span><span class="params">(<span class="meta">@Nullable</span> Object o1, <span class="meta">@Nullable</span> Object o2)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> doCompare(o1, o2);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">doCompare</span><span class="params">(<span class="meta">@Nullable</span> Object o1, <span class="meta">@Nullable</span> Object o2)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">boolean</span> p1 = (o1 <span class="keyword">instanceof</span> PriorityOrdered);</span><br><span class="line">  <span class="keyword">boolean</span> p2 = (o2 <span class="keyword">instanceof</span> PriorityOrdered);</span><br><span class="line">  <span class="comment">// PriorityOrdered有短路作用，有实现PriorityOrdered的比没有实现的优先级低</span></span><br><span class="line">  <span class="keyword">if</span> (p1 &amp;&amp; !p2) &#123;</span><br><span class="line">    <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span> (p2 &amp;&amp; !p1) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 二者都没有实现PriorityOrdered，则根据Ordered接口或@Order注解来</span></span><br><span class="line">  <span class="keyword">int</span> i1 = getOrder(o1);</span><br><span class="line">  <span class="keyword">int</span> i2 = getOrder(o2);</span><br><span class="line">  <span class="keyword">return</span> Integer.compare(i1, i2);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">int</span> <span class="title">getOrder</span><span class="params">(<span class="meta">@Nullable</span> Object obj)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (obj != <span class="keyword">null</span>) &#123;</span><br><span class="line">    Integer order = findOrder(obj);</span><br><span class="line">    <span class="keyword">if</span> (order != <span class="keyword">null</span>) &#123;</span><br><span class="line">      <span class="keyword">return</span> order;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 没有实现任何顺序的优先级最低</span></span><br><span class="line">  <span class="keyword">return</span> Ordered.LOWEST_PRECEDENCE;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">protected</span> Integer <span class="title">findOrder</span><span class="params">(Object obj)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> (obj <span class="keyword">instanceof</span> Ordered ? ((Ordered) obj).getOrder() : <span class="keyword">null</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>可以总结出优先级顺序，两个组件</p>
<ul>
<li><p>如果一个实现了<code>PriorityOrdered</code>接口，一个没有实现<code>PriorityOrdered</code>接口，则实现了这个优先级更高</p>
<p><code>PriorityOrdered</code>是<code>Order</code>的子接口，没有任何附加实现</p>
<p>也就是说，<code>PriorityOrdered</code>就是想实现一点：它比普通<code>Ordered</code>接口具有更高的优先级</p>
</li>
<li><p>如果都实现了<code>PriorityOrdered</code>，则根据其order值排序</p>
</li>
<li><p>如果实现了<code>Ordered</code>或被<code>@Order</code>注解，则根据其order值排序</p>
</li>
<li><p>没有任何排序接口或注解的组件之间相互对比，永远是相等的</p>
</li>
<li><p>没有任何排序接口或注解的组件，和，有任意一个排序接口或注解的组件，后者优先级更高，除非后者主动指定order为<code>Ordered.LOWEST_PRECEDENCE</code></p>
</li>
</ul>
]]></content>
      <categories>
        <category>Spring</category>
      </categories>
      <tags>
        <tag>Spring</tag>
      </tags>
  </entry>
  <entry>
    <title>Spring Webflow - 视图状态</title>
    <url>/2018/09/09/Spring%20Webflow%20-%20%E8%A7%86%E5%9B%BE%E7%8A%B6%E6%80%81-springwebflow-%E8%A7%86%E5%9B%BE%E7%8A%B6%E6%80%81/</url>
    <content><![CDATA[<h1 id="基础"><a href="#基础" class="headerlink" title="基础"></a>基础</h1><h2 id="指定view-state的view属性的几种方式"><a href="#指定view-state的view属性的几种方式" class="headerlink" title="指定view-state的view属性的几种方式"></a>指定view-state的view属性的几种方式</h2><ul>
<li>按照默认名称在相对路径下查找view</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;!-- 在flow配置文件同目录下查找名为enterBookingDetails的视图 --&gt;</span><br><span class="line">&lt;view-state id=&quot;enterBookingDetails&quot;&gt;</span><br></pre></td></tr></table></figure>

<ul>
<li>指明view名称，在相对路径下查找view</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;!-- 在flow配置文件同目录下查找名为bookingDetails.xhtml的视图 --&gt;</span><br><span class="line">&lt;view-state id=&quot;enterBookingDetails&quot; view=&quot;bookingDetails.xhtml&quot;&gt;</span><br></pre></td></tr></table></figure>

<ul>
<li>绝对路径查找view</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;!-- 直接查找/WEB-INF/hotels/booking/bookingDetails.xhtml的视图 --&gt;</span><br><span class="line">&lt;view-state id=&quot;enterBookingDetails&quot; view=&quot;/WEB-INF/hotels/booking/bookingDetails.xhtml&quot;&gt;</span><br></pre></td></tr></table></figure>

<ul>
<li>按照逻辑ID定位view<br>这是结合Spring提供的其它viewResolver来定位到其他组件中的view，如Tiles等。在前面 <a href="https://blog.csdn.net/zou8944/article/details/82391712">配置</a> 一章中有讲</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;!-- 结合viewResolver共同确定视图位 --&gt;</span><br><span class="line">&lt;view-state id=&quot;enterBookingDetails&quot; view=&quot;bookingDetails&quot;&gt;</span><br></pre></td></tr></table></figure>
<h2 id="在viewScope中分配变量"><a href="#在viewScope中分配变量" class="headerlink" title="在viewScope中分配变量"></a>在viewScope中分配变量</h2><ul>
<li>直接分配</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;var name=&quot;searchCriteria&quot; class=&quot;com.mycompany.myapp.hotels.SearchCriteria&quot; /&gt;</span><br></pre></td></tr></table></figure>

<ul>
<li>依靠运算结果分配</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;on-render&gt;</span><br><span class="line">  	 &lt;evaluate expression=&quot;bookingService.findHotels(searchCriteria)&quot; result=&quot;viewScope.hotels&quot; /&gt;</span><br><span class="line">&lt;/on-render&gt;</span><br></pre></td></tr></table></figure>
<h2 id="在viewScope中操作对象"><a href="#在viewScope中操作对象" class="headerlink" title="在viewScope中操作对象"></a>在viewScope中操作对象</h2><p>如下例子展示了如何在同一个view state的不同时机操作一系列对象</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;view-state id=&quot;searchResults&quot;&gt;</span><br><span class="line">   	&lt;on-render&gt;</span><br><span class="line">		&lt;evaluate expression=&quot;bookingService.findHotels(searchCriteria)&quot;</span><br><span class="line">                 result=&quot;viewScope.hotels&quot; /&gt;</span><br><span class="line">	&lt;/on-render&gt;</span><br><span class="line">	&lt;transition on=&quot;next&quot;&gt;</span><br><span class="line">		&lt;evaluate expression=&quot;searchCriteria.nextPage()&quot; /&gt;</span><br><span class="line">		&lt;render fragments=&quot;searchResultsFragment&quot; /&gt;</span><br><span class="line">	&lt;/transition&gt;</span><br><span class="line">	&lt;transition on=&quot;previous&quot;&gt;</span><br><span class="line">		&lt;evaluate expression=&quot;searchCriteria.previousPage()&quot; /&gt;</span><br><span class="line">		&lt;render fragments=&quot;searchResultsFragment&quot; /&gt;</span><br><span class="line">	&lt;/transition&gt;</span><br><span class="line">&lt;/view-state&gt;</span><br><span class="line">&lt;!-- 渲染view之前，首先执行findHotels方法，将结果放到viewScope的hotels中 --&gt;</span><br><span class="line">&lt;!-- 当返回next事件时，执行nextPage()方法， 然后渲染查找结果部分 --&gt;</span><br><span class="line">&lt;!-- 当返回previous事件时，执行前一页操作，然后渲染查找结果部分 --&gt;</span><br></pre></td></tr></table></figure>
<h2 id="lt-on-render-gt"><a href="#lt-on-render-gt" class="headerlink" title="&lt;on-render&gt;"></a><code>&lt;on-render&gt;</code></h2><p>在view渲染前可以执行一个或多个action，<strong>这些action将会在视图最开始渲染以及后续的任何刷新，甚至视图局部的重新渲染执行</strong>。以上面的代码为例，在重新渲染结果之前，还会先执行一次findHotels方法。<br>##数据绑定</p>
<h2 id="在view-state上绑定model"><a href="#在view-state上绑定model" class="headerlink" title="在view-state上绑定model"></a>在view-state上绑定model</h2><p>使用model属性，可以将一个对象绑定到view中的表单中。web flow可以帮助完成对象属性和表单域的绑定和验证。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;view-state id=&quot;enterBookingDetails&quot; model=&quot;booking&quot;&gt;</span><br></pre></td></tr></table></figure>
<p>绑定时机是当view的event发生时</p>
<ul>
<li><p><code>view-to-model</code>绑定：在view完成并回发时，用户的输入域会被绑定到指定对象的属性上</p>
</li>
<li><p><code>model</code>验证：绑定后，如果需要验证，验证逻辑会被调用。</p>
</li>
<li><p>需要指出的是：只有当验证成功后才能transition到别的state，验证失败时会重新渲染该view，要求用户重新输入。<br>##绑定model时的类型转换<br>####基础<br>由于客户端上传的表单数据都是字符串类型的， 因此需要进行类型转换</p>
</li>
<li><p>Web Flow类型转换和Spring MVC的类型转换的关系<br>在web-flow 2.1以前，Sprign MVC和web-flow使用不同的类型转换机制，但是2.1以后，二者使用相同的类型转换</p>
</li>
</ul>
<p><strong>以前</strong>，Web Flow使用<code>spring-binding-2.4.6.RELEASE.jar</code>包提供的API进行类型转换，相关的类有<code>org.springframework.binding.convert.service.DefaultConversionService</code>， <code>org.springframework.binding.convert.converters.Converter</code>等，通过实现<code>Converter</code>接口完成自定义转换器，再通过<code>DefaultConversionService</code>进行注册，就像如下所示的方式1那样；而且这样还能够注册带命名ID的转换器，可以结合<code>&lt;bingding&gt;</code>的<code>converter</code>属性进行使用，但这种方式已经非常不建议了。<br><strong>目前</strong>， Web Flow在执行conversionService时依然使用<code>org.springframework.binding.convert.service.DefaultConversionService</code>，但该服务已经不会去注册任何默认的转换器和格式化器了，而是将转换和格式任务全部委托给来自<code>spring-core-4.3.7.RELEASE.jar</code>包的<code>org.springframework.core.convert.ConversionService</code>完成。<code>DefaultConversionService</code>内部维护一个<code>ConversionService</code>对象，对<code>DefaultConversionService</code>中进行的大多数操作都被转变成对<code>ConversionService</code>的操作(对带命名ID转换器的管理除外)。值得一提的是，命名ID的转换器非常没有必要，因为在检测到相应类型后，系统会自动调用合适的转换器。</p>
<ul>
<li>方式一 传统方式添加Converter(不建议使用)</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">import org.springframework.binding.convert.converters.Converter;</span><br><span class="line">// 定义自己的转换器</span><br><span class="line">public class DateConverter implements Converter &#123;</span><br><span class="line"></span><br><span class="line">    public Class&lt;?&gt; getSourceClass() &#123;</span><br><span class="line">        return String.class;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public Class&lt;?&gt; getTargetClass() &#123;</span><br><span class="line">        return java.util.Date.class;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public Object convertSourceToTargetClass(Object source, Class&lt;?&gt; targetClass) throws Exception &#123;</span><br><span class="line">        SimpleDateFormat sdf = new SimpleDateFormat(&quot;yyyy-MM-dd&quot;);</span><br><span class="line">        </span><br><span class="line">        return sdf.parse(source.toString());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">// 注册自己的转换器</span><br><span class="line">public class ApplicationConversionService extends DefaultConversionService &#123;</span><br><span class="line">	public ApplicationConversionService() &#123;</span><br><span class="line">   		addConverter(new DateConverter());</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;!-- 使用转换器，什么都不用指定，当检测到model中的checkinDate属性为Date类型时，DateConverter会自动被调用 --&gt;</span><br><span class="line">&lt;view-state id=&quot;enterBookingDetails&quot; model=&quot;booking&quot;&gt;</span><br><span class="line">   	&lt;binder&gt;</span><br><span class="line">       	&lt;binding property=&quot;checkinDate&quot;/&gt;</span><br><span class="line">   	&lt;/binder&gt;</span><br><span class="line">&lt;/view-state&gt;</span><br></pre></td></tr></table></figure>

<ul>
<li>方式二 添加带ID的Converter(已过时，不推荐使用)</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">DateConverter的定义不变</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">// 注册时指定id</span><br><span class="line">public class ApplicationConversionService extends DefaultConversionService &#123;</span><br><span class="line">	public ApplicationConversionService() &#123;</span><br><span class="line">		// 该方法已被标为deprecated</span><br><span class="line">   		addConverter(&quot;dateConverter&quot;, new DateConverter());</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;!-- 使用时指定id --&gt;</span><br><span class="line">&lt;view-state id=&quot;enterBookingDetails&quot; model=&quot;booking&quot;&gt;</span><br><span class="line">   	&lt;binder&gt;</span><br><span class="line">       	&lt;binding property=&quot;checkinDate&quot; converter=&quot;dateConverter&quot;/&gt;</span><br><span class="line">   	&lt;/binder&gt;</span><br><span class="line">&lt;/view-state&gt;</span><br></pre></td></tr></table></figure>
<ul>
<li>方式三 - 配置通用的Converter和Formatter(推荐使用，当前版本鼓励的方式)</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">// 首先实现FormattingConversionServiceFactoryBean，添加自定义格式化器和转换器</span><br><span class="line">public class ApplicationConversionServiceFactoryBean extends FormattingConversionServiceFactoryBean &#123;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public void setConverters(Set&lt;?&gt; converters) &#123;</span><br><span class="line">        Converter&lt;String, Date&gt; converter = new Converter&lt;String, Date&gt;() &#123;</span><br><span class="line">            public Date convert(String source) &#123;</span><br><span class="line">                SimpleDateFormat sdf = new SimpleDateFormat(&quot;yyyy-MM-dd&quot;);</span><br><span class="line">                return sdf.parse(source);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line">        </span><br><span class="line">        Set&lt;Converter&lt;String, Date&gt;&gt; set = new HashSet&lt;Converter&lt;String,Date&gt;&gt;();</span><br><span class="line">        set.add(converter);</span><br><span class="line">        super.setConverters(set);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public void setFormatters(Set&lt;?&gt; formatters) &#123;</span><br><span class="line">        Set&lt;Formatter&lt;Date&gt;&gt; set= new HashSet&lt;Formatter&lt;Date&gt;&gt;();</span><br><span class="line">        set.add(new Formatter&lt;Date&gt;() &#123;</span><br><span class="line"></span><br><span class="line">            public String print(Date object, Locale locale) &#123;</span><br><span class="line">                SimpleDateFormat sdf = new SimpleDateFormat(&quot;yyyy-MM-dd&quot;);</span><br><span class="line">                return sdf.format(object);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            public Date parse(String text, Locale locale) throws ParseException &#123;</span><br><span class="line">                SimpleDateFormat sdf = new SimpleDateFormat(&quot;yyyy-MM-dd&quot;);</span><br><span class="line">                return sdf.parse(text);</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">        &#125;);</span><br><span class="line">        </span><br><span class="line">        super.setFormatters(set);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">// 创建由ApplicationConversionServiceFactoryBean产生的ConversionService</span><br><span class="line">// 该ConversionService是Spring MVC中类型转换的核心，可以同时配置给Spring MVC和Web Flow</span><br><span class="line">@Bean(&quot;applicationConversionService&quot;)</span><br><span class="line">public ConversionService applicationConversionService() &#123;</span><br><span class="line">    FormattingConversionServiceFactoryBean factory = new ApplicationConversionServiceFactoryBean();</span><br><span class="line">    // 添加自定义格式化器</span><br><span class="line">    factory.setFormatters(null);</span><br><span class="line">    // 添加自定义格式转换器</span><br><span class="line">    factory.setConverters(null);</span><br><span class="line">    // 生成ConversionService </span><br><span class="line">    factory.afterPropertiesSet();</span><br><span class="line">    // 返回ConversionService </span><br><span class="line">    return factory.getObject();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">// 下面三个步骤用于配置给Web Flow</span><br><span class="line"></span><br><span class="line">@Bean(&quot;defaultConversionService&quot;)</span><br><span class="line">public DefaultConversionService conversionService(@Autowired ConversionService applicationConversionService) &#123;</span><br><span class="line">    return new DefaultConversionService(applicationConversionService);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">@Bean</span><br><span class="line">public FlowBuilderServices flowBuilderServices(@Autowired MvcViewFactoryCreator mvcViewFactoryCreator, @Autowired DefaultConversionService defaultConversionService) &#123;</span><br><span class="line">    return getFlowBuilderServicesBuilder()</span><br><span class="line">            .setConversionService(defaultConversionService)</span><br><span class="line">            .build();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 注册flow</span><br><span class="line">@Bean(&quot;flowRegistry&quot;)</span><br><span class="line">public FlowDefinitionRegistry flowRegistry(@Autowired FlowBuilderServices flowBuilderServices) &#123;</span><br><span class="line">    </span><br><span class="line">    return getFlowDefinitionRegistryBuilder()</span><br><span class="line">            .setBasePath(&quot;/WEB-INF/jsp/flow&quot;)</span><br><span class="line">            .addFlowLocation(&quot;/config/search-flow.xml&quot;)</span><br><span class="line">            .setFlowBuilderServices(flowBuilderServices)</span><br><span class="line">            .build();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;!-- 下面的步骤用于注册给Spring MVC --&gt;</span><br><span class="line">&lt;mvc:annotation-driven conversion-service=&quot;applicationConversionService&quot; /&gt;</span><br></pre></td></tr></table></figure>
<ul>
<li>针对上述三种方式的说明</li>
<li>方式一表面上使用的是旧的转换器添加方式，但内部实现还是按照新的方式进行，在添加Converter时，会通过一个适配器类转换将<code>org.springframework.binding.convert.converters.Converter</code>转换为<code>org.springframework.core.convert.converter.GenericConverter</code></li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">// 源码片段</span><br><span class="line">public void addConverter(Converter converter) &#123;</span><br><span class="line">	((ConverterRegistry) delegate).addConverter(new SpringBindingConverterAdapter(converter));</span><br><span class="line">	if (converter instanceof TwoWayConverter) &#123;</span><br><span class="line">		TwoWayConverter twoWayConverter = (TwoWayConverter) converter;</span><br><span class="line">		((ConverterRegistry) delegate).addConverter(new SpringBindingConverterAdapter(new ReverseConverter(</span><br><span class="line">				twoWayConverter)));</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>方式二已过时，这里仅展示</li>
<li>方式三推荐使用，但这里仅展示了我自己实验成功的java config配置方式，xml配置方式可以参见<a href="https://docs.spring.io/spring-webflow/docs/2.4.5.RELEASE/reference/html/views.html#converter-configuration">官网</a>。</li>
<li>实际使用时，会发现方式一从视图提交到model时类型转换能够正常进行，但是从model回填到视图时并非自己最开始输入的数值，那是因为我们只设置了Converter，没有设置Formatter。</li>
<li>关于转换器的配置，只要认识到ConversionService是类型转换的核心，就会省事很多</li>
</ul>
<h2 id="Converter和Formatter的区别"><a href="#Converter和Formatter的区别" class="headerlink" title="Converter和Formatter的区别"></a>Converter和Formatter的区别</h2><ul>
<li><code>Converter</code>: 是<code>spring-core-4.3.7.RELEASE.jar</code>包提供的，用于<code>Object to Object</code>的转换</li>
<li><code>Formatter</code>: 是<code>spring-context-4.3.7.RELEASE.jar</code>包提供的，用于<code>Object to String</code>的转换。</li>
</ul>
<h2 id="格式化注解"><a href="#格式化注解" class="headerlink" title="格式化注解"></a>格式化注解</h2><p>新的类型转换提供两个有用的注解，可以放在model类的属性上，和被@Controller类的方法参数中。</p>
<ul>
<li><code>NumberFormat</code></li>
<li><code>DateTimeFormat</code>： 该注解默认使用<a href="http://www.joda.org/joda-time/"><code>Joda Time</code></a>，需要在类路径中包含Joda Time的包。默认情况下Spring MVC和web flow都没有其他的日期相关的转换器和格式化器。因此定义我们自己的日期相关转换器和格式化器非常重要。</li>
<li>此外，我们还可以参照上述两个注解定义自己的注解.</li>
</ul>
<h2 id="关于绑定的另外两点"><a href="#关于绑定的另外两点" class="headerlink" title="关于绑定的另外两点"></a>关于绑定的另外两点</h2><ul>
<li>取消绑定<br>可以使用bind属性在特定情况下取消绑定。如下当触发cancel事件时不会执行绑定操作</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;view-state id=&quot;enterBookingDetails&quot; model=&quot;booking&quot;&gt;</span><br><span class="line">    &lt;transition on=&quot;proceed&quot; to=&quot;reviewBooking&quot;&gt;</span><br><span class="line">    &lt;transition on=&quot;cancel&quot; to=&quot;bookingCancelled&quot; bind=&quot;false&quot; /&gt;</span><br><span class="line">&lt;/view-state&gt;</span><br></pre></td></tr></table></figure>

<ul>
<li>显式地指明绑定的字段<br>使用<binder>标签可以显式指明需要绑定的字段，同时可以指明需要使用到的转换器，和是否允许为空。</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;view-state id=&quot;enterBookingDetails&quot; model=&quot;booking&quot;&gt;</span><br><span class="line">    &lt;binder&gt;</span><br><span class="line">        &lt;binding property=&quot;checkinDate&quot; converter=&quot;shortDate&quot; required=&quot;true&quot; /&gt;</span><br><span class="line">        &lt;binding property=&quot;checkoutDate&quot; converter=&quot;shortDate&quot; required=&quot;true&quot; /&gt;</span><br><span class="line">        &lt;binding property=&quot;creditCard&quot; required=&quot;true&quot; /&gt;</span><br><span class="line">        &lt;binding property=&quot;creditCardName&quot; required=&quot;true&quot; /&gt;</span><br><span class="line">        &lt;binding property=&quot;creditCardExpiryMonth&quot; required=&quot;true&quot; /&gt;</span><br><span class="line">        &lt;binding property=&quot;creditCardExpiryYear&quot; required=&quot;true&quot; /&gt;</span><br><span class="line">    &lt;/binder&gt;</span><br><span class="line">    &lt;transition on=&quot;proceed&quot; to=&quot;reviewBooking&quot;&gt;</span><br><span class="line">    &lt;transition on=&quot;cancel&quot; to=&quot;bookingCancelled&quot; bind=&quot;false&quot; /&gt;</span><br><span class="line">&lt;/view-state&gt;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>注意事项</p>
<ol>
<li>没有显式指定绑定字段时，所有model对象的公共属性都会被绑定；指定绑定字段时，则只有显式指定的字段会被绑定</li>
<li>没有显式声明转换器时，会使用自动检测的转换器</li>
<li>声明不允许为空时，若出现空，则会产生验证错误，并会重新绘制视图并报错。<br>##绑定数据的验证<br>Web Flow支持自定义验证条件和JSR-303 Bean验证框架<br>####JSR-303 Bean Validation</li>
</ol>
<ul>
<li> 基础配置<br>首先类路径中需要有一个validator的jar包，然后按照如下配置后，validator会应用到所有的添加了条件注解的model属性中</li>
</ul>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;webflow:flow-registry flow-builder-services=&quot;flowBuilderServices&quot; /&gt;</span><br><span class="line">&lt;webflow:flow-builder-services id=&quot;flowBuilderServices&quot; validator=&quot;validator&quot; /&gt;</span><br><span class="line">&lt;bean id=&quot;validator&quot; class=&quot;org.springframework.validation.beanvalidation.LocalValidatorFactoryBean&quot; /&gt;</span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;form中按如下方式配置</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">@NotNull</span><br><span class="line">@Size(min = 2, max = 30, message=&quot;at least 3 chars&quot; )</span><br><span class="line">private String name;</span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;前端按如下配置，使用<code>&lt;sf:errors&gt;</code>可将name属性的错误信息显示出来</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;sf:form action=&quot;$&#123;flowExecutionUrl&#125;&amp;_eventId=submit&quot; commandName=&quot;searchForm&quot; method=&quot;post&quot;&gt;</span><br><span class="line">    Name: &lt;sf:input path=&quot;name&quot;/&gt; &lt;sf:errors path=&quot;name&quot;&gt;&lt;/sf:errors&gt;&lt;br/&gt;</span><br><span class="line">       &lt;input type=&quot;submit&quot; value=&quot;Submit&quot;&gt;</span><br><span class="line">&lt;/sf:form&gt;</span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;效果如下<br><img src="https://img-blog.csdn.net/20180909184901856?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3pvdTg5NDQ=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70" alt="这里写图片描述"></p>
<ul>
<li>部分验证<br>JSR-303支持部分验证，通过验证组的方式，使用如下(我在验证该方式时是不行的，提示viwe-state标签不允许出现validation-hints属性)</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">@NotNull</span><br><span class="line">@Size(min = 2, max = 30, groups = State1.class)</span><br><span class="line">private String name;</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;view-state id=&quot;state1&quot; model=&quot;myModel&quot; validation-hints=&quot;&#x27;group1,group2&#x27;&quot;&gt;</span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;对该方法不做详细解释，最好还是参考一下JSR-303再来看</p>
<h2 id="自定义验证"><a href="#自定义验证" class="headerlink" title="自定义验证"></a>自定义验证</h2><p>JSR-303仅支持对Bean的验证，如非空，字符串长度等。我们经常需要自定义验证逻辑，有如下两种方式进行自定义</p>
<ul>
<li>一是在model类内部定义一个以<code>validate$&#123;stateId&#125;(ValidationContext)</code>为签名的方法，在view提交时会自动调用该验证方法。stateId是view-state的id</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">// 官方示例</span><br><span class="line">public class Booking &#123;</span><br><span class="line">    private Date checkinDate;</span><br><span class="line">    private Date checkoutDate;</span><br><span class="line">    ...</span><br><span class="line"></span><br><span class="line">    public void validateEnterBookingDetails(ValidationContext context) &#123;</span><br><span class="line">        MessageContext messages = context.getMessageContext();</span><br><span class="line">        if (checkinDate.before(today())) &#123;</span><br><span class="line">            messages.addMessage(new MessageBuilder().error().source(&quot;checkinDate&quot;).</span><br><span class="line">                defaultText(&quot;Check in date must be a future date&quot;).build());</span><br><span class="line">        &#125; else if (!checkinDate.before(checkoutDate)) &#123;</span><br><span class="line">            messages.addMessage(new MessageBuilder().error().source(&quot;checkoutDate&quot;).</span><br><span class="line">                defaultText(&quot;Check out date must be later than check in date&quot;).build());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>二是单独定义一个类，类名为<code>$&#123;model&#125;Validator</code>，在其内部定义一个以<code>validate$&#123;stateId&#125;($&#123;model&#125;, ValidationContext)</code>为签名的方法，然后将该类装载到Spring中。</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">// 官方示例</span><br><span class="line">@Component</span><br><span class="line">public class BookingValidator &#123;</span><br><span class="line">    public void validateEnterBookingDetails(Booking booking, ValidationContext context) &#123;</span><br><span class="line">        MessageContext messages = context.getMessageContext();</span><br><span class="line">        if (booking.getCheckinDate().before(today())) &#123;</span><br><span class="line">            messages.addMessage(new MessageBuilder().error().source(&quot;checkinDate&quot;).</span><br><span class="line">                defaultText(&quot;Check in date must be a future date&quot;).build());</span><br><span class="line">        &#125; else if (!booking.getCheckinDate().before(booking.getCheckoutDate())) &#123;</span><br><span class="line">            messages.addMessage(new MessageBuilder().error().source(&quot;checkoutDate&quot;).</span><br><span class="line">                defaultText(&quot;Check out date must be later than check in date&quot;).build());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;针对第二种情况也可以定义一个<code>validate($&#123;model&#125;, ValidationContext)</code>方法，这样无论在哪个view-state的view返回时，只要绑定了该moel，都会调用该验证方法。<br>&emsp;&emsp;当<code>validate($&#123;model&#125;, ValidationContext)</code>和validate<code>$&#123;stateId&#125;($&#123;model&#125;, ValidationContext)</code>都存在时，会先调用后者，再调用前者。</p>
<h2 id="多说两点"><a href="#多说两点" class="headerlink" title="多说两点"></a>多说两点</h2><ul>
<li>失能验证<br>通过如下方式可以在局部使得验证失效</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;view-state id=&quot;chooseAmenities&quot; model=&quot;booking&quot;&gt;</span><br><span class="line">    &lt;transition on=&quot;proceed&quot; to=&quot;reviewBooking&quot;&gt;</span><br><span class="line">    &lt;transition on=&quot;back&quot; to=&quot;enterBookingDetails&quot; validate=&quot;false&quot; /&gt;</span><br><span class="line">&lt;/view-state&gt;</span><br></pre></td></tr></table></figure>
<h1 id="转移"><a href="#转移" class="headerlink" title="转移"></a>转移</h1><p>在一个view-state中，可能发生各种转移</p>
<ul>
<li> 转移之前执行操作<br>可以在转移之前执行特定的操作，如一个方法， 当方法返回false或者发生错误时，转移不会继续进行下去。而是重新渲染相应的部分</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;transition on=&quot;submit&quot; to=&quot;bookingConfirmed&quot;&gt;</span><br><span class="line">    &lt;evaluate expression=&quot;bookingAction.makeBooking(booking, messageContext)&quot; /&gt;</span><br><span class="line">&lt;/transition&gt;</span><br></pre></td></tr></table></figure>

<ul>
<li>全局转移<br>定义全局有效的转移操作</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;global-transitions&gt;</span><br><span class="line">    &lt;transition on=&quot;login&quot; to=&quot;login&quot; /&gt;</span><br><span class="line">    &lt;transition on=&quot;logout&quot; to=&quot;logout&quot; /&gt;</span><br><span class="line">&lt;/global-transitions&gt;</span><br></pre></td></tr></table></figure>

<ul>
<li>事件处理器<br>可以利用transition标签只响应事件，而不做任何跳转操作，从而作为事件处理器</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;transition on=&quot;event&quot;&gt;</span><br><span class="line">    &lt;!-- Handle event --&gt;</span><br><span class="line">&lt;/transition&gt;</span><br></pre></td></tr></table></figure>

<ul>
<li>局部渲染<br>利用<code>&lt;render&gt;</code>标签可以进行局部渲染，一般用于Ajax的局部刷新操作</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;transition on=&quot;next&quot;&gt;</span><br><span class="line">    &lt;evaluate expression=&quot;searchCriteria.nextPage()&quot; /&gt;</span><br><span class="line">    &lt;render fragments=&quot;searchResultsFragment&quot; /&gt;</span><br><span class="line">&lt;/transition&gt;</span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;如上，当发生next事件时，首先执行翻页操作，然后重新刷新查询结果区域。fragment属性应该引用想要刷新的view的id,当刷新多个区域时，使用逗号隔开。</p>
<h1 id="view的回退控制"><a href="#view的回退控制" class="headerlink" title="view的回退控制"></a>view的回退控制</h1><p>当我们从一个view跳转到另一个view时，通过浏览器的回退按钮，可以返回上一个view，我们可以对这个功能进行配置</p>
<ul>
<li>失能一个回退view，即当前view不能再下一个view上回退，回退到的是前一个view</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;transition on=&quot;cancel&quot; to=&quot;bookingCancelled&quot; history=&quot;discard&quot;&gt;</span><br></pre></td></tr></table></figure>

<ul>
<li>失能所有回退view，即当前及之前所有view都是不能够被回退的。</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;transition on=&quot;confirm&quot; to=&quot;bookingConfirmed&quot; history=&quot;invalidate&quot;&gt;</span><br></pre></td></tr></table></figure>
<p>##MessageContext<br>Spring web flow的MessageContext是用来记录在flow执行期间的信息的。而其中包含的信息都由MessageBuilder产生，可以手动添加，也可以由系统自动产生。</p>
<h2 id="手动添加信息"><a href="#手动添加信息" class="headerlink" title="手动添加信息"></a>手动添加信息</h2><ul>
<li>手动添加普通文本</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">MessageContext context = ...（这里一般是从上一级获取到context对象）</span><br><span class="line">MessageBuilder builder = new MessageBuilder();</span><br><span class="line">context.addMessage(builder.error().source(&quot;checkinDate&quot;)</span><br><span class="line">    .defaultText(&quot;Check in date must be a future date&quot;).build());</span><br><span class="line">context.addMessage(builder.warn().source(&quot;smoking&quot;)</span><br><span class="line">    .defaultText(&quot;Smoking is bad for your health&quot;).build());</span><br><span class="line">context.addMessage(builder.info()</span><br><span class="line">    .defaultText(&quot;We have processed your reservation - thank you and enjoy your stay&quot;).build());</span><br></pre></td></tr></table></figure>

<ul>
<li>添加Spring MessageSource得到的信息</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">MessageContext context = ...</span><br><span class="line">MessageBuilder builder = new MessageBuilder();</span><br><span class="line">context.addMessage(builder.error().source(&quot;checkinDate&quot;).code(&quot;checkinDate.notFuture&quot;).build());</span><br><span class="line">context.addMessage(builder.warn().source(&quot;smoking&quot;).code(&quot;notHealthy&quot;)</span><br><span class="line">    .resolvableArg(&quot;smoking&quot;).build());</span><br><span class="line">context.addMessage(builder.info().code(&quot;reservationConfirmation&quot;).build());</span><br></pre></td></tr></table></figure>

<ul>
<li>添加message bundle获取的信息<br>可以直接在view或flow中使用<code>resourceBundle</code>这个EL变量来获取资源文件中的内容。(这个需要在web-flow同目录下放置一个<code>message.properties</code>文件)</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;input value=&quot;#&#123;resourceBundle.reservationConfirmation&#125;&quot; /&gt;</span><br></pre></td></tr></table></figure>
<h2 id="系统自动产生信息"><a href="#系统自动产生信息" class="headerlink" title="系统自动产生信息"></a>系统自动产生信息</h2><p>&emsp;&emsp;有多重情况下web-flow会自动生成message,其中一种重要的情况是当view-to-model验证失败时，生成规则是，首先到资源文件中查找key为<code>$&#123;model&#125;l.$&#123;property&#125;.$&#123;errCode&#125;</code>的资源，如果找不到，则直接查找key为<code>$&#123;errCode&#125;</code>的资源。<br>&emsp;&emsp; 举例：有model名为booking，验证其中的checkDate属性，当出现类型不匹配时，系统给出的错误代码为<code>typeMismatch</code>，则会在资源文件中查找如下key的资源<br> <code>booking.checkDate.typeMismatch</code>  或 <code>typeMismatch</code></p>
<h1 id="附"><a href="#附" class="headerlink" title="附"></a>附</h1><p>下面大致列举一下Spring MVC会自动注册的转换器和格式化器(调用<code>ConversionService</code>的<code>toString()</code>方法)</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">@org.springframework.format.annotation.DateTimeFormat java.lang.Long -&gt; java.lang.String: org.springframework.format.datetime.DateTimeFormatAnnotationFormatterFactory@3de4aaed,@org.springframework.format.annotation.NumberFormat java.lang.Long -&gt; java.lang.String: org.springframework.format.number.NumberFormatAnnotationFormatterFactory@806d8b</span><br><span class="line">@org.springframework.format.annotation.DateTimeFormat java.time.LocalDate -&gt; java.lang.String: org.springframework.format.datetime.standard.Jsr310DateTimeFormatAnnotationFormatterFactory@13c06099,java.time.LocalDate -&gt; java.lang.String : org.springframework.format.datetime.standard.TemporalAccessorPrinter@1cb91eff</span><br><span class="line">@org.springframework.format.annotation.DateTimeFormat java.time.LocalDateTime -&gt; java.lang.String: org.springframework.format.datetime.standard.Jsr310DateTimeFormatAnnotationFormatterFactory@13c06099,java.time.LocalDateTime -&gt; java.lang.String : org.springframework.format.datetime.standard.TemporalAccessorPrinter@2918eadb</span><br><span class="line">@org.springframework.format.annotation.DateTimeFormat java.time.LocalTime -&gt; java.lang.String: org.springframework.format.datetime.standard.Jsr310DateTimeFormatAnnotationFormatterFactory@13c06099,java.time.LocalTime -&gt; java.lang.String : org.springframework.format.datetime.standard.TemporalAccessorPrinter@6d563cf9</span><br><span class="line">@org.springframework.format.annotation.DateTimeFormat java.time.OffsetDateTime -&gt; java.lang.String: org.springframework.format.datetime.standard.Jsr310DateTimeFormatAnnotationFormatterFactory@13c06099,java.time.OffsetDateTime -&gt; java.lang.String : org.springframework.format.datetime.standard.TemporalAccessorPrinter@2f20d514</span><br><span class="line">@org.springframework.format.annotation.DateTimeFormat java.time.OffsetTime -&gt; java.lang.String: org.springframework.format.datetime.standard.Jsr310DateTimeFormatAnnotationFormatterFactory@13c06099,java.time.OffsetTime -&gt; java.lang.String : org.springframework.format.datetime.standard.TemporalAccessorPrinter@19212c1c</span><br><span class="line">@org.springframework.format.annotation.DateTimeFormat java.time.ZonedDateTime -&gt; java.lang.String: org.springframework.format.datetime.standard.Jsr310DateTimeFormatAnnotationFormatterFactory@13c06099,java.time.ZonedDateTime -&gt; java.lang.String : org.springframework.format.datetime.standard.TemporalAccessorPrinter@2e061032</span><br><span class="line">@org.springframework.format.annotation.DateTimeFormat java.util.Calendar -&gt; java.lang.String: org.springframework.format.datetime.DateTimeFormatAnnotationFormatterFactory@3de4aaed</span><br><span class="line">@org.springframework.format.annotation.NumberFormat java.lang.Byte -&gt; java.lang.String: org.springframework.format.number.NumberFormatAnnotationFormatterFactory@806d8b</span><br><span class="line">@org.springframework.format.annotation.NumberFormat java.lang.Double -&gt; java.lang.String: org.springframework.format.number.NumberFormatAnnotationFormatterFactory@806d8b</span><br><span class="line">@org.springframework.format.annotation.NumberFormat java.lang.Float -&gt; java.lang.String: org.springframework.format.number.NumberFormatAnnotationFormatterFactory@806d8b</span><br><span class="line">@org.springframework.format.annotation.NumberFormat java.lang.Integer -&gt; java.lang.String: org.springframework.format.number.NumberFormatAnnotationFormatterFactory@806d8b</span><br><span class="line">@org.springframework.format.annotation.NumberFormat java.lang.Short -&gt; java.lang.String: org.springframework.format.number.NumberFormatAnnotationFormatterFactory@806d8b</span><br><span class="line">@org.springframework.format.annotation.NumberFormat java.math.BigDecimal -&gt; java.lang.String: org.springframework.format.number.NumberFormatAnnotationFormatterFactory@806d8b</span><br><span class="line">@org.springframework.format.annotation.NumberFormat java.math.BigInteger -&gt; java.lang.String: org.springframework.format.number.NumberFormatAnnotationFormatterFactory@806d8b</span><br><span class="line">java.lang.Boolean -&gt; java.lang.String : org.springframework.core.convert.support.ObjectToStringConverter@839fe61</span><br><span class="line">java.lang.Character -&gt; java.lang.Number : org.springframework.core.convert.support.CharacterToNumberFactory@30f9d9cf</span><br><span class="line">java.lang.Character -&gt; java.lang.String : org.springframework.core.convert.support.ObjectToStringConverter@2062b73e</span><br><span class="line">java.lang.Enum -&gt; java.lang.Integer : org.springframework.core.convert.support.EnumToIntegerConverter@65bd69cd</span><br><span class="line">java.lang.Enum -&gt; java.lang.String : org.springframework.core.convert.support.EnumToStringConverter@24ccca42</span><br><span class="line">java.lang.Integer -&gt; java.lang.Enum : org.springframework.core.convert.support.IntegerToEnumConverterFactory@22b0410c</span><br><span class="line">java.lang.Long -&gt; java.time.Instant : org.springframework.format.datetime.standard.DateTimeConverters$LongToInstantConverter@36c61628</span><br><span class="line">java.lang.Long -&gt; java.util.Calendar : org.springframework.format.datetime.DateFormatterRegistrar$LongToCalendarConverter@7a56bca3,java.lang.Long -&gt; java.util.Calendar : org.springframework.format.datetime.DateFormatterRegistrar$LongToCalendarConverter@32680fd1</span><br><span class="line">java.lang.Long -&gt; java.util.Date : org.springframework.format.datetime.DateFormatterRegistrar$LongToDateConverter@21f63842,java.lang.Long -&gt; java.util.Date : org.springframework.format.datetime.DateFormatterRegistrar$LongToDateConverter@3ae27639</span><br><span class="line">java.lang.Number -&gt; java.lang.Character : org.springframework.core.convert.support.NumberToCharacterConverter@37dca65c</span><br><span class="line">java.lang.Number -&gt; java.lang.Number : org.springframework.core.convert.support.NumberToNumberConverterFactory@5ad62efe</span><br><span class="line">java.lang.Number -&gt; java.lang.String : org.springframework.core.convert.support.ObjectToStringConverter@5dbb5323</span><br><span class="line">java.lang.String -&gt; @org.springframework.format.annotation.DateTimeFormat java.lang.Long: org.springframework.format.datetime.DateTimeFormatAnnotationFormatterFactory@3de4aaed,java.lang.String -&gt; @org.springframework.format.annotation.NumberFormat java.lang.Long: org.springframework.format.number.NumberFormatAnnotationFormatterFactory@806d8b</span><br><span class="line">java.lang.String -&gt; @org.springframework.format.annotation.DateTimeFormat java.time.LocalDate: org.springframework.format.datetime.standard.Jsr310DateTimeFormatAnnotationFormatterFactory@13c06099,java.lang.String -&gt; java.time.LocalDate: org.springframework.format.datetime.standard.TemporalAccessorParser@1a482c16</span><br><span class="line">java.lang.String -&gt; @org.springframework.format.annotation.DateTimeFormat java.time.LocalDateTime: org.springframework.format.datetime.standard.Jsr310DateTimeFormatAnnotationFormatterFactory@13c06099,java.lang.String -&gt; java.time.LocalDateTime: org.springframework.format.datetime.standard.TemporalAccessorParser@726b4b72</span><br><span class="line">java.lang.String -&gt; @org.springframework.format.annotation.DateTimeFormat java.time.LocalTime: org.springframework.format.datetime.standard.Jsr310DateTimeFormatAnnotationFormatterFactory@13c06099,java.lang.String -&gt; java.time.LocalTime: org.springframework.format.datetime.standard.TemporalAccessorParser@7d025d62</span><br><span class="line">java.lang.String -&gt; @org.springframework.format.annotation.DateTimeFormat java.time.OffsetDateTime: org.springframework.format.datetime.standard.Jsr310DateTimeFormatAnnotationFormatterFactory@13c06099,java.lang.String -&gt; java.time.OffsetDateTime: org.springframework.format.datetime.standard.TemporalAccessorParser@7b82b59</span><br><span class="line">java.lang.String -&gt; @org.springframework.format.annotation.DateTimeFormat java.time.OffsetTime: org.springframework.format.datetime.standard.Jsr310DateTimeFormatAnnotationFormatterFactory@13c06099,java.lang.String -&gt; java.time.OffsetTime: org.springframework.format.datetime.standard.TemporalAccessorParser@5d6bf8bc</span><br><span class="line">java.lang.String -&gt; @org.springframework.format.annotation.DateTimeFormat java.time.ZonedDateTime: org.springframework.format.datetime.standard.Jsr310DateTimeFormatAnnotationFormatterFactory@13c06099,java.lang.String -&gt; java.time.ZonedDateTime: org.springframework.format.datetime.standard.TemporalAccessorParser@4100b1dd</span><br><span class="line">java.lang.String -&gt; @org.springframework.format.annotation.DateTimeFormat java.util.Calendar: org.springframework.format.datetime.DateTimeFormatAnnotationFormatterFactory@3de4aaed</span><br><span class="line">java.lang.String -&gt; @org.springframework.format.annotation.NumberFormat java.lang.Byte: org.springframework.format.number.NumberFormatAnnotationFormatterFactory@806d8b</span><br><span class="line">java.lang.String -&gt; @org.springframework.format.annotation.NumberFormat java.lang.Double: org.springframework.format.number.NumberFormatAnnotationFormatterFactory@806d8b</span><br><span class="line">java.lang.String -&gt; @org.springframework.format.annotation.NumberFormat java.lang.Float: org.springframework.format.number.NumberFormatAnnotationFormatterFactory@806d8b</span><br><span class="line">java.lang.String -&gt; @org.springframework.format.annotation.NumberFormat java.lang.Integer: org.springframework.format.number.NumberFormatAnnotationFormatterFactory@806d8b</span><br><span class="line">java.lang.String -&gt; @org.springframework.format.annotation.NumberFormat java.lang.Short: org.springframework.format.number.NumberFormatAnnotationFormatterFactory@806d8b</span><br><span class="line">java.lang.String -&gt; @org.springframework.format.annotation.NumberFormat java.math.BigDecimal: org.springframework.format.number.NumberFormatAnnotationFormatterFactory@806d8b</span><br><span class="line">java.lang.String -&gt; @org.springframework.format.annotation.NumberFormat java.math.BigInteger: org.springframework.format.number.NumberFormatAnnotationFormatterFactory@806d8b</span><br><span class="line">java.lang.String -&gt; java.lang.Boolean : org.springframework.core.convert.support.StringToBooleanConverter@3dd765a2</span><br><span class="line">java.lang.String -&gt; java.lang.Character : org.springframework.core.convert.support.StringToCharacterConverter@4b28d17b</span><br><span class="line">java.lang.String -&gt; java.lang.Enum : org.springframework.core.convert.support.StringToEnumConverterFactory@5a85577c</span><br><span class="line">java.lang.String -&gt; java.lang.Number : org.springframework.core.convert.support.StringToNumberConverterFactory@4a4bac52</span><br><span class="line">java.lang.String -&gt; java.nio.charset.Charset : org.springframework.core.convert.support.StringToCharsetConverter@77b7395f</span><br><span class="line">java.lang.String -&gt; java.time.Duration: org.springframework.format.datetime.standard.DurationFormatter@223f8ade</span><br><span class="line">java.lang.String -&gt; java.time.Instant: org.springframework.format.datetime.standard.InstantFormatter@744a1e70</span><br><span class="line">java.lang.String -&gt; java.time.MonthDay: org.springframework.format.datetime.standard.MonthDayFormatter@48e0bd1</span><br><span class="line">java.lang.String -&gt; java.time.Period: org.springframework.format.datetime.standard.PeriodFormatter@326e1143</span><br><span class="line">java.lang.String -&gt; java.time.YearMonth: org.springframework.format.datetime.standard.YearMonthFormatter@2013283d</span><br><span class="line">java.lang.String -&gt; java.util.Currency : org.springframework.core.convert.support.StringToCurrencyConverter@73d62889</span><br><span class="line">java.lang.String -&gt; java.util.Date: cn.floyd.pw.flow.converter.ApplicationConversionServiceFactoryBean$2@c01b01e,java.lang.String -&gt; java.util.Date : cn.floyd.pw.flow.converter.ApplicationConversionServiceFactoryBean$1@bda7edf,java.lang.String -&gt; @org.springframework.format.annotation.DateTimeFormat java.util.Date: org.springframework.format.datetime.DateTimeFormatAnnotationFormatterFactory@3de4aaed</span><br><span class="line">java.lang.String -&gt; java.util.Locale : org.springframework.core.convert.support.StringToLocaleConverter@15f3ecb1</span><br><span class="line">java.lang.String -&gt; java.util.Properties : org.springframework.core.convert.support.StringToPropertiesConverter@1734f8d8</span><br><span class="line">java.lang.String -&gt; java.util.TimeZone : org.springframework.core.convert.support.StringToTimeZoneConverter@219e655b</span><br><span class="line">java.lang.String -&gt; java.util.UUID : org.springframework.core.convert.support.StringToUUIDConverter@7a2a1350</span><br><span class="line">java.nio.charset.Charset -&gt; java.lang.String : org.springframework.core.convert.support.ObjectToStringConverter@79cac565</span><br><span class="line">java.time.Duration -&gt; java.lang.String : org.springframework.format.datetime.standard.DurationFormatter@223f8ade</span><br><span class="line">java.time.Instant -&gt; java.lang.Long : org.springframework.format.datetime.standard.DateTimeConverters$InstantToLongConverter@bbf9adc</span><br><span class="line">java.time.Instant -&gt; java.lang.String : org.springframework.format.datetime.standard.InstantFormatter@744a1e70</span><br><span class="line">java.time.LocalDateTime -&gt; java.time.LocalDate : org.springframework.format.datetime.standard.DateTimeConverters$LocalDateTimeToLocalDateConverter@224c05f6</span><br><span class="line">java.time.LocalDateTime -&gt; java.time.LocalTime : org.springframework.format.datetime.standard.DateTimeConverters$LocalDateTimeToLocalTimeConverter@bb6fc38</span><br><span class="line">java.time.MonthDay -&gt; java.lang.String : org.springframework.format.datetime.standard.MonthDayFormatter@48e0bd1</span><br><span class="line">java.time.OffsetDateTime -&gt; java.time.Instant : org.springframework.format.datetime.standard.DateTimeConverters$OffsetDateTimeToInstantConverter@7e4083f</span><br><span class="line">java.time.OffsetDateTime -&gt; java.time.LocalDate : org.springframework.format.datetime.standard.DateTimeConverters$OffsetDateTimeToLocalDateConverter@1e188fca</span><br><span class="line">java.time.OffsetDateTime -&gt; java.time.LocalDateTime : org.springframework.format.datetime.standard.DateTimeConverters$OffsetDateTimeToLocalDateTimeConverter@79b804b1</span><br><span class="line">java.time.OffsetDateTime -&gt; java.time.LocalTime : org.springframework.format.datetime.standard.DateTimeConverters$OffsetDateTimeToLocalTimeConverter@178638ba</span><br><span class="line">java.time.OffsetDateTime -&gt; java.time.ZonedDateTime : org.springframework.format.datetime.standard.DateTimeConverters$OffsetDateTimeToZonedDateTimeConverter@5dd8aa91</span><br><span class="line">java.time.Period -&gt; java.lang.String : org.springframework.format.datetime.standard.PeriodFormatter@326e1143</span><br><span class="line">java.time.YearMonth -&gt; java.lang.String : org.springframework.format.datetime.standard.YearMonthFormatter@2013283d</span><br><span class="line">java.time.ZoneId -&gt; java.util.TimeZone : org.springframework.core.convert.support.ZoneIdToTimeZoneConverter@375fe360</span><br><span class="line">java.time.ZonedDateTime -&gt; java.time.Instant : org.springframework.format.datetime.standard.DateTimeConverters$ZonedDateTimeToInstantConverter@5b6ff572</span><br><span class="line">java.time.ZonedDateTime -&gt; java.time.LocalDate : org.springframework.format.datetime.standard.DateTimeConverters$ZonedDateTimeToLocalDateConverter@44caea49</span><br><span class="line">java.time.ZonedDateTime -&gt; java.time.LocalDateTime : org.springframework.format.datetime.standard.DateTimeConverters$ZonedDateTimeToLocalDateTimeConverter@748fb300</span><br><span class="line">java.time.ZonedDateTime -&gt; java.time.LocalTime : org.springframework.format.datetime.standard.DateTimeConverters$ZonedDateTimeToLocalTimeConverter@362e6386</span><br><span class="line">java.time.ZonedDateTime -&gt; java.time.OffsetDateTime : org.springframework.format.datetime.standard.DateTimeConverters$ZonedDateTimeToOffsetDateTimeConverter@4864c695</span><br><span class="line">java.time.ZonedDateTime -&gt; java.util.Calendar : org.springframework.core.convert.support.ZonedDateTimeToCalendarConverter@53757723</span><br><span class="line">java.util.Calendar -&gt; java.lang.Long : org.springframework.format.datetime.DateFormatterRegistrar$CalendarToLongConverter@3effd16f,java.util.Calendar -&gt; java.lang.Long : org.springframework.format.datetime.DateFormatterRegistrar$CalendarToLongConverter@6625da72</span><br><span class="line">java.util.Calendar -&gt; java.time.Instant : org.springframework.format.datetime.standard.DateTimeConverters$CalendarToInstantConverter@3ea63a04</span><br><span class="line">java.util.Calendar -&gt; java.time.LocalDate : org.springframework.format.datetime.standard.DateTimeConverters$CalendarToLocalDateConverter@311b3b</span><br><span class="line">java.util.Calendar -&gt; java.time.LocalDateTime : org.springframework.format.datetime.standard.DateTimeConverters$CalendarToLocalDateTimeConverter@b827cbe</span><br><span class="line">java.util.Calendar -&gt; java.time.LocalTime : org.springframework.format.datetime.standard.DateTimeConverters$CalendarToLocalTimeConverter@27334ef2</span><br><span class="line">java.util.Calendar -&gt; java.time.OffsetDateTime : org.springframework.format.datetime.standard.DateTimeConverters$CalendarToOffsetDateTimeConverter@18a5b69c</span><br><span class="line">java.util.Calendar -&gt; java.time.ZonedDateTime : org.springframework.format.datetime.standard.DateTimeConverters$CalendarToZonedDateTimeConverter@2181b391</span><br><span class="line">java.util.Calendar -&gt; java.util.Date : org.springframework.format.datetime.DateFormatterRegistrar$CalendarToDateConverter@43409a9e,java.util.Calendar -&gt; java.util.Date : org.springframework.format.datetime.DateFormatterRegistrar$CalendarToDateConverter@25a7d510</span><br><span class="line">java.util.Currency -&gt; java.lang.String : org.springframework.core.convert.support.ObjectToStringConverter@59874f76</span><br><span class="line">java.util.Date -&gt; java.lang.Long : org.springframework.format.datetime.DateFormatterRegistrar$DateToLongConverter@2d72afcb,java.util.Date -&gt; java.lang.Long : org.springframework.format.datetime.DateFormatterRegistrar$DateToLongConverter@60b0c620</span><br><span class="line">java.util.Date -&gt; java.lang.String : cn.floyd.pw.flow.converter.ApplicationConversionServiceFactoryBean$2@c01b01e,@org.springframework.format.annotation.DateTimeFormat java.util.Date -&gt; java.lang.String: org.springframework.format.datetime.DateTimeFormatAnnotationFormatterFactory@3de4aaed</span><br><span class="line">java.util.Date -&gt; java.util.Calendar : org.springframework.format.datetime.DateFormatterRegistrar$DateToCalendarConverter@635f0388,java.util.Date -&gt; java.util.Calendar : org.springframework.format.datetime.DateFormatterRegistrar$DateToCalendarConverter@7b746ecc</span><br><span class="line">java.util.Locale -&gt; java.lang.String : org.springframework.core.convert.support.ObjectToStringConverter@572faa97</span><br><span class="line">java.util.Properties -&gt; java.lang.String : org.springframework.core.convert.support.PropertiesToStringConverter@387ae6b6</span><br><span class="line">java.util.UUID -&gt; java.lang.String : org.springframework.core.convert.support.ObjectToStringConverter@19b50f9c</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>后端</category>
      </categories>
      <tags>
        <tag>Spring</tag>
        <tag>Webflow</tag>
      </tags>
  </entry>
  <entry>
    <title>Spring 和 Kotlin</title>
    <url>/2022/03/19/Spring%E5%AF%B9Kotlin%E7%9A%84%E4%B8%8D%E5%8F%8B%E5%A5%BD/</url>
    <content><![CDATA[<p>Kotlin与Java百分百互操作，顺理成章，Spring开发也可以用Kotlin。可以享受到Kotlin的简洁语法。二者结合的大部分特点，在尝试之后都能体会。本文列举一些实际开发中最容易遇到的问题。</p>
<span id="more"></span>

<h2 id="关于POJO"><a href="#关于POJO" class="headerlink" title="关于POJO"></a>关于POJO</h2><p>DTO、VO、BO、MyBatis的Entity、Spring配置文件对应的PropertiesBean，各种Bean的组装与传输。直觉告诉我们，最好定义成data class，属性最好是val，最好是不可空，但不可一概而论，需按情况分析。</p>
<ul>
<li><p>与前端交互的Bean：由于需要在前后端进行传输，需要设置为var的可空类型，且需要有一个不带任何参数的构造方法，有几点原因</p>
<ul>
<li><p>var：以@RequestBody为例，Spring框架会先创建传输对象，再进行赋值</p>
</li>
<li><p>可空：无法预测前端输入是否为空，且Spring Validate是先构建对象、为属性赋值、再进行验证，即时我们以@NotNull注释了，还是可能在赋值时报不可空的类型赋值错误，而不是@NotNull引起的验证错误</p>
</li>
<li><p>不带参的构造方法：构建空对象 - 属性赋值，是Spring框架内部的常规操作，这也广泛存在于Java的其它三方库，因为Java默认存在无参构造，但Kotlin没有，需要显式构建。这又有两种方法</p>
<ul>
<li><p>所有属性写构造方法，但都是可控类型，且赋予了默认值null</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">data</span> <span class="class"><span class="keyword">class</span> <span class="title">AppleLoginReq</span></span>(</span><br><span class="line">    <span class="meta">@ApiModelProperty(<span class="meta-string">&quot;OICD的idToken&quot;</span>, required = true)</span></span><br><span class="line">    <span class="meta">@NotBlank</span></span><br><span class="line">    <span class="keyword">var</span> identityToken: String? = <span class="literal">null</span></span><br><span class="line">)</span><br></pre></td></tr></table></figure></li>
<li><p>真无参构造</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">AppleLoginReq</span> </span>&#123;</span><br><span class="line">    <span class="meta">@ApiModelProperty(<span class="meta-string">&quot;OICD的idToken&quot;</span>, required = true)</span></span><br><span class="line">    <span class="meta">@NotBlank</span></span><br><span class="line">    <span class="keyword">var</span> identityToken: String? = <span class="literal">null</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
</ul>
</li>
<li><p>业务内传输Bean：业务内可控，依据实际需要定义为data class + val属性 + 不可空或可空类型，构造方法如实即可</p>
</li>
<li><p>配置对应的Bean：Spring<a href="https://docs.spring.io/spring-boot/docs/2.0.x/reference/html/boot-features-kotlin.html#boot-features-kotlin-configuration-properties">手册</a>中特别提到，可以用data class + lateinit var的形式，不过还是得有无参构造方法</p>
</li>
<li><p>ORM的Table对应的Bean：虽然数据表是我们定义的，但将ORM对应的Bean属性的可空性和数据表字段的可空性对齐是一件非常繁琐的事。且涉及到日后维护问题，因此建议和前端交互Bean一样，var + 可空类型 + 无参构造方法</p>
</li>
</ul>
<h2 id="val和var"><a href="#val和var" class="headerlink" title="val和var"></a>val和var</h2><p>项目中，纯业务代码能够依照Kotlin建议尽量使用val，但在与框架交互的代码中，使用var经常是唯一选择，主要原因是框架常常采用先创建对象再赋值的形式进行初始化。且赋值可能使用属性字段，也可能使用setter方法，因此，还得是var。常见的注入声明也变成了如下形式</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="meta">@DisplayName(<span class="meta-string">&quot;接口鉴权测试&quot;</span>)</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">AuthenticationTest</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 注意这里是lateinit var</span></span><br><span class="line">  <span class="meta">@Autowired</span></span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">lateinit</span> <span class="keyword">var</span> mockMvc: MockMvc</span><br></pre></td></tr></table></figure>

<h2 id="属性复制"><a href="#属性复制" class="headerlink" title="属性复制"></a>属性复制</h2><p>字段太多怎么办，属性赋值方法挺不错。考虑到原理，要求源对象的属性必须有getter方法，且，目标对象的属性必须有setter方法，否则复制不会成功</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 将类S的同名属性填充到D中</span></span><br><span class="line"><span class="comment"> * 要求源对象的属性必须有getter方法，且，目标对象的属性必须有setter方法，否则复制不会成功</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Suppress(<span class="meta-string">&quot;NULLABILITY_MISMATCH_BASED_ON_JAVA_ANNOTATIONS&quot;</span>)</span></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="type">&lt;S, D&gt;</span> D.<span class="title">fillWith</span><span class="params">(source: <span class="type">S</span>)</span></span>: D = apply &#123;</span><br><span class="line">    BeanUtils.copyProperties(source!!, <span class="keyword">this</span>!!)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="默认final的问题"><a href="#默认final的问题" class="headerlink" title="默认final的问题"></a>默认final的问题</h2><p>Spring中用到动态代理或CGLib，要求类可继承，而Kotlin具有默认final的原则，常见方式是手动标注该类为open，使用open关键字。<a href="https://kotlinlang.org/docs/all-open-plugin.html#gradle">Kotlin提供了一个插件</a>，用注解替代open。我们可以将已有注解放在这里，就啥也不必加了。</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line">allOpen &#123;</span><br><span class="line">    <span class="keyword">annotation</span>(<span class="string">&quot;io.swagger.annotations.ApiModel&quot;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="Kotlin的Spring插件"><a href="#Kotlin的Spring插件" class="headerlink" title="Kotlin的Spring插件"></a>Kotlin的Spring插件</h2><p>针对Spring的特殊要求，Kotlin提供了五个插件：三个已成熟、两个实验中</p>
<ul>
<li><a href="https://kotlinlang.org/docs/no-arg-plugin.html">自动生成无参构造方法</a></li>
<li><a href="https://kotlinlang.org/docs/all-open-plugin.html">自动为类加上open效果</a></li>
<li><a href="https://kotlinlang.org/docs/sam-with-receiver-plugin.html">将SAM当成lambda表达式使用</a></li>
</ul>
<h2 id="MyBatis-Plus的Kotlin支持"><a href="#MyBatis-Plus的Kotlin支持" class="headerlink" title="MyBatis Plus的Kotlin支持"></a>MyBatis Plus的Kotlin支持</h2><p>注意MyBatis Plus支持的kotlin DSL的使用，会简单很多，不要再手动创建QueryWrapper了、不要再手动指定字段名了</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Repository</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">BoardDao</span> : <span class="type">ServiceImpl</span>&lt;<span class="type">BoardMapper, BoardModel</span>&gt;</span>() &#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">getBySn</span><span class="params">(ownerId: <span class="type">Long</span>, sn: <span class="type">String</span>)</span></span>: BoardModel &#123;</span><br><span class="line">        <span class="keyword">return</span> ktQuery().eq(BoardModel::ownerId, ownerId).eq(BoardModel::sn, sn).one()</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">listByOwner</span><span class="params">(ownerId: <span class="type">Long</span>)</span></span>: List&lt;BoardModel&gt; &#123;</span><br><span class="line">        <span class="keyword">return</span> ktQuery().eq(BoardModel::ownerId, ownerId).list()</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>这一点放在这里有点突兀，但体现了其重要性，值得强调</p>
</blockquote>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>Spring切换Kotlin遇到的最大问题还是框架本身大量使用反射、动态代理等技术带来的，究其原因，它是依据Java特性开发的框架。这就导致并不能在Spring中非常完美地使用Kotlin的各种特性，只能发挥Kotlin **90%**的简介特性。不那么Kotlin的点，总结下就是</p>
<ul>
<li>经常使用var</li>
<li>经常使用平台类型</li>
<li>出于对值的未知不得不使用可空类型</li>
<li>必须有的无参构造、class的open关键字</li>
</ul>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ul>
<li><a href="https://docs.spring.io/spring-boot/docs/2.0.x/reference/html/boot-features-kotlin.html">Spring Kotlin Support</a></li>
<li><a href="https://github.com/sdeleuze/spring-kotlin-deepdive">Spring Kotlin Deepdive</a></li>
<li><a href="https://github.com/sdeleuze/spring-boot-kotlin-demo">Spring Boot Kotlin Demo</a></li>
<li><a href="https://spring.io/blog/2016/02/15/developing-spring-boot-applications-with-kotlin">https://spring.io/blog/2016/02/15/developing-spring-boot-applications-with-kotlin</a></li>
<li><a href="https://www.baeldung.com/kotlin/spring-boot-kotlin">https://www.baeldung.com/kotlin/spring-boot-kotlin</a></li>
</ul>
]]></content>
      <categories>
        <category>后端</category>
      </categories>
      <tags>
        <tag>Spring</tag>
        <tag>Kotlin</tag>
      </tags>
  </entry>
  <entry>
    <title>Spring源码分析 - PostProcessor们</title>
    <url>/2021/11/30/Spring%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90-PostProcessor%E4%BB%AC/</url>
    <content><![CDATA[<p><code>BeanPostProcessor</code>是Spring中参与Bean生命周期定制非常重要的一个手段，上文分析过，其执行有两个时机</p>
<ul>
<li>一前：Bean自动注入之后，自定义初始化方法调用前</li>
<li>一后：自定义方法调用之后</li>
</ul>
<p>Spring中很多重要的特性利用了<code>BeanPostProcessor</code>达成，毕竟，算来算去，Spring中整个Bean的生命周期已经足够复杂了，如果每加一个功能就要在生命周期上做文章，只会增加复杂度，而<code>BeanPostProcessor</code>则是Spring提供的一种扩展方式。与其相对的，一般用户用的可能较少的<code>BeanFactoryPostProcessor</code>是针对整个容器初始化完成后提供定制化功能的扩展，我们也要观察一下。观察的主要内容是主要实现类及其作用。</p>
<span id="more"></span>

<h2 id="BeanFactoryPostProcessor"><a href="#BeanFactoryPostProcessor" class="headerlink" title="BeanFactoryPostProcessor"></a>BeanFactoryPostProcessor</h2><p>它的调用，在<code>org.springframework.context.support.AbstractApplicationContext#refresh.564行</code>。</p>
<p>其接口及其简单：一个简单的函数式接口。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@FunctionalInterface</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">BeanFactoryPostProcessor</span> </span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">postProcessBeanFactory</span><span class="params">(ConfigurableListableBeanFactory beanFactory)</span> <span class="keyword">throws</span> BeansException</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这意味着，在容器创建后，我们能够向其中设置任何内容，也可以利用容器刚刚创建这个时机，来做一些时机上再容器全局的一些事情。</p>
<p><img src="https://gdz.oss-cn-shenzhen.aliyuncs.com/local/image-20211122183440854.png" alt="image-20211122183440854"></p>
<p>具体来说，有这么几类</p>
<h3 id="修改现有容器配置"><a href="#修改现有容器配置" class="headerlink" title="修改现有容器配置"></a>修改现有容器配置</h3><ul>
<li><p><code>AbstractDependsOnBeanFactoryPostProcessor</code>、<code>CacheManagerEntityManagerFactoryDependsOnPostProcessor</code>。强制为某些Bean显式设置依赖关系，使得不满足依赖时容器无法启动。这在自动配时会有用</p>
</li>
<li><p><code>CustomScopeConfigurer</code>，添加自定义scope，这在<code>WebSocketMessageBrokerConfigurationSupport</code>有使用</p>
</li>
<li><p><code>CustomEditorConfigurer</code>，注册一些自定义的<code>PropertyEditor</code></p>
</li>
<li><p><code>LazyInitializationBeanFactoryPostProcessor</code>，它将容器中没有指定延迟加载属性的bean定义，除以下条件的bean设置为延迟加载</p>
<ul>
<li><code>SmartInitializingSingleton</code>类型</li>
<li><code>AopInfrastructureBean</code>类型</li>
<li><code>TaskScheduler</code>类型</li>
<li><code>ScheduledExecutorService</code>类型</li>
<li>被<code>@Scheduled</code>或<code>Schedules</code>注解的类</li>
</ul>
</li>
</ul>
<h3 id="向容器中添加Bean"><a href="#向容器中添加Bean" class="headerlink" title="向容器中添加Bean"></a>向容器中添加Bean</h3><ul>
<li><code>ServletComponentRegisteringPostProcessor</code>，它创建了一个Servlet环境，注册了必要的Bean</li>
<li><code>EventListenerMethodProcessor</code>，它配合<code>SmartInitializingSingleton</code>，实现了<code>@EventListener</code>注解<ul>
<li>在容器初始化完成后，获取并持有了容器的<code>EventListenerFactory</code>、容器本身</li>
<li>在单例Bean初始化完成后，检测带有<code>@Component</code>的Bean内部是否有<code>@EventListener</code>注解的方法，如果有，则使用上一步持有的<code>EventListenerFactory</code>将该方法创建为一个<code>ApplicationListener</code>实例，然后注入容器</li>
</ul>
</li>
</ul>
<h3 id="一些全局开关"><a href="#一些全局开关" class="headerlink" title="一些全局开关"></a>一些全局开关</h3><ul>
<li><code>AspectJWeavingEnabler</code>，开启AspectJ。</li>
</ul>
<h2 id="BeanPostProcessor"><a href="#BeanPostProcessor" class="headerlink" title="BeanPostProcessor"></a>BeanPostProcessor</h2><p>它的执行时机，有两个：Bean创建后，实例化前；Bean实例化后。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">BeanPostProcessor</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">default</span> Object <span class="title">postProcessBeforeInitialization</span><span class="params">(Object bean, String beanName)</span> <span class="keyword">throws</span> BeansException </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> bean;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">default</span> Object <span class="title">postProcessAfterInitialization</span><span class="params">(Object bean, String beanName)</span> <span class="keyword">throws</span> BeansException </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> bean;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>下面是主要实现</p>
<h3 id="xxxAware"><a href="#xxxAware" class="headerlink" title="xxxAware"></a>xxxAware</h3><ul>
<li><code>ApplicationContextAwareProcessor</code>，在Bean初始化之前，调用了如下接口的setxxx方法<ul>
<li><code>EnvironmentAware</code></li>
<li><code>EmbeddedValueResolverAware</code></li>
<li><code>ResourceLoaderAware</code></li>
<li><code>ApplicationEventPublisherAware</code></li>
<li><code>MessageSourceAware</code></li>
<li><code>ApplicationContextAware</code></li>
<li><code>ApplicationStartupAware</code></li>
</ul>
</li>
<li><code>BootstrapContextAwareProcessor</code>，在Bean初始化之前，调用了如下接口的setxxx方法<ul>
<li><code>BootstrapContextAware</code></li>
</ul>
</li>
<li><code>WebApplicationContextServletContextAwareProcessor</code>，在Bean初始化之前，调用了如下接口的setxxx方法<ul>
<li><code>ServletContextAware</code></li>
<li><code>ServletConfigAware</code></li>
</ul>
</li>
</ul>
<h3 id="ConfigurationPropertiesBindingPostProcessor"><a href="#ConfigurationPropertiesBindingPostProcessor" class="headerlink" title="ConfigurationPropertiesBindingPostProcessor"></a>ConfigurationPropertiesBindingPostProcessor</h3><p>它将环境中的属性绑定到<code>@ConfigurationProperties</code>注解到的类上。比如</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="meta">@ConfigurationProperties(prefix = <span class="meta-string">&quot;aliyun&quot;</span>)</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">AliyunConfig</span> </span>&#123;</span><br><span class="line">  <span class="keyword">lateinit</span> <span class="keyword">var</span> accessKey: String</span><br><span class="line">  <span class="keyword">lateinit</span> <span class="keyword">var</span> secretKey: String</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>它能够将配置中的如下属性注入对象</p>
<figure class="highlight properties"><table><tr><td class="code"><pre><span class="line"><span class="meta">aliyun.access-key</span>=<span class="string">xxxx</span></span><br><span class="line"><span class="meta">aliyun.secret-key</span>=<span class="string">xxx</span></span><br></pre></td></tr></table></figure>

<p>来看看该类的源码</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ConfigurationPropertiesBindingPostProcessor</span> <span class="keyword">implements</span> <span class="title">BeanPostProcessor</span>, <span class="title">PriorityOrdered</span>, <span class="title">ApplicationContextAware</span>, <span class="title">InitializingBean</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">private</span> ApplicationContext applicationContext;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">private</span> BeanDefinitionRegistry registry;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">private</span> ConfigurationPropertiesBinder binder;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setApplicationContext</span><span class="params">(ApplicationContext applicationContext)</span> <span class="keyword">throws</span> BeansException </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.applicationContext = applicationContext;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">afterPropertiesSet</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.registry = (BeanDefinitionRegistry) <span class="keyword">this</span>.applicationContext.getAutowireCapableBeanFactory();</span><br><span class="line">    <span class="comment">// 创建ConfigurationPropertiesBinder，这是关键点1</span></span><br><span class="line">    <span class="keyword">this</span>.binder = ConfigurationPropertiesBinder.get(<span class="keyword">this</span>.applicationContext);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> Object <span class="title">postProcessBeforeInitialization</span><span class="params">(Object bean, String beanName)</span> <span class="keyword">throws</span> BeansException </span>&#123;</span><br><span class="line">    <span class="comment">// 关键点2：构建ConfigurationPropertiesBean</span></span><br><span class="line">    bind(ConfigurationPropertiesBean.get(<span class="keyword">this</span>.applicationContext, bean, beanName));</span><br><span class="line">    <span class="keyword">return</span> bean;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">bind</span><span class="params">(ConfigurationPropertiesBean bean)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (bean == <span class="keyword">null</span> || hasBoundValueObject(bean.getName())) &#123;</span><br><span class="line">      <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    Assert.state(bean.getBindMethod() == BindMethod.JAVA_BEAN, <span class="string">&quot;错误信息&quot;</span>);</span><br><span class="line">    <span class="comment">// 关键点3：调用binder.bind方法，完成绑定</span></span><br><span class="line">    <span class="keyword">this</span>.binder.bind(bean);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>理解它的关键，在于理解Spring的绑定机制，该机制有点复杂，不是一两句能说清的。简单来说，就是将一堆属性绑定到指定的领域模型。我们只简单地看一下上面涉及到的两个类。具体的，下一篇文章再来看。</p>
<h4 id="ConfigurationPropertiesBean"><a href="#ConfigurationPropertiesBean" class="headerlink" title="ConfigurationPropertiesBean"></a>ConfigurationPropertiesBean</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">ConfigurationPropertiesBean</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 名字，直接就是传入bean的名字</span></span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">final</span> String name;</span><br><span class="line">	<span class="comment">// 传入bean的实例</span></span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">final</span> Object instance;</span><br><span class="line">	<span class="comment">// 注解在bean实例上的ConfigurationProperties注解实例</span></span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">final</span> ConfigurationProperties annotation;</span><br><span class="line">	<span class="comment">// 绑定目标，由传入的bean实例+其它的注解构成</span></span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">final</span> Bindable&lt;?&gt; bindTarget;</span><br><span class="line">	<span class="comment">// 绑定方法，枚举，JAVA_BEAN：java bean，使用getter和setter绑定；VALUE_OBJECT：值对象，使用构造方法绑定</span></span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">final</span> BindMethod bindMethod;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">private</span> <span class="title">ConfigurationPropertiesBean</span><span class="params">(String name, Object instance, ConfigurationProperties annotation, Bindable&lt;?&gt; bindTarget)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.name = name;</span><br><span class="line">    <span class="keyword">this</span>.instance = instance;</span><br><span class="line">    <span class="keyword">this</span>.annotation = annotation;</span><br><span class="line">    <span class="keyword">this</span>.bindTarget = bindTarget;</span><br><span class="line">    <span class="keyword">this</span>.bindMethod = BindMethod.forType(bindTarget.getType().resolve());</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> ConfigurationPropertiesBean <span class="title">get</span><span class="params">(ApplicationContext applicationContext, Object bean, String beanName)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 获取bean的工厂方法，就是我们创建时指定的工厂方法，没有就为null</span></span><br><span class="line">    Method factoryMethod = findFactoryMethod(applicationContext, beanName);</span><br><span class="line">    <span class="keyword">return</span> create(beanName, bean, bean.getClass(), factoryMethod);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> ConfigurationPropertiesBean <span class="title">create</span><span class="params">(String name, Object instance, Class&lt;?&gt; type, Method factory)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 获取ConfigurationProperties注解</span></span><br><span class="line">    ConfigurationProperties annotation = findAnnotation(instance, type, factory, ConfigurationProperties.class);</span><br><span class="line">    <span class="keyword">if</span> (annotation == <span class="keyword">null</span>) &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 获取Validated注解</span></span><br><span class="line">    Validated validated = findAnnotation(instance, type, factory, Validated.class);</span><br><span class="line">    Annotation[] annotations = (validated != <span class="keyword">null</span>) ? <span class="keyword">new</span> Annotation[] &#123; annotation, validated &#125;</span><br><span class="line">    : <span class="keyword">new</span> Annotation[] &#123; annotation &#125;;</span><br><span class="line">    <span class="comment">// 解析待绑定类型：工厂方法的返回类型，或者，传入type所指定的类型</span></span><br><span class="line">    ResolvableType bindType = (factory != <span class="keyword">null</span>) ? ResolvableType.forMethodReturnType(factory) : ResolvableType.forClass(type);</span><br><span class="line">    Bindable&lt;Object&gt; bindTarget = Bindable.of(bindType).withAnnotations(annotations);</span><br><span class="line">    <span class="keyword">if</span> (instance != <span class="keyword">null</span>) &#123;</span><br><span class="line">      bindTarget = bindTarget.withExistingValue(instance);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> ConfigurationPropertiesBean(name, instance, annotation, bindTarget);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>对<code>Bindable</code>和<code>BindMethod</code>，可能有一些陌生，暂且不管，后面专门写文章介绍它</li>
<li><code>ConfigurationPropertiesBean</code>中包含的内容：目标bean实例、<code>ConfigurationProperties</code>注解、绑定目标、绑定方式</li>
<li>该类为绑定做准备</li>
</ul>
<h4 id="ConfigurationPropertiesBinder"><a href="#ConfigurationPropertiesBinder" class="headerlink" title="ConfigurationPropertiesBinder"></a>ConfigurationPropertiesBinder</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ConfigurationPropertiesBinder</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String BEAN_NAME = <span class="string">&quot;org.springframework.boot.context.internalConfigurationPropertiesBinder&quot;</span>;</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String VALIDATOR_BEAN_NAME = EnableConfigurationProperties.VALIDATOR_BEAN_NAME;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 构造方法，初始化了四个属性</span></span><br><span class="line">  ConfigurationPropertiesBinder(ApplicationContext applicationContext) &#123;</span><br><span class="line">		<span class="keyword">this</span>.applicationContext = applicationContext;</span><br><span class="line">    <span class="comment">// 获取容器的属性源</span></span><br><span class="line">		<span class="keyword">this</span>.propertySources = <span class="keyword">new</span> PropertySourcesDeducer(applicationContext).getPropertySources();</span><br><span class="line">    <span class="comment">// 从容器中获取EnableConfigurationProperties.VALIDATOR_BEAN_NAME指定的验证器</span></span><br><span class="line">		<span class="keyword">this</span>.configurationPropertiesValidator = getConfigurationPropertiesValidator(applicationContext);</span><br><span class="line">    <span class="comment">// 判定是否要遵循jsr303验证规范：&quot;javax.validation.Validator&quot;, &quot;javax.validation.ValidatorFactory&quot;, &quot;javax.validation.bootstrap.GenericBootstrap&quot; 这三个类存在，就需要遵循</span></span><br><span class="line">		<span class="keyword">this</span>.jsr303Present = ConfigurationPropertiesJsr303Validator.isJsr303Present(applicationContext);</span><br><span class="line">	&#125;</span><br><span class="line">  </span><br><span class="line">  <span class="comment">// 从容器中获取提前初始化OK的binder</span></span><br><span class="line">  <span class="function"><span class="keyword">static</span> ConfigurationPropertiesBinder <span class="title">get</span><span class="params">(BeanFactory beanFactory)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> beanFactory.getBean(BEAN_NAME, ConfigurationPropertiesBinder.class);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 那个绑定方法</span></span><br><span class="line">  BindResult&lt;?&gt; bind(ConfigurationPropertiesBean propertiesBean) &#123;</span><br><span class="line">    <span class="comment">// 绑定目标</span></span><br><span class="line">    Bindable&lt;?&gt; target = propertiesBean.asBindTarget();</span><br><span class="line">    <span class="comment">// 注解</span></span><br><span class="line">    ConfigurationProperties annotation = propertiesBean.getAnnotation();</span><br><span class="line">    <span class="comment">// 获取处理器</span></span><br><span class="line">    BindHandler bindHandler = getBindHandler(target, annotation);</span><br><span class="line">    <span class="comment">// 调用Binder.bind方法，完成绑定</span></span><br><span class="line">    <span class="keyword">return</span> getBinder().bind(annotation.prefix(), target, bindHandler);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 获取绑定处理器</span></span><br><span class="line">  <span class="keyword">private</span> &lt;T&gt; <span class="function">BindHandler <span class="title">getBindHandler</span><span class="params">(Bindable&lt;T&gt; target, ConfigurationProperties annotation)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 获取验证器：configurationPropertiesValidator、ConfigurationPropertiesJsr303Validator、自定义验证器</span></span><br><span class="line">    List&lt;Validator&gt; validators = getValidators(target);</span><br><span class="line">    <span class="comment">// 获取处理器：IgnoreTopLevelConverterNotFoundBindHandler</span></span><br><span class="line">    BindHandler handler = getHandler();</span><br><span class="line">    <span class="comment">// 根据不同条件构建不同BindHandler</span></span><br><span class="line">    handler = <span class="keyword">new</span> ConfigurationPropertiesBindHander(handler);</span><br><span class="line">    <span class="keyword">if</span> (annotation.ignoreInvalidFields()) &#123;</span><br><span class="line">      handler = <span class="keyword">new</span> IgnoreErrorsBindHandler(handler);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (!annotation.ignoreUnknownFields()) &#123;</span><br><span class="line">      UnboundElementsSourceFilter filter = <span class="keyword">new</span> UnboundElementsSourceFilter();</span><br><span class="line">      handler = <span class="keyword">new</span> NoUnboundElementsBindHandler(handler, filter);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (!validators.isEmpty()) &#123;</span><br><span class="line">      handler = <span class="keyword">new</span> ValidationBindHandler(handler, validators.toArray(<span class="keyword">new</span> Validator[<span class="number">0</span>]));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 一些额外的处理器</span></span><br><span class="line">    <span class="keyword">for</span> (ConfigurationPropertiesBindHandlerAdvisor advisor : getBindHandlerAdvisors()) &#123;</span><br><span class="line">      handler = advisor.apply(handler);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> handler;</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="comment">// 获取有效的验证器</span></span><br><span class="line">  <span class="function"><span class="keyword">private</span> List&lt;Validator&gt; <span class="title">getValidators</span><span class="params">(Bindable&lt;?&gt; target)</span> </span>&#123;</span><br><span class="line">		List&lt;Validator&gt; validators = <span class="keyword">new</span> ArrayList&lt;&gt;(<span class="number">3</span>);</span><br><span class="line">		<span class="keyword">if</span> (<span class="keyword">this</span>.configurationPropertiesValidator != <span class="keyword">null</span>) &#123;</span><br><span class="line">      <span class="comment">// 容器中的configurationPropertiesValidator</span></span><br><span class="line">			validators.add(<span class="keyword">this</span>.configurationPropertiesValidator);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span> (<span class="keyword">this</span>.jsr303Present &amp;&amp; target.getAnnotation(Validated.class) != <span class="keyword">null</span>) &#123;</span><br><span class="line">      <span class="comment">// 新建的ConfigurationPropertiesJsr303Validator</span></span><br><span class="line">			validators.add(getJsr303Validator());</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span> (target.getValue() != <span class="keyword">null</span> &amp;&amp; target.getValue().get() <span class="keyword">instanceof</span> Validator) &#123;</span><br><span class="line">      <span class="comment">// 绑定目标本身也可以是验证器</span></span><br><span class="line">			validators.add((Validator) target.getValue().get());</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">return</span> validators;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 创建Binder</span></span><br><span class="line">  <span class="function"><span class="keyword">private</span> Binder <span class="title">getBinder</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">this</span>.binder == <span class="keyword">null</span>) &#123;</span><br><span class="line">      <span class="keyword">this</span>.binder = <span class="keyword">new</span> Binder(getConfigurationPropertySources(), getPropertySourcesPlaceholdersResolver(),</span><br><span class="line">                               getConversionServices(), getPropertyEditorInitializer(), <span class="keyword">null</span>,</span><br><span class="line">                               ConfigurationPropertiesBindConstructorProvider.INSTANCE);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>.binder;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>最终还是委托给了<code>Binder</code>进行调用，<code>ConfigurationPropertiesBinder</code>只能算是一个代理，准备好绑定需要的组件，然后调用<code>Binder</code>完成绑定</li>
<li>我们看到大量的从容器中获取绑定组件的方式，却没看到什么时候在容器中创建了该bean？实际上<code>getBean()</code>方法的首次调用就完成了创建和返回两个操作</li>
<li>绑定包含了验证的过程，默认会使用两个验证器<ul>
<li><code>ConfigurationPropertiesValidator</code></li>
<li><code>ConfigurationPropertiesJsr303Validator</code></li>
</ul>
</li>
<li>支持JSR303验证规范的前提条件：同时存在如下三个类型的Bean<ul>
<li><code>Validator</code></li>
<li><code>ValidatorFactory</code></li>
<li><code>GenericBootstrap</code></li>
</ul>
</li>
</ul>
<h3 id="ApplicationListenerDetector"><a href="#ApplicationListenerDetector" class="headerlink" title="ApplicationListenerDetector"></a>ApplicationListenerDetector</h3><p><code>ApplicationListenerDetector</code>，用于检测实现了<code>ApplicationListener</code>的Bean，并将其注入容器和时间广播器。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ApplicationListenerDetector</span> <span class="keyword">implements</span> <span class="title">DestructionAwareBeanPostProcessor</span>, <span class="title">MergedBeanDefinitionPostProcessor</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">transient</span> AbstractApplicationContext applicationContext;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">transient</span> Map&lt;String, Boolean&gt; singletonNames = <span class="keyword">new</span> ConcurrentHashMap&lt;&gt;(<span class="number">256</span>);</span><br><span class="line">  </span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">postProcessMergedBeanDefinition</span><span class="params">(RootBeanDefinition beanDefinition, Class&lt;?&gt; beanType, String beanName)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 如果Bean类型是ApplicationListener的子类，则加入缓存</span></span><br><span class="line">    <span class="keyword">if</span> (ApplicationListener.class.isAssignableFrom(beanType)) &#123;</span><br><span class="line">      <span class="keyword">this</span>.singletonNames.put(beanName, beanDefinition.isSingleton());</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> Object <span class="title">postProcessAfterInitialization</span><span class="params">(Object bean, String beanName)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (bean <span class="keyword">instanceof</span> ApplicationListener) &#123;</span><br><span class="line">      <span class="comment">// 缓存里有就注册到容器中</span></span><br><span class="line">      Boolean flag = <span class="keyword">this</span>.singletonNames.get(beanName);</span><br><span class="line">      <span class="keyword">if</span> (Boolean.TRUE.equals(flag)) &#123;</span><br><span class="line">        <span class="keyword">this</span>.applicationContext.addApplicationListener((ApplicationListener&lt;?&gt;) bean);</span><br><span class="line">      &#125; <span class="keyword">else</span> <span class="keyword">if</span> (Boolean.FALSE.equals(flag)) &#123;</span><br><span class="line">        <span class="keyword">this</span>.singletonNames.remove(beanName);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> bean;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">postProcessBeforeDestruction</span><span class="params">(Object bean, String beanName)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 销毁时移除</span></span><br><span class="line">    <span class="keyword">if</span> (bean <span class="keyword">instanceof</span> ApplicationListener) &#123;</span><br><span class="line">      <span class="keyword">try</span> &#123;</span><br><span class="line">        ApplicationEventMulticaster multicaster = <span class="keyword">this</span>.applicationContext.getApplicationEventMulticaster();</span><br><span class="line">        multicaster.removeApplicationListener((ApplicationListener&lt;?&gt;) bean);</span><br><span class="line">        multicaster.removeApplicationListenerBean(beanName);</span><br><span class="line">      &#125; <span class="keyword">catch</span> (IllegalStateException ex) &#123;</span><br><span class="line">        <span class="comment">// ApplicationEventMulticaster not initialized yet - no need to remove a listener</span></span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="AutowiredAnnotationBeanPostProcessor"><a href="#AutowiredAnnotationBeanPostProcessor" class="headerlink" title="AutowiredAnnotationBeanPostProcessor"></a>AutowiredAnnotationBeanPostProcessor</h3><p>可以以该类为入口，查看整个Spring自动注入的逻辑。首先其继承结构如下。</p>
<p><img src="https://gdz.oss-cn-shenzhen.aliyuncs.com/local/image-20211129174225231.png" alt="image-20211129174225231"></p>
<p>这就意味着有以下几个扩展点可以观察</p>
<ul>
<li><p>获取到<code>MergedBeanDefinition</code>之后的执行点（关于<code>MergedBeanDefinition</code>在关于Bean的描述那篇文章讨论过，这里不再看）</p>
<p>调用点：<code>AbstractAutowireCapableBeanFactory.java:1116行，applyMergedBeanDefinitionPostProcessors()方法</code></p>
</li>
<li><p>Bean的属性读取完成之后的执行点</p>
<p>调用点：<code>AbstractAutowireCapableBeanFactory.java:1436行，polupateBean()方法</code></p>
</li>
<li><p>构建Bean实例时用于判断构造方法参数的执行点</p>
<p>调用点：<code>AbstractAutowireCapableBeanFactory.java:1302行，determineConstructorsFromBeanPostProcessors()方法</code></p>
</li>
</ul>
<p>实际上，该processor同时干预了字段注入、方法注入、构造器注入。</p>
<p>首先看其构造方法，可知，适用的注解有三个：<code>@Autowired、@Value、@Inject</code>，最后一个是适配JSR330。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AutowiredAnnotationBeanPostProcessor</span> <span class="keyword">implements</span> <span class="title">SmartInstantiationAwareBeanPostProcessor</span>, <span class="title">MergedBeanDefinitionPostProcessor</span> </span>&#123;</span><br><span class="line">  <span class="comment">// 适用注解：Autowired、Value、Inject</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="title">AutowiredAnnotationBeanPostProcessor</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="keyword">this</span>.autowiredAnnotationTypes.add(Autowired.class);</span><br><span class="line">		<span class="keyword">this</span>.autowiredAnnotationTypes.add(Value.class);</span><br><span class="line">		<span class="keyword">try</span> &#123;</span><br><span class="line">			<span class="keyword">this</span>.autowiredAnnotationTypes.add((Class&lt;? extends Annotation&gt;)ClassUtils.forName(<span class="string">&quot;javax.inject.Inject&quot;</span>, AutowiredAnnotationBeanPostProcessor.class.getClassLoader()));</span><br><span class="line">			logger.trace(<span class="string">&quot;JSR-330 &#x27;javax.inject.Inject&#x27; annotation found and supported for autowiring&quot;</span>);</span><br><span class="line">		&#125; <span class="keyword">catch</span> (ClassNotFoundException ex) &#123;</span><br><span class="line">			<span class="comment">// JSR-330 API not available - simply skip.</span></span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>然后看第一个扩展点：<code>postProcessMergedBeanDefinition()</code>，与他相关的方法全部摆出来。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">postProcessMergedBeanDefinition</span><span class="params">(RootBeanDefinition beanDefinition, Class&lt;?&gt; beanType, String beanName)</span> </span>&#123;</span><br><span class="line">  <span class="comment">// 查找用于自动注入的元数据，InjectionMetadata只是Spring的又一个抽象而已，这里不深究</span></span><br><span class="line">  InjectionMetadata metadata = findAutowiringMetadata(beanName, beanType, <span class="keyword">null</span>);</span><br><span class="line">  <span class="comment">// 忽略它做了啥</span></span><br><span class="line">  metadata.checkConfigMembers(beanDefinition);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> InjectionMetadata <span class="title">findAutowiringMetadata</span><span class="params">(String beanName, Class&lt;?&gt; clazz, <span class="meta">@Nullable</span> PropertyValues pvs)</span> </span>&#123;</span><br><span class="line">  <span class="comment">// 这里是从缓存中取，省略掉了</span></span><br><span class="line">  InjectionMetadata metadata = ...</span><br><span class="line">    ... ...</span><br><span class="line">    <span class="comment">// 真实地去构建</span></span><br><span class="line">    metadata = buildAutowiringMetadata(clazz);</span><br><span class="line">  ... ...  </span><br><span class="line">    <span class="keyword">return</span> metadata;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> InjectionMetadata <span class="title">buildAutowiringMetadata</span><span class="params">(<span class="keyword">final</span> Class&lt;?&gt; clazz)</span> </span>&#123;</span><br><span class="line">  <span class="comment">// 目标类上没有前面指定的三个注解之一，则直接忽略</span></span><br><span class="line">  <span class="keyword">if</span> (!AnnotationUtils.isCandidateClass(clazz, <span class="keyword">this</span>.autowiredAnnotationTypes)) &#123;</span><br><span class="line">    <span class="keyword">return</span> InjectionMetadata.EMPTY;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  List&lt;InjectionMetadata.InjectedElement&gt; elements = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">  Class&lt;?&gt; targetClass = clazz;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">do</span> &#123;</span><br><span class="line">    <span class="keyword">final</span> List&lt;InjectionMetadata.InjectedElement&gt; currElements = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 逐个字段扫描</span></span><br><span class="line">    ReflectionUtils.doWithLocalFields(targetClass, field -&gt; &#123;</span><br><span class="line">      <span class="comment">// 在该字段上查找自动注入的注解</span></span><br><span class="line">      MergedAnnotation&lt;?&gt; ann = findAutowiredAnnotation(field);</span><br><span class="line">      <span class="keyword">if</span> (ann != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="comment">// 静态字段忽略</span></span><br><span class="line">        <span class="keyword">if</span> (Modifier.isStatic(field.getModifiers())) &#123;</span><br><span class="line">          <span class="keyword">if</span> (logger.isInfoEnabled()) &#123;</span><br><span class="line">            logger.info(<span class="string">&quot;Autowired annotation is not supported on static fields: &quot;</span> + field);</span><br><span class="line">          &#125;</span><br><span class="line">          <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 确定是否是必须</span></span><br><span class="line">        <span class="keyword">boolean</span> required = determineRequiredStatus(ann);</span><br><span class="line">        currElements.add(<span class="keyword">new</span> AutowiredFieldElement(field, required));</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 逐个方法扫描</span></span><br><span class="line">    ReflectionUtils.doWithLocalMethods(targetClass, method -&gt; &#123;</span><br><span class="line">      <span class="comment">// 桥接方法，暂时忽略</span></span><br><span class="line">      Method bridgedMethod = BridgeMethodResolver.findBridgedMethod(method);</span><br><span class="line">      <span class="keyword">if</span> (!BridgeMethodResolver.isVisibilityBridgeMethodPair(method, bridgedMethod)) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">      &#125;</span><br><span class="line">      MergedAnnotation&lt;?&gt; ann = findAutowiredAnnotation(bridgedMethod);</span><br><span class="line">      <span class="keyword">if</span> (ann != <span class="keyword">null</span> &amp;&amp; method.equals(ClassUtils.getMostSpecificMethod(method, clazz))) &#123;</span><br><span class="line">        <span class="comment">// 静态方法忽略</span></span><br><span class="line">        <span class="keyword">if</span> (Modifier.isStatic(method.getModifiers())) &#123;</span><br><span class="line">          <span class="keyword">if</span> (logger.isInfoEnabled()) &#123;</span><br><span class="line">            logger.info(<span class="string">&quot;Autowired annotation is not supported on static methods: &quot;</span> + method);</span><br><span class="line">          &#125;</span><br><span class="line">          <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 注入的方法必须要有一个参数</span></span><br><span class="line">        <span class="keyword">if</span> (method.getParameterCount() == <span class="number">0</span>) &#123;</span><br><span class="line">          <span class="keyword">if</span> (logger.isInfoEnabled()) &#123;</span><br><span class="line">            logger.info(<span class="string">&quot;Autowired annotation should only be used on methods with parameters: &quot;</span> +</span><br><span class="line">                        method);</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 确定是否必须</span></span><br><span class="line">        <span class="keyword">boolean</span> required = determineRequiredStatus(ann);</span><br><span class="line">        <span class="comment">// 为该方法查找对应的属性描述符</span></span><br><span class="line">        PropertyDescriptor pd = BeanUtils.findPropertyForMethod(bridgedMethod, clazz);</span><br><span class="line">        currElements.add(<span class="keyword">new</span> AutowiredMethodElement(method, required, pd));</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">    elements.addAll(<span class="number">0</span>, currElements);</span><br><span class="line">    targetClass = targetClass.getSuperclass();</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">while</span> (targetClass != <span class="keyword">null</span> &amp;&amp; targetClass != Object.class);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 搞定收工</span></span><br><span class="line">  <span class="keyword">return</span> InjectionMetadata.forElements(elements, clazz);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 从一个字段或方法查找注解</span></span><br><span class="line"><span class="keyword">private</span> MergedAnnotation&lt;?&gt; findAutowiredAnnotation(AccessibleObject ao) &#123;</span><br><span class="line">  MergedAnnotations annotations = MergedAnnotations.from(ao);</span><br><span class="line">  <span class="comment">// 那三个注解依次检查一遍，有就返回</span></span><br><span class="line">  <span class="keyword">for</span> (Class&lt;? extends Annotation&gt; type : <span class="keyword">this</span>.autowiredAnnotationTypes) &#123;</span><br><span class="line">    MergedAnnotation&lt;?&gt; annotation = annotations.get(type);</span><br><span class="line">    <span class="keyword">if</span> (annotation.isPresent()) &#123;</span><br><span class="line">      <span class="keyword">return</span> annotation;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">boolean</span> <span class="title">determineRequiredStatus</span><span class="params">(MergedAnnotation&lt;?&gt; ann)</span> </span>&#123;</span><br><span class="line">  <span class="comment">// The following (AnnotationAttributes) cast is required on JDK 9+.</span></span><br><span class="line">  <span class="keyword">return</span> determineRequiredStatus((AnnotationAttributes)</span><br><span class="line">                                 ann.asMap(mergedAnnotation -&gt; <span class="keyword">new</span> AnnotationAttributes(mergedAnnotation.getType())));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">boolean</span> <span class="title">determineRequiredStatus</span><span class="params">(AnnotationAttributes ann)</span> </span>&#123;</span><br><span class="line">  <span class="comment">// this.requiredParameterName写死了是required字符串</span></span><br><span class="line">  <span class="comment">// this.requiredParameterValue写死了是true</span></span><br><span class="line">  <span class="comment">// 如果注解不包含required属性，或者required属性为true，则必须，否则非必须</span></span><br><span class="line">  <span class="keyword">return</span> (!ann.containsKey(<span class="keyword">this</span>.requiredParameterName) ||</span><br><span class="line">          <span class="keyword">this</span>.requiredParameterValue == ann.getBoolean(<span class="keyword">this</span>.requiredParameterName));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>三个注解<code>@Autowired、@Value、@Inject</code>，作用在字段或构造方法上都可以；甚至可以作用在静态字段和方法上，只不过会被忽略而已</li>
<li>作用在方法上时，该方法必须拥有参数，方法不应是setter方法</li>
<li>决定注入是否必须的条件：未指定required时默认为必须，否则指定什么就是什么</li>
</ul>
<p>然后我们来看第二个扩展点：<code>postProcessProperties（）</code>，它是执行注入的地方</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> PropertyValues <span class="title">postProcessProperties</span><span class="params">(PropertyValues pvs, Object bean, String beanName)</span> </span>&#123;</span><br><span class="line">  <span class="comment">// 这和字段扫描时调用的一个方法，不过这里会命中缓存</span></span><br><span class="line">  InjectionMetadata metadata = findAutowiringMetadata(beanName, bean.getClass(), pvs);</span><br><span class="line">  <span class="comment">// 执行注入逻辑</span></span><br><span class="line">  metadata.inject(bean, beanName, pvs);</span><br><span class="line">  <span class="keyword">return</span> pvs;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">inject</span><span class="params">(Object target, <span class="meta">@Nullable</span> String beanName, <span class="meta">@Nullable</span> PropertyValues pvs)</span> <span class="keyword">throws</span> Throwable </span>&#123;</span><br><span class="line">  <span class="comment">// checkedElements和injectedElements的含义忽略，这里关注注入即可</span></span><br><span class="line">  Collection&lt;InjectedElement&gt; checkedElements = <span class="keyword">this</span>.checkedElements;</span><br><span class="line">  Collection&lt;InjectedElement&gt; elementsToIterate = (checkedElements != <span class="keyword">null</span> ? checkedElements : <span class="keyword">this</span>.injectedElements);</span><br><span class="line">  <span class="keyword">if</span> (!elementsToIterate.isEmpty()) &#123;</span><br><span class="line">    <span class="keyword">for</span> (InjectedElement element : elementsToIterate) &#123;</span><br><span class="line">      <span class="comment">// 注入</span></span><br><span class="line">      element.inject(target, beanName, pvs);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">inject</span><span class="params">(Object target, <span class="meta">@Nullable</span> String requestingBeanName, <span class="meta">@Nullable</span> PropertyValues pvs)</span> <span class="keyword">throws</span> Throwable </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (<span class="keyword">this</span>.isField) &#123;</span><br><span class="line">    Field field = (Field) <span class="keyword">this</span>.member;</span><br><span class="line">    ReflectionUtils.makeAccessible(field);</span><br><span class="line">    <span class="comment">// 是字段时，按照字段注入，注入的资源来源比较多，这里可以当它是从容器中取的就好</span></span><br><span class="line">    field.set(target, getResourceToInject(target, requestingBeanName));</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    ... ...</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">      Method method = (Method) <span class="keyword">this</span>.member;</span><br><span class="line">      ReflectionUtils.makeAccessible(method);</span><br><span class="line">      <span class="comment">// 方法注入</span></span><br><span class="line">      method.invoke(target, getResourceToInject(target, requestingBeanName));</span><br><span class="line">    &#125; <span class="keyword">catch</span> (InvocationTargetException ex) &#123;</span><br><span class="line">      <span class="keyword">throw</span> ex.getTargetException();</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>看起来，自动注入的方法，只允许有一个参数。</li>
</ul>
<p>最后来看它是如何决定构造方法以干预实例创建的：<code>determineCandidateConstructors()</code></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> Constructor&lt;?&gt;[] determineCandidateConstructors(Class&lt;?&gt; beanClass, <span class="keyword">final</span> String beanName) <span class="keyword">throws</span> BeanCreationException &#123;</span><br><span class="line">  <span class="comment">// 缓存查询</span></span><br><span class="line">  <span class="keyword">if</span> (!<span class="keyword">this</span>.lookupMethodsChecked.contains(beanName)) &#123;</span><br><span class="line">    <span class="comment">// </span></span><br><span class="line">    <span class="keyword">if</span> (AnnotationUtils.isCandidateClass(beanClass, Lookup.class)) &#123;</span><br><span class="line">      Class&lt;?&gt; targetClass = beanClass;</span><br><span class="line">      <span class="keyword">do</span> &#123;</span><br><span class="line">        ReflectionUtils.doWithLocalMethods(targetClass, method -&gt; &#123;</span><br><span class="line">          <span class="comment">// 获取Lookup注解</span></span><br><span class="line">          Lookup lookup = method.getAnnotation(Lookup.class);</span><br><span class="line">          <span class="keyword">if</span> (lookup != <span class="keyword">null</span>) &#123;</span><br><span class="line">            LookupOverride override = <span class="keyword">new</span> LookupOverride(method, lookup.value());</span><br><span class="line">            RootBeanDefinition mbd = (RootBeanDefinition)<span class="keyword">this</span>.beanFactory.getMergedBeanDefinition(beanName);</span><br><span class="line">            <span class="comment">// 将Lookup注解的方法添加到overrides中</span></span><br><span class="line">            mbd.getMethodOverrides().addOverride(override);</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">        targetClass = targetClass.getSuperclass();</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">while</span> (targetClass != <span class="keyword">null</span> &amp;&amp; targetClass != Object.class);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">this</span>.lookupMethodsChecked.add(beanName);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  candidateConstructors = <span class="keyword">this</span>.candidateConstructorsCache.get(beanClass);</span><br><span class="line">  <span class="keyword">if</span> (candidateConstructors == <span class="keyword">null</span>) &#123;</span><br><span class="line">    Constructor&lt;?&gt;[] rawCandidates;</span><br><span class="line">    <span class="comment">// 反射获取所有的构造器</span></span><br><span class="line">    rawCandidates = beanClass.getDeclaredConstructors();</span><br><span class="line">    List&lt;Constructor&lt;?&gt;&gt; candidates = <span class="keyword">new</span> ArrayList&lt;&gt;(rawCandidates.length);</span><br><span class="line">    Constructor&lt;?&gt; requiredConstructor = <span class="keyword">null</span>;</span><br><span class="line">    Constructor&lt;?&gt; defaultConstructor = <span class="keyword">null</span>;</span><br><span class="line">    <span class="comment">// 获取主构造方法，这里主要是考虑Kotlin的主构造方法</span></span><br><span class="line">    Constructor&lt;?&gt; primaryConstructor = BeanUtils.findPrimaryConstructor(beanClass);</span><br><span class="line">    <span class="keyword">int</span> nonSyntheticConstructors = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (Constructor&lt;?&gt; candidate : rawCandidates) &#123;</span><br><span class="line">      <span class="keyword">if</span> (!candidate.isSynthetic()) &#123;</span><br><span class="line">        nonSyntheticConstructors++;</span><br><span class="line">      &#125; <span class="keyword">else</span> <span class="keyword">if</span> (primaryConstructor != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">continue</span>;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="comment">// 查看构造方法上是否存在Autowired、Value、Inject注解</span></span><br><span class="line">      MergedAnnotation&lt;?&gt; ann = findAutowiredAnnotation(candidate);</span><br><span class="line">      <span class="keyword">if</span> (ann == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="comment">// 获取用户的类：这里是考虑代理类，获取被代理的类</span></span><br><span class="line">        Class&lt;?&gt; userClass = ClassUtils.getUserClass(beanClass);</span><br><span class="line">        <span class="keyword">if</span> (userClass != beanClass) &#123;</span><br><span class="line">          <span class="keyword">try</span> &#123;</span><br><span class="line">            Constructor&lt;?&gt; superCtor = userClass.getDeclaredConstructor(candidate.getParameterTypes());</span><br><span class="line">            <span class="comment">// 查看该构造方法上是否存在Autowired、Value、Inject注解</span></span><br><span class="line">            ann = findAutowiredAnnotation(superCtor);</span><br><span class="line">          &#125; <span class="keyword">catch</span> (NoSuchMethodException ex) &#123;</span><br><span class="line">            <span class="comment">// Simply proceed, no equivalent superclass constructor found...</span></span><br><span class="line">          &#125;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">if</span> (ann != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="comment">// 查看注解是否指定required参数</span></span><br><span class="line">        <span class="keyword">boolean</span> required = determineRequiredStatus(ann);</span><br><span class="line">        <span class="keyword">if</span> (required) &#123;</span><br><span class="line">          requiredConstructor = candidate;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 只有有被那三个注解注解的构造器才会被加入candidates</span></span><br><span class="line">        candidates.add(candidate);</span><br><span class="line">      &#125; <span class="keyword">else</span> <span class="keyword">if</span> (candidate.getParameterCount() == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="comment">// 默认构造器：无参构造器</span></span><br><span class="line">        defaultConstructor = candidate;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (!candidates.isEmpty()) &#123;</span><br><span class="line">      <span class="comment">// 有被注解的构造方法，就返回</span></span><br><span class="line">      ... ...</span><br><span class="line">      candidateConstructors = candidates.toArray(<span class="keyword">new</span> Constructor&lt;?&gt;[<span class="number">0</span>]);</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (rawCandidates.length == <span class="number">1</span> &amp;&amp; rawCandidates[<span class="number">0</span>].getParameterCount() &gt; <span class="number">0</span>) &#123;</span><br><span class="line">      <span class="comment">// 就一个有参构造方法时，直接取</span></span><br><span class="line">      candidateConstructors = <span class="keyword">new</span> Constructor&lt;?&gt;[] &#123;rawCandidates[<span class="number">0</span>]&#125;;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (nonSyntheticConstructors == <span class="number">2</span> &amp;&amp; primaryConstructor != <span class="keyword">null</span> &amp;&amp;</span><br><span class="line">               defaultConstructor != <span class="keyword">null</span> &amp;&amp; !primaryConstructor.equals(defaultConstructor)) &#123;</span><br><span class="line">      <span class="comment">// 主构造方法和默认构造方法</span></span><br><span class="line">      candidateConstructors = <span class="keyword">new</span> Constructor&lt;?&gt;[] &#123;primaryConstructor, defaultConstructor&#125;;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (nonSyntheticConstructors == <span class="number">1</span> &amp;&amp; primaryConstructor != <span class="keyword">null</span>) &#123;</span><br><span class="line">      <span class="comment">// 主构造方法</span></span><br><span class="line">      candidateConstructors = <span class="keyword">new</span> Constructor&lt;?&gt;[] &#123;primaryConstructor&#125;;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="comment">// 莫有</span></span><br><span class="line">      candidateConstructors = <span class="keyword">new</span> Constructor&lt;?&gt;[<span class="number">0</span>];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">this</span>.candidateConstructorsCache.put(beanClass, candidateConstructors);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> (candidateConstructors.length &gt; <span class="number">0</span> ? candidateConstructors : <span class="keyword">null</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>该方法做了两件事：处理<code>@Lookup</code>注解、处理候选构造方法。关于<code>@Lookup</code>注解：<a href="https://www.baeldung.com/spring-lookup%EF%BC%8C%E5%AE%83%E6%B3%A8%E8%A7%A3%E5%9C%A8%E6%96%B9%E6%B3%95%E4%B8%8A%EF%BC%8C%E5%AE%B9%E5%99%A8%E4%BC%9A%E6%A0%B9%E6%8D%AE%E5%85%B6%E8%BF%94%E5%9B%9E%E5%80%BC%E4%BB%8E%E5%AE%B9%E5%99%A8%E4%B8%AD%E5%AF%BB%E6%89%BE%E5%AF%B9%E5%BA%94%E7%9A%84Bean">https://www.baeldung.com/spring-lookup，它注解在方法上，容器会根据其返回值从容器中寻找对应的Bean</a></li>
</ul>
<p>总结一下，<code>AutowiredAnnotationBeanPostProcessor</code>做了以下事情</p>
<ol>
<li>被<code>@Autowired、@Value、@Inject</code>注解的字段，会注入对应类型的实例；对被注解的方法，会将方法的参数注入对应类型的实例</li>
<li>被<code>@Lookup</code>注解的方法，返回值将不会去方法真是返回的，而是返回类型对应的容器内的Bean实例</li>
</ol>
<h3 id="RequiredAnnotationBeanPostProcessor"><a href="#RequiredAnnotationBeanPostProcessor" class="headerlink" title="RequiredAnnotationBeanPostProcessor"></a>RequiredAnnotationBeanPostProcessor</h3><blockquote>
<p>先说明：<code>@Required</code>注解已经过时了，现在推荐的使用方式是使用构造器注入，或实现自定义的<code>InitializingBean</code>。</p>
</blockquote>
<p><img src="https://gdz.oss-cn-shenzhen.aliyuncs.com/local/image-20211130112452213.png" alt="image-20211130112452213"></p>
<p>其关键逻辑比较简单：检查被<code>@Required</code>注解的字段，是否都已经找到值准备注入，如果这个时候还没有值，就会报违反“必须”的错误。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> PropertyValues <span class="title">postProcessPropertyValues</span><span class="params">(PropertyValues pvs, PropertyDescriptor[] pds, Object bean, String beanName)</span> </span>&#123;</span><br><span class="line">  <span class="comment">// 判断是否应该忽略当前bean的处理</span></span><br><span class="line">  <span class="keyword">if</span> (!shouldSkip(<span class="keyword">this</span>.beanFactory, beanName)) &#123;</span><br><span class="line">    List&lt;String&gt; invalidProperties = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">    <span class="comment">// 遍历pds，pds是当前bean的所有属性的描述符</span></span><br><span class="line">    <span class="keyword">for</span> (PropertyDescriptor pd : pds) &#123;</span><br><span class="line">      <span class="comment">// 如果属性描述符上存在@Required注解，但pvs中却不包含该属性对应的值，则该属性会报错。</span></span><br><span class="line">      <span class="keyword">if</span> (isRequiredProperty(pd) &amp;&amp; !pvs.contains(pd.getName())) &#123;</span><br><span class="line">        invalidProperties.add(pd.getName());</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 存在必须但没有值的字段，报错</span></span><br><span class="line">    <span class="keyword">if</span> (!invalidProperties.isEmpty()) &#123;</span><br><span class="line">      <span class="keyword">throw</span> <span class="keyword">new</span> BeanInitializationException(buildExceptionMessage(invalidProperties, beanName));</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> pvs;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">boolean</span> <span class="title">shouldSkip</span><span class="params">(<span class="meta">@Nullable</span> ConfigurableListableBeanFactory beanFactory, String beanName)</span> </span>&#123;</span><br><span class="line">  <span class="comment">// 容器中没有该bean，忽略</span></span><br><span class="line">  <span class="keyword">if</span> (beanFactory == <span class="keyword">null</span> || !beanFactory.containsBeanDefinition(beanName)) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  BeanDefinition beanDefinition = beanFactory.getBeanDefinition(beanName);</span><br><span class="line">  <span class="comment">// 存在该bean的工厂bean，不应该忽略</span></span><br><span class="line">  <span class="keyword">if</span> (beanDefinition.getFactoryBeanName() != <span class="keyword">null</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 存在skipRequiredCheck属性，则忽略</span></span><br><span class="line">  Object value = beanDefinition.getAttribute(SKIP_REQUIRED_CHECK_ATTRIBUTE);</span><br><span class="line">  <span class="keyword">return</span> (value != <span class="keyword">null</span> &amp;&amp; (Boolean.TRUE.equals(value) || Boolean.parseBoolean(value.toString())));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">boolean</span> <span class="title">isRequiredProperty</span><span class="params">(PropertyDescriptor propertyDescriptor)</span> </span>&#123;</span><br><span class="line">  Method setter = propertyDescriptor.getWriteMethod();</span><br><span class="line">  <span class="comment">// getRequiredAnnotationType()方法获取的就是@Required注解</span></span><br><span class="line">  <span class="keyword">return</span> (setter != <span class="keyword">null</span> &amp;&amp; AnnotationUtils.getAnnotation(setter, getRequiredAnnotationType()) != <span class="keyword">null</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="InitDestroyAnnotationBeanPostProcessor"><a href="#InitDestroyAnnotationBeanPostProcessor" class="headerlink" title="InitDestroyAnnotationBeanPostProcessor"></a>InitDestroyAnnotationBeanPostProcessor</h3><p>它其实和<code>AutowiredAnnotationBeanPostProcessor</code>类似，在<code>BeanDefinition</code>准备好后查找<code>@PostConstruct、@PreDestroy</code>，后在对应的时机调用查找好的方法。</p>
<p><img src="https://gdz.oss-cn-shenzhen.aliyuncs.com/local/image-20211130113548755.png" alt="image-20211130113548755"></p>
<p>首先是查找这些方法的点：<code>postProcessMergedBeanDefinition()</code></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">postProcessMergedBeanDefinition</span><span class="params">(RootBeanDefinition beanDefinition, Class&lt;?&gt; beanType, String beanName)</span> </span>&#123;</span><br><span class="line">  <span class="comment">// 查找生命周期元数据，即那两个注解对应的方法</span></span><br><span class="line">  LifecycleMetadata metadata = findLifecycleMetadata(beanType);</span><br><span class="line">  <span class="comment">// 忽略</span></span><br><span class="line">  metadata.checkConfigMembers(beanDefinition);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> LifecycleMetadata <span class="title">findLifecycleMetadata</span><span class="params">(Class&lt;?&gt; clazz)</span> </span>&#123;</span><br><span class="line">  ...</span><br><span class="line">  ...</span><br><span class="line">  <span class="keyword">return</span> buildLifecycleMetadata(clazz);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> LifecycleMetadata <span class="title">buildLifecycleMetadata</span><span class="params">(<span class="keyword">final</span> Class&lt;?&gt; clazz)</span> </span>&#123;</span><br><span class="line">  <span class="comment">// this.initAnnotationType 即 @PostConstruct; this.destroyAnnotationType 即 @PreDestroy</span></span><br><span class="line">  <span class="keyword">if</span> (!AnnotationUtils.isCandidateClass(clazz, Arrays.asList(<span class="keyword">this</span>.initAnnotationType, <span class="keyword">this</span>.destroyAnnotationType))) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>.emptyLifecycleMetadata;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  List&lt;LifecycleElement&gt; initMethods = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">  List&lt;LifecycleElement&gt; destroyMethods = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">  Class&lt;?&gt; targetClass = clazz;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">do</span> &#123;</span><br><span class="line">    <span class="keyword">final</span> List&lt;LifecycleElement&gt; currInitMethods = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">    <span class="keyword">final</span> List&lt;LifecycleElement&gt; currDestroyMethods = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 逐个方法遍历</span></span><br><span class="line">    ReflectionUtils.doWithLocalMethods(targetClass, method -&gt; &#123;</span><br><span class="line">      <span class="comment">// 查找所有被@PostConstruct注解的方法</span></span><br><span class="line">      <span class="keyword">if</span> (<span class="keyword">this</span>.initAnnotationType != <span class="keyword">null</span> &amp;&amp; method.isAnnotationPresent(<span class="keyword">this</span>.initAnnotationType)) &#123;</span><br><span class="line">        LifecycleElement element = <span class="keyword">new</span> LifecycleElement(method);</span><br><span class="line">        currInitMethods.add(element);</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="comment">// 查找素有被@PreDestroy注解的方法</span></span><br><span class="line">      <span class="keyword">if</span> (<span class="keyword">this</span>.destroyAnnotationType != <span class="keyword">null</span> &amp;&amp; method.isAnnotationPresent(<span class="keyword">this</span>.destroyAnnotationType)) &#123;</span><br><span class="line">        currDestroyMethods.add(<span class="keyword">new</span> LifecycleElement(method));</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">    initMethods.addAll(<span class="number">0</span>, currInitMethods);</span><br><span class="line">    destroyMethods.addAll(currDestroyMethods);</span><br><span class="line">    targetClass = targetClass.getSuperclass();</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">while</span> (targetClass != <span class="keyword">null</span> &amp;&amp; targetClass != Object.class);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 将这些方法组包装成一个LifecycleMetadata予以返回</span></span><br><span class="line">  <span class="keyword">return</span> (initMethods.isEmpty() &amp;&amp; destroyMethods.isEmpty() ? <span class="keyword">this</span>.emptyLifecycleMetadata :</span><br><span class="line">          <span class="keyword">new</span> LifecycleMetadata(clazz, initMethods, destroyMethods));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>然后是<code>@PostConstruct</code>的执行点：<code>postProcessBeforeInitialization()</code></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> Object <span class="title">postProcessBeforeInitialization</span><span class="params">(Object bean, String beanName)</span> <span class="keyword">throws</span> BeansException </span>&#123;</span><br><span class="line">  LifecycleMetadata metadata = findLifecycleMetadata(bean.getClass());</span><br><span class="line">  ... ...</span><br><span class="line">  <span class="comment">// 调用初始化方法们</span></span><br><span class="line">  metadata.invokeInitMethods(bean, beanName);</span><br><span class="line">  ... ...</span><br><span class="line">  <span class="keyword">return</span> bean;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">invokeInitMethods</span><span class="params">(Object target, String beanName)</span> <span class="keyword">throws</span> Throwable </span>&#123;</span><br><span class="line">  Collection&lt;LifecycleElement&gt; checkedInitMethods = <span class="keyword">this</span>.checkedInitMethods;</span><br><span class="line">  Collection&lt;LifecycleElement&gt; initMethodsToIterate =</span><br><span class="line">    (checkedInitMethods != <span class="keyword">null</span> ? checkedInitMethods : <span class="keyword">this</span>.initMethods);</span><br><span class="line">  <span class="keyword">if</span> (!initMethodsToIterate.isEmpty()) &#123;</span><br><span class="line">    <span class="comment">// 调用初始化方法们</span></span><br><span class="line">    <span class="keyword">for</span> (LifecycleElement element : initMethodsToIterate) &#123;</span><br><span class="line">      element.invoke(target);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>最后是<code>@PreDestroy</code>的执行点：<code>postProcessBeforeDestruction()</code></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">postProcessBeforeDestruction</span><span class="params">(Object bean, String beanName)</span> <span class="keyword">throws</span> BeansException </span>&#123;</span><br><span class="line">  LifecycleMetadata metadata = findLifecycleMetadata(bean.getClass());</span><br><span class="line">  ... ...</span><br><span class="line">  <span class="comment">// 调用销毁方法们</span></span><br><span class="line">  metadata.invokeDestroyMethods(bean, beanName);</span><br><span class="line">  ... ...</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">invokeDestroyMethods</span><span class="params">(Object target, String beanName)</span> <span class="keyword">throws</span> Throwable </span>&#123;</span><br><span class="line">  Collection&lt;LifecycleElement&gt; checkedDestroyMethods = <span class="keyword">this</span>.checkedDestroyMethods;</span><br><span class="line">  Collection&lt;LifecycleElement&gt; destroyMethodsToUse =</span><br><span class="line">    (checkedDestroyMethods != <span class="keyword">null</span> ? checkedDestroyMethods : <span class="keyword">this</span>.destroyMethods);</span><br><span class="line">  <span class="keyword">if</span> (!destroyMethodsToUse.isEmpty()) &#123;</span><br><span class="line">    <span class="keyword">for</span> (LifecycleElement element : destroyMethodsToUse) &#123;</span><br><span class="line">      element.invoke(target);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>从这个源码看来</p>
<ul>
<li>被<code>@PostConstruct、@PreDesctroy</code>注解的方法可以有多个，他们会依次执行</li>
<li>被它们注解的方法需要是无参的，就算有参，也不会给你传值</li>
</ul>
<h3 id="ScheduledAnnotationBeanPostProcessor"><a href="#ScheduledAnnotationBeanPostProcessor" class="headerlink" title="ScheduledAnnotationBeanPostProcessor"></a>ScheduledAnnotationBeanPostProcessor</h3><p><img src="https://gdz.oss-cn-shenzhen.aliyuncs.com/local/image-20211130145022089.png" alt="image-20211130145022089"></p>
<h4 id="源码分析"><a href="#源码分析" class="headerlink" title="源码分析"></a>源码分析</h4><p>大致描述一下它的工作原理：</p>
<ul>
<li>在单例初始化完成后，或收到<code>ContextRefreshEvent</code>事件后，该<code>Processor</code>需要准备好，准备的内容包括初始化用于指定定时任务的<code>Scheduler</code>，持有任务元数据的<code>ScheduledTaskRegistrar</code>；</li>
<li>在实例初始化完成后，从容器中查找带有<code>@Scheduled、@Schedules</code>注解的方法，解析定时参数，构建成任务，然后提交执行；</li>
<li>在单个实例销毁前，从缓存中删除该实例对应的定时任务</li>
<li>在容器销毁前，清空缓存的定时任务</li>
</ul>
<p>然后，我们来看准备阶段和检测阶段的代码，结束阶段就忽略掉了。先是准备阶段</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">ScheduledAnnotationBeanPostProcessor</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="comment">// ScheduledTaskRegistrar是实例初始化时创建的</span></span><br><span class="line">  <span class="keyword">this</span>.registrar = <span class="keyword">new</span> ScheduledTaskRegistrar();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onApplicationEvent</span><span class="params">(ContextRefreshedEvent event)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (event.getApplicationContext() == <span class="keyword">this</span>.applicationContext) &#123;</span><br><span class="line">    <span class="comment">// 先完成定时器和定时注册器的准备工作</span></span><br><span class="line">    finishRegistration();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">finishRegistration</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (<span class="keyword">this</span>.scheduler != <span class="keyword">null</span>) &#123;</span><br><span class="line">    <span class="keyword">this</span>.registrar.setScheduler(<span class="keyword">this</span>.scheduler);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (<span class="keyword">this</span>.beanFactory <span class="keyword">instanceof</span> ListableBeanFactory) &#123;</span><br><span class="line">    <span class="comment">// 从容器中查找SchedulingConfigurer实例，用来配置任务注册器</span></span><br><span class="line">    Map&lt;String, SchedulingConfigurer&gt; beans = ((ListableBeanFactory) <span class="keyword">this</span>.beanFactory).getBeansOfType(SchedulingConfigurer.class);</span><br><span class="line">    List&lt;SchedulingConfigurer&gt; configurers = <span class="keyword">new</span> ArrayList&lt;&gt;(beans.values());</span><br><span class="line">    AnnotationAwareOrderComparator.sort(configurers);</span><br><span class="line">    <span class="keyword">for</span> (SchedulingConfigurer configurer : configurers) &#123;</span><br><span class="line">      configurer.configureTasks(<span class="keyword">this</span>.registrar);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (<span class="keyword">this</span>.registrar.hasTasks() &amp;&amp; <span class="keyword">this</span>.registrar.getScheduler() == <span class="keyword">null</span>) &#123;</span><br><span class="line">    Assert.state(<span class="keyword">this</span>.beanFactory != <span class="keyword">null</span>, <span class="string">&quot;BeanFactory must be set to find scheduler by type&quot;</span>);</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">      <span class="comment">// 从容器中查找TaskScheduler，按类型查找</span></span><br><span class="line">      <span class="keyword">this</span>.registrar.setTaskScheduler(resolveSchedulerBean(<span class="keyword">this</span>.beanFactory, TaskScheduler.class, <span class="keyword">false</span>));</span><br><span class="line">    &#125; <span class="keyword">catch</span> (NoUniqueBeanDefinitionException ex) &#123;</span><br><span class="line">      <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">// 如果不止一个，则按照名称taskScheduler来找</span></span><br><span class="line">        <span class="keyword">this</span>.registrar.setTaskScheduler(resolveSchedulerBean(<span class="keyword">this</span>.beanFactory, TaskScheduler.class, <span class="keyword">true</span>));</span><br><span class="line">      &#125; <span class="keyword">catch</span> (NoSuchBeanDefinitionException ex2) &#123;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125; <span class="keyword">catch</span> (NoSuchBeanDefinitionException ex) &#123;</span><br><span class="line">      <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">// 如果找不到，则查找ScheduledExecutorService类型的Bean</span></span><br><span class="line">        <span class="keyword">this</span>.registrar.setScheduler(resolveSchedulerBean(<span class="keyword">this</span>.beanFactory, ScheduledExecutorService.class, <span class="keyword">false</span>));</span><br><span class="line">      &#125; <span class="keyword">catch</span> (NoUniqueBeanDefinitionException ex2) &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">          <span class="comment">// 如果不止一个，则按照名称taskScheduler来找</span></span><br><span class="line">          <span class="keyword">this</span>.registrar.setScheduler(resolveSchedulerBean(<span class="keyword">this</span>.beanFactory, ScheduledExecutorService.class, <span class="keyword">true</span>));</span><br><span class="line">        &#125; <span class="keyword">catch</span> (NoSuchBeanDefinitionException ex3) &#123;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125; <span class="keyword">catch</span> (NoSuchBeanDefinitionException ex2) &#123;</span><br><span class="line">        <span class="comment">// 实在找不到，就算了，也不报错</span></span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">this</span>.registrar.afterPropertiesSet();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>然后来看检测阶段</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> Object <span class="title">postProcessAfterInitialization</span><span class="params">(Object bean, String beanName)</span> </span>&#123;</span><br><span class="line">  <span class="comment">// 获取最终的类（如果是代理类，则获取被代理类）</span></span><br><span class="line">  Class&lt;?&gt; targetClass = AopProxyUtils.ultimateTargetClass(bean);</span><br><span class="line">  <span class="comment">// this.nonAnnotatedClasses是个缓存</span></span><br><span class="line">  <span class="comment">// 判断目标类是否被Scheduled或Schedules注解</span></span><br><span class="line">  <span class="keyword">if</span> (!<span class="keyword">this</span>.nonAnnotatedClasses.contains(targetClass) &amp;&amp;</span><br><span class="line">      AnnotationUtils.isCandidateClass(targetClass, Arrays.asList(Scheduled.class, Schedules.class))) &#123;</span><br><span class="line">    <span class="comment">// 获取所有被Scheduled注解的方法</span></span><br><span class="line">    Map&lt;Method, Set&lt;Scheduled&gt;&gt; annotatedMethods = MethodIntrospector.selectMethods(targetClass, (MethodIntrospector.MetadataLookup&lt;Set&lt;Scheduled&gt;&gt;) method -&gt; &#123;</span><br><span class="line">      Set&lt;Scheduled&gt; scheduledMethods = AnnotatedElementUtils.getMergedRepeatableAnnotations(method, Scheduled.class, Schedules.class);</span><br><span class="line">      <span class="keyword">return</span> (!scheduledMethods.isEmpty() ? scheduledMethods : <span class="keyword">null</span>);</span><br><span class="line">    &#125;);</span><br><span class="line">    <span class="keyword">if</span> (annotatedMethods.isEmpty()) &#123;</span><br><span class="line">      <span class="comment">// 缓存填充，为的是下次遇到该类时可以快速略过，提升性能</span></span><br><span class="line">      <span class="keyword">this</span>.nonAnnotatedClasses.add(targetClass);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="comment">// 处理哪些定时方法</span></span><br><span class="line">      annotatedMethods.forEach((method, scheduledMethods) -&gt; scheduledMethods.forEach(scheduled -&gt; processScheduled(scheduled, method, bean)));</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> bean;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">processScheduled</span><span class="params">(Scheduled scheduled, Method method, Object bean)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="comment">// 创建Runnable任务</span></span><br><span class="line">    Runnable runnable = createRunnable(bean, method);</span><br><span class="line">    <span class="keyword">boolean</span> processedSchedule = <span class="keyword">false</span>;</span><br><span class="line"></span><br><span class="line">    Set&lt;ScheduledTask&gt; tasks = <span class="keyword">new</span> LinkedHashSet&lt;&gt;(<span class="number">4</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Determine initial delay：解析出首次执行的延迟时间</span></span><br><span class="line">    <span class="keyword">long</span> initialDelay = scheduled.initialDelay();</span><br><span class="line">    String initialDelayString = scheduled.initialDelayString();</span><br><span class="line">    <span class="keyword">if</span> (StringUtils.hasText(initialDelayString)) &#123;</span><br><span class="line">      Assert.isTrue(initialDelay &lt; <span class="number">0</span>, <span class="string">&quot;Specify &#x27;initialDelay&#x27; or &#x27;initialDelayString&#x27;, not both&quot;</span>);</span><br><span class="line">      <span class="keyword">if</span> (<span class="keyword">this</span>.embeddedValueResolver != <span class="keyword">null</span>) &#123;</span><br><span class="line">        initialDelayString = <span class="keyword">this</span>.embeddedValueResolver.resolveStringValue(initialDelayString);</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">if</span> (StringUtils.hasLength(initialDelayString)) &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">          initialDelay = parseDelayAsLong(initialDelayString);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (RuntimeException ex) &#123;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 解析cron表达式</span></span><br><span class="line">    String cron = scheduled.cron();</span><br><span class="line">    <span class="keyword">if</span> (StringUtils.hasText(cron)) &#123;</span><br><span class="line">      String zone = scheduled.zone();</span><br><span class="line">      <span class="keyword">if</span> (<span class="keyword">this</span>.embeddedValueResolver != <span class="keyword">null</span>) &#123;</span><br><span class="line">        cron = <span class="keyword">this</span>.embeddedValueResolver.resolveStringValue(cron);</span><br><span class="line">        zone = <span class="keyword">this</span>.embeddedValueResolver.resolveStringValue(zone);</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">if</span> (StringUtils.hasLength(cron)) &#123;</span><br><span class="line">        Assert.isTrue(initialDelay == -<span class="number">1</span>, <span class="string">&quot;&#x27;initialDelay&#x27; not supported for cron triggers&quot;</span>);</span><br><span class="line">        processedSchedule = <span class="keyword">true</span>;</span><br><span class="line">        <span class="keyword">if</span> (!Scheduled.CRON_DISABLED.equals(cron)) &#123;</span><br><span class="line">          TimeZone timeZone;</span><br><span class="line">          <span class="keyword">if</span> (StringUtils.hasText(zone)) &#123;</span><br><span class="line">            timeZone = StringUtils.parseTimeZoneString(zone);</span><br><span class="line">          &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            timeZone = TimeZone.getDefault();</span><br><span class="line">          &#125;</span><br><span class="line">          <span class="comment">// 注册Cron任务</span></span><br><span class="line">          tasks.add(<span class="keyword">this</span>.registrar.scheduleCronTask(<span class="keyword">new</span> CronTask(runnable, <span class="keyword">new</span> CronTrigger(cron, timeZone))));</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// At this point we don&#x27;t need to differentiate between initial delay set or not anymore</span></span><br><span class="line">    <span class="keyword">if</span> (initialDelay &lt; <span class="number">0</span>) &#123;</span><br><span class="line">      initialDelay = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 解析fixdelay的情况，即一次性任务</span></span><br><span class="line">    <span class="keyword">long</span> fixedDelay = scheduled.fixedDelay();</span><br><span class="line">    <span class="keyword">if</span> (fixedDelay &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">      Assert.isTrue(!processedSchedule, errorMessage);</span><br><span class="line">      processedSchedule = <span class="keyword">true</span>;</span><br><span class="line">      <span class="comment">// 添加FixedDelay任务</span></span><br><span class="line">      tasks.add(<span class="keyword">this</span>.registrar.scheduleFixedDelayTask(<span class="keyword">new</span> FixedDelayTask(runnable, fixedDelay, initialDelay)));</span><br><span class="line">    &#125;</span><br><span class="line">    String fixedDelayString = scheduled.fixedDelayString();</span><br><span class="line">    <span class="keyword">if</span> (StringUtils.hasText(fixedDelayString)) &#123;</span><br><span class="line">      <span class="keyword">if</span> (<span class="keyword">this</span>.embeddedValueResolver != <span class="keyword">null</span>) &#123;</span><br><span class="line">        fixedDelayString = <span class="keyword">this</span>.embeddedValueResolver.resolveStringValue(fixedDelayString);</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">if</span> (StringUtils.hasLength(fixedDelayString)) &#123;</span><br><span class="line">        Assert.isTrue(!processedSchedule, errorMessage);</span><br><span class="line">        processedSchedule = <span class="keyword">true</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">          fixedDelay = parseDelayAsLong(fixedDelayString);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (RuntimeException ex) &#123;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 添加FixedDelay任务</span></span><br><span class="line">        tasks.add(<span class="keyword">this</span>.registrar.scheduleFixedDelayTask(<span class="keyword">new</span> FixedDelayTask(runnable, fixedDelay, initialDelay)));</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 解析固定间隔执行的情况</span></span><br><span class="line">    <span class="keyword">long</span> fixedRate = scheduled.fixedRate();</span><br><span class="line">    <span class="keyword">if</span> (fixedRate &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">      Assert.isTrue(!processedSchedule, errorMessage);</span><br><span class="line">      processedSchedule = <span class="keyword">true</span>;</span><br><span class="line">      <span class="comment">// 添加FixedRate任务</span></span><br><span class="line">      tasks.add(<span class="keyword">this</span>.registrar.scheduleFixedRateTask(<span class="keyword">new</span> FixedRateTask(runnable, fixedRate, initialDelay)));</span><br><span class="line">    &#125;</span><br><span class="line">    String fixedRateString = scheduled.fixedRateString();</span><br><span class="line">    <span class="keyword">if</span> (StringUtils.hasText(fixedRateString)) &#123;</span><br><span class="line">      <span class="keyword">if</span> (<span class="keyword">this</span>.embeddedValueResolver != <span class="keyword">null</span>) &#123;</span><br><span class="line">        fixedRateString = <span class="keyword">this</span>.embeddedValueResolver.resolveStringValue(fixedRateString);</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">if</span> (StringUtils.hasLength(fixedRateString)) &#123;</span><br><span class="line">        Assert.isTrue(!processedSchedule, errorMessage);</span><br><span class="line">        processedSchedule = <span class="keyword">true</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">          fixedRate = parseDelayAsLong(fixedRateString);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (RuntimeException ex) &#123;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 添加FixedRate任务</span></span><br><span class="line">        tasks.add(<span class="keyword">this</span>.registrar.scheduleFixedRateTask(<span class="keyword">new</span> FixedRateTask(runnable, fixedRate, initialDelay)));</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Finally register the scheduled tasks</span></span><br><span class="line">    <span class="keyword">synchronized</span> (<span class="keyword">this</span>.scheduledTasks) &#123;</span><br><span class="line">      Set&lt;ScheduledTask&gt; regTasks = <span class="keyword">this</span>.scheduledTasks.computeIfAbsent(bean, key -&gt; <span class="keyword">new</span> LinkedHashSet&lt;&gt;(<span class="number">4</span>));</span><br><span class="line">      regTasks.addAll(tasks);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125; <span class="keyword">catch</span> (IllegalArgumentException ex) &#123;</span><br><span class="line">    ... ...</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>至此，<code>Processor</code>的任务结束了，我们来看看这些任务的执行逻辑，以<code>ScheduledTaskRegistrar.scheduleFixedRateTask()</code>为例：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> ScheduledTask <span class="title">scheduleFixedRateTask</span><span class="params">(FixedRateTask task)</span> </span>&#123;</span><br><span class="line">  ScheduledTask scheduledTask = <span class="keyword">this</span>.unresolvedTasks.remove(task);</span><br><span class="line">  <span class="keyword">boolean</span> newTask = <span class="keyword">false</span>;</span><br><span class="line">  <span class="keyword">if</span> (scheduledTask == <span class="keyword">null</span>) &#123;</span><br><span class="line">    scheduledTask = <span class="keyword">new</span> ScheduledTask(task);</span><br><span class="line">    newTask = <span class="keyword">true</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> (<span class="keyword">this</span>.taskScheduler != <span class="keyword">null</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> (task.getInitialDelay() &gt; <span class="number">0</span>) &#123;</span><br><span class="line">      Date startTime = <span class="keyword">new</span> Date(<span class="keyword">this</span>.taskScheduler.getClock().millis() + task.getInitialDelay());</span><br><span class="line">      <span class="comment">// 调用的是taskScheduler的scheduleAtFixedRate</span></span><br><span class="line">      scheduledTask.future = <span class="keyword">this</span>.taskScheduler.scheduleAtFixedRate(task.getRunnable(), startTime, task.getInterval());</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      scheduledTask.future = <span class="keyword">this</span>.taskScheduler.scheduleAtFixedRate(task.getRunnable(), task.getInterval());</span><br><span class="line">    &#125;</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    addFixedRateTask(task);</span><br><span class="line">    <span class="keyword">this</span>.unresolvedTasks.put(task, scheduledTask);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> (newTask ? scheduledTask : <span class="keyword">null</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> ScheduledFuture&lt;?&gt; scheduleAtFixedRate(Runnable task, Date startTime, <span class="keyword">long</span> period) &#123;</span><br><span class="line">  <span class="comment">// 获取ScheduledExecutorService</span></span><br><span class="line">  ScheduledExecutorService executor = getScheduledExecutor();</span><br><span class="line">  <span class="keyword">long</span> initialDelay = startTime.getTime() - <span class="keyword">this</span>.clock.millis();</span><br><span class="line">  <span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="comment">// 提交固定速率的任务</span></span><br><span class="line">    <span class="keyword">return</span> executor.scheduleAtFixedRate(errorHandlingTask(task, <span class="keyword">true</span>), initialDelay, period, TimeUnit.MILLISECONDS);</span><br><span class="line">  &#125; <span class="keyword">catch</span> (RejectedExecutionException ex) &#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> TaskRejectedException(<span class="string">&quot;Executor [&quot;</span> + executor + <span class="string">&quot;] did not accept task: &quot;</span> + task, ex);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="定时器如何生效"><a href="#定时器如何生效" class="headerlink" title="定时器如何生效"></a>定时器如何生效</h4><p>定时器默认不生效，当需要使用时，通过<code>@EnableScheduling</code>引入，其最终结果是向容器中声明了<code>ScheduledAnnotationBeanPostProcessor</code>实例。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// EnableScheduling注解引入了SchedulingConfiguration配置类</span></span><br><span class="line"><span class="meta">@Target(ElementType.TYPE)</span></span><br><span class="line"><span class="meta">@Retention(RetentionPolicy.RUNTIME)</span></span><br><span class="line"><span class="meta">@Import(SchedulingConfiguration.class)</span></span><br><span class="line"><span class="meta">@Documented</span></span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> EnableScheduling &#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// SchedulingConfiguration配置类创建了ScheduledAnnotationBeanPostProcessor实例Bean，而它，我们上面已经分析过了</span></span><br><span class="line"><span class="meta">@Configuration(proxyBeanMethods = false)</span></span><br><span class="line"><span class="meta">@Role(BeanDefinition.ROLE_INFRASTRUCTURE)</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SchedulingConfiguration</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Bean(name = TaskManagementConfigUtils.SCHEDULED_ANNOTATION_PROCESSOR_BEAN_NAME)</span></span><br><span class="line">  <span class="meta">@Role(BeanDefinition.ROLE_INFRASTRUCTURE)</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> ScheduledAnnotationBeanPostProcessor <span class="title">scheduledAnnotationProcessor</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> ScheduledAnnotationBeanPostProcessor();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="其它"><a href="#其它" class="headerlink" title="其它"></a>其它</h3><p>还有两个非常重要的内容：<code>BeanValidationPostProcessor</code>、AOP相关处理器，涉及内容较多，将单独来看，这里忽略。</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>本文介绍了通过<code>BeanPostProcessor</code>实现的几个关键内容：配置绑定类、事件监听器的侦测、自动注入的实现、初始化和销毁注解的实现、定时任务的实现等。</p>
]]></content>
      <categories>
        <category>Spring</category>
      </categories>
      <tags>
        <tag>Spring</tag>
      </tags>
  </entry>
  <entry>
    <title>Vert.x - Web API Contract的错误处理</title>
    <url>/2020/03/14/Vert.x%20-%20Web%20API%20Contract%E7%9A%84%E9%94%99%E8%AF%AF%E5%A4%84%E7%90%86-vertx-webapicontract%E7%9A%84%E9%94%99%E8%AF%AF%E5%A4%84%E7%90%86/</url>
    <content><![CDATA[<p>Vert.x Web API Contract模块在Vert.x Web的基础上进行扩展，支持OpenAPI 3.0规范。</p>
<p>使用上有两种方式</p>
<ul>
<li><p>编程方式</p>
<p>预定义<code>HTTPRequestValidationHandler</code>，并在route中传入，就像<a href="https://vertx.io/docs/vertx-web-api-contract/java/">手册给的那样</a></p>
</li>
<li><p>配置文件方式</p>
<p>预先定义好接口描述文件，通过<code>OpenAPI3RouterFactory</code>加载并挂载到Router上</p>
<span id="more"></span>

<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">val</span> openAPI3RouterFactoryList = mutableListOf&lt;OpenAPI3RouterFactory&gt;()</span><br><span class="line">listOf(</span><br><span class="line">    <span class="string">&quot;/webroot/swagger/openapi-admin.yaml&quot;</span></span><br><span class="line">).forEach &#123; configPath -&gt;</span><br><span class="line">           awaitResult&lt;OpenAPI3RouterFactory&gt; &#123;</span><br><span class="line">               OpenAPI3RouterFactory.create(vertx, configPath, it)</span><br><span class="line">           &#125;.apply &#123;</span><br><span class="line">               openAPI3RouterFactoryList.add(<span class="keyword">this</span>)</span><br><span class="line">           &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">val</span> mainRouter = Router.router(vertx)</span><br><span class="line">openAPI3RouterFactoryList.forEach &#123; routerFactory -&gt;</span><br><span class="line">      mainRouter.mountSubRouter(<span class="string">&quot;/&quot;</span>, routerFactory.mountServicesFromExtensions()..router)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>通过这种方式加载，Vert.x能够自动解析描述文件，提供自动挂载验证handler和securityHandler的能力，在请求不符合配置文件定义的约束时，能够自动以合适的状态码回绝用户请求。</p>
</li>
</ul>
<h1 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h1><p>使用配置文件方式生成Route，不增加额外Handler的情况下，在遇到验证失败或空指针异常之类的情况时，Vert.x处理验证错误和内部错误的方式是直接报400 Bad Request和500 Internal Error，没有任何附加信息，日志上也不会有任何输出，这为问题排查和API使用者都是很不友好的方式。</p>
<p><img src="https://www.tapd.cn/tfl/pictures/202003/tapd_61207716_1584160209_25.png" alt="image-20200314115204080"></p>
<h1 id="解决方案"><a href="#解决方案" class="headerlink" title="解决方案"></a>解决方案</h1><p>通过查看手册和源码跟踪，找到如下处理方式，在Router上挂载一个全局的400和500错误处理器，对错误信息进行详细解析</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">val</span> OpenAPIErrorTypeMap = mapOf(</span><br><span class="line">  Pair(ValidationException.ErrorType.NO_MATCH, <span class="string">&quot;格式错误&quot;</span>),</span><br><span class="line">  Pair(ValidationException.ErrorType.NOT_FOUND, <span class="string">&quot;缺失&quot;</span>),</span><br><span class="line">  Pair(ValidationException.ErrorType.UNEXPECTED_ARRAY, <span class="string">&quot;不应为数组&quot;</span>),</span><br><span class="line">  Pair(ValidationException.ErrorType.UNEXPECTED_SINGLE_STRING, <span class="string">&quot;必须为数组&quot;</span>),</span><br><span class="line">  Pair(ValidationException.ErrorType.FILE_NOT_FOUND, <span class="string">&quot;文件未找到&quot;</span>),</span><br><span class="line">  Pair(ValidationException.ErrorType.WRONG_CONTENT_TYPE, <span class="string">&quot;请求头Content-Type错误&quot;</span>),</span><br><span class="line">  Pair(ValidationException.ErrorType.EMPTY_VALUE, <span class="string">&quot;值不应为空&quot;</span>),</span><br><span class="line">  Pair(ValidationException.ErrorType.UNEXPECTED_ARRAY_SIZE, <span class="string">&quot;数组容量不匹配&quot;</span>),</span><br><span class="line">  Pair(ValidationException.ErrorType.DESERIALIZATION_ERROR, <span class="string">&quot;反序列化失败&quot;</span>),</span><br><span class="line">  Pair(ValidationException.ErrorType.OBJECT_FIELD_NOT_FOUND, <span class="string">&quot;缺失&quot;</span>),</span><br><span class="line">  Pair(ValidationException.ErrorType.JSON_NOT_PARSABLE, <span class="string">&quot;JSON无法解析&quot;</span>),</span><br><span class="line">  Pair(ValidationException.ErrorType.JSON_INVALID, <span class="string">&quot;格式错误&quot;</span>),</span><br><span class="line">  Pair(ValidationException.ErrorType.XML_INVALID, <span class="string">&quot;格式错误&quot;</span>)</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 针对OpenAPI的参数校验错误</span></span><br><span class="line">mainRouter.errorHandler(<span class="number">400</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> (it.failure() <span class="keyword">is</span> ValidationException) &#123;</span><br><span class="line">        <span class="keyword">val</span> failure = it.failure() <span class="keyword">as</span> ValidationException</span><br><span class="line">        <span class="keyword">val</span> msg = JsonObject()</span><br><span class="line">        .put(<span class="string">&quot;errCode&quot;</span>, <span class="string">&quot;BadRequest&quot;</span>)</span><br><span class="line">        .put(<span class="string">&quot;errMsg&quot;</span>, it.failure().message)</span><br><span class="line">        .put(<span class="string">&quot;userMsg&quot;</span>, <span class="string">&quot;请求参数 <span class="subst">$&#123;failure.parameterName()&#125;</span> <span class="subst">$&#123;OpenAPIErrorTypeMap[failure.type()]&#125;</span>&quot;</span>)</span><br><span class="line">        it.response()</span><br><span class="line">        .setStatusCode(it.statusCode())</span><br><span class="line">        .putHeader(<span class="string">&quot;Content-type&quot;</span>, <span class="string">&quot;application/json&quot;</span>)</span><br><span class="line">        .putHeader(<span class="string">&quot;Content-length&quot;</span>, <span class="string">&quot;<span class="subst">$&#123;msg.toString().toByteArray().size&#125;</span>&quot;</span>)</span><br><span class="line">        .write(msg.toBuffer()).end()</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如此，若再发生请求参数验证错误，将给出明确的问题所在，而不是靠猜测。</p>
<p><img src="https://www.tapd.cn/tfl/pictures/202003/tapd_61207716_1584160224_3.png" alt="image-20200314115352490"></p>
<h1 id="方案出处"><a href="#方案出处" class="headerlink" title="方案出处"></a>方案出处</h1><p>遇到这个问题时，我个人倾向于Vert.x应该会提供一个打印详细报错信息的开关之类的东西，但在手册中并没有找到，于是通过源码定位到如下报错地点。</p>
<p><code>io.vertx.ext.web.api.validation.impl.BaseValidationHandler#handle()</code></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">handle</span><span class="params">(RoutingContext routingContext)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">      RequestParametersImpl parsedParameters = <span class="keyword">new</span> RequestParametersImpl();</span><br><span class="line"></span><br><span class="line">      parsedParameters.setPathParameters(validatePathParams(routingContext));</span><br><span class="line">      parsedParameters.setQueryParameters(validateQueryParams(routingContext));</span><br><span class="line">      parsedParameters.setHeaderParameters(validateHeaderParams(routingContext));</span><br><span class="line">      parsedParameters.setCookieParameters(validateCookieParams(routingContext));</span><br><span class="line">      </span><br><span class="line">      <span class="comment">// . . . . . .</span></span><br><span class="line">      </span><br><span class="line">      routingContext.next();</span><br><span class="line">    &#125; <span class="keyword">catch</span> (ValidationException e) &#123;</span><br><span class="line">      routingContext.fail(<span class="number">400</span>, e);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>

<p>可以看到，在验证失败时，它直接将routingContext设置为了400错误，并将异常一并传入，查看routingContext.fail()方法定义，明确说明，如果没有任何错误处理器对该状态码进行处理，将直接向客户端响应状态码对应的默认响应，对于400的默认响应，就是statucode=400和statusmessage=Bad Request</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Fail the context with the specified throwable and the specified the status code.</span></span><br><span class="line"><span class="comment"> * &lt;p&gt;</span></span><br><span class="line"><span class="comment"> * This will cause the router to route the context to any matching failure handlers for the request. If no failure handlers</span></span><br><span class="line"><span class="comment"> * match It will trigger the error handler matching the status code. You can define such error handler with</span></span><br><span class="line"><span class="comment"> * &#123;<span class="doctag">@link</span> Router#errorHandler(int, Handler)&#125;. If no error handler is not defined, It will send a default failure response with provided status code.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> statusCode the HTTP status code</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> throwable a throwable representing the failure</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">fail</span><span class="params">(<span class="keyword">int</span> statusCode, Throwable throwable)</span></span>;</span><br></pre></td></tr></table></figure>

<p>因此，就此处来讲，定义针对400的处理器是非常有必要的，同时也是<a href="https://vertx.io/docs/vertx-web-api-contract/java/">官方推荐的处理方式</a>，官方文档中特意提到了错误处理的管理方式，有如下两种，很明显，对于很多path的情况，使用第二种更好。</p>
<ul>
<li><p>单独为一个路径增加错误处理器</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">router.get(<span class="string">&quot;/awesome/:pathParam&quot;</span>)</span><br><span class="line">  <span class="comment">// Mount validation handler</span></span><br><span class="line">  .handler(validationHandler)</span><br><span class="line">  <span class="comment">//Mount your handler</span></span><br><span class="line">  .handler((routingContext) -&gt; &#123;</span><br><span class="line">    <span class="comment">// Your logic</span></span><br><span class="line">  &#125;)</span><br><span class="line">  <span class="comment">//Mount your failure handler to manage the validation failure at path level</span></span><br><span class="line">  .failureHandler((routingContext) -&gt; &#123;</span><br><span class="line">    Throwable failure = routingContext.failure();</span><br><span class="line">    <span class="keyword">if</span> (failure <span class="keyword">instanceof</span> ValidationException) &#123;</span><br><span class="line">      <span class="comment">// Something went wrong during validation!</span></span><br><span class="line">      String validationErrorMessage = failure.getMessage();</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;);</span><br></pre></td></tr></table></figure></li>
<li><p>为一个状态码增加错误处理器</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Manage the validation failure for all routes in the router</span></span><br><span class="line">router.errorHandler(<span class="number">400</span>, routingContext -&gt; &#123;</span><br><span class="line">  <span class="keyword">if</span> (routingContext.failure() <span class="keyword">instanceof</span> ValidationException) &#123;</span><br><span class="line">    <span class="comment">// Something went wrong during validation!</span></span><br><span class="line">    String validationErrorMessage = routingContext.failure().getMessage();</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="comment">// Unknown 400 failure happened</span></span><br><span class="line">    routingContext.response().setStatusCode(<span class="number">400</span>).end();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></li>
</ul>
<h1 id="延伸"><a href="#延伸" class="headerlink" title="延伸"></a>延伸</h1><p>关于在Router上为某个特定的状态码增加错误处理器的处理，不仅在于此处，个人认为是可以通用的，对高频发生的状态码，可以这样增加一个全局处理器，使得不至于丢失错误信息。</p>
<p>此外，这也衍生出另一个问题，Vert.x的全局错误处理，对于运行中错误的漏网之鱼，要定义合适有效的全局处理器，使得不放过任何错误，这一点要注意。</p>
<h1 id="参考文档"><a href="#参考文档" class="headerlink" title="参考文档"></a>参考文档</h1><ol>
<li><p><a href="https://vertx.io/docs/vertx-web-api-contract/java/">Vert.x Web API Contract</a></p>
</li>
<li><p><a href="https://swagger.io/specification/">Swagger OpenAPI Specification</a></p>
</li>
</ol>
]]></content>
      <categories>
        <category>响应式</category>
      </categories>
      <tags>
        <tag>Vert.x</tag>
      </tags>
  </entry>
  <entry>
    <title>Vert.x源码解析 - Core</title>
    <url>/2020/10/03/Vert.x%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90%20-%20Core-vertx-yuan-ma-jie-xi--core/</url>
    <content><![CDATA[<blockquote>
<p>希望通过本文的解析，让读者了解Vertx的关键部分的实现原理。对诸如如下问题有一个具象的认识。</p>
<ul>
<li>Vertx实例的作用？一个应用是否只对应一个Vertx实例？</li>
<li>Verticle是一个怎样的存在？</li>
<li>本地模式下消息是如何在EventBus上传输和响应的？</li>
<li>EventBus和EventLoop是如何关联起来的？</li>
</ul>
</blockquote>
<span id="more"></span>

<h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p>Vert.x是一个事件驱动，基于Netty库构建的高性能应用程序框架。实现了所谓的Multi-Reactor模型，能够充分利用多核CPU实现以事件循环为基础的基本编程模型。同时在此基础上构建了Verticle这样类似Actor的概念，以应对并发编程的需求。</p>
<p>Vert.x的核心为EventBus和EventLoop，前者用户消息传输，作为联通各个Handler的神经系统；后者作为任务执行的调度者，保证高性能。任何使用Vert.x构建的应用，都必须围绕这二者作文章。否则就失去了使用它的意义。</p>
<h2 id="核心类"><a href="#核心类" class="headerlink" title="核心类"></a><strong>核心类</strong></h2><h3 id="Vertx"><a href="#Vertx" class="headerlink" title="Vertx"></a>Vertx</h3><p>Vertx是最为核心的类，创建任何Vertx组件几乎都需要Vertx类的实例。</p>
<p>创建一个单机实例的方法是<code>Vertx.vertx()</code>，然后就可以使用了。以此为入口，我们看看Vertx在创建时都做了什么。</p>
<h4 id="看继承关系"><a href="#看继承关系" class="headerlink" title="看继承关系"></a>看继承关系</h4><p>Vertx是一个接口，VertxImpl是最终实现类，也是唯一的实现类。其中包含了单机和集群两种模式的实现。</p>
<p><img src="https://img-blog.csdnimg.cn/20201003110710869.png#pic_center" alt="在这里插入图片描述"></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 单机实现，创建返回VertxImpl即可</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> VertxImpl <span class="title">vertx</span><span class="params">(VertxOptions options, Transport transport)</span> </span>&#123;</span><br><span class="line">    VertxImpl vertx = <span class="keyword">new</span> VertxImpl(options, transport);</span><br><span class="line">    vertx.init();</span><br><span class="line">    <span class="keyword">return</span> vertx;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 集群实现，创建并加入集群</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">clusteredVertx</span><span class="params">(VertxOptions options, Transport transport, Handler&lt;AsyncResult&lt;Vertx&gt;&gt; resultHandler)</span> </span>&#123;</span><br><span class="line">    VertxImpl vertx = <span class="keyword">new</span> VertxImpl(options, transport);</span><br><span class="line">    vertx.joinCluster(options, resultHandler);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="看Vertx接口的功能"><a href="#看Vertx接口的功能" class="headerlink" title="看Vertx接口的功能"></a>看Vertx接口的功能</h4><p>从Vertx接口，看Vertx能干啥。图太长，不方便放，这里只列举核心部分，也是我们用得最多的。</p>
<ul>
<li>创建单机/集群版的Vertx实例</li>
<li>创建或获取上下文Context</li>
<li>指定特定的Handler运行在当前上下文中</li>
<li>获取EventBus</li>
<li>获取共享数据</li>
<li>设定定时任务</li>
<li>发布Verticle</li>
<li>执行阻塞方法</li>
</ul>
<p><img src="https://img-blog.csdnimg.cn/20201003110732393.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3pvdTg5NDQ=,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"><br>如上，Vertx类几乎撑起了所有部分。接着我们看它是如何做到的。</p>
<h4 id="看VertxImpl构造方法"><a href="#看VertxImpl构造方法" class="headerlink" title="看VertxImpl构造方法"></a>看VertxImpl构造方法</h4><p>VertxImpl在构造时创建了很多私有对象，具体如下。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="title">VertxImpl</span><span class="params">(VertxOptions options, Transport transport)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 创建closeHooks，CloseHooks维护了一个Closeable的Set，可向其中添加、移除任务，还有执行所有钩子的run方法啦。</span></span><br><span class="line">    closeHooks = <span class="keyword">new</span> CloseHooks(log);</span><br><span class="line">    <span class="comment">// 创建线程阻塞检查器，它启动一个名为vertx-blocked-thread-checker的定时器，</span></span><br><span class="line">    checker = <span class="keyword">new</span> BlockedThreadChecker(options.getBlockedThreadCheckInterval(), options.getBlockedThreadCheckIntervalUnit(), options.getWarningExceptionTime(), options.getWarningExceptionTimeUnit());</span><br><span class="line">    <span class="comment">// 指定一个EventLoop最长可以连续执行多久</span></span><br><span class="line">    maxEventLoopExTime = options.getMaxEventLoopExecuteTime();</span><br><span class="line">    maxEventLoopExecTimeUnit = options.getMaxEventLoopExecuteTimeUnit();</span><br><span class="line">    <span class="comment">// 创建EventLoop线程工厂，主要用于指定线程名称和线程阻塞检测器</span></span><br><span class="line">    eventLoopThreadFactory = <span class="keyword">new</span> VertxThreadFactory(<span class="string">&quot;vert.x-eventloop-thread-&quot;</span>, checker, <span class="keyword">false</span>, maxEventLoopExTime, maxEventLoopExecTimeUnit);</span><br><span class="line">    <span class="comment">// 创建EventLoopGroup，它又实际创建了NioEventLoopGroup，它是Netty的组件。一个EventLoopGroup，就是一个EventLoop组。在Netty中，一个EventLoop是线程和IO的结合，一个EventLoop始终绑定在同一个线程上。</span></span><br><span class="line">    eventLoopGroup = transport.eventLoopGroup(Transport.IO_EVENT_LOOP_GROUP, options.getEventLoopPoolSize(), eventLoopThreadFactory, NETTY_IO_RATIO);</span><br><span class="line">    <span class="comment">// 创建一个acceptor EventLoopGroup，创建方式和上面类似。</span></span><br><span class="line">    ThreadFactory acceptorEventLoopThreadFactory = <span class="keyword">new</span> VertxThreadFactory(<span class="string">&quot;vert.x-acceptor-thread-&quot;</span>, checker, <span class="keyword">false</span>, options.getMaxEventLoopExecuteTime(), options.getMaxEventLoopExecuteTimeUnit());</span><br><span class="line">    acceptorEventLoopGroup = transport.eventLoopGroup(Transport.ACCEPTOR_EVENT_LOOP_GROUP, <span class="number">1</span>, acceptorEventLoopThreadFactory, <span class="number">100</span>);</span><br><span class="line">    <span class="comment">// 创建worker线程池</span></span><br><span class="line">    ExecutorService workerExec = <span class="keyword">new</span> ThreadPoolExecutor(workerPoolSize, workerPoolSize,</span><br><span class="line">                                                        <span class="number">0L</span>, TimeUnit.MILLISECONDS, <span class="keyword">new</span> LinkedTransferQueue&lt;&gt;(),</span><br><span class="line">                                                        <span class="keyword">new</span> VertxThreadFactory(<span class="string">&quot;vert.x-worker-thread-&quot;</span>, checker, <span class="keyword">true</span>, options.getMaxWorkerExecuteTime(), options.getMaxWorkerExecuteTimeUnit()));</span><br><span class="line">    PoolMetrics workerPoolMetrics = metrics != <span class="keyword">null</span> ? metrics.createPoolMetrics(<span class="string">&quot;worker&quot;</span>, <span class="string">&quot;vert.x-worker-thread&quot;</span>, 	options.getWorkerPoolSize()) : <span class="keyword">null</span>;</span><br><span class="line">    workerPool = <span class="keyword">new</span> WorkerPool(workerExec, workerPoolMetrics);</span><br><span class="line">    <span class="comment">// 创建inertnal阻塞线程池</span></span><br><span class="line">    ExecutorService internalBlockingExec = Executors.newFixedThreadPool(options.getInternalBlockingPoolSize(),</span><br><span class="line">                                                                        <span class="keyword">new</span> VertxThreadFactory(<span class="string">&quot;vert.x-internal-blocking-&quot;</span>, checker, <span class="keyword">true</span>, options.getMaxWorkerExecuteTime(), options.getMaxWorkerExecuteTimeUnit()));</span><br><span class="line">    internalBlockingPool = <span class="keyword">new</span> WorkerPool(internalBlockingExec, internalBlockingPoolMetrics);</span><br><span class="line">    <span class="comment">// 创建文件解析器，在FileSystem中有使用，进行文件操作时使用的是java nio</span></span><br><span class="line">    <span class="keyword">this</span>.fileResolver = <span class="keyword">new</span> FileResolver(options.getFileSystemOptions());</span><br><span class="line">    <span class="comment">// 创建地址解析器，在DNS解析时会用到</span></span><br><span class="line">    <span class="keyword">this</span>.addressResolver = <span class="keyword">new</span> AddressResolver(<span class="keyword">this</span>, options.getAddressResolverOptions());</span><br><span class="line">    <span class="comment">// 创建发布管理器，用于发布Verticle</span></span><br><span class="line">    <span class="keyword">this</span>.deploymentManager = <span class="keyword">new</span> DeploymentManager(<span class="keyword">this</span>);</span><br><span class="line">    <span class="keyword">if</span> (options.getEventBusOptions().isClustered()) &#123;</span><br><span class="line">        <span class="comment">// 创建集群管理器和集群的EventBus</span></span><br><span class="line">        <span class="keyword">this</span>.clusterManager = getClusterManager(options);</span><br><span class="line">        <span class="keyword">this</span>.eventBus = <span class="keyword">new</span> ClusteredEventBus(<span class="keyword">this</span>, options, clusterManager);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// 创建本地EventBus</span></span><br><span class="line">        <span class="keyword">this</span>.clusterManager = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">this</span>.eventBus = <span class="keyword">new</span> EventBusImpl(<span class="keyword">this</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 创建sharedData，允许你在整个应用中共享你的数据，包括集群范围内</span></span><br><span class="line">    <span class="keyword">this</span>.sharedData = <span class="keyword">new</span> SharedDataImpl(<span class="keyword">this</span>, clusterManager);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上面太复杂，整理成思维导图会好看很多。</p>
<p><img src="https://img-blog.csdnimg.cn/20201003110752755.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3pvdTg5NDQ=,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"><br>EventBus用于进行消息传输；</p>
<p>EventLoopGroup为事件循环组，是Netty库中的类，每当有新的任务都会被提交到该组中执行；</p>
<p>而另一个EventLoopGroup——acceptorEventLoopGroup专用于网络服务的创建，目的是避免上面的eventLoopGroup的阻塞造成服务响应不及时；</p>
<p>WorkerPool为单独开的线程池，负责执行阻塞操作；</p>
<p>FileSystem用于操作文件；</p>
<p>AddressResolver用于进行DNS地址解析；</p>
<p>SharedData用于在整个Vertx应用内部共享数据，包括集群模式；</p>
<p>ClusterManager用于进行集群管理；</p>
<p>DeploymentManager和VerticleManager用于发布Verticle，保证Verticle的特性。</p>
<p>所有上述类你可能都不是很熟悉，没关系，先有个印象，下面分析具体场景时会用到。</p>
<h3 id="EventBus"><a href="#EventBus" class="headerlink" title="EventBus"></a>EventBus</h3><p>EventBus的继承关系也很简单，其单机版实现类为EventBusImpl，ClusteredEventBus继承自它，除了服务监听和远程调用，均使用了EventBusImpl中的方法。</p>
<p><img src="https://img-blog.csdnimg.cn/20201003110812514.png#pic_center" alt="在这里插入图片描述"></p>
<p>EventBus的能力，以及EventBusImpl持有对象如下：<br><img src="https://img-blog.csdnimg.cn/20201003110827811.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3pvdTg5NDQ=,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"></p>
<p>出入拦截器自不必说，每次消息进来和出去都会先被拦截器处理；</p>
<p>vertx对象，主要用于获取发送调用代码所处的上线文环境；</p>
<p>handerMap是核心，以地址为key，地址上注册的Handler序列为value，存储了地址-处理器的映射管理；当触发发送动作时，就会到该映射中查找对应的处理器然后执行；对于单机应用，handlerMap就是所有；对于集群应用，则是先找到节点，再在节点中的handlerMap查找对应处理器。</p>
<p>sendNoContext是为了在执行发送的代码块不处于任何上下文时使用的上下文。EventBusImpl创建时使用。</p>
<p>EventBusImpl的构造方法没什么内容，就不提了。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">EventBusImpl</span><span class="params">(VertxInternal vertx)</span> </span>&#123;</span><br><span class="line">    VertxMetrics metrics = vertx.metricsSPI();</span><br><span class="line">    <span class="keyword">this</span>.vertx = vertx;</span><br><span class="line">    <span class="keyword">this</span>.metrics = metrics != <span class="keyword">null</span> ? metrics.createEventBusMetrics() : <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">this</span>.sendNoContext = vertx.getOrCreateContext();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="EventLoop"><a href="#EventLoop" class="headerlink" title="EventLoop"></a>EventLoop</h3><p>Vertx中并没有EventLoop这个类，它是Netty中的类。对Vertx的源码，与EventLoop相关的交互只有两处：创建EventLoopGroup；向EventLoopGroup提交任务。</p>
<p>具体内容请查找Netty相关资料进行学习。</p>
<h3 id="Context"><a href="#Context" class="headerlink" title="Context"></a>Context</h3><p>Context是真正提交任务的地方，凡Vertx中涉及到任务的执行，总是少不了Context的身影。<br><img src="https://img-blog.csdnimg.cn/20201003110844860.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3pvdTg5NDQ=,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"><br>其核心能力主要在协调代码的运行，同时也可存储数据。其大部分逻辑都在ContextImpl中。其两个子类，仅在自我裁定、任务提交、上下文复制上有所不同。<br><img src="https://img-blog.csdnimg.cn/20201003110857360.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3pvdTg5NDQ=,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"></p>
<h3 id="Verticle"><a href="#Verticle" class="headerlink" title="Verticle"></a>Verticle</h3><p>Verticle放在这里有一点另类，因为它并非核心组件。只是Vertx提供的actor模式实现的一个发布单元。它的actor特性由VerticleManager、EventBus、Context等一起保证。就其能力来说，也只有启动和停止两个方法。</p>
<p><img src="https://img-blog.csdnimg.cn/20201003110909141.png#pic_center" alt="在这里插入图片描述"></p>
<h2 id="从EventBus看Vertx工作原理"><a href="#从EventBus看Vertx工作原理" class="headerlink" title="从EventBus看Vertx工作原理"></a>从EventBus看Vertx工作原理</h2><p>一个简单的Vertx应用如下，我们从它开始分析。</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">  <span class="keyword">val</span> vertx = Vertx.vertx();</span><br><span class="line">  vertx.eventBus().consumer&lt;String&gt;(<span class="string">&quot;helloAddress&quot;</span>).handler&#123;</span><br><span class="line">    print(it.body())</span><br><span class="line">  &#125;</span><br><span class="line">  vertx.eventBus().send(<span class="string">&quot;helloAddress&quot;</span>, <span class="string">&quot;hello world!&quot;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Vertx.vertx()在上面已经看过了，它创建了一个VertxImpl对象，持有一堆用于组织工作的属性，包括EventBus。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// vertx实例时对eventBus赋值的快照</span></span><br><span class="line"><span class="keyword">this</span>.eventBus = <span class="keyword">new</span> EventBusImpl(<span class="keyword">this</span>);</span><br></pre></td></tr></table></figure>

<h3 id="consumer做了什么"><a href="#consumer做了什么" class="headerlink" title="consumer做了什么"></a>consumer做了什么</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> &lt;T&gt; <span class="function">MessageConsumer&lt;T&gt; <span class="title">consumer</span><span class="params">(String address, Handler&lt;Message&lt;T&gt;&gt; handler)</span> </span>&#123;</span><br><span class="line">    Objects.requireNonNull(handler, <span class="string">&quot;handler&quot;</span>);</span><br><span class="line">    MessageConsumer&lt;T&gt; consumer = consumer(address);</span><br><span class="line">    consumer.handler(handler);</span><br><span class="line">    <span class="keyword">return</span> consumer;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 往里进一步</span></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> &lt;T&gt; <span class="function">MessageConsumer&lt;T&gt; <span class="title">consumer</span><span class="params">(String address)</span> </span>&#123;</span><br><span class="line">    checkStarted();</span><br><span class="line">    Objects.requireNonNull(address, <span class="string">&quot;address&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> HandlerRegistration&lt;&gt;(vertx, metrics, <span class="keyword">this</span>, address, <span class="keyword">null</span>, <span class="keyword">false</span>, <span class="keyword">null</span>, -<span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 重点在HandlerRegistration，收集地址后，开启超时回复定时器。</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">HandlerRegistration</span><span class="params">(Vertx vertx, EventBusMetrics metrics, EventBusImpl eventBus, String address,</span></span></span><br><span class="line"><span class="params"><span class="function">                               String repliedAddress, <span class="keyword">boolean</span> localOnly,</span></span></span><br><span class="line"><span class="params"><span class="function">                               Handler&lt;AsyncResult&lt;Message&lt;T&gt;&gt;&gt; asyncResultHandler, <span class="keyword">long</span> timeout)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.vertx = vertx;</span><br><span class="line">    <span class="keyword">this</span>.metrics = metrics;</span><br><span class="line">    <span class="keyword">this</span>.eventBus = eventBus;</span><br><span class="line">    <span class="keyword">this</span>.address = address;</span><br><span class="line">    <span class="keyword">this</span>.repliedAddress = repliedAddress;</span><br><span class="line">    <span class="keyword">this</span>.localOnly = localOnly;</span><br><span class="line">    <span class="keyword">this</span>.asyncResultHandler = asyncResultHandler;</span><br><span class="line">    <span class="keyword">if</span> (timeout != -<span class="number">1</span>) &#123;</span><br><span class="line">        timeoutID = vertx.setTimer(timeout, tid -&gt; &#123;</span><br><span class="line">            <span class="keyword">if</span> (metrics != <span class="keyword">null</span>) &#123;</span><br><span class="line">                metrics.replyFailure(address, ReplyFailure.TIMEOUT);</span><br><span class="line">            &#125;</span><br><span class="line">            sendAsyncResultFailure(<span class="keyword">new</span> ReplyException(ReplyFailure.TIMEOUT, <span class="string">&quot;Timed out after waiting &quot;</span> + timeout + <span class="string">&quot;(ms) for a reply. address: &quot;</span> + address + <span class="string">&quot;, repliedAddress: &quot;</span> + repliedAddress));</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 最上面的consumer.handler(handler);调用了HandlerRegistration的handler方法，如下。可以看到最终是在eventBus上调用了注册方法。</span></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> MessageConsumer&lt;T&gt; <span class="title">handler</span><span class="params">(Handler&lt;Message&lt;T&gt;&gt; h)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (h != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">synchronized</span> (<span class="keyword">this</span>) &#123;</span><br><span class="line">            handler = h;</span><br><span class="line">            <span class="keyword">if</span> (registered == <span class="keyword">null</span>) &#123;</span><br><span class="line">                registered = eventBus.addRegistration(address, <span class="keyword">this</span>, repliedAddress != <span class="keyword">null</span>, localOnly);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">this</span>.unregister();</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 最终来到了EventBus的addRegistration方法。在addLocalRegistration中，创建了HandlerHolder，并将其加入EventBus的成员变量handlerMap，然后返回创建的HandlerHolder</span></span><br><span class="line"><span class="keyword">protected</span> &lt;T&gt; <span class="function">HandlerHolder&lt;T&gt; <span class="title">addRegistration</span><span class="params">(String address, HandlerRegistration&lt;T&gt; registration,</span></span></span><br><span class="line"><span class="params"><span class="function">                                               <span class="keyword">boolean</span> replyHandler, <span class="keyword">boolean</span> localOnly)</span> </span>&#123;</span><br><span class="line">    Objects.requireNonNull(registration.getHandler(), <span class="string">&quot;handler&quot;</span>);</span><br><span class="line">    LocalRegistrationResult&lt;T&gt; result = addLocalRegistration(address, registration, replyHandler, localOnly);</span><br><span class="line">    addRegistration(result.newAddress, address, replyHandler, localOnly, registration::setResult);</span><br><span class="line">    <span class="keyword">return</span> result.holder;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>要点总结</p>
<ul>
<li>consumer方法仅仅将给定的handler注册到EventBusImpl持有的handlerMap中，等待被消费。</li>
</ul>
<h3 id="send做了什么"><a href="#send做了什么" class="headerlink" title="send做了什么"></a>send做了什么</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//通过跟踪，最终会来到sendOrPubInternal，首先创建一个用于回复的HandlerRegistration，然后创建OutboundDeliveryContext，调用其next方法</span></span><br><span class="line"><span class="keyword">public</span> &lt;T&gt; <span class="function"><span class="keyword">void</span> <span class="title">sendOrPubInternal</span><span class="params">(MessageImpl message, DeliveryOptions options,</span></span></span><br><span class="line"><span class="params"><span class="function">                                  Handler&lt;AsyncResult&lt;Message&lt;T&gt;&gt;&gt; replyHandler)</span> </span>&#123;</span><br><span class="line">    checkStarted();</span><br><span class="line">    HandlerRegistration&lt;T&gt; replyHandlerRegistration = createReplyHandlerRegistration(message, options, replyHandler);</span><br><span class="line">    OutboundDeliveryContext&lt;T&gt; sendContext = <span class="keyword">new</span> OutboundDeliveryContext&lt;&gt;(message, options, replyHandlerRegistration);</span><br><span class="line">    sendContext.next();</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// createReplyHandlerRegistration方法创建了__vertx.reply.xxx地址的响应HandlerRegistration</span></span><br><span class="line"><span class="keyword">private</span> &lt;T&gt; <span class="function">HandlerRegistration&lt;T&gt; <span class="title">createReplyHandlerRegistration</span><span class="params">(MessageImpl message,</span></span></span><br><span class="line"><span class="params"><span class="function">                                                                  DeliveryOptions options,</span></span></span><br><span class="line"><span class="params"><span class="function">                                                                  Handler&lt;AsyncResult&lt;Message&lt;T&gt;&gt;&gt; replyHandler)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (replyHandler != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">long</span> timeout = options.getSendTimeout();</span><br><span class="line">        String replyAddress = generateReplyAddress();</span><br><span class="line">        message.setReplyAddress(replyAddress);</span><br><span class="line">        Handler&lt;Message&lt;T&gt;&gt; simpleReplyHandler = convertHandler(replyHandler);</span><br><span class="line">        HandlerRegistration&lt;T&gt; registration =</span><br><span class="line">            <span class="keyword">new</span> HandlerRegistration&lt;&gt;(vertx, metrics, <span class="keyword">this</span>, replyAddress, message.address, <span class="keyword">true</span>, replyHandler, timeout);</span><br><span class="line">        registration.handler(simpleReplyHandler);</span><br><span class="line">        <span class="keyword">return</span> registration;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">protected</span> String <span class="title">generateReplyAddress</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;__vertx.reply.&quot;</span> + Long.toString(replySequence.incrementAndGet());</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// OutboundDeliveryContext类接收了消息和响应HandlerRegistration，调用next，如下。其中的iter多半是拦截器，暂时不用管。核心在sendOrPub(this)和sendReply(this, replierMessage)</span></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">next</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (iter.hasNext()) &#123;</span><br><span class="line">        Handler&lt;DeliveryContext&gt; handler = iter.next();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (handler != <span class="keyword">null</span>) &#123;</span><br><span class="line">                handler.handle(<span class="keyword">this</span>);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                next();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Throwable t) &#123;</span><br><span class="line">            log.error(<span class="string">&quot;Failure in interceptor&quot;</span>, t);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (replierMessage == <span class="keyword">null</span>) &#123;</span><br><span class="line">            sendOrPub(<span class="keyword">this</span>);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            sendReply(<span class="keyword">this</span>, replierMessage);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 定义io.vertx.core.eventbus.impl.EventBusImpl#sendOrPub，再定位到io.vertx.core.eventbus.impl.EventBusImpl#deliverMessageLocally,最终来到io.vertx.core.eventbus.impl.EventBusImpl#deliverMessageLocally</span></span><br><span class="line"><span class="comment">// 这里的关键由两个地方：一是点对点的实现——再handlerMap中找到指定地址的handlers，只取第一个进行处理；还有发布订阅的实现——对在一个地址注册的handlers全部处理；第二个关键点是消息发送的方法deliverToHandler(msg, holder)</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> ReplyException <span class="title">deliverMessageLocally</span><span class="params">(MessageImpl msg)</span> </span>&#123;</span><br><span class="line">    msg.setBus(<span class="keyword">this</span>);</span><br><span class="line">    ConcurrentCyclicSequence&lt;HandlerHolder&gt; handlers = handlerMap.get(msg.address());</span><br><span class="line">    <span class="keyword">if</span> (handlers != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (msg.isSend()) &#123;</span><br><span class="line">            <span class="comment">//Choose one</span></span><br><span class="line">            HandlerHolder holder = handlers.next();</span><br><span class="line">            <span class="keyword">if</span> (metrics != <span class="keyword">null</span>) &#123;</span><br><span class="line">                metrics.messageReceived(msg.address(), !msg.isSend(), isMessageLocal(msg), holder != <span class="keyword">null</span> ? <span class="number">1</span> : <span class="number">0</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (holder != <span class="keyword">null</span>) &#123;</span><br><span class="line">                deliverToHandler(msg, holder);</span><br><span class="line">                Handler&lt;AsyncResult&lt;Void&gt;&gt; handler = msg.writeHandler;</span><br><span class="line">                <span class="keyword">if</span> (handler != <span class="keyword">null</span>) &#123;</span><br><span class="line">                    handler.handle(Future.succeededFuture());</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// Publish</span></span><br><span class="line">            <span class="keyword">if</span> (metrics != <span class="keyword">null</span>) &#123;</span><br><span class="line">                metrics.messageReceived(msg.address(), !msg.isSend(), isMessageLocal(msg), handlers.size());</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">for</span> (HandlerHolder holder: handlers) &#123;</span><br><span class="line">                deliverToHandler(msg, holder);</span><br><span class="line">            &#125;</span><br><span class="line">            Handler&lt;AsyncResult&lt;Void&gt;&gt; handler = msg.writeHandler;</span><br><span class="line">            <span class="keyword">if</span> (handler != <span class="keyword">null</span>) &#123;</span><br><span class="line">                handler.handle(Future.succeededFuture());</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        ... ...</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 最终的处理函数如下：创建InboundDeliveryContext，在HandlerHolder的context环境下运行其next方法：</span></span><br><span class="line"><span class="keyword">private</span> &lt;T&gt; <span class="function"><span class="keyword">void</span> <span class="title">deliverToHandler</span><span class="params">(MessageImpl msg, HandlerHolder&lt;T&gt; holder)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// Each handler gets a fresh copy</span></span><br><span class="line">    MessageImpl copied = msg.copyBeforeReceive();</span><br><span class="line">    DeliveryContext&lt;T&gt; receiveContext = <span class="keyword">new</span> InboundDeliveryContext&lt;&gt;(copied, holder);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (metrics != <span class="keyword">null</span>) &#123;</span><br><span class="line">        metrics.scheduleMessage(holder.getHandler().getMetric(), msg.isLocal());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    holder.getContext().runOnContext((v) -&gt; &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            receiveContext.next();</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (holder.isReplyHandler()) &#123;</span><br><span class="line">                holder.getHandler().unregister();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// next方法啥也没干，直接将message传入目标handler</span></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">next</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (iter.hasNext()) &#123;</span><br><span class="line">        <span class="comment">// ... 拦截器迭代，忽略</span></span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        holder.getHandler().handle(message);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>要点总结</p>
<ul>
<li>send分为两步<ul>
<li>查询handler，调用send时马上执行，是同步的。</li>
<li>执行handler，通过handler注册时的context执行，是异步的。</li>
</ul>
</li>
<li>消息响应的实现方式是注册一个响应handler到EventBus中，名为__vertx.reply.xxx，其中xxx为单调递增数字。</li>
<li>如果同一地址注册了多个handler，则点对点传输模式下只会取第一个handler进行处理；发布模式下才会执行所有。</li>
<li>在一个上下文中注册的handler，不管被执行时机如何，最终都会在该上下文中执行。参见：<code>holder.getContext().runOnContext(...</code>，hodler为HandlerHolder对象，在调用consumer注册时保存了注册上下文。</li>
</ul>
<h3 id="和EventLoop的关系在哪？"><a href="#和EventLoop的关系在哪？" class="headerlink" title="和EventLoop的关系在哪？"></a>和EventLoop的关系在哪？</h3><p>通过consumer和send看到了EventBus是如何协调接收和发送的，但并没有看到EventLoop是如何参与的。其实它是有参与的，在<code>holder.getContext().runOnContext(...</code>是进行了参与。</p>
<p>于是我们看看EventLoopContext.runOnContext()，如下。就是向Context保存的EventLoop对象提交一个任务即可。调度的事，交给Netty来做</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 看到只调用了一个executeAsync()</span></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">runOnContext</span><span class="params">(Handler&lt;Void&gt; task)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        executeAsync(task);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (RejectedExecutionException ignore) &#123;</span><br><span class="line">        <span class="comment">// Pool is already shut down</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 这里就能看到Vertx的底了，它直接将任务提交给了netty的eventLoop</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">executeAsync</span><span class="params">(Handler&lt;Void&gt; task)</span> </span>&#123;</span><br><span class="line">    nettyEventLoop().execute(() -&gt; executeTask(<span class="keyword">null</span>, task));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="Verticle工作机制"><a href="#Verticle工作机制" class="headerlink" title="Verticle工作机制"></a>Verticle工作机制</h2><p>Vert.x推荐使用Verticle进行开发，它是一个类Actor的模型，具有如下特点。</p>
<ul>
<li>同一Verticle下的所有操作均在一个EventLoop线程上执行。以此避免了线程安全问题。</li>
<li>Verticle之间通过EventBus进行消息传递</li>
<li>Verticle具有父子层级关系</li>
</ul>
<p>一个典型的代码结构如下（官方starter使用Launcher启动的应用，本质上也是通过这种方式启动的）</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Verticle1</span> : <span class="type">AbstractVerticle</span></span>() &#123;</span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">start</span><span class="params">()</span></span> &#123;</span><br><span class="line">        println(<span class="string">&quot;Verticle 1 started&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Verticle2</span> : <span class="type">AbstractVerticle</span></span>() &#123;</span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">start</span><span class="params">()</span></span> &#123;</span><br><span class="line">        println(<span class="string">&quot;Verticle 2 started&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">val</span> vertx = Vertx.vertx();</span><br><span class="line">    vertx.deployVerticle(Verticle1::<span class="keyword">class</span>.java.canonicalName)</span><br><span class="line">    vertx.deployVerticle(Verticle2::<span class="keyword">class</span>.java.canonicalName)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>我们需要探究的问题是</p>
<ul>
<li>deployVerticle时发生了什么？</li>
<li>start()和stop()方法什么时候被调用？</li>
<li>如何保证一个Verticle下的所有操作都在一个EventLoop线程上执行？</li>
<li>父子层级关系如何维持？有什么作用？</li>
</ul>
<p>要搞清楚这些问题，我们先看几个与此相关的类</p>
<h3 id="Deployment"><a href="#Deployment" class="headerlink" title="Deployment"></a>Deployment</h3><p>维护一个发布状态，父子状态也是由它维护的。其唯一实现类DeploymentImpl是作为DeploymentManager的私有内部类存在的。这意味着Verticle发布的所有操作都在DeploymentManager内完成。</p>
<p>其中可能需要解释的点是getVerticles()，这意味着一个Deployment可以有多个Verticle吗？一定程度上是，但仅当一个Verticle需要发布多个实例时，才会存在多个Verticle对象。</p>
<p><img src="https://img-blog.csdnimg.cn/20201003111022872.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3pvdTg5NDQ=,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"><br>其中需要重点关注的方法是<code>io.vertx.core.impl.DeploymentManager.DeploymentImpl#doUndeploy</code>和<code>io.vertx.core.impl.DeploymentManager.DeploymentImpl#doUndeployChildren</code>，两个方法递归调用，完成了指定Verticle及其子Verticle的取消。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> Future&lt;Void&gt; <span class="title">doUndeploy</span><span class="params">(ContextInternal undeployingContext)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (status == ST_UNDEPLOYED) &#123;</span><br><span class="line">        <span class="keyword">return</span> Future.failedFuture(<span class="keyword">new</span> IllegalStateException(<span class="string">&quot;Already undeployed&quot;</span>));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 子发布不为空，则先取消子发布，成功后再取消当前发布。</span></span><br><span class="line">    <span class="keyword">if</span> (!children.isEmpty()) &#123;</span><br><span class="line">        status = ST_UNDEPLOYING;</span><br><span class="line">        <span class="keyword">return</span> doUndeployChildren(undeployingContext).compose(v -&gt; doUndeploy(undeployingContext));</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// 子发布为空、或取消子发布完成，现在来取消当前发布</span></span><br><span class="line">        status = ST_UNDEPLOYED;</span><br><span class="line">        List&lt;Future&gt; undeployFutures = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        <span class="keyword">if</span> (parent != <span class="keyword">null</span>) &#123;</span><br><span class="line">            parent.removeChild(<span class="keyword">this</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 为当前发布的每个Verticle实例执行此操作</span></span><br><span class="line">        <span class="keyword">for</span> (VerticleHolder verticleHolder: verticles) &#123;</span><br><span class="line">            ContextImpl context = verticleHolder.context;</span><br><span class="line">            Promise p = Promise.promise();</span><br><span class="line">            undeployFutures.add(p.future());</span><br><span class="line">            <span class="comment">// 该context是Verticle发布时就存好的，调用它保证了Verticle的stop和start方法在同一个线程运行。</span></span><br><span class="line">            context.runOnContext(v -&gt; &#123;</span><br><span class="line">                Promise&lt;Void&gt; stopPromise = Promise.promise();</span><br><span class="line">                Future&lt;Void&gt; stopFuture = stopPromise.future();</span><br><span class="line">                stopFuture.setHandler(ar -&gt; &#123;</span><br><span class="line">                    <span class="comment">// 从deployments映射中移除</span></span><br><span class="line">                    deployments.remove(deploymentID);</span><br><span class="line">                    VertxMetrics metrics = vertx.metricsSPI();</span><br><span class="line">                    <span class="keyword">if</span> (metrics != <span class="keyword">null</span>) &#123;</span><br><span class="line">                        metrics.verticleUndeployed(verticleHolder.verticle);</span><br><span class="line">                    &#125;</span><br><span class="line">                    context.runCloseHooks(ar2 -&gt; &#123;</span><br><span class="line">                        <span class="keyword">if</span> (ar2.failed()) &#123;</span><br><span class="line">                            <span class="comment">// Log error but we report success anyway</span></span><br><span class="line">                            log.error(<span class="string">&quot;Failed to run close hook&quot;</span>, ar2.cause());</span><br><span class="line">                        &#125;</span><br><span class="line">                        <span class="keyword">if</span> (ar.succeeded()) &#123;</span><br><span class="line">                            p.complete();</span><br><span class="line">                        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (ar.failed()) &#123;</span><br><span class="line">                            p.fail(ar.cause());</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;);</span><br><span class="line">                &#125;);</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    <span class="comment">// 执行Verticle的stop方法</span></span><br><span class="line">                    verticleHolder.verticle.stop(stopPromise);</span><br><span class="line">                &#125; <span class="keyword">catch</span> (Throwable t) &#123;</span><br><span class="line">                    <span class="keyword">if</span> (!stopPromise.tryFail(t)) &#123;</span><br><span class="line">                        undeployingContext.reportException(t);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;);</span><br><span class="line">        &#125;</span><br><span class="line">        Promise&lt;Void&gt; resolvingPromise = undeployingContext.promise();</span><br><span class="line">        CompositeFuture.all(undeployFutures).&lt;Void&gt;mapEmpty().setHandler(resolvingPromise);</span><br><span class="line">        <span class="keyword">return</span> resolvingPromise.future();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">synchronized</span> Future&lt;Void&gt; <span class="title">doUndeployChildren</span><span class="params">(ContextInternal undeployingContext)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!children.isEmpty()) &#123;</span><br><span class="line">        List&lt;Future&gt; childFuts = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        <span class="comment">// 对每个子发布执行doUndeploy方法</span></span><br><span class="line">        <span class="keyword">for</span> (Deployment childDeployment: <span class="keyword">new</span> HashSet&lt;&gt;(children)) &#123;</span><br><span class="line">            Promise&lt;Void&gt; p = Promise.promise();</span><br><span class="line">            childFuts.add(p.future());</span><br><span class="line">            childDeployment.doUndeploy(undeployingContext, ar -&gt; &#123;</span><br><span class="line">                children.remove(childDeployment);</span><br><span class="line">                p.handle(ar);</span><br><span class="line">            &#125;);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> CompositeFuture.all(childFuts).mapEmpty();</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> Future.succeededFuture();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>总结如下</p>
<ul>
<li>一个Verticle被取消，则其所有子Verticle都会被取消</li>
<li>VerticleHolder中存储了Verticle对应的Context，因此能够保证Verticle的所有生命周期方法都在同一个Context中执行。</li>
</ul>
<h3 id="DeploymentManager"><a href="#DeploymentManager" class="headerlink" title="DeploymentManager"></a>DeploymentManager</h3><p>DeploymentManager专门用于Verticle发布。</p>
<p><img src="https://img-blog.csdnimg.cn/20201003111046409.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3pvdTg5NDQ=,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"></p>
<p>重点方法在如下几个</p>
<ul>
<li><code>DeploymentManager#doDeploy(DeploymentOptions, Function&lt;Verticle,String&gt;, ContextInternal, ContextInternal,ClassLoader, Callable&lt;io.vertx.core.Verticle&gt;)</code></li>
<li><code>DeploymentManager#undeployVerticle(String)</code></li>
</ul>
<h4 id="发布"><a href="#发布" class="headerlink" title="发布"></a>发布</h4><p>发布代码如下</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> Future&lt;Deployment&gt; <span class="title">doDeploy</span><span class="params">(String identifier,</span></span></span><br><span class="line"><span class="params"><span class="function">                                    DeploymentOptions options,</span></span></span><br><span class="line"><span class="params"><span class="function">                                    ContextInternal parentContext,</span></span></span><br><span class="line"><span class="params"><span class="function">                                    ContextInternal callingContext,</span></span></span><br><span class="line"><span class="params"><span class="function">                                    ClassLoader tccl, Verticle... verticles)</span> </span>&#123;</span><br><span class="line">    Promise&lt;Deployment&gt; promise = callingContext.promise();</span><br><span class="line">    String poolName = options.getWorkerPoolName();</span><br><span class="line"></span><br><span class="line">    Deployment parent = parentContext.getDeployment();</span><br><span class="line">    <span class="comment">// 生成发布ID</span></span><br><span class="line">    String deploymentID = generateDeploymentID();</span><br><span class="line">    <span class="comment">// 创建Deployment对象，上面有说过它是干啥的</span></span><br><span class="line">    DeploymentImpl deployment = <span class="keyword">new</span> DeploymentImpl(parent, deploymentID, identifier, options);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 发布计数</span></span><br><span class="line">    AtomicInteger deployCount = <span class="keyword">new</span> AtomicInteger();</span><br><span class="line">    <span class="comment">// 失败标示</span></span><br><span class="line">    AtomicBoolean failureReported = <span class="keyword">new</span> AtomicBoolean();</span><br><span class="line">    <span class="comment">// 如果一个Verticle发布多个实例，则会有多个verticle对象</span></span><br><span class="line">    <span class="keyword">for</span> (Verticle verticle: verticles) &#123;</span><br><span class="line">        <span class="comment">// Verticle可以被要求发布到Worker线程池还是EventLoop线程池，在这里做区分</span></span><br><span class="line">        WorkerExecutorInternal workerExec = poolName != <span class="keyword">null</span> ? vertx.createSharedWorkerExecutor(poolName, options.getWorkerPoolSize(), options.getMaxWorkerExecuteTime(), options.getMaxWorkerExecuteTimeUnit()) : <span class="keyword">null</span>;</span><br><span class="line">        WorkerPool pool = workerExec != <span class="keyword">null</span> ? workerExec.getPool() : <span class="keyword">null</span>;</span><br><span class="line">        <span class="comment">// 为每个Verticle都创建一个新的Context</span></span><br><span class="line">        ContextImpl context = (ContextImpl) (options.isWorker() ? vertx.createWorkerContext(deployment, pool, tccl) :</span><br><span class="line">                                             vertx.createEventLoopContext(deployment, pool, tccl));</span><br><span class="line">        <span class="keyword">if</span> (workerExec != <span class="keyword">null</span>) &#123;</span><br><span class="line">            context.addCloseHook(workerExec);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 向Deployment加入Verticle对象</span></span><br><span class="line">        deployment.addVerticle(<span class="keyword">new</span> VerticleHolder(verticle, context));</span><br><span class="line">        <span class="comment">// 在新创建的Context上执行Verticle生命周期</span></span><br><span class="line">        context.runOnContext(v -&gt; &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="comment">// 执行init方法</span></span><br><span class="line">                verticle.init(vertx, context);</span><br><span class="line">                Promise&lt;Void&gt; startPromise = context.promise();</span><br><span class="line">                Future&lt;Void&gt; startFuture = startPromise.future();</span><br><span class="line">                <span class="comment">// 执行start方法</span></span><br><span class="line">                verticle.start(startPromise);</span><br><span class="line">                startFuture.setHandler(ar -&gt; &#123;</span><br><span class="line">                    <span class="keyword">if</span> (ar.succeeded()) &#123;</span><br><span class="line">                        <span class="keyword">if</span> (parent != <span class="keyword">null</span>) &#123;</span><br><span class="line">                            <span class="comment">// 发布成功，加入父节点</span></span><br><span class="line">                            <span class="keyword">if</span> (parent.addChild(deployment)) &#123;</span><br><span class="line">                                deployment.child = <span class="keyword">true</span>;</span><br><span class="line">                            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                                <span class="comment">// Orphan</span></span><br><span class="line">                                deployment.undeploy(event -&gt; promise.fail(<span class="string">&quot;Verticle deployment failed.Could not be added as child of parent verticle&quot;</span>));</span><br><span class="line">                                <span class="keyword">return</span>;</span><br><span class="line">                            &#125;</span><br><span class="line">                        &#125;</span><br><span class="line">                        <span class="comment">// 加入发布完成的map</span></span><br><span class="line">                        deployments.put(deploymentID, deployment);</span><br><span class="line">                        <span class="comment">// 发布的数量和待发布的数量匹配，说明发布完成，成功结束</span></span><br><span class="line">                        <span class="keyword">if</span> (deployCount.incrementAndGet() == verticles.length) &#123;</span><br><span class="line">                            promise.complete(deployment);</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (failureReported.compareAndSet(<span class="keyword">false</span>, <span class="keyword">true</span>)) &#123;</span><br><span class="line">                        <span class="comment">// 发布失败的回滚</span></span><br><span class="line">                        deployment.rollback(callingContext, promise, context, ar.cause());</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (Throwable t) &#123;</span><br><span class="line">                <span class="keyword">if</span> (failureReported.compareAndSet(<span class="keyword">false</span>, <span class="keyword">true</span>))</span><br><span class="line">                    deployment.rollback(callingContext, promise, context, t);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> promise.future();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>总结如下</p>
<ul>
<li>对每个verticle，vertx都会创建一个新的Context，因此每个verticle之间是相互独立的(一个Context代表了一个EventLoop线程。)</li>
<li>传入init和start方法的vertx实例，是DeploymentManager中维护的，它是在Vertx.vertx()创建时赋予的，整个应用一个。</li>
<li>整个verticle的内容都通过Context.runOnContext注册运行，所以它们才会始终都在一个线程上执行，并且执行顺序从上到下，不存在多线程竞争问题。</li>
<li>发布完成的Deployment会被加入DeploymentManager维护的deployments映射中，方便进行查找和之后的使用。</li>
</ul>
<h4 id="取消发布"><a href="#取消发布" class="headerlink" title="取消发布"></a>取消发布</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> Future&lt;Void&gt; <span class="title">undeployVerticle</span><span class="params">(String deploymentID)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 从deployments中获取Deployment对象</span></span><br><span class="line">    Deployment deployment = deployments.get(deploymentID);</span><br><span class="line">    <span class="comment">// 获取当前上下文</span></span><br><span class="line">    Context currentContext = vertx.getOrCreateContext();</span><br><span class="line">    <span class="keyword">if</span> (deployment == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> ((ContextInternal) currentContext).failedFuture(<span class="keyword">new</span> IllegalStateException(<span class="string">&quot;Unknown deployment&quot;</span>));</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// 调用deployment的undeploy()</span></span><br><span class="line">        <span class="keyword">return</span> deployment.undeploy();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Deployment.undeploy()在上面介绍Deployment时已介绍。</p>
<h3 id="VerticleManager"><a href="#VerticleManager" class="headerlink" title="VerticleManager"></a>VerticleManager</h3><p>DeploymentManager专注于发布，VerticleManager则主要专注于Verticle的创建。其内部持有一个DeploymentManager对象，用于执行实际的发布操作。</p>
<p><img src="https://img-blog.csdnimg.cn/20201003111106890.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3pvdTg5NDQ=,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"><br>该类中有两个主要逻辑</p>
<ul>
<li>VerticleFactory的注册、取消、查找等。可以实现自定义的VerticleFactory，这里不深入。</li>
<li>Verticle的发布和创建的逻辑：调用VerticleFactory创建Verticle实例，在调用DeploymentManager.deploy()发布，代码过长，不给出。</li>
</ul>
<h3 id="所以Verticle是如何工作的？"><a href="#所以Verticle是如何工作的？" class="headerlink" title="所以Verticle是如何工作的？"></a>所以Verticle是如何工作的？</h3><p>这里回答最初提出的四个问题，就能解释Verticle是如何工作的。</p>
<ul>
<li><p>deployVerticle时发生了什么？</p>
<p>创建Verticle对象 -&gt; 创建Context并和Verticle对象绑定 -&gt; 构建Deployment并存起来 -&gt; 执行init() -&gt; 执行start() -&gt; 完成</p>
</li>
<li><p>start()和stop()方法什么时候被调用？</p>
<p>start(): 发布时，在新创建的Context上执行。</p>
<p>stop(): 取消发布时，在与该Verticle绑定的Context上执行。</p>
</li>
<li><p>如何保证一个Verticle下的所有操作都在一个EventLoop线程上执行？</p>
<p>通过将Context和Verticle绑定，调用start()和stop()时均在该Context下执行；而在start()和stop()中调用vertx的大多数操作，均是在调用代码块的当前Context下执行，而一个Context始终对应同一个EventLoop线程，如此即能保证一个Verticle下的所有操作都在同一个EventLoop线程上执行。</p>
</li>
<li><p>父子层级关系如何维持？有什么作用？</p>
<p>通过Deployment对象记录并维持。作用在于关闭一个Verticle时，其子Verticle也会被依次关闭。</p>
</li>
</ul>
<p>如此一来，Verticle几乎有了除容错机制外的所有的Actor模型的特性。</p>
<h2 id="数据共享机制"><a href="#数据共享机制" class="headerlink" title="数据共享机制"></a><strong>数据共享机制</strong></h2><p>Vertx提供了SharedData组件，用于为整个应用范围内提供共享组件，一个共享Map的使用大概如下</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Verticle1</span> : <span class="type">AbstractVerticle</span></span>() &#123;</span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">start</span><span class="params">()</span></span> &#123;</span><br><span class="line">        println(<span class="string">&quot;Verticle 1 started&quot;</span>)</span><br><span class="line">        vertx.sharedData().getLocalAsyncMap&lt;String, String&gt;(<span class="string">&quot;myMap&quot;</span>).setHandler &#123; ar -&gt;</span><br><span class="line">                                                                                 ar.result().put(<span class="string">&quot;你好&quot;</span>, <span class="string">&quot;我是Verticle1&quot;</span>)</span><br><span class="line">                                                                                &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Verticle2</span> : <span class="type">AbstractVerticle</span></span>() &#123;</span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">start</span><span class="params">()</span></span> &#123;</span><br><span class="line">        println(<span class="string">&quot;Verticle 2 started&quot;</span>)</span><br><span class="line">        vertx.sharedData().getLocalAsyncMap&lt;String, String&gt;(<span class="string">&quot;myMap&quot;</span>).setHandler &#123; ar -&gt;</span><br><span class="line">                                                                                 <span class="keyword">val</span> value = ar.result().<span class="keyword">get</span>(<span class="string">&quot;你好&quot;</span>).result()</span><br><span class="line">                                                                                 println(value)</span><br><span class="line">                                                                                &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">val</span> vertx = Vertx.vertx();</span><br><span class="line">    vertx.deployVerticle(Verticle1::<span class="keyword">class</span>.java.canonicalName)</span><br><span class="line">    Thread.sleep(<span class="number">1000</span>)</span><br><span class="line">    vertx.deployVerticle(Verticle2::<span class="keyword">class</span>.java.canonicalName)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>所有关于共享数据的内容都在io.vertx.core.shareddata包下，核心类是SharedDataImpl。</p>
<p>提供如下三种数据结构</p>
<ul>
<li><p>io.vertx.core.shareddata.impl.LocalAsyncLocks</p>
<p>异步排他锁，在集群内部有效的锁。其实现的思路如下</p>
<ul>
<li>维护一个ConcurrentMap，存储锁名和等待该锁的Handler列表</li>
<li>每次新来一个获取锁的请求，向等待列表中加入。并启动定时器开始计算超时，超时后直接回调锁等待超时。</li>
</ul>
<p>至此加入等待列表的逻辑完成。然后是锁流转逻辑。采用被动的逻辑，非常节省复杂度。</p>
<ul>
<li>当等待列表为空时，来一个请求就将锁给它；列表不为空时，仅加入等待列表，不做尝试获取锁的操作。</li>
<li>当一个锁被释放时，再主动将锁给等待列表的下一个请求。这样几乎从来不会出现竞争的情况。</li>
</ul>
</li>
<li><p>io.vertx.core.shareddata.impl.AsynchronousCounter</p>
<p>计数器，增减都是原子操作</p>
</li>
<li><p>io.vertx.core.shareddata.impl.LocalMapImpl</p>
<p>本地Map，用于单个实例中共享数据。仅是对ConcurrentMap的包装，没有其它特别之处。他的所有操作都是同步的。</p>
</li>
<li><p>io.vertx.core.shareddata.impl.LocalAsyncMapImpl</p>
<p>异步Map，同样是对ConcurrentMap的包装。不同之处在于其value是Holder类，它封装了TTL，实现原理是调用vertx.setTimer设置一个TTL长度的定时器，过期移除。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">put</span><span class="params">(K k, V v, <span class="keyword">long</span> timeout, Handler&lt;AsyncResult&lt;Void&gt;&gt; completionHandler)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">long</span> timestamp = System.nanoTime();</span><br><span class="line">    <span class="keyword">long</span> timerId = vertx.setTimer(timeout, l -&gt; removeIfExpired(k));</span><br><span class="line">    Holder&lt;V&gt; previous = map.put(k, <span class="keyword">new</span> Holder&lt;&gt;(v, timerId, timeout, timestamp));</span><br><span class="line">    <span class="keyword">if</span> (previous != <span class="keyword">null</span> &amp;&amp; previous.expires()) &#123;</span><br><span class="line">        vertx.cancelTimer(previous.timerId);</span><br><span class="line">    &#125;</span><br><span class="line">    completionHandler.handle(Future.succeededFuture());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>可能有顾虑设置太多定时器不好，但vertx其实是将定时任务加入eventLoop线程去执行，因此并不会增加额外成本</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">long</span> <span class="title">setTimer</span><span class="params">(<span class="keyword">long</span> delay, Handler&lt;Long&gt; handler)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> scheduleTimeout(getOrCreateContext(), handler, delay, <span class="keyword">false</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">long</span> <span class="title">scheduleTimeout</span><span class="params">(ContextImpl context, Handler&lt;Long&gt; handler, <span class="keyword">long</span> delay, <span class="keyword">boolean</span> periodic)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (delay &lt; <span class="number">1</span>) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">&quot;Cannot schedule a timer with delay &lt; 1 ms&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">long</span> timerId = timeoutCounter.getAndIncrement();</span><br><span class="line">    InternalTimerHandler task = <span class="keyword">new</span> InternalTimerHandler(timerId, handler, periodic, delay, context);</span><br><span class="line">    timeouts.put(timerId, task);</span><br><span class="line">    context.addCloseHook(task);</span><br><span class="line">    <span class="keyword">return</span> timerId;</span><br><span class="line">&#125;</span><br><span class="line">InternalTimerHandler(<span class="keyword">long</span> timerID, Handler&lt;Long&gt; runnable, <span class="keyword">boolean</span> periodic, <span class="keyword">long</span> delay, ContextImpl context) &#123;</span><br><span class="line">    <span class="keyword">this</span>.context = context;</span><br><span class="line">    <span class="keyword">this</span>.timerID = timerID;</span><br><span class="line">    <span class="keyword">this</span>.handler = runnable;</span><br><span class="line">    <span class="keyword">this</span>.periodic = periodic;</span><br><span class="line">    EventLoop el = context.nettyEventLoop();</span><br><span class="line">    <span class="keyword">if</span> (periodic) &#123;</span><br><span class="line">        future = el.scheduleAtFixedRate(<span class="keyword">this</span>, delay, delay, TimeUnit.MILLISECONDS);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        future = el.schedule(<span class="keyword">this</span>, delay, TimeUnit.MILLISECONDS);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (metrics != <span class="keyword">null</span>) &#123;</span><br><span class="line">        metrics.timerCreated(timerID);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<h2 id="框图"><a href="#框图" class="headerlink" title="框图"></a><strong>框图</strong></h2><p>有待为每个工作原理都加上框图</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a><strong>总结</strong></h2><p>Vertx核心为EventBus、EventLoop，以及Verticle。这里通过先展示核心类的能力和实现原理，让读者有一个具象的认识，了解每个核心类大概有能干什么。然后通过EventBus的简单收发分析，展示了EventBus的工作原理及EventLoop参与代码执行的方式；通过Verticle的发布，展示了Verticle是如何运转的，以及Verticle的线程安全特性得到保障的原因；最后展示了SharedData进行应用范围内数据共享的实现原理。让读者对Vert.x核心部分有了较为深入的认识。</p>
<p>当然，Vert.x的能力远不止于此，这里仅介绍了单机版运行原理，它还支持集群和高可用特性，都是本文没有覆盖到的；此外，核心部分的文件系统、网络编程相关内容也均未介绍，这些留待之后再说。</p>
<p>最后，总结一波一些核心组件相互之间的关系。</p>
<ul>
<li>一般来说，一个应用只有一个Vertx，在整个应用中传来传去的vertx实例，都是一个，除非我们想要拥有完全隔离的EventBus。</li>
<li>一个Vertx实例只持有一个EventBus和一个用于日常调度的EventLoopGroup(用于网络服务监听的不算)。</li>
<li>一个Vertx实例持有多个线程池，我们最常解除的只有EventLoopGroup和WorkerPool。</li>
<li>一个Context只持有一个EventLoop，即只对应一个线程。通过runOnContext()将任务调度到该EventLoop上执行。</li>
<li>一个VerticleManager持有多个VerticleFactory。</li>
<li>一个DeployManager持有多个Deployment，Deployment之间的父子关系由Deployment自己维护。</li>
<li>一个Deployment可以持有多个Verticle实例，但仅能持有一个Verticle类型</li>
</ul>
]]></content>
      <categories>
        <category>响应式</category>
      </categories>
      <tags>
        <tag>Vert.x</tag>
      </tags>
  </entry>
  <entry>
    <title>Vert.x — 从缓存Future说起</title>
    <url>/2020/02/27/Vert.x%20%E2%80%94%20%E4%BB%8E%E7%BC%93%E5%AD%98Future%E8%AF%B4%E8%B5%B7-vertx%E4%BB%8E%E7%BC%93%E5%AD%98future%E8%AF%B4%E8%B5%B7/</url>
    <content><![CDATA[<h1 id="引子"><a href="#引子" class="headerlink" title="引子"></a>引子</h1><p>这是一个晴朗的午后，我沐浴着窗口洒落的阳光，懒洋洋地敲着代码，喝着并不存在的咖啡，听着窗外并不存在的熙熙攘攘。这是一个疫情中的午后，深圳二月份的天气算是比较厚道，一件薄外套已经让我微微出汗。我，又遇到bug了，调了一上午的bug，自己写的bug，查了半天的bug，甚至让我分不清此刻的汗水是气温还是bug导致的。</p>
<p>随着时间的流逝，bug终究会解决，我们要做的，就是静静地等着。不知不觉已经到了晚上，果然，bug解决了。往往一个bug的持续时间决定了它是否值得被记录。解决完这个bug时，我惊喜地意识到又可以水一篇博文了。呵呵。</p>
<span id="more"></span>

<p>在Vert.x中，Future是遵循Promise/Future原则的接口，是一个占位符。按官方说的，它代表了一个可能已经发生、或可能还没发生的动作的结果，即一个异步结果。读取其中的结果，通常是设置一个回调方法，但是注意，<strong>一个future只能设置一个回调方法，即一个Handler，或者更具体地说，如果设置多个Handler，则只有最后一个Handler有效。</strong></p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">val</span> future = Promise.promise&lt;String&gt;().future();</span><br><span class="line">future.setHandler &#123; ar -&gt; </span><br><span class="line">    <span class="keyword">if</span>(ar.failed())&#123;</span><br><span class="line">        <span class="comment">// 处理失败的情况</span></span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// 处理成功的情况</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="事故回放"><a href="#事故回放" class="headerlink" title="事故回放"></a>事故回放</h1><h2 id="使用场景"><a href="#使用场景" class="headerlink" title="使用场景"></a>使用场景</h2><p>有一缓存需求：将一段读取数据库的代码的结果缓存起来，缓存有效期十分钟，过期后自动刷新，要求整个过程全异步。</p>
<p>为了后期能够随时更换缓存实现，于是抽闲出如下缓存接口</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">Cache</span>&lt;<span class="type">K, V</span>&gt; </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// get方法，第一个参数为key，第二个参数为缓存过期时获取新的缓存的方法</span></span><br><span class="line">  <span class="function"><span class="keyword">fun</span> <span class="title">get</span><span class="params">(key: <span class="type">K</span>, mappingFunction: () -&gt; <span class="type">Future</span>&lt;<span class="type">V</span>&gt;)</span></span>: Future&lt;V&gt;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 删除缓存值</span></span><br><span class="line">  <span class="function"><span class="keyword">fun</span> <span class="title">invalidate</span><span class="params">(key: <span class="type">K</span>)</span></span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>并使用Caffeine实现上述接口</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">CaffeineProxy</span>&lt;<span class="type">K, V</span>&gt;  : <span class="type">Cache</span>&lt;<span class="type">K, V</span>&gt; </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">val</span> cache: Cache&lt;K, Future&lt;V&gt;&gt; = Caffeine.newBuilder().build()</span><br><span class="line"></span><br><span class="line">  <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">get</span><span class="params">(key: <span class="type">K</span>, mappingFunction: () -&gt; <span class="type">Future</span>&lt;<span class="type">V</span>&gt;)</span></span>: Future&lt;V&gt; = </span><br><span class="line">    cache.<span class="keyword">get</span>(key) &#123; mappingFunction.invoke() &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">invalidate</span><span class="params">(key: <span class="type">K</span>)</span></span> = cache.invalidate(key!!)</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在<strong>协程上下文</strong>中使用，如下</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ServiceImpl</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">val</span> locationCache = LocationCache()</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 由于只缓存一段代码的执行结果，因此只有一个key，用一个内部类将缓存包裹起来</span></span><br><span class="line">    <span class="keyword">inner</span> <span class="class"><span class="keyword">class</span> <span class="title">LocationCache</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 创建缓存实例</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">val</span> innerCache = CaffeineProxy&lt;String, List&lt;Location&gt;&gt;()</span><br><span class="line">    <span class="comment">// 取值方法，取的结果是Future实例</span></span><br><span class="line">    <span class="keyword">override</span> <span class="keyword">suspend</span> <span class="function"><span class="keyword">fun</span> <span class="title">getCache</span><span class="params">()</span></span>: Future&lt;List&lt;JsonObject&gt;&gt; = innerCache.<span class="keyword">get</span>(<span class="string">&quot;UniqueCache&quot;</span>) &#123;</span><br><span class="line">        <span class="keyword">val</span> promise = Promise.promise&lt;List&lt;JsonObject&gt;&gt;()</span><br><span class="line">		adminDao.getAvailableLocations(promise)</span><br><span class="line">        promise.future()</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">    </span><br><span class="line">  <span class="comment">// 在方法1中使用该缓存</span></span><br><span class="line">  <span class="keyword">suspend</span> <span class="function"><span class="keyword">fun</span> <span class="title">fun1</span><span class="params">()</span></span> &#123;</span><br><span class="line">      <span class="keyword">val</span> result = locationCache.getCache().await()</span><br><span class="line">      . . .  后续操作 . . .</span><br><span class="line">  &#125;</span><br><span class="line">    </span><br><span class="line">  <span class="comment">// 在方法2中使用该缓存</span></span><br><span class="line">  <span class="keyword">suspend</span> <span class="function"><span class="keyword">fun</span> <span class="title">fun2</span><span class="params">()</span></span> &#123;</span><br><span class="line">      <span class="keyword">val</span> result = locationCache.getCache().await()</span><br><span class="line">      . . .  后续操作 . . .</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="问题复现"><a href="#问题复现" class="headerlink" title="问题复现"></a>问题复现</h2><p>并发较高的场景下，会出现部分方法调用无响应的情况。上述缓存方法放在Web代码中，对应的就是多个会用到缓存的请求同时发起时，部分请求会永远无响应，或者触发系统的超时机制。</p>
<h2 id="原因分析"><a href="#原因分析" class="headerlink" title="原因分析"></a>原因分析</h2><p>上述缓存有一个大前提，即将Future缓存起来，并在之后的流通中反复使用同一个被缓存的Future。前文中，我们在协程上下文中调用了Future的await()方法，该方法定义如下。</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Awaits the completion of a future without blocking the event loop.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">suspend</span> <span class="function"><span class="keyword">fun</span> <span class="type">&lt;T&gt;</span> Future<span class="type">&lt;T&gt;</span>.<span class="title">await</span><span class="params">()</span></span>: T = <span class="keyword">when</span> &#123;</span><br><span class="line">  succeeded() -&gt; result()</span><br><span class="line">  failed() -&gt; <span class="keyword">throw</span> cause()</span><br><span class="line">  <span class="keyword">else</span> -&gt; suspendCancellableCoroutine &#123; cont: CancellableContinuation&lt;T&gt; -&gt;</span><br><span class="line">    setHandler &#123; asyncResult -&gt;</span><br><span class="line">      <span class="keyword">if</span> (asyncResult.succeeded()) cont.resume(asyncResult.result() <span class="keyword">as</span> T)</span><br><span class="line">      <span class="keyword">else</span> cont.resumeWithException(asyncResult.cause())</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>可以看到，其逻辑是：如果成功则返回结果；如果失败则抛出异常；Future未完成则调用setHandler()设置回调方法。</p>
<p>再来看看Future的实现FutureImpl的定义</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">FutureImpl</span>&lt;<span class="title">T</span>&gt; <span class="keyword">implements</span> <span class="title">Promise</span>&lt;<span class="title">T</span>&gt;, <span class="title">Future</span>&lt;<span class="title">T</span>&gt; </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">boolean</span> failed;</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">boolean</span> succeeded;</span><br><span class="line">  <span class="keyword">private</span> Handler&lt;AsyncResult&lt;T&gt;&gt; handler;</span><br><span class="line">  <span class="keyword">private</span> T result;</span><br><span class="line">  <span class="keyword">private</span> Throwable throwable;</span><br><span class="line">    </span><br><span class="line">    . . . . . .</span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * Set a handler for the result. It will get called when it&#x27;s complete</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> Future&lt;T&gt; <span class="title">setHandler</span><span class="params">(Handler&lt;AsyncResult&lt;T&gt;&gt; handler)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">boolean</span> callHandler;</span><br><span class="line">    <span class="keyword">synchronized</span> (<span class="keyword">this</span>) &#123;</span><br><span class="line">      callHandler = isComplete();</span><br><span class="line">      <span class="keyword">if</span> (!callHandler) &#123;</span><br><span class="line">        <span class="keyword">this</span>.handler = handler;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (callHandler) &#123;</span><br><span class="line">      handler.handle(<span class="keyword">this</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">  &#125;</span><br><span class="line">    . . . . . .</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>可以看到，setHandler()会将传入的handler直接覆盖掉现有的handler属性。</p>
<p>于是可以分析出正常情景和异常情景如下</p>
<ul>
<li><p>异常情景</p>
<p>缓存已过期，此时方法1调用获取缓存方法，拿到Future，该Future未完成，于是通过await()方法调用setHandler()设置了一个回调方法；在缓存中的Future尚未完成前，方法2也调用获取缓存方法，得到同一个Future实例，同样，由于它未完成，于是通过await()方法再次调用setHandler()设置了新的回调方法。</p>
<p>这样，方法2设置的回调方法覆盖了方法1设置的回调，当Future完成时，方法2的回调方法将得到通知，使得方法2能够正常继续执行；方法1的回调则会永远等待被回调，直到超时。</p>
</li>
<li><p>正常情景</p>
<p>缓存有效，且Future已完成，根据await()方法的定义：先同步地读取Future的结果，在本场景中，一直能够读取到Future结果，而不会进入到setHandler()，这样无论并发多高，都能够正确返回结果。</p>
</li>
</ul>
<p>如果缓存时间设置很长，Future从创建到完成的时间很短，在单元测试阶段甚至SIT都很难发现。很容易造成线上偶现的bug，并且相当地隐晦，可以说是非常难以发现了。</p>
<h2 id="然后呢？"><a href="#然后呢？" class="headerlink" title="然后呢？"></a>然后呢？</h2><p>到这里，原因找到了。但是仔细想想，从语义上，Future代表一个异步执行的结果，常规的使用方法是setHandler()设置回调方法，那一个结果被多处使用似乎是很自然的需求，Vert.x设置这样一个限制，是不是有些反直觉，或者反人类呢？</p>
<p>或许我们可以在这个<a href="https://github.com/eclipse-vertx/vert.x/issues/1920">issue</a>找到些许解释。简而言之，Future就这样了，如果需要一次生成多次使用，请考虑其它库来实现这样的效果，如RxJava。或者等Vert.x4中将会有类似功能的实现。</p>
<p>我想吐槽的点在于，目前Vert.x的Future实现不修改没有问题，但做一些针对上述问题的防护措施也是可以的，可是并没有。</p>
<h1 id="正确的做法"><a href="#正确的做法" class="headerlink" title="正确的做法"></a>正确的做法</h1><p>看来，Future是不能使用了，那我们应该使用什么呢？官方推荐使用RxJava，查看<a href="http://reactivex.io/documentation/subject.html">文档</a>后，发现有如下几个占位符可选。</p>
<ul>
<li>Single — Single.cache()生成的Single，可被多次订阅</li>
<li>订阅Single的BehaviorSubject —— 可订阅和被订阅，用它订阅Single，我们再订阅它。特性上，它返回其订阅的最近的消息，并永远不会主动结束，即可被多次订阅</li>
</ul>
<p>二者综合选其一，肯定是能直接使用Single就直接使用Single就好呀。</p>
<p>于是将我们的缓存实现修改成缓存Single的形式</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="comment">/** </span></span><br><span class="line"><span class="comment"> * Cache接口</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">Cache</span>&lt;<span class="type">K, V</span>&gt; </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// get方法，第一个参数为key，第二个参数为缓存过期时获取新的缓存的方法</span></span><br><span class="line">  <span class="function"><span class="keyword">fun</span> <span class="title">get</span><span class="params">(key: <span class="type">K</span>, mappingFunction: () -&gt; <span class="type">Single</span>&lt;<span class="type">V</span>&gt;)</span></span>: Single&lt;V&gt;</span><br><span class="line">  . . . . . .</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/** </span></span><br><span class="line"><span class="comment"> * Cache实现</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">CaffeineProxy</span>&lt;<span class="type">K, V</span>&gt;  : <span class="type">Cache</span>&lt;<span class="type">K, V</span>&gt; </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">val</span> cache: Cache&lt;K, Single&lt;V&gt;&gt; = Caffeine.newBuilder().build()</span><br><span class="line"></span><br><span class="line">  <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">get</span><span class="params">(key: <span class="type">K</span>, mappingFunction: () -&gt; <span class="type">Single</span>&lt;<span class="type">V</span>&gt;)</span></span>: Single&lt;V&gt; = </span><br><span class="line">    cache.<span class="keyword">get</span>(key) &#123; mappingFunction.invoke() &#125;</span><br><span class="line">  . . . . . .</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>使用时获取Single并订阅即可。</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ServiceImpl</span> </span>&#123;</span><br><span class="line">    . . . . . .</span><br><span class="line">    <span class="keyword">suspend</span> <span class="function"><span class="keyword">fun</span> <span class="title">fun1</span><span class="params">()</span></span> &#123;</span><br><span class="line">        locationCache.getCache().subscribe(&#123; result -&gt;</span><br><span class="line">        <span class="comment">// 对成功的处理</span></span><br><span class="line">        &#125;,&#123; cause -&gt;</span><br><span class="line">            <span class="comment">// 对失败的处理</span></span><br><span class="line">        &#125;)</span><br><span class="line">    &#125;</span><br><span class="line">    . . . . . .</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="合适的做法"><a href="#合适的做法" class="headerlink" title="合适的做法"></a>合适的做法</h1><p>使用Single虽然实现了异步缓存的功能，但在协程中使用RxJava却是浪费了协程的特性。那如果我们在调用时想要使用Future呢。为此可以将缓存包装一下，同时暴露协程、Future、Single三种API风格的接口，任君选择。</p>
<p>接口如下</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">CacheProxy</span>&lt;<span class="type">K, V</span>&gt; </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Single API</span></span><br><span class="line">  <span class="function"><span class="keyword">fun</span> <span class="title">singleGet</span><span class="params">(key: <span class="type">K</span>, mappingFunction: () -&gt; <span class="type">Single</span>&lt;<span class="type">V</span>&gt;)</span></span>: Single&lt;V&gt;</span><br><span class="line">  </span><br><span class="line">  <span class="comment">// Future API </span></span><br><span class="line">  <span class="function"><span class="keyword">fun</span> <span class="title">futureGet</span><span class="params">(key: <span class="type">K</span>, mappingFunction: () -&gt; <span class="type">Future</span>&lt;<span class="type">V</span>&gt;)</span></span>: Future&lt;V&gt;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 协程API</span></span><br><span class="line">  <span class="keyword">suspend</span> <span class="function"><span class="keyword">fun</span> <span class="title">coroutineGet</span><span class="params">(key: <span class="type">K</span>, mappingFunction: <span class="type">suspend</span> () -&gt; <span class="type">V</span>)</span></span>: V</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>实现类可以这么做。</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">CaffeineProxy</span>&lt;<span class="type">K, V</span>&gt;</span>(<span class="keyword">val</span> vertx: Vertx) : CacheProxy&lt;K, V&gt; &#123;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">val</span> cache: Cache&lt;K, Single&lt;V&gt;&gt; = Caffeine.newBuilder().build()</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 接收返回Single的方法，返回一个Single</span></span><br><span class="line">  <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">singleGet</span><span class="params">(key: <span class="type">K</span>, mappingFunction: () -&gt; <span class="type">Single</span>&lt;<span class="type">V</span>&gt;)</span></span>: Single&lt;V&gt; &#123;</span><br><span class="line">    <span class="keyword">return</span> cache.<span class="keyword">get</span>(key!!) &#123; mappingFunction.invoke() &#125;!!</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 接收返回Future的方法，返回一个Future</span></span><br><span class="line">  <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">futureGet</span><span class="params">(key: <span class="type">K</span>, mappingFunction: () -&gt; <span class="type">Future</span>&lt;<span class="type">V</span>&gt;)</span></span>: Future&lt;V&gt; &#123;</span><br><span class="line">    <span class="keyword">val</span> promise = Promise.promise&lt;V&gt;()</span><br><span class="line">    cache.<span class="keyword">get</span>(key) &#123; SingleHelper.toSingle&lt;V&gt; &#123; mappingFunction.invoke().setHandler(it) &#125;.cache() &#125;!!.subscribe(&#123;</span><br><span class="line">      promise.complete(it)</span><br><span class="line">    &#125;, &#123;</span><br><span class="line">      promise.fail(it)</span><br><span class="line">    &#125;)</span><br><span class="line">    <span class="keyword">return</span> promise.future()</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 接收suspend方法，返回一个值</span></span><br><span class="line">  <span class="keyword">override</span> <span class="keyword">suspend</span> <span class="function"><span class="keyword">fun</span> <span class="title">coroutineGet</span><span class="params">(key: <span class="type">K</span>, mappingFunction: <span class="type">suspend</span> () -&gt; <span class="type">V</span>)</span></span> = withContext(vertx.dispatcher()) &#123;</span><br><span class="line">    <span class="keyword">val</span> promise = Promise.promise&lt;V&gt;()</span><br><span class="line">    cache.<span class="keyword">get</span>(key) &#123;</span><br><span class="line">      Single.create&lt;V&gt; &#123;</span><br><span class="line">        launch &#123;</span><br><span class="line">          <span class="keyword">try</span> &#123;</span><br><span class="line">            it.onSuccess(mappingFunction.invoke())</span><br><span class="line">          &#125; <span class="keyword">catch</span> (e: Exception) &#123;</span><br><span class="line">            it.onError(e)</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;.cache()</span><br><span class="line">    &#125;!!.subscribe(&#123;</span><br><span class="line">      promise.complete(it)</span><br><span class="line">    &#125;, &#123;</span><br><span class="line">      promise.fail(it)</span><br><span class="line">    &#125;)</span><br><span class="line">    promise.future().await()</span><br><span class="line">  &#125;!!</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Rx风格的接口不必多说，直来直去；</p>
<p>Future风格的接口，使用了Vert.x提供的API在Single和Future之间进行了切换；协程会稍微麻烦点：</p>
<p>协程内部可以看做是同步执行的，在获取Single时，为了全异步特性，我们需要异步执行，因此使用launch启动新协程是个好办法。</p>
<p>至此，我们的缓存接口能够适用于目前所有三种异步API，使用时无缝衔接。</p>
<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>Future多次使用的问题，并不是我第一次遇到，只不过上次主要是靠前辈解决，以至于过了太久我都没什么印象，说来确实不太应该。</p>
<p>但好在问题解决了，同时也提出了一种通用的调用方法，在实用层面上，是值得参考的。</p>
<h1 id="参考文档"><a href="#参考文档" class="headerlink" title="参考文档"></a>参考文档</h1><ol>
<li><p><a href="https://vertx.io/docs/vertx-core/java/">Vert.x官方手册 - 核心部分</a></p>
</li>
<li><p><a href="https://github.com/eclipse-vertx/vert.x/issues/1920">exlipse-vertx/vert.x - issue#1920</a></p>
</li>
<li><p><a href="http://reactivex.io/documentation/single.html">Reactivex Java - Single</a></p>
</li>
<li><p><a href="http://reactivex.io/documentation/subject.html">Reactivex Java - Subject</a></p>
</li>
</ol>
]]></content>
      <categories>
        <category>响应式</category>
      </categories>
      <tags>
        <tag>Vert.x</tag>
      </tags>
  </entry>
  <entry>
    <title>Vertx源码解析 - Web（上）</title>
    <url>/2020/11/03/Vertx%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90%20-%20Web%EF%BC%88%E4%B8%8A%EF%BC%89-vertx-yuan-ma-jie-xi--web-shang-/</url>
    <content><![CDATA[<p>我们在前面的文章分析了Vertx核心单机部分的源码。今天轮到<a href="https://vertx-web-site.github.io/docs/vertx-web/java/">Vert.x-Web</a>，由于Web的内容比较多，因此分为上下两部分。</p>
<ul>
<li>上：分析Vert.x-Web核心类及其主要能力。</li>
<li>下：分析HttpServer的线程调度以及Web OpenAPI的工作原理</li>
</ul>
<span id="more"></span>

<p>一个基本的VertxWeb代码片段如下：</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">val</span> vertx = Vertx.vertx()</span><br><span class="line">    <span class="keyword">val</span> router = Router.router(vertx)</span><br><span class="line">    router.<span class="keyword">get</span>(<span class="string">&quot;/hello&quot;</span>)</span><br><span class="line">        .handler &#123; ctx -&gt;</span><br><span class="line">                  println(<span class="string">&quot;哈哈哈，我好开心&quot;</span>)</span><br><span class="line">                  ctx.next()</span><br><span class="line">                 &#125;</span><br><span class="line">    .failureHandler(ErrorHandler.create())</span><br><span class="line">    <span class="keyword">val</span> server = vertx.createHttpServer().requestHandler(router)</span><br><span class="line">    server.listen(<span class="number">8080</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上面创建了一个Http服务，暴露8080端口，并注册了一个path为hello，方法为GET的接口。上面涉及到Vert.x-Web的类有：Router、Route、RoutingContext、HttpServer。我们介绍前三个。</p>
<h2 id="Router"><a href="#Router" class="headerlink" title="Router"></a>Router</h2><h3 id="Router-1"><a href="#Router-1" class="headerlink" title="Router"></a>Router</h3><p>首先是Router接口，它主要有以下几个方面组成。</p>
<ul>
<li><p>Router.router(vertx) 创建一个Router对象</p>
</li>
<li><p>routeXXX() 各种路由方法，可以根据路径、方法、媒体类型、正则表达式等各种方式路由，返回一个Route对象，用于指定处理器。</p>
</li>
<li><p>getRoutes() 获取所有route</p>
</li>
<li><p>clear() 清除所有Route</p>
</li>
<li><p>mountSubRouter() 挂载子router</p>
</li>
<li><p>exceptionHandler() 指定一个router级别的异常处理器，当handler中抛出异常时，它会捕获。但它不会影响正常业务逻辑。</p>
<p>但它目前已被废弃，应该使用errorHandler()，它对应的是500的错误</p>
</li>
<li><p>errorHandler(code, handler)  当发生特定错误码时会调用它。当RoutingContext失败(fail) 或 一些handler失败但没有写响应 或 handler中抛出了异常，都会调用它。需要注意的是它的500有特殊的意义，代表通用错误。</p>
</li>
<li><p>handleContext(context) 将一个RoutingContext传进来，当一个Router被挂载到某个route时会用：将该route的RoutingContext传入本router进行处理。</p>
</li>
<li><p>handleFailure(RoutingContext) 使用场景同上，处理失败</p>
</li>
<li><p>modifiedHandler(handler) 当本Router的Route发生变化时该方法会被触发。</p>
</li>
</ul>
<p>首先说，Router只是Handler的子类，因此本质上还只是一个处理器，是被动调用的。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@VertxGen</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Router</span> <span class="keyword">extends</span> <span class="title">Handler</span>&lt;<span class="title">HttpServerRequest</span>&gt; </span>&#123;</span><br><span class="line">... ...</span><br></pre></td></tr></table></figure>

<h3 id="RouterImpl"><a href="#RouterImpl" class="headerlink" title="RouterImpl"></a>RouterImpl</h3><p>众多route生成方法的实现都大同小异，都是创建RouteImpl</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> synchronized Route route(String path) &#123;</span><br><span class="line">  state = state.incrementOrderSequence();</span><br><span class="line">  <span class="keyword">return</span> new RouteImpl(<span class="keyword">this</span>, state.getOrderSequence(), path);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>另外一个重点是handle，既然Router是Handler的子类，因此本类最初被调用的一定是handle方法（<strong>在请求进来时调用</strong>）</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> void handle(HttpServerRequest request) &#123;</span><br><span class="line">    <span class="comment">// 注意后面的next()调用，这很容易被看漏掉。</span></span><br><span class="line">    new RoutingContextImpl(<span class="literal">null</span>, <span class="keyword">this</span>, request, state.getRoutes()).next();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>啥也没干，就<strong>创建了一个RoutingContextImpl，并调用了next()，开启处理逻辑</strong>。</p>
<h3 id="RouterState"><a href="#RouterState" class="headerlink" title="RouterState"></a>RouterState</h3><p>一个RouterImpl包含一个RouterState，在初始化时创建，用于管理Router的状态</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> RouterImpl(Vertx vertx) &#123;</span><br><span class="line">    <span class="keyword">this</span>.vertx = vertx;</span><br><span class="line">    <span class="keyword">this</span>.state = new RouterState(<span class="keyword">this</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>共有如下几种状态</p>
<ul>
<li>Route集合：Router内注册的Route全在这里</li>
<li>errorHandler映射：失败的处理器，其中key对应的错误码，如400</li>
<li>modifiedHandler：用于在Router发生变化时做出响应的处理器</li>
</ul>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> Set&lt;RouteImpl&gt; routes;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> Map&lt;Integer, Handler&lt;RoutingContext&gt;&gt; errorHandlers;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> Handler&lt;Router&gt; modifiedHandler;</span><br></pre></td></tr></table></figure>

<h2 id="Route"><a href="#Route" class="headerlink" title="Route"></a>Route</h2><h3 id="Route-1"><a href="#Route-1" class="headerlink" title="Route"></a>Route</h3><p>一个接口，对路由信息的描述，包含如下几种信息，见名思义。</p>
<ul>
<li>method</li>
<li>path</li>
<li>regex</li>
<li>consumes</li>
<li>produces</li>
</ul>
<p>同时包含了对匹配到的请求的处理方式</p>
<ul>
<li>handler()：为Route添加一个处理器，多个handler之间会连缀调用。</li>
<li>failureHandler()：为Route添加一个失败处理器，多个handler之间会连缀调用。</li>
<li>blockingHandler()：为Route添加一个能够执行阻塞操作的处理器。</li>
<li>subRouter()：为Route添加一个子Router，符合要求的请求都会被转发给该Router。</li>
</ul>
<h3 id="RouteImpl"><a href="#RouteImpl" class="headerlink" title="RouteImpl"></a>RouteImpl</h3><p>就是对上面各个方法的实现，这里不赘述。</p>
<h3 id="RouteState"><a href="#RouteState" class="headerlink" title="RouteState"></a>RouteState</h3><p>对一个路由状态的持有，相对RouterState而言，它持有的状态复杂得多。</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 路径</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> String path;</span><br><span class="line"><span class="comment">// 顺序</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> int order;</span><br><span class="line"><span class="comment">// 是否开启</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> boolean enabled;</span><br><span class="line"><span class="comment">// 方法</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> Set&lt;HttpMethod&gt; methods;</span><br><span class="line"><span class="comment">// 消费的多媒体类型</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> Set&lt;MIMEHeader&gt; consumes;</span><br><span class="line"><span class="comment">// 是否允许body为空</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> boolean emptyBodyPermittedWithConsumes;</span><br><span class="line"><span class="comment">// 产生的多媒体类型</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> Set&lt;MIMEHeader&gt; produces;</span><br><span class="line"><span class="comment">// 常规处理器集合</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> List&lt;Handler&lt;RoutingContext&gt;&gt; contextHandlers;</span><br><span class="line"><span class="comment">// 失败处理器集合</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> List&lt;Handler&lt;RoutingContext&gt;&gt; failureHandlers;</span><br><span class="line"><span class="comment">// 不知道干嘛的</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> boolean added;</span><br><span class="line"><span class="comment">// 用于匹配的正则</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> Pattern pattern;</span><br><span class="line"><span class="comment">// 也属于正则表达式的一部分</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> List&lt;String&gt; groups;</span><br><span class="line"><span class="comment">// 是否使用归一化路径</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> boolean useNormalisedPath;</span><br><span class="line"><span class="comment">// 还是正则表达式</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> Set&lt;String&gt; namedGroupsInRegex;</span><br><span class="line"><span class="comment">// 主机匹配</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> Pattern virtualHostPattern;</span><br><span class="line"><span class="comment">// 路径是否以斜杠结尾</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> boolean pathEndsWithSlash;</span><br><span class="line"><span class="comment">// 是否被排除</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> boolean exclusive;</span><br><span class="line"><span class="comment">// 是否精确匹配</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> boolean exactPath;</span><br></pre></td></tr></table></figure>

<p>对Route最重要的方法当然是判断是否匹配，该方法也是在RouteState中给出</p>
<p>io.vertx.ext.web.impl.RouteState#matches，逻辑比较复杂，有兴趣可以去看看</p>
<h2 id="RoutingContext"><a href="#RoutingContext" class="headerlink" title="RoutingContext"></a>RoutingContext</h2><p>RoutingContext是Router上下文的抽象，代表一个请求从进入到响应全阶段的状态。由于在Router.handle()中，直接创建了RoutingContextImpl对象，并调用了RoutingContext.next()，因此我们重点关注它。</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="comment">// RoutingContext的实现类RoutingContextImpl的构造方法</span></span><br><span class="line"><span class="keyword">public</span> RoutingContextImpl(String mountPoint, RouterImpl router, HttpServerRequest request, Set&lt;RouteImpl&gt; routes) &#123;</span><br><span class="line">    <span class="keyword">super</span>(mountPoint, request, routes);</span><br><span class="line">    <span class="keyword">this</span>.router = router;</span><br><span class="line">    <span class="keyword">this</span>.fillParsedHeaders(request);</span><br><span class="line">    <span class="keyword">if</span> (request.path().length() == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">this</span>.fail(<span class="number">400</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (request.path().charAt(<span class="number">0</span>) != <span class="string">&#x27;/&#x27;</span>) &#123;</span><br><span class="line">        <span class="keyword">this</span>.fail(<span class="number">404</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// RoutingContextImpl的父类RoutingContextImplBase的构造方法</span></span><br><span class="line">RoutingContextImplBase(String mountPoint, HttpServerRequest request, Set&lt;RouteImpl&gt; routes) &#123;</span><br><span class="line">    <span class="keyword">this</span>.mountPoint = mountPoint;</span><br><span class="line">    <span class="keyword">this</span>.request = new HttpServerRequestWrapper(request);</span><br><span class="line">    <span class="keyword">this</span>.routes = routes;</span><br><span class="line">    <span class="keyword">this</span>.iter = routes.iterator();</span><br><span class="line">    <span class="keyword">this</span>.currentRouteNextHandlerIndex = new AtomicInteger(<span class="number">0</span>);</span><br><span class="line">    <span class="keyword">this</span>.currentRouteNextFailureHandlerIndex = new AtomicInteger(<span class="number">0</span>);</span><br><span class="line">    <span class="keyword">this</span>.resetMatchFailure();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// next方法</span></span><br><span class="line"><span class="keyword">public</span> void next() &#123;</span><br><span class="line">    <span class="keyword">if</span> (!<span class="keyword">this</span>.iterateNext()) &#123;</span><br><span class="line">        <span class="keyword">this</span>.checkHandleNoMatch();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>仔细看iterateNext()</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line">boolean iterateNext() &#123;</span><br><span class="line">    boolean failed = <span class="keyword">this</span>.failed();</span><br><span class="line">    <span class="comment">// 在route的第二个handler调用next时，走的是这段逻辑。</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">this</span>.currentRoute != <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (!failed &amp;&amp; <span class="keyword">this</span>.currentRoute.hasNextContextHandler(<span class="keyword">this</span>)) &#123;</span><br><span class="line">                <span class="keyword">this</span>.currentRouteNextHandlerIndex.incrementAndGet();</span><br><span class="line">                <span class="keyword">this</span>.resetMatchFailure();</span><br><span class="line">                <span class="keyword">this</span>.currentRoute.handleContext(<span class="keyword">this</span>);</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (failed &amp;&amp; <span class="keyword">this</span>.currentRoute.hasNextFailureHandler(<span class="keyword">this</span>)) &#123;</span><br><span class="line">                <span class="keyword">this</span>.currentRouteNextFailureHandlerIndex.incrementAndGet();</span><br><span class="line">                <span class="keyword">this</span>.currentRoute.handleFailure(<span class="keyword">this</span>);</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Throwable var5) &#123;</span><br><span class="line">            <span class="keyword">this</span>.handleInHandlerRuntimeFailure(<span class="keyword">this</span>.currentRoute.getRouter(), failed, var5);</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 死循环迭代所有route</span></span><br><span class="line">    <span class="keyword">while</span>(<span class="literal">true</span>) &#123;</span><br><span class="line">        <span class="comment">// this.iter是Router.getRoutes().iterator()得到的，即迭代所有routes</span></span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">this</span>.iter.hasNext()) &#123;</span><br><span class="line">            <span class="comment">// RouteState包含了所有Route的状态和内容，因此要操作Route就一定要获取它啦</span></span><br><span class="line">            RouteState routeState = ((RouteImpl)<span class="keyword">this</span>.iter.next()).state();</span><br><span class="line">            <span class="keyword">this</span>.currentRouteNextHandlerIndex.<span class="keyword">set</span>(<span class="number">0</span>);</span><br><span class="line">            <span class="keyword">this</span>.currentRouteNextFailureHandlerIndex.<span class="keyword">set</span>(<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="comment">// 匹配结果是0或4开头的状态码，如果是0则表示成功。这意味着每个route都会匹配一次，也一定会有一个结果。</span></span><br><span class="line">                int matchResult = routeState.matches(<span class="keyword">this</span>, <span class="keyword">this</span>.mountPoint(), failed);</span><br><span class="line">                <span class="comment">// 匹配失败的情况</span></span><br><span class="line">                <span class="keyword">if</span> (matchResult != <span class="number">0</span>) &#123;</span><br><span class="line">                    <span class="keyword">if</span> (matchResult == <span class="number">405</span>) &#123;</span><br><span class="line">                        <span class="keyword">if</span> (<span class="keyword">this</span>.matchFailure == <span class="number">404</span>) &#123;</span><br><span class="line">                            <span class="keyword">this</span>.matchFailure = matchResult;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (matchResult != <span class="number">404</span>) &#123;</span><br><span class="line">                        <span class="keyword">this</span>.matchFailure = matchResult;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">continue</span>;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="comment">// 匹配成功的情况</span></span><br><span class="line">                <span class="keyword">this</span>.resetMatchFailure();</span><br><span class="line"></span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    <span class="keyword">this</span>.currentRoute = routeState;、</span><br><span class="line"></span><br><span class="line">                    <span class="keyword">if</span> (failed &amp;&amp; <span class="keyword">this</span>.currentRoute.hasNextFailureHandler(<span class="keyword">this</span>)) &#123;</span><br><span class="line">	                    <span class="comment">// 如果有失败，则调用route原先保存的failureHandler</span></span><br><span class="line">                        <span class="keyword">this</span>.currentRouteNextFailureHandlerIndex.incrementAndGet();</span><br><span class="line">                        routeState.handleFailure(<span class="keyword">this</span>);</span><br><span class="line">                    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                        <span class="comment">// 如果成功，则调用route原先保存的contextHandler</span></span><br><span class="line">                        <span class="keyword">if</span> (!<span class="keyword">this</span>.currentRoute.hasNextContextHandler(<span class="keyword">this</span>)) &#123;</span><br><span class="line">                            <span class="keyword">continue</span>;</span><br><span class="line">                        &#125;</span><br><span class="line"></span><br><span class="line">                        <span class="keyword">this</span>.currentRouteNextHandlerIndex.incrementAndGet();</span><br><span class="line">                        routeState.handleContext(<span class="keyword">this</span>);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125; <span class="keyword">catch</span> (Throwable var6) &#123;</span><br><span class="line">                    <span class="keyword">this</span>.handleInHandlerRuntimeFailure(routeState.getRouter(), failed, var6);</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">            &#125; <span class="keyword">catch</span> (Throwable var7) &#123;</span><br><span class="line">                <span class="keyword">if</span> (LOG.isTraceEnabled()) &#123;</span><br><span class="line">                    LOG.trace(<span class="string">&quot;IllegalArgumentException thrown during iteration&quot;</span>, var7);</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span> (!<span class="keyword">this</span>.response().ended()) &#123;</span><br><span class="line">                    <span class="keyword">this</span>.unhandledFailure(var7 instanceof IllegalArgumentException ? <span class="number">400</span> : -<span class="number">1</span>, var7, routeState.getRouter());</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>再来仔细看</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> void checkHandleNoMatch() &#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">this</span>.failed()) &#123;</span><br><span class="line">	    <span class="comment">// 如果失败了，则按照未处理的异常处理，即从router的errorHandler中获取对应code的handler并给出结果</span></span><br><span class="line">        <span class="keyword">this</span>.unhandledFailure(<span class="keyword">this</span>.statusCode, <span class="keyword">this</span>.failure, <span class="keyword">this</span>.router);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// 没有失败时也获取以下，有说明是预期的失败，还是要处理。</span></span><br><span class="line">        Handler&lt;RoutingContext&gt; handler = <span class="keyword">this</span>.router.getErrorHandlerByStatusCode(<span class="keyword">this</span>.matchFailure);</span><br><span class="line">        <span class="keyword">this</span>.statusCode = <span class="keyword">this</span>.matchFailure;</span><br><span class="line">        <span class="keyword">if</span> (handler == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">this</span>.response().setStatusCode(<span class="keyword">this</span>.matchFailure);</span><br><span class="line">            <span class="comment">// 404的情况</span></span><br><span class="line">            <span class="keyword">if</span> (<span class="keyword">this</span>.request().method() != HttpMethod.HEAD &amp;&amp; <span class="keyword">this</span>.matchFailure == <span class="number">404</span>) &#123;</span><br><span class="line">                <span class="keyword">this</span>.response().putHeader(HttpHeaderNames.CONTENT_TYPE, <span class="string">&quot;text/html; charset=utf-8&quot;</span>).end(<span class="string">&quot;&lt;html&gt;&lt;body&gt;&lt;h1&gt;Resource not found&lt;/h1&gt;&lt;/body&gt;&lt;/html&gt;&quot;</span>);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">// 常规情况，直接结束</span></span><br><span class="line">                <span class="keyword">this</span>.response().end();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            handler.handle(<span class="keyword">this</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>到现在，抛开Router是被谁调用这问题。我们知道<strong>整个RoutingContext的执行起始是Router的handle方法：它创建RoutingContextImpl对象，并调用next()启动route的匹配操作，并在匹配后调用对应route的正常handler链或失败handler链。</strong></p>
<p>这里掌握三个关键点</p>
<ul>
<li><strong>RoutingContext对象是在Router的handle中创建的，并在匹配到的route的handler中流转。</strong></li>
<li><strong>遍历所有route的过程会在每次请求进来被处理。逻辑在iterateNext()方法的下半部分。</strong></li>
<li><strong>route的handler链调用比较特殊，需要开发者手动调用RoutingContext的next()方法处理。逻辑在iterateNext()方法的上半部分。</strong></li>
<li><strong>在从Router的handle开始，都是在当前线程不阻塞地执行，可以一镜到底。</strong></li>
</ul>
<p>对于Web的整个处理链，我们弄得差不多了。现在还存在如下问题，我们留待下篇再来看。</p>
<ul>
<li>谁构建HttpServerRequest并调用了Router的handler？</li>
<li>调用Router时线程分配是如何的？</li>
</ul>
]]></content>
      <categories>
        <category>响应式</category>
      </categories>
      <tags>
        <tag>Vert.x</tag>
      </tags>
  </entry>
  <entry>
    <title>gitops实践总结</title>
    <url>/2022/04/21/gitops%E5%AE%9E%E8%B7%B5%E6%80%BB%E7%BB%93/</url>
    <content><![CDATA[<blockquote>
<p>Infrastructure as Code，将基础设施以代码的形式管理起来，放在git仓库中。Kubernetes的清单文件就是一种<br>gitops = Infrastructure as Code + version control + Pull/Push Request + CI/CD流水线。即，将维护在git仓库中的基础设施代码，以git仓库的方式进行开发、权限管理，再在CI中做正确性检查，然后CD交付到具体基础设施。<br>此处，需要维护的基础设施，即Kubernetes。</p>
</blockquote>
<span id="more"></span>

<h1 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h1><p>当前应用发布方式。</p>
<ol>
<li>应用创建：在仓库中创建应用，生成清单文件，kubectl apply到目标集群</li>
<li>CI：镜像打包上传远端仓库后，通过kubectl edit Deployment set 命令修改目标镜像</li>
</ol>
<p>这样做的缺点</p>
<ol>
<li>kubectl属于主动push，多个集群就要维护多套配置</li>
<li>当前的清单文件仓库鸡肋，只能够初始化应用，无法跟踪应用状态</li>
<li>Runner依赖：依赖于有kubectl和配置的Runner</li>
<li>Kubernetes访问配置文件外泄，安全性不高</li>
</ol>
<p>这个问题的解决方式——gitops</p>
<h1 id="选型"><a href="#选型" class="headerlink" title="选型"></a>选型</h1><p>目前三种技术比较流行：argo cd、jenkins x、flux cd，考虑到我们使用gitlab作为版本控制管理工具，还有gitlab kubernetes agent可供考虑。至于怎么选，只是一个CD工具而已，功能大差不差。看起来肯定是gitlab最好，最流行的是argo cd，如果我用jenkins作为流水线，可能会考虑jenkins x。而gitlab kubernetes agent仅是高级版本支持，我们使用了社区版自建，因此无缘。于是顺理成章用到了argo cd。</p>
<h1 id="实践"><a href="#实践" class="headerlink" title="实践"></a>实践</h1><p>argo cd的手册算是写得很详细，按照手册做，就没问题了。这里只列出值得注意的问题</p>
<h2 id="注意事项"><a href="#注意事项" class="headerlink" title="注意事项"></a>注意事项</h2><h3 id="工作原理"><a href="#工作原理" class="headerlink" title="工作原理"></a>工作原理</h3><p>argo cd基于拉模式，是安装在K8S集群内部的，而当实现一个argocd实例管理多个集群时，被管理的外部集群则不需要安装任何argocd组件，因为它是基于RBAC进行访问。</p>
<p>其工作组件主要如下</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">zouguodong@zouguodongdeMacBook-Pro ~ % kubeoverseas get deployment -n argocd</span><br><span class="line">NAME                               READY   UP-TO-DATE   AVAILABLE   AGE</span><br><span class="line">argocd-applicationset-controller   1/1     1            1           4d17h</span><br><span class="line">argocd-redis                       1/1     1            1           4d17h</span><br><span class="line">argocd-notifications-controller    1/1     1            1           4d17h</span><br><span class="line">argocd-dex-server                  1/1     1            1           4d17h</span><br><span class="line">argocd-repo-server                 1/1     1            1           4d17h</span><br><span class="line">argocd-server                      1/1     1            1           4d17h</span><br></pre></td></tr></table></figure>

<ul>
<li>argocd-server：中枢</li>
<li>argocd-repo-server ：git仓库的本地缓存</li>
<li>argocd-applicationset-controller：一个k8s控制器，用于比较原版本和目标版本</li>
<li>argocd-dex-server：一个SSO服务</li>
<li>argocd-redis ：一次性缓存</li>
<li>argocd-notifications-controller：给用户发送通知</li>
</ul>
<h3 id="argocd服务外部访问方式"><a href="#argocd服务外部访问方式" class="headerlink" title="argocd服务外部访问方式"></a>argocd服务外部访问方式</h3><p>端口转发、ingress、slb service。端口转发在我电脑上会出现自动断开的情况，不明原因。ingress倒是可以用，但在没有配置证书时，会出现无线重定向的问题。两个解决方案</p>
<ul>
<li>给ingress配置正确的证书</li>
<li>关闭argocd-server的安全选项，在启动参数添加 –insecure</li>
</ul>
<h3 id="引用私有git仓库"><a href="#引用私有git仓库" class="headerlink" title="引用私有git仓库"></a>引用私有git仓库</h3><p>如果manifest文件来自自建git仓库，需要配置两个东西</p>
<ul>
<li>私钥</li>
<li>unknown host</li>
</ul>
<p>具体参考<a href="https://argo-cd.readthedocs.io/en/stable/user-guide/private-repositories/#managing-ssh-known-hosts-using-the-cli">这里</a></p>
<h3 id="同步逻辑"><a href="#同步逻辑" class="headerlink" title="同步逻辑"></a>同步逻辑</h3><p>默认三分钟从清单仓库同步一次，但还支持UI和命令行的手动同步，以及WebHook同步（可用于CI）</p>
<h3 id="命名问题"><a href="#命名问题" class="headerlink" title="命名问题"></a>命名问题</h3><p>argocd的应用名全局唯一。下面解释原因</p>
<ul>
<li>argocd只对存在于argocd命名空间下的资源进行解析和管理，应用名就是资源名</li>
<li>根据k8s的命名规则，同一命名空间下的资源名不能相同</li>
</ul>
<p>这会造成一个问题：如果想用一个argocd实例管理对应两个环境的两个集群，它们是平行的世界，按理来说对应的argocd应用名也应该一致，然而现实却无法做到。因此你只能为它们添加前缀进行区分。</p>
<h3 id="忘记密码"><a href="#忘记密码" class="headerlink" title="忘记密码"></a>忘记密码</h3><p>如果忘记管理员密码</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">kubectl -n argocd get secret argocd-initial-admin-secret -o jsonpath=&quot;&#123;.data.password&#125;&quot; | base64 -d; echo</span><br></pre></td></tr></table></figure>

<h2 id="最佳实践"><a href="#最佳实践" class="headerlink" title="最佳实践"></a>最佳实践</h2><h3 id="使用app-of-apps"><a href="#使用app-of-apps" class="headerlink" title="使用app-of-apps"></a>使用app-of-apps</h3><p>这是官方推荐的应用安装方式。这儿有一篇<a href="https://medium.com/dzerolabs/turbocharge-argocd-with-app-of-apps-pattern-and-kustomized-helm-ea4993190e7c">相关文章</a></p>
<blockquote>
<p>说白了，<a href="https://argoproj.github.io/argo-cd/operator-manual/cluster-bootstrapping/#app-of-apps-pattern">App of Apps Pattern</a>让我们定义了一个根 ArgoCD Application（Root App）。根应用程序不是指向应用程序清单，而是指向一个文件夹，该文件夹包含Application应用程序包（子应用程序）指向的每个微服务的 YAML 定义。然后，每个微服务的ApplicationYAML 指向一个包含应用程序清单的目录。</p>
</blockquote>
<p>实际体验下来，这种方式最大的方便，就是只需要手动创建父应用，子应用就能够声明式创建。</p>
<h3 id="secrets的存放方式"><a href="#secrets的存放方式" class="headerlink" title="secrets的存放方式"></a>secrets的存放方式</h3><p>k8s的secret资源，肯定是不能明文存放在版本库的。推荐使用<a href="https://github.com/bitnami-labs/sealed-secrets">sealed-secrets</a>。它通过CRD+Server+Client的方式工作，Server负责秘钥分发、CRD转Secret资源；Client负责本地加密并创建CRD。加密时需要从Server处获取秘钥。</p>
<h3 id="CI脚本"><a href="#CI脚本" class="headerlink" title="CI脚本"></a>CI脚本</h3><p>对gitlab ci，可以使用扩展+模板的方式达成。如下主要关注脚本修改版本库文件和kustomize edit命令的使用。需要了解git over http。且它要在docker类型的gitlab runner运行，否则会污染本地git配置</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">variables:</span></span><br><span class="line">  <span class="comment"># 用户密码在环境变量中给出</span></span><br><span class="line">  <span class="attr">GITOPS_USERNAME:</span> <span class="string">xxx</span></span><br><span class="line">  <span class="attr">GITOPS_PASSWORD:</span> <span class="string">xxx</span></span><br><span class="line">  <span class="comment"># 应用名、环境、镜像需要用户给出</span></span><br><span class="line">  <span class="attr">GITOPS_APP_NAME:</span> <span class="string">demo</span></span><br><span class="line">  <span class="attr">GITOPS_ENVIRONMENT:</span> <span class="string">prod</span></span><br><span class="line">  <span class="attr">IMAGE:</span> <span class="string">xxx</span></span><br><span class="line"></span><br><span class="line"><span class="string">.deploy-k8s:</span></span><br><span class="line">  <span class="attr">stage:</span> <span class="string">deploy</span></span><br><span class="line">  <span class="attr">image:</span> <span class="string">cnych/kustomize:v1.0</span></span><br><span class="line">  <span class="attr">tags:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">docker</span></span><br><span class="line">  <span class="attr">before_script:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">git</span> <span class="string">clone</span> <span class="string">https://$&#123;GITOPS_USERNAME&#125;:$&#123;GITOPS_PASSWORD&#125;@git.mampod.work/g1/platform/kubernetes-manifest.git</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">git</span> <span class="string">config</span> <span class="string">--global</span> <span class="string">user.name</span> <span class="string">&quot;gitops&quot;</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">git</span> <span class="string">config</span> <span class="string">--global</span> <span class="string">user.email</span> <span class="string">&quot;gitops@mampod.com&quot;</span></span><br><span class="line">  <span class="attr">script:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">git</span> <span class="string">checkout</span> <span class="string">-B</span> <span class="string">master</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">cd</span> <span class="string">kubernetes-manifest/kustomize/$&#123;GITOPS_APP_NAME&#125;/overlays/$&#123;GITOPS_ENVIRONMENT&#125;</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">kustomize</span> <span class="string">edit</span> <span class="string">set</span> <span class="string">image</span> <span class="string">$&#123;GITOPS_APP_NAME&#125;=$&#123;IMAGE&#125;:$&#123;CI_COMMIT_SHORT_SHA&#125;</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">cat</span> <span class="string">kustomization.yaml</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">git</span> <span class="string">commit</span> <span class="string">-am</span> <span class="string">&quot;[skip ci] update image of app $&#123;GITOPS_APP_NAME&#125; - $&#123;GITOPS_ENVIRONMENT&#125; to $IMAGE:$CI_COMMIT_SHORT_SHA&quot;</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">git</span> <span class="string">push</span> <span class="string">origin</span> <span class="string">master</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="kustomize最佳实践"><a href="#kustomize最佳实践" class="headerlink" title="kustomize最佳实践"></a>kustomize最佳实践</h3><ul>
<li>base不要有多级，一来违反kustomize默认规则，二来层数过多应用间耦合加深，也不好管理</li>
<li>base仅定义最通用的，差异配置放overlays，方便调试，典型的差异配置如下<ul>
<li>ingress域名、证书等</li>
<li>deployment的亲和性、健康检查等待时间、资源分配大小等</li>
</ul>
</li>
</ul>
<p><img src="https://gdz.oss-cn-shenzhen.aliyuncs.com/local/image-20220421164003128.png" alt="image-20220421164003128"></p>
<h3 id="多集群管理"><a href="#多集群管理" class="headerlink" title="多集群管理"></a>多集群管理</h3><p>考虑到命名问题，个人认为argocd比较适合多集群分别对应不同应用的场景，而不是多集群对应不同环境；如果不介意命名，则所有场景都可以用。</p>
<p>多集群管理时要结合project工作，能够起到资源隔离的效果。每个project，有单独的可用仓库、目标集群、角色。</p>
<h3 id="关于datree"><a href="#关于datree" class="headerlink" title="关于datree"></a>关于datree</h3><p>datree是用于检查清单文件正确性的技术，可以直接检查kustomize。但在调试时因为遇到网络问题，检查过慢，且经常检查失败，无疾而终。</p>
<p>不过从其作用来看，如果复杂度上去，是可以考虑引入的。</p>
<h2 id="更大的潜力"><a href="#更大的潜力" class="headerlink" title="更大的潜力"></a>更大的潜力</h2><p>翻看argocd手册，列举了支持的功能。看起来，它能做SSO集成、能做权限管理、能查看应用启停状态、能方便地查看日志。<strong>那是不是对普通开发人员，可以用它对k8s做屏蔽</strong>🤔。</p>
<img src="https://gdz.oss-cn-shenzhen.aliyuncs.com/local/image-20220421170307442.png" alt="image-20220421170307442" style="zoom:80%;" />



<h1 id="知识地图"><a href="#知识地图" class="headerlink" title="知识地图"></a>知识地图</h1><p>按照下面的路线学习了解，能够对使用argo cd搭建gitops有比较形象的认识。</p>
<h2 id="gitops"><a href="#gitops" class="headerlink" title="gitops"></a>gitops</h2><ul>
<li><a href="https://www.gitops.tech/">官网</a> </li>
<li><a href="https://www.youtube.com/watch?v=f5EpcWp0THw">Nana的视频介绍</a> </li>
</ul>
<h2 id="argo-cd"><a href="#argo-cd" class="headerlink" title="argo cd"></a>argo cd</h2><ul>
<li><a href="https://argo-cd.readthedocs.io/en/stable/">官方手册（建议通篇浏览）</a> </li>
<li><a href="https://www.youtube.com/watch?v=MeU5_k9ssrs">Nana的视频介绍</a></li>
</ul>
<h2 id="gitlab-kubernetes-agent"><a href="#gitlab-kubernetes-agent" class="headerlink" title="gitlab kubernetes agent"></a>gitlab kubernetes agent</h2><p>资料较少，如果只看官方手册会让人发晕，加上下面列举的两篇文章会好得多。</p>
<p>重点是明白它的架构和工作原理，否则根本不知道在配置什么</p>
<ul>
<li><a href="https://docs.gitlab.com/ee/user/clusters/agent/gitops.html">官方手册</a></li>
<li><a href="https://xie.infoq.cn/article/45bfd162146b3b5bf47ae0faf">写的不错的文章1</a></li>
<li><a href="https://xie.infoq.cn/article/45bfd162146b3b5bf47ae0faf">写的不错的文章2</a></li>
</ul>
]]></content>
      <categories>
        <category>运维</category>
      </categories>
      <tags>
        <tag>gitops</tag>
      </tags>
  </entry>
  <entry>
    <title>Spring源码剖析 - BeanDefinition</title>
    <url>/2021/11/17/Spring%E6%BA%90%E7%A0%81%E5%89%96%E6%9E%90-BeanDefinition/</url>
    <content><![CDATA[<blockquote>
<p>阅读提示：TL;DR。文章包含大量源码，阅读时长较长，认真阅读可能超过20分钟。</p>
</blockquote>
<p>回想一下，Spring最最核心的功能，终究是一个容器，用于提供所谓的”<code>Bean</code>“，并负责<code>Bean</code>之间的联结。而我们又知道，<code>Bean</code>有不同的<code>Scope</code>，即作用范围，单例的、原型的、<code>Session</code>的，或自定义的。<code>Bean</code>还能够懒加载。因此，创建<code>Bean</code>的时机可能是运行时的任何时候。Spring使用<code>BeanDefinition</code>描述一个<code>Bean</code>的name、类、scope等元数据，并在需要时候创建。创建过程自然也包括了自动注入的过程。</p>
<span id="more"></span>

<p>本文我们重点关注Spring中对<code>Bean</code>的管理。</p>
<h2 id="如何描述Bean"><a href="#如何描述Bean" class="headerlink" title="如何描述Bean"></a>如何描述Bean</h2><p><img src="https://gdz.oss-cn-shenzhen.aliyuncs.com/local/%E6%88%AA%E5%B1%8F2021-11-17%20%E4%B8%8B%E5%8D%887.52.20.png" alt="截屏2021-11-17 下午7.52.20"></p>
<p>Spring使用<code>BeanDefinition</code>来描述<code>Bean</code>，其继承拓扑图如上，我们只选取了几个具有代表性的来看。根绝<code>BeanDefinition</code>接口的定义，能够知道，Spring中的<code>Bean</code>具有如下特性：</p>
<ul>
<li>基本信息<ul>
<li>名字</li>
<li>描述</li>
<li>用于创建该Bean的Class对象</li>
</ul>
</li>
<li>具有作用范围Scope<ul>
<li>singleton：全局唯一实例</li>
<li>prototype：每次获取都创建新的实例</li>
</ul>
</li>
<li>可以有父子关系</li>
<li>可以有依赖关系，即一个Bean的创建依赖于另一个Bean的存在</li>
<li>可延迟加载</li>
<li>可自动装配<ul>
<li>设置是否参与自动装配（基于类型）</li>
<li>如果有多个类型符合要求，可设置主要的</li>
</ul>
</li>
<li>可自定义Bean实例创建方式<ul>
<li>设置工厂Bean，用另一个Bean来创建该Bean</li>
<li>设置工厂方法，用该方法创建实例</li>
</ul>
</li>
<li>生命周期管理<ul>
<li>可指定初始化方法 <code>initMethod</code></li>
<li>可指定销毁方法 <code>destroyMethod</code></li>
</ul>
</li>
<li>具有角色，目前定义了三种角色，但暂未看到如何使用<ul>
<li><code>ROLE_APPLICATION</code>：该Bean是应用的主体，默认值</li>
<li><code>ROLE_SUPPORT</code>：标识该Bean是其它更大部分的支持部分</li>
<li><code>ROLE_INFRASTRUCTURE</code>：该Bean作为纯基础设施的支持，用户接触不到它</li>
</ul>
</li>
<li>获取构造方法的参数的值</li>
<li>获取<code>MutablePropertyValues</code>，这对应的是Bean的属性键值对，自动注入时会使用。</li>
<li><code>BeanDefinition</code>可包装另一个<code>BeanDefinition</code>，通过<code>BeanDefinition getOriginatingBeanDefinition()</code>获取被包装的定义。</li>
</ul>
<p>至于继承树中其它类，各自有所区别，我们依次看</p>
<h3 id="AbstractBeanDefinition"><a href="#AbstractBeanDefinition" class="headerlink" title="AbstractBeanDefinition"></a>AbstractBeanDefinition</h3><p><code>BeanDefinition</code>的直接实现，从中也可以看到一些特性的默认值</p>
<ul>
<li><code>scope</code>默认为单例</li>
<li>延迟加载默认关闭</li>
<li>自动注入默认关闭</li>
<li>角色默认为<code>ROLE_APPLICATION</code></li>
</ul>
<h3 id="RootBeanDefinition"><a href="#RootBeanDefinition" class="headerlink" title="RootBeanDefinition"></a>RootBeanDefinition</h3><p>说实话直接看这个类时，有点懵，原注释这么说。</p>
<blockquote>
<p>A root bean definition represents the merged bean definition that backs a specific bean in a Spring BeanFactory at runtime. It might have been created from multiple original bean definitions that inherit from each other, typically registered as GenericBeanDefinitions. A root bean definition is essentially the ‘unified’ bean definition view at runtime.<br>Root bean definitions may also be used for registering individual bean definitions in the configuration phase. However, since Spring 2.5, the preferred way to register bean definitions programmatically is the GenericBeanDefinition class. GenericBeanDefinition has the advantage that it allows to dynamically define parent dependencies, not ‘hard-coding’ the role as a root bean definition.</p>
</blockquote>
<p>我看懂了字面意思，却没看懂这串英文背后的含义。什么是<code>MergedBean</code>，关于这点，可以参考<a href="https://blog.csdn.net/andy_zhang2007/article/details/86514320">这篇文章</a>，所谓合并，就是将具有父子关系的<code>BeanDefinition</code>合并为一个<code>BeanDefinition</code>。”合并“的具体过程，下文”如何创建Bean“将会分析。</p>
<h3 id="GenericBeanDefinition"><a href="#GenericBeanDefinition" class="headerlink" title="GenericBeanDefinition"></a>GenericBeanDefinition</h3><p><code>BeanDefinition</code>的标准实现，相较于<code>AbstractBeanDefinition</code>，它多了对父子关系的实现。我们是可以直接用该类创建自己的<code>BeanDefinition</code>的。如果我们要凭空创建一个<code>BeanDefinition</code>注入容器，可以用它。</p>
<h3 id="AnnotatedBeanDefinition"><a href="#AnnotatedBeanDefinition" class="headerlink" title="AnnotatedBeanDefinition"></a>AnnotatedBeanDefinition</h3><p><code>BeanDefinition</code>的直接扩展接口，向调用者暴露了<code>AnnotationMetadata</code>。那么问题来了，什么是<code>AnnotationMetadata</code>呢？它是Spring为指定类的注解所定义的抽象，通过它可以不加载目标类即可获取到注解信息。类似的还有<code>ClassMetadata</code>。看来，Spring是将Bean定义的方方面面都进行了抽象。</p>
<p><img src="https://gdz.oss-cn-shenzhen.aliyuncs.com/local/%E6%88%AA%E5%B1%8F2021-11-17%20%E4%B8%8B%E5%8D%889.45.35.png" alt="截屏2021-11-17 下午9.45.35"></p>
<h3 id="AnnotatedGenericBeanDefinition"><a href="#AnnotatedGenericBeanDefinition" class="headerlink" title="AnnotatedGenericBeanDefinition"></a>AnnotatedGenericBeanDefinition</h3><p>同时实现了<code>GenericBeanDefinition</code>和<code>AnnotatedBeanDefinition</code>，表明它既具有一个完整<code>BeanDefinition</code>的能力，又持有Bean原类上的注解信息。持有注解信息有什么用呢？当然有用，运行时可以直接获取Bean定义的注解而不加载原类呀，提升性能。</p>
<h3 id="ScannedGenericBeanDefinition"><a href="#ScannedGenericBeanDefinition" class="headerlink" title="ScannedGenericBeanDefinition"></a>ScannedGenericBeanDefinition</h3><p>和<code>AnnotatedGenericBeanDefinition</code>一样，可以说是一模一样。</p>
<h3 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h3><p>Spring关于Bean的描述，其实不止这几个类，但我认为其它都是干扰，因此去掉了。我们的重点，是要通过这些定义看到Spring是如何进行抽象的，以及各级抽象的作用。写代码时不会用到，但它可保看源码时不会懵逼。</p>
<h2 id="Bean定义从何而来"><a href="#Bean定义从何而来" class="headerlink" title="Bean定义从何而来"></a>Bean定义从何而来</h2><p>还是上一篇文章那个例子，一个最最简单的应用方式。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function">fun <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    val context = AnnotationConfigApplicationContext(<span class="string">&quot;com.gitee.floyd.springme.core&quot;</span>)</span><br><span class="line">    println(context.getBean(Bean1::class.java))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>我们以<code>org.springframework.context.annotation.AnnotationConfigApplicationContext</code>构造方法为入口，分析Bean定义加载的过程。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">AnnotationConfigApplicationContext</span><span class="params">(String... basePackages)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">this</span>();</span><br><span class="line">  scan(basePackages);</span><br><span class="line">  ... ...</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">AnnotationConfigApplicationContext</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="keyword">this</span>.reader = <span class="keyword">new</span> AnnotatedBeanDefinitionReader(<span class="keyword">this</span>);</span><br><span class="line">  <span class="keyword">this</span>.scanner = <span class="keyword">new</span> ClassPathBeanDefinitionScanner(<span class="keyword">this</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">scan</span><span class="params">(String... basePackages)</span> </span>&#123;</span><br><span class="line">  ... ... </span><br><span class="line">    <span class="keyword">this</span>.scanner.scan(basePackages);</span><br><span class="line">  ... ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这里引入两个新的类：<code>AnnotatedBeanDefinitionReader</code>和<code>ClassPathBeanDefinitionScanner</code>，我们先看它们的能力，再看这个扫描的过程</p>
<h3 id="AnnotatedBeanDefinitionReader"><a href="#AnnotatedBeanDefinitionReader" class="headerlink" title="AnnotatedBeanDefinitionReader"></a>AnnotatedBeanDefinitionReader</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AnnotatedBeanDefinitionReader</span> </span>&#123;</span><br><span class="line">  <span class="comment">// Bean定义注册器，一个注册接口，其实现类一般会持有所有这些注册的BeanDefinition，典型的实现类就是具体的ApplicationContext</span></span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">final</span> BeanDefinitionRegistry registry;</span><br><span class="line">  <span class="comment">// Bean名称生成器，AnnotationBeanNameGenerator是按照@Component注解或其子注解生成名字</span></span><br><span class="line">  <span class="keyword">private</span> BeanNameGenerator beanNameGenerator = AnnotationBeanNameGenerator.INSTANCE;</span><br><span class="line">  <span class="comment">// Scope元信息解析器，AnnotationScopeMetadataResolver解析的是@Scope注解</span></span><br><span class="line">  <span class="keyword">private</span> ScopeMetadataResolver scopeMetadataResolver = <span class="keyword">new</span> AnnotationScopeMetadataResolver();</span><br><span class="line">  <span class="comment">// 条件计算器，用于解析@Conditional注解</span></span><br><span class="line">  <span class="keyword">private</span> ConditionEvaluator conditionEvaluator;</span><br><span class="line"></span><br><span class="line">  ... ...</span><br><span class="line">  <span class="comment">// 注册Bean</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">registerBean</span><span class="params">(Class&lt;?&gt; beanClass)</span> </span>&#123;</span><br><span class="line">    doRegisterBean(beanClass, <span class="keyword">null</span>, <span class="keyword">null</span>, <span class="keyword">null</span>, <span class="keyword">null</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  ... ...</span><br><span class="line">  <span class="comment">// 实际注册Bean，传入bean的类型、名字等</span></span><br><span class="line">  <span class="keyword">private</span> &lt;T&gt; <span class="function"><span class="keyword">void</span> <span class="title">doRegisterBean</span><span class="params">(Class&lt;T&gt; beanClass, <span class="meta">@Nullable</span> String name,</span></span></span><br><span class="line"><span class="params"><span class="function">                                    <span class="meta">@Nullable</span> Class&lt;? extends Annotation&gt;[] qualifiers, <span class="meta">@Nullable</span> Supplier&lt;T&gt; supplier,</span></span></span><br><span class="line"><span class="params"><span class="function">                                    <span class="meta">@Nullable</span> BeanDefinitionCustomizer[] customizers)</span> </span>&#123;</span><br><span class="line">		<span class="comment">// 根据类对象创建AnnotatedGenericBeanDefinition</span></span><br><span class="line">    AnnotatedGenericBeanDefinition abd = <span class="keyword">new</span> AnnotatedGenericBeanDefinition(beanClass);</span><br><span class="line">    <span class="comment">// 判断是否需要忽略该Bean定义</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">this</span>.conditionEvaluator.shouldSkip(abd.getMetadata())) &#123;</span><br><span class="line">      <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">		<span class="comment">// 设置一个实例创建时的回调函数，它作为一种工厂方法的替换</span></span><br><span class="line">    abd.setInstanceSupplier(supplier);</span><br><span class="line">    ScopeMetadata scopeMetadata = <span class="keyword">this</span>.scopeMetadataResolver.resolveScopeMetadata(abd);</span><br><span class="line">    <span class="comment">// 为Bean定义加上Scope</span></span><br><span class="line">    abd.setScope(scopeMetadata.getScopeName());</span><br><span class="line">    <span class="comment">// 生成bean名字</span></span><br><span class="line">    String beanName = (name != <span class="keyword">null</span> ? name : <span class="keyword">this</span>.beanNameGenerator.generateBeanName(abd, <span class="keyword">this</span>.registry));</span><br><span class="line">		<span class="comment">// 处理通用注解：@Lazy、@Primary、@DependsOn、@Role、@Description</span></span><br><span class="line">    AnnotationConfigUtils.processCommonDefinitionAnnotations(abd);</span><br><span class="line">    <span class="comment">// 根据传入的修饰注解决定</span></span><br><span class="line">    <span class="keyword">if</span> (qualifiers != <span class="keyword">null</span>) &#123;</span><br><span class="line">      <span class="keyword">for</span> (Class&lt;? extends Annotation&gt; qualifier : qualifiers) &#123;</span><br><span class="line">        <span class="keyword">if</span> (Primary.class == qualifier) &#123;</span><br><span class="line">          abd.setPrimary(<span class="keyword">true</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (Lazy.class == qualifier) &#123;</span><br><span class="line">          abd.setLazyInit(<span class="keyword">true</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">          abd.addQualifier(<span class="keyword">new</span> AutowireCandidateQualifier(qualifier));</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 应用传入的BeanDefinition定制器</span></span><br><span class="line">    <span class="keyword">if</span> (customizers != <span class="keyword">null</span>) &#123;</span><br><span class="line">      <span class="keyword">for</span> (BeanDefinitionCustomizer customizer : customizers) &#123;</span><br><span class="line">        customizer.customize(abd);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">		</span><br><span class="line">    <span class="comment">// 包装成BeanDefinitionHolder</span></span><br><span class="line">    BeanDefinitionHolder definitionHolder = <span class="keyword">new</span> BeanDefinitionHolder(abd, beanName);</span><br><span class="line">    <span class="comment">// Bean的scope代理模式是封装在BeanDefinitionHolder中的，这里进行设置</span></span><br><span class="line">    definitionHolder = AnnotationConfigUtils.applyScopedProxyMode(scopeMetadata, definitionHolder, <span class="keyword">this</span>.registry);</span><br><span class="line">    <span class="comment">// 将处理完的BeanDefinitionHolder注入registry</span></span><br><span class="line">    BeanDefinitionReaderUtils.registerBeanDefinition(definitionHolder, <span class="keyword">this</span>.registry);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// AnnotationConfigUtils.processCommonDefinitionAnnotations方法</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">processCommonDefinitionAnnotations</span><span class="params">(AnnotatedBeanDefinition abd, AnnotatedTypeMetadata metadata)</span> </span>&#123;</span><br><span class="line">  <span class="comment">// 延迟加载的处理</span></span><br><span class="line">  AnnotationAttributes lazy = attributesFor(metadata, Lazy.class);</span><br><span class="line">  <span class="keyword">if</span> (lazy != <span class="keyword">null</span>) &#123;</span><br><span class="line">    abd.setLazyInit(lazy.getBoolean(<span class="string">&quot;value&quot;</span>));</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">else</span> <span class="keyword">if</span> (abd.getMetadata() != metadata) &#123;</span><br><span class="line">    lazy = attributesFor(abd.getMetadata(), Lazy.class);</span><br><span class="line">    <span class="keyword">if</span> (lazy != <span class="keyword">null</span>) &#123;</span><br><span class="line">      abd.setLazyInit(lazy.getBoolean(<span class="string">&quot;value&quot;</span>));</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">	<span class="comment">// primary的处理</span></span><br><span class="line">  <span class="keyword">if</span> (metadata.isAnnotated(Primary.class.getName())) &#123;</span><br><span class="line">    abd.setPrimary(<span class="keyword">true</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 依赖的处理</span></span><br><span class="line">  AnnotationAttributes dependsOn = attributesFor(metadata, DependsOn.class);</span><br><span class="line">  <span class="keyword">if</span> (dependsOn != <span class="keyword">null</span>) &#123;</span><br><span class="line">    abd.setDependsOn(dependsOn.getStringArray(<span class="string">&quot;value&quot;</span>));</span><br><span class="line">  &#125;</span><br><span class="line">	<span class="comment">// 角色的处理</span></span><br><span class="line">  AnnotationAttributes role = attributesFor(metadata, Role.class);</span><br><span class="line">  <span class="keyword">if</span> (role != <span class="keyword">null</span>) &#123;</span><br><span class="line">    abd.setRole(role.getNumber(<span class="string">&quot;value&quot;</span>).intValue());</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 描述的处理</span></span><br><span class="line">  AnnotationAttributes description = attributesFor(metadata, Description.class);</span><br><span class="line">  <span class="keyword">if</span> (description != <span class="keyword">null</span>) &#123;</span><br><span class="line">    abd.setDescription(description.getString(<span class="string">&quot;value&quot;</span>));</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>要点总结</p>
<ul>
<li><code>AnnotatedBeanDefinitionReader</code>，封装了<code>BeanDefinition</code>构建并注入<code>BeanDefinitionRegistry</code>的流程，这里<code>BeanDefinitionRegistry</code>就是我们的容器</li>
<li><code>BeanDefinitionRegistry</code>，在前面介绍<code>ApplicationContext</code>就已经介绍过，用于接收并持有Bean定义</li>
<li>bean名称生成器：<code>AnnotationBeanNameGenerator</code>，按照<code>@Component</code>及其子注解、<code>@ManagedBean</code>、<code>@Named</code>生成，详细分析见下</li>
<li><code>Scope</code>元信息，包含了<code>Scope</code>的作用范围、代理模式，通过<code>@Scope</code>注解标识，<code>AnnotationScopeMetadataResolver</code>就是解析<code>@Scope</code>注解的。如果未指定<code>@Scope</code>注解，得到的结果是：单例+不代理。</li>
<li><code>ConditionEvaluator</code>，条件解析器。针对<code>@Conditional</code>进行解析。详细分析见下文。</li>
</ul>
<h4 id="bean名称生成逻辑"><a href="#bean名称生成逻辑" class="headerlink" title="bean名称生成逻辑"></a>bean名称生成逻辑</h4><p>AnnotationBeanNameGenerator这个类值得看一看，它有一些隐藏的功能</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AnnotationBeanNameGenerator</span> <span class="keyword">implements</span> <span class="title">BeanNameGenerator</span> </span>&#123;</span><br><span class="line">  <span class="comment">// @Compenent注解通过字面量的形式呈现</span></span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String COMPONENT_ANNOTATION_CLASSNAME = <span class="string">&quot;org.springframework.stereotype.Component&quot;</span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 核心方法</span></span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> String <span class="title">generateBeanName</span><span class="params">(BeanDefinition definition, BeanDefinitionRegistry registry)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 如果Bean有注解，则根据注解生成名称</span></span><br><span class="line">    <span class="keyword">if</span> (definition <span class="keyword">instanceof</span> AnnotatedBeanDefinition) &#123;</span><br><span class="line">      String beanName = determineBeanNameFromAnnotation((AnnotatedBeanDefinition) definition);</span><br><span class="line">      <span class="keyword">if</span> (StringUtils.hasText(beanName)) &#123;</span><br><span class="line">        <span class="comment">// Explicit bean name found.</span></span><br><span class="line">        <span class="keyword">return</span> beanName;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 如果Bean没有注解，则直接使用类名的首字母小写形式</span></span><br><span class="line">    <span class="keyword">return</span> buildDefaultBeanName(definition, registry);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">protected</span> String <span class="title">determineBeanNameFromAnnotation</span><span class="params">(AnnotatedBeanDefinition annotatedDef)</span> </span>&#123;</span><br><span class="line">    AnnotationMetadata amd = annotatedDef.getMetadata();</span><br><span class="line">    Set&lt;String&gt; types = amd.getAnnotationTypes();</span><br><span class="line">    String beanName = <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">for</span> (String type : types) &#123;</span><br><span class="line">      AnnotationAttributes attributes = AnnotationConfigUtils.attributesFor(amd, type);</span><br><span class="line">      <span class="keyword">if</span> (attributes != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="comment">// 获取元注解，即注解的注解，这样才能检测到@Service、@Repository之类的注解</span></span><br><span class="line">        Set&lt;String&gt; metaTypes = <span class="keyword">this</span>.metaAnnotationTypesCache.computeIfAbsent(type, key -&gt; &#123;</span><br><span class="line">          Set&lt;String&gt; result = amd.getMetaAnnotationTypes(key);</span><br><span class="line">          <span class="keyword">return</span> (result.isEmpty() ? Collections.emptySet() : result);</span><br><span class="line">        &#125;);</span><br><span class="line">        <span class="keyword">if</span> (isStereotypeWithNameValue(type, metaTypes, attributes)) &#123;</span><br><span class="line">          <span class="comment">// 注解的value属性必须有值，且不为空串，才会取</span></span><br><span class="line">          Object value = attributes.get(<span class="string">&quot;value&quot;</span>);</span><br><span class="line">          <span class="keyword">if</span> (value <span class="keyword">instanceof</span> String) &#123;</span><br><span class="line">            String strVal = (String) value;</span><br><span class="line">            <span class="keyword">if</span> (StringUtils.hasLength(strVal)) &#123;</span><br><span class="line">              <span class="keyword">if</span> (beanName != <span class="keyword">null</span> &amp;&amp; !strVal.equals(beanName)) &#123;</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(<span class="string">&quot;Stereotype annotations suggest inconsistent &quot;</span> +</span><br><span class="line">                                                <span class="string">&quot;component names: &#x27;&quot;</span> + beanName + <span class="string">&quot;&#x27; versus &#x27;&quot;</span> + strVal + <span class="string">&quot;&#x27;&quot;</span>);</span><br><span class="line">              &#125;</span><br><span class="line">              beanName = strVal;</span><br><span class="line">            &#125;</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> beanName;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// </span></span><br><span class="line">  <span class="function"><span class="keyword">protected</span> <span class="keyword">boolean</span> <span class="title">isStereotypeWithNameValue</span><span class="params">(String annotationType, Set&lt;String&gt; metaAnnotationTypes, <span class="meta">@Nullable</span> Map&lt;String, Object&gt; attributes)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 这里也可以看到，还支持@ManagedBean、Named这样的JSR规定的注解</span></span><br><span class="line">    <span class="keyword">boolean</span> isStereotype = annotationType.equals(COMPONENT_ANNOTATION_CLASSNAME) ||</span><br><span class="line">      metaAnnotationTypes.contains(COMPONENT_ANNOTATION_CLASSNAME) ||</span><br><span class="line">      annotationType.equals(<span class="string">&quot;javax.annotation.ManagedBean&quot;</span>) ||</span><br><span class="line">      annotationType.equals(<span class="string">&quot;javax.inject.Named&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> (isStereotype &amp;&amp; attributes != <span class="keyword">null</span> &amp;&amp; attributes.containsKey(<span class="string">&quot;value&quot;</span>));</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">protected</span> String <span class="title">buildDefaultBeanName</span><span class="params">(BeanDefinition definition)</span> </span>&#123;</span><br><span class="line">    String beanClassName = definition.getBeanClassName();</span><br><span class="line">    Assert.state(beanClassName != <span class="keyword">null</span>, <span class="string">&quot;No bean class name set&quot;</span>);</span><br><span class="line">    String shortClassName = ClassUtils.getShortName(beanClassName);</span><br><span class="line">    <span class="keyword">return</span> Introspector.decapitalize(shortClassName);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>要点</p>
<ul>
<li>支持生成Bean名称的注解有：<code>@Component</code>及其子注解、<code>@MangedBean</code>、<code>@Named</code></li>
<li>如果这些注解没有显式指明名称，则回退成默认规则：类名首字母小写</li>
</ul>
<h4 id="判定BeanDefinition是否需要被加载"><a href="#判定BeanDefinition是否需要被加载" class="headerlink" title="判定BeanDefinition是否需要被加载"></a>判定BeanDefinition是否需要被加载</h4><p>ConditionEvaluator这个类也值得一看，它解释了<code>@Conditional</code>注解的工作原理。整个类就暴露一个方法：<code>shouldSkip()</code></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">shouldSkip</span><span class="params">(<span class="meta">@Nullable</span> AnnotatedTypeMetadata metadata, <span class="meta">@Nullable</span> ConfigurationPhase phase)</span> </span>&#123;</span><br><span class="line">  <span class="comment">// 如果目标类没有被Conditional注解，则不应被跳过</span></span><br><span class="line">  <span class="keyword">if</span> (metadata == <span class="keyword">null</span> || !metadata.isAnnotated(Conditional.class.getName())) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (phase == <span class="keyword">null</span>) &#123;</span><br><span class="line">  	<span class="comment">// 如果没有指定配置过程，就根据其它条件判断是属于配置阶段还是创建Bean阶段</span></span><br><span class="line">    <span class="keyword">if</span> (metadata <span class="keyword">instanceof</span> AnnotationMetadata &amp;&amp; ConfigurationClassUtils.isConfigurationCandidate((AnnotationMetadata) metadata)) &#123;</span><br><span class="line">      <span class="keyword">return</span> shouldSkip(metadata, ConfigurationPhase.PARSE_CONFIGURATION);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> shouldSkip(metadata, ConfigurationPhase.REGISTER_BEAN);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  List&lt;Condition&gt; conditions = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">  <span class="comment">// 从@Conditional注解中提取出Condition条件</span></span><br><span class="line">  <span class="keyword">for</span> (String[] conditionClasses : getConditionClasses(metadata)) &#123;</span><br><span class="line">    <span class="keyword">for</span> (String conditionClass : conditionClasses) &#123;</span><br><span class="line">      Condition condition = getCondition(conditionClass, <span class="keyword">this</span>.context.getClassLoader());</span><br><span class="line">      conditions.add(condition);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">	<span class="comment">// 排序</span></span><br><span class="line">  AnnotationAwareOrderComparator.sort(conditions);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span> (Condition condition : conditions) &#123;</span><br><span class="line">    ConfigurationPhase requiredPhase = <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">if</span> (condition <span class="keyword">instanceof</span> ConfigurationCondition) &#123;</span><br><span class="line">      requiredPhase = ((ConfigurationCondition) condition).getConfigurationPhase();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 当阶段匹配，且条件不匹配时，则跳过Bean注册</span></span><br><span class="line">    <span class="keyword">if</span> ((requiredPhase == <span class="keyword">null</span> || requiredPhase == phase) &amp;&amp; !condition.matches(<span class="keyword">this</span>.context, metadata)) &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">	<span class="comment">// 其它情况，不应当跳过</span></span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>分析一下<code>ConfigurationClassUtils.isConfigurationCandidate()</code></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Set&lt;String&gt; candidateIndicators = <span class="keyword">new</span> HashSet&lt;&gt;(<span class="number">8</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> &#123;</span><br><span class="line">  <span class="comment">// 有下面这四个注解，就说明是配置Bean</span></span><br><span class="line">  candidateIndicators.add(Component.class.getName());</span><br><span class="line">  candidateIndicators.add(ComponentScan.class.getName());</span><br><span class="line">  candidateIndicators.add(Import.class.getName());</span><br><span class="line">  candidateIndicators.add(ImportResource.class.getName());</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">boolean</span> <span class="title">isConfigurationCandidate</span><span class="params">(AnnotationMetadata metadata)</span> </span>&#123;</span><br><span class="line">  <span class="comment">// 接口上的注解不考虑</span></span><br><span class="line">  <span class="keyword">if</span> (metadata.isInterface()) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">  &#125;</span><br><span class="line">	<span class="comment">// 只要被上面那四个注解注解了，就说明是配置Bean</span></span><br><span class="line">  <span class="keyword">for</span> (String indicator : candidateIndicators) &#123;</span><br><span class="line">    <span class="keyword">if</span> (metadata.isAnnotated(indicator)) &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">	<span class="comment">// 否则，如果其内部存在被@Bean注解的方法，也算配置Bean</span></span><br><span class="line">  <span class="keyword">return</span> hasBeanMethods(metadata);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">boolean</span> <span class="title">hasBeanMethods</span><span class="params">(AnnotationMetadata metadata)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> metadata.hasAnnotatedMethods(Bean.class.getName());</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">catch</span> (Throwable ex) &#123;</span><br><span class="line">    ... ...</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>理解关键</p>
<ul>
<li><code>AnnotatedTypeMetadata</code>要理解，前面<code>AnnotatedBeanDefinition</code>看到过，Spring将<code>Bean</code>上的注解信息和类信息进行了抽象，使得不需要加载具体的类就能获取其上的注解，使用方便。</li>
<li><code>Condition</code>条件，它只有一个匹配方法<code>boolean matches(ConditionContext context, AnnotatedTypeMetadata metadata)</code>，用于匹配指定Bean在容器中是否满足条件，我们常用的<code>@ConditionalOnClassMissingBean</code>之类的注解，就是<code>@Conditional</code>派生注解+<code>Condition</code>派生类组合完成的。</li>
</ul>
<p>要点总结</p>
<ul>
<li><code>ConditionEvaluator</code>是用来判断某个Bean定义是否符合加载条件，是加载还是有应该被忽略。判断逻辑<ul>
<li>如果不存在<code>@Conditional</code>注解，则需要加载</li>
<li>如果存在<code>@Conditional</code>注解，则需要看该注解的作用阶段和其内部<code>Condition</code>的行为<ul>
<li>如果<code>Condition</code>所指定的阶段与<code>@Conditional</code>实际作用的阶段不一致，则需要加载</li>
<li>否则，根据<code>Condition.matches()</code>的结果来判定是否需要加载</li>
</ul>
</li>
</ul>
</li>
<li>当一个Bean定义被<code>@Component、@ComponentScan、@Import、@ImportResource</code>注解，或其内含有<code>@Bean</code>注解方法时，说明它是一个配置Bean。即作用阶段是<code>ConfigurationPhase.PARSE_CONFIGURATION</code>，否则，作用阶段是<code>ConfigurationPhase.REGISTER_BEAN</code>，作用阶段，也可以用来判断是否需要加载该Bean定义：当声明的作用阶段和<code>Condition</code>类的作用阶段不一致时，将忽略匹配过程，直接加载</li>
</ul>
<h3 id="ClassPathBeanDefinitionScanner"><a href="#ClassPathBeanDefinitionScanner" class="headerlink" title="ClassPathBeanDefinitionScanner"></a>ClassPathBeanDefinitionScanner</h3><p><img src="https://gdz.oss-cn-shenzhen.aliyuncs.com/local/%E6%88%AA%E5%B1%8F2021-11-18%20%E4%B8%8B%E5%8D%886.33.05.png" alt="截屏2021-11-18 下午6.33.05"></p>
<p>继承树如上</p>
<ul>
<li><code>ClassPathScanningCandidateComponentProvider</code>用于在指定包下扫描并提供Bean定义（所谓的<code>CandidateComponent</code>），核心逻辑在<code>public Set&lt;BeanDefinition&gt; findCandidateComponents(String basePackage)</code>方法。</li>
<li><code>ClassPathBeanDefinitionScanner</code>用于批量扫描包下的Bean定义，核心逻辑在<code>protected Set&lt;BeanDefinitionHolder&gt; doScan(String... basePackages)</code>方法。</li>
</ul>
<p>我们按照调用关系来看，从scan方法看起</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">scan</span><span class="params">(String... basePackages)</span> </span>&#123;</span><br><span class="line">  <span class="comment">// 扫描：从包下扫描出BeanDefinition，然后注入registry，详情见下</span></span><br><span class="line">  doScan(basePackages);</span><br><span class="line">  <span class="keyword">if</span> (<span class="keyword">this</span>.includeAnnotationConfig) &#123;</span><br><span class="line">    <span class="comment">// 注册一批后置处理器，这个我们忽略，它注册了一批内部的后置处理器</span></span><br><span class="line">    AnnotationConfigUtils.registerAnnotationConfigProcessors(<span class="keyword">this</span>.registry);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// return什么不重要</span></span><br><span class="line">  <span class="keyword">return</span> ...</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">protected</span> Set&lt;BeanDefinitionHolder&gt; <span class="title">doScan</span><span class="params">(String... basePackages)</span> </span>&#123;</span><br><span class="line">  Set&lt;BeanDefinitionHolder&gt; beanDefinitions = <span class="keyword">new</span> LinkedHashSet&lt;&gt;();</span><br><span class="line">  <span class="keyword">for</span> (String basePackage : basePackages) &#123;</span><br><span class="line">    <span class="comment">// 调用父类的findCandidateComponents，在指定包下找到符合要求的BeanDefinition</span></span><br><span class="line">    Set&lt;BeanDefinition&gt; candidates = findCandidateComponents(basePackage);</span><br><span class="line">    <span class="keyword">for</span> (BeanDefinition candidate : candidates) &#123;</span><br><span class="line">      <span class="comment">// 解析Scope元信息</span></span><br><span class="line">      ScopeMetadata scopeMetadata = <span class="keyword">this</span>.scopeMetadataResolver.resolveScopeMetadata(candidate);</span><br><span class="line">      candidate.setScope(scopeMetadata.getScopeName());</span><br><span class="line">      <span class="comment">// 生成bean名称</span></span><br><span class="line">      String beanName = <span class="keyword">this</span>.beanNameGenerator.generateBeanName(candidate, <span class="keyword">this</span>.registry);</span><br><span class="line">      <span class="keyword">if</span> (candidate <span class="keyword">instanceof</span> AbstractBeanDefinition) &#123;</span><br><span class="line">        <span class="comment">// 一波附加逻辑，详情见下</span></span><br><span class="line">        postProcessBeanDefinition((AbstractBeanDefinition) candidate, beanName);</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">if</span> (candidate <span class="keyword">instanceof</span> AnnotatedBeanDefinition) &#123;</span><br><span class="line">        <span class="comment">// 处理一波通用注解：@Lazy、@Primary、@DependsOn、@Role、@Description，该方法前面已经分析过了</span></span><br><span class="line">        AnnotationConfigUtils.processCommonDefinitionAnnotations((AnnotatedBeanDefinition) candidate);</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="comment">// 检查新建的BeanDefinition是否合法，主要是检查容器中是否已经有同名Bean了</span></span><br><span class="line">      <span class="keyword">if</span> (checkCandidate(beanName, candidate)) &#123;</span><br><span class="line">        <span class="comment">// 构建BeanDefinitionHolder</span></span><br><span class="line">        BeanDefinitionHolder definitionHolder = <span class="keyword">new</span> BeanDefinitionHolder(candidate, beanName);</span><br><span class="line">        <span class="comment">// 应用scope的代理mode</span></span><br><span class="line">        definitionHolder = AnnotationConfigUtils.applyScopedProxyMode(scopeMetadata, definitionHolder, <span class="keyword">this</span>.registry);</span><br><span class="line">        beanDefinitions.add(definitionHolder);</span><br><span class="line">        <span class="comment">// 注入registry</span></span><br><span class="line">        registerBeanDefinition(definitionHolder, <span class="keyword">this</span>.registry);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> beanDefinitions;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">postProcessBeanDefinition</span><span class="params">(AbstractBeanDefinition beanDefinition, String beanName)</span> </span>&#123;</span><br><span class="line">  <span class="comment">// 应用默认设置：延迟加载、自动注入mode、依赖检查、初始化方法、销毁方法等</span></span><br><span class="line">  beanDefinition.applyDefaults(<span class="keyword">this</span>.beanDefinitionDefaults);</span><br><span class="line">  <span class="keyword">if</span> (<span class="keyword">this</span>.autowireCandidatePatterns != <span class="keyword">null</span>) &#123;</span><br><span class="line">    <span class="comment">// 设置是否参与自动注入</span></span><br><span class="line">    beanDefinition.setAutowireCandidate(PatternMatchUtils.simpleMatch(<span class="keyword">this</span>.autowireCandidatePatterns, beanName));</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">applyDefaults</span><span class="params">(BeanDefinitionDefaults defaults)</span> </span>&#123;</span><br><span class="line">  Boolean lazyInit = defaults.getLazyInit();</span><br><span class="line">  <span class="keyword">if</span> (lazyInit != <span class="keyword">null</span>) &#123;</span><br><span class="line">    setLazyInit(lazyInit);</span><br><span class="line">  &#125;</span><br><span class="line">  setAutowireMode(defaults.getAutowireMode());</span><br><span class="line">  setDependencyCheck(defaults.getDependencyCheck());</span><br><span class="line">  setInitMethodName(defaults.getInitMethodName());</span><br><span class="line">  setEnforceInitMethod(<span class="keyword">false</span>);</span><br><span class="line">  setDestroyMethodName(defaults.getDestroyMethodName());</span><br><span class="line">  setEnforceDestroyMethod(<span class="keyword">false</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上面有调用到<code>ClassPathScanningCandidateComponentProvider</code>的<code>findCandidateComponents</code>方法，我们再看</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> Set&lt;BeanDefinition&gt; <span class="title">findCandidateComponents</span><span class="params">(String basePackage)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (<span class="keyword">this</span>.componentsIndex != <span class="keyword">null</span> &amp;&amp; indexSupportsIncludeFilters()) &#123;</span><br><span class="line">    <span class="comment">// 通过Index进行组件扫描</span></span><br><span class="line">    <span class="keyword">return</span> addCandidateComponentsFromIndex(<span class="keyword">this</span>.componentsIndex, basePackage);</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="comment">// 直接扫描</span></span><br><span class="line">    <span class="keyword">return</span> scanCandidateComponents(basePackage);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 直接扫描的过程：</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> Set&lt;BeanDefinition&gt; <span class="title">scanCandidateComponents</span><span class="params">(String basePackage)</span> </span>&#123;</span><br><span class="line">  Set&lt;BeanDefinition&gt; candidates = <span class="keyword">new</span> LinkedHashSet&lt;&gt;();</span><br><span class="line">  <span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="comment">// 路径：classpath*:&#123;包转换后的路径名&#125;/**/*.class，即所有jar包下的置顶包名下的所有层级的所有class文件</span></span><br><span class="line">    String packageSearchPath = ResourcePatternResolver.CLASSPATH_ALL_URL_PREFIX + resolveBasePackage(basePackage) + <span class="string">&#x27;/&#x27;</span> + <span class="keyword">this</span>.resourcePattern;</span><br><span class="line">    Resource[] resources = getResourcePatternResolver().getResources(packageSearchPath);</span><br><span class="line">    <span class="keyword">for</span> (Resource resource : resources) </span><br><span class="line">      <span class="keyword">if</span> (resource.isReadable()) &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">          MetadataReader metadataReader = getMetadataReaderFactory().getMetadataReader(resource);</span><br><span class="line">          <span class="comment">// 必须符合includeFilters中的过滤器要求才会被扫描出来</span></span><br><span class="line">          <span class="keyword">if</span> (isCandidateComponent(metadataReader)) &#123;</span><br><span class="line">            <span class="comment">// 刚扫描出来的BeanDefinition，只创建了Bean定义的实例，还没开始解析，解析留给子类。</span></span><br><span class="line">            ScannedGenericBeanDefinition sbd = <span class="keyword">new</span> ScannedGenericBeanDefinition(metadataReader);</span><br><span class="line">            sbd.setSource(resource);</span><br><span class="line">            <span class="keyword">if</span> (isCandidateComponent(sbd)) &#123;</span><br><span class="line">              candidates.add(sbd);</span><br><span class="line">            &#125;</span><br><span class="line">          &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Throwable ex) &#123;</span><br><span class="line">          <span class="keyword">throw</span> <span class="keyword">new</span> BeanDefinitionStoreException(<span class="string">&quot;Failed to read candidate component class: &quot;</span> + resource, ex);</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125; <span class="keyword">catch</span> (IOException ex) &#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> BeanDefinitionStoreException(<span class="string">&quot;I/O failure during classpath scanning&quot;</span>, ex);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> candidates;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">boolean</span> <span class="title">isCandidateComponent</span><span class="params">(MetadataReader metadataReader)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">  <span class="comment">// 在排除过滤器中，直接不符合要求</span></span><br><span class="line">  <span class="keyword">for</span> (TypeFilter tf : <span class="keyword">this</span>.excludeFilters) &#123;</span><br><span class="line">    <span class="keyword">if</span> (tf.match(metadataReader, getMetadataReaderFactory())) &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 在include过滤器中匹配才符合要求</span></span><br><span class="line">  <span class="keyword">for</span> (TypeFilter tf : <span class="keyword">this</span>.includeFilters) &#123;</span><br><span class="line">    <span class="keyword">if</span> (tf.match(metadataReader, getMetadataReaderFactory())) &#123;</span><br><span class="line">      <span class="keyword">return</span> isConditionMatch(metadataReader);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上面只贴出了直接从类中扫描的代码，但另一个<code>addCandidateComponentsFromIndex</code>没说。我们需要先知道一下Spring中的Index是什么。可以参考<a href="https://juejin.cn/post/6844904014509768712">这篇文章</a>:</p>
<blockquote>
<p>在项目中使用了<code>@Indexed</code>之后，编译打包的时候会在项目中自动生成<code>META-INT/spring.components</code>文件。 当Spring应用上下文执行<code>ComponentScan</code>扫描时，<code>META-INT/spring.components</code>将会被<code>CandidateComponentsIndexLoader</code> 读取并加载，转换为<code>CandidateComponentsIndex</code>对象，这样的话<code>@ComponentScan</code>不在扫描指定的package，而是读取<code>CandidateComponentsIndex</code>对象，从而达到提升性能的目的。</p>
</blockquote>
<p>此时我们再去跟踪<code>addCandidateComponentsFromIndex()</code>方法，会发现和上面说的可以说是一模一样了。</p>
<p>要点总结</p>
<ul>
<li><p>可以看到，<code>ClassPathBeanDefinitionScanner</code>做的事和<code>AnnotatedBeanDefinitionReader</code>差不多，都是构建<code>BeanDefinition</code>并向容器中注册；唯一的差别是，前者的Bean定义是自己扫描得来的，而后者的Bean定义是外界调用方法注册来的</p>
</li>
<li><p>通过<code>ClassPathScanningCandidateComponentProvider.findCandidateComponents()</code>我们知道，它只提供最原始的扫描并生成<code>BeanDefinition</code>的逻辑，而<code>BeanDefinition</code>各种属性的解析和设置放在其子类<code>ClassPathBeanDefinitionScanner</code>中了。</p>
</li>
</ul>
<h3 id="小结-1"><a href="#小结-1" class="headerlink" title="小结"></a>小结</h3><p>这一个Reader，一个Scanner，都只是一个工具，最终完成了容器中的<code>BeanDefinition</code>创建。</p>
<h2 id="如何创建Bean"><a href="#如何创建Bean" class="headerlink" title="如何创建Bean"></a>如何创建Bean</h2><h3 id="Bean的创建逻辑"><a href="#Bean的创建逻辑" class="headerlink" title="Bean的创建逻辑"></a>Bean的创建逻辑</h3><p>Bean的创建有几个时机</p>
<ul>
<li>对于非延迟加载的单例Bean，在容器refresh时就会被创建，在<code>ApplicationContext</code>源码分析时我们看到过</li>
<li>对于延迟加载的单例Bean，在第一次被获取时会被创建</li>
<li>对于原型Bean，每次被获取时都会被创建</li>
</ul>
<p>我们先看第一种情况，直接进<code>org.springframework.beans.factory.support.DefaultListableBeanFactory#preInstantiateSingletons</code>，我删掉了不重要的代码。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">preInstantiateSingletons</span><span class="params">()</span> <span class="keyword">throws</span> BeansException </span>&#123;</span><br><span class="line">  <span class="comment">// Iterate over a copy to allow for init methods which in turn register new bean definitions.</span></span><br><span class="line">  <span class="comment">// While this may not be part of the regular factory bootstrap, it does otherwise work fine.</span></span><br><span class="line">  List&lt;String&gt; beanNames = <span class="keyword">new</span> ArrayList&lt;&gt;(<span class="keyword">this</span>.beanDefinitionNames);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Trigger initialization of all non-lazy singleton beans...</span></span><br><span class="line">  <span class="keyword">for</span> (String beanName : beanNames) &#123;</span><br><span class="line">    <span class="comment">// 获取合并后的BeanDefinition</span></span><br><span class="line">    RootBeanDefinition bd = getMergedLocalBeanDefinition(beanName);</span><br><span class="line">    <span class="comment">// 单例且非延迟加载才会创建</span></span><br><span class="line">    <span class="keyword">if</span> (!bd.isAbstract() &amp;&amp; bd.isSingleton() &amp;&amp; !bd.isLazyInit()) &#123;</span><br><span class="line">      <span class="keyword">if</span> (isFactoryBean(beanName)) &#123;</span><br><span class="line">        <span class="comment">// 工厂Bean的名字有特殊前缀：&amp;</span></span><br><span class="line">        Object bean = getBean(FACTORY_BEAN_PREFIX + beanName);</span><br><span class="line">        <span class="keyword">if</span> (bean <span class="keyword">instanceof</span> FactoryBean) &#123;</span><br><span class="line">          FactoryBean&lt;?&gt; factory = (FactoryBean&lt;?&gt;) bean;</span><br><span class="line">          <span class="comment">// 针对SmartFactoryBean的特殊处理</span></span><br><span class="line">          <span class="keyword">boolean</span> isEagerInit = (factory <span class="keyword">instanceof</span> SmartFactoryBean &amp;&amp; ((SmartFactoryBean&lt;?&gt;) factory).isEagerInit());</span><br><span class="line">          <span class="keyword">if</span> (isEagerInit) &#123;</span><br><span class="line">            <span class="comment">// 真的去创建Bean</span></span><br><span class="line">            getBean(beanName);</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// 真的去创建Bean</span></span><br><span class="line">        getBean(beanName);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span> (String beanName : beanNames) &#123;</span><br><span class="line">    <span class="comment">// 针对SmartInitializingSingleton的特殊处理</span></span><br><span class="line">    Object singletonInstance = getSingleton(beanName);</span><br><span class="line">    <span class="keyword">if</span> (singletonInstance <span class="keyword">instanceof</span> SmartInitializingSingleton) &#123;</span><br><span class="line">      SmartInitializingSingleton smartSingleton = (SmartInitializingSingleton) singletonInstance;</span><br><span class="line">      smartSingleton.afterSingletonsInstantiated();</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> Object <span class="title">getBean</span><span class="params">(String name)</span> <span class="keyword">throws</span> BeansException </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> doGetBean(name, <span class="keyword">null</span>, <span class="keyword">null</span>, <span class="keyword">false</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 真的去创建Bean</span></span><br><span class="line"><span class="comment"> * name: bean的名称</span></span><br><span class="line"><span class="comment"> * requiedType: 希望解析出来的Bean的类型</span></span><br><span class="line"><span class="comment"> * args: 用于创建bean时的构造方法的参数。如果只是获取已有的bean，则不需要</span></span><br><span class="line"><span class="comment"> * typeCheckOnly: 只检查得到的bean与目标类型是否匹配，而不真正地标记创建</span></span><br><span class="line"><span class="comment"> **/</span></span><br><span class="line"><span class="keyword">protected</span> &lt;T&gt; <span class="function">T <span class="title">doGetBean</span><span class="params">(String name, <span class="meta">@Nullable</span> Class&lt;T&gt; requiredType, <span class="meta">@Nullable</span> Object[] args, <span class="keyword">boolean</span> typeCheckOnly)</span> </span>&#123;</span><br><span class="line">  <span class="comment">// 名字转换：主要是处理别名，根据别名获取真名</span></span><br><span class="line">  String beanName = transformedBeanName(name);</span><br><span class="line">  Object beanInstance;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Eagerly check singleton cache for manually registered singletons.</span></span><br><span class="line">  <span class="comment">// 从单例缓存中获取已经注册号的单例Bean实例</span></span><br><span class="line">  Object sharedInstance = getSingleton(beanName);</span><br><span class="line">  <span class="keyword">if</span> (sharedInstance != <span class="keyword">null</span> &amp;&amp; args == <span class="keyword">null</span>) &#123;</span><br><span class="line">    <span class="comment">// 根据共享实例创建Bean实例，如果共享实例是factoryBean，则用它创建一个Bean</span></span><br><span class="line">    beanInstance = getObjectForBeanInstance(sharedInstance, name, beanName, <span class="keyword">null</span>);</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="comment">// Check if bean definition exists in this factory.</span></span><br><span class="line">    BeanFactory parentBeanFactory = getParentBeanFactory();</span><br><span class="line">    <span class="comment">// 如果父容器中还不存在该Bean，则尝试从父容器中获取该Bean，逻辑和本类一致。</span></span><br><span class="line">    <span class="keyword">if</span> (parentBeanFactory != <span class="keyword">null</span> &amp;&amp; !containsBeanDefinition(beanName)) &#123;</span><br><span class="line">      String nameToLookup = originalBeanName(name);</span><br><span class="line">      <span class="keyword">if</span> (parentBeanFactory <span class="keyword">instanceof</span> AbstractBeanFactory) &#123;</span><br><span class="line">        <span class="keyword">return</span> ((AbstractBeanFactory) parentBeanFactory).doGetBean(nameToLookup, requiredType, args, typeCheckOnly);</span><br><span class="line">      &#125; <span class="keyword">else</span> <span class="keyword">if</span> (args != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="comment">// Delegation to parent with explicit args.</span></span><br><span class="line">        <span class="keyword">return</span> (T) parentBeanFactory.getBean(nameToLookup, args);</span><br><span class="line">      &#125; <span class="keyword">else</span> <span class="keyword">if</span> (requiredType != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="comment">// No args -&gt; delegate to standard getBean method.</span></span><br><span class="line">        <span class="keyword">return</span> parentBeanFactory.getBean(nameToLookup, requiredType);</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> (T) parentBeanFactory.getBean(nameToLookup);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 标记已创建</span></span><br><span class="line">    <span class="keyword">if</span> (!typeCheckOnly) &#123;</span><br><span class="line">      markBeanAsCreated(beanName);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 从缓存和父容器中都没有获取到，就要重新创建了，这里获取BeanDefinition，用于创建</span></span><br><span class="line">    RootBeanDefinition mbd = getMergedLocalBeanDefinition(beanName);</span><br><span class="line">    <span class="comment">// Guarantee initialization of beans that the current bean depends on.</span></span><br><span class="line">    <span class="comment">// 获取依赖</span></span><br><span class="line">    String[] dependsOn = mbd.getDependsOn();</span><br><span class="line">    <span class="keyword">if</span> (dependsOn != <span class="keyword">null</span>) &#123;</span><br><span class="line">      <span class="keyword">for</span> (String dep : dependsOn) &#123;</span><br><span class="line">        <span class="comment">// 如果当前Bean又被它的依赖所依赖，就产生的循环依赖，报错</span></span><br><span class="line">        <span class="keyword">if</span> (isDependent(beanName, dep)) &#123;</span><br><span class="line">          <span class="keyword">throw</span> <span class="keyword">new</span> BeanCreationException(mbd.getResourceDescription(), beanName, <span class="string">&quot;Circular depends-on relationship between &#x27;&quot;</span> + beanName + <span class="string">&quot;&#x27; and &#x27;&quot;</span> + dep + <span class="string">&quot;&#x27;&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">          <span class="comment">// 创建该依赖的Bean，逻辑还是本方法的逻辑</span></span><br><span class="line">          getBean(dep);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (NoSuchBeanDefinitionException ex) &#123;</span><br><span class="line">          <span class="keyword">throw</span> <span class="keyword">new</span> BeanCreationException(mbd.getResourceDescription(), beanName, <span class="string">&quot;&#x27;&quot;</span> + beanName + <span class="string">&quot;&#x27; depends on missing bean &#x27;&quot;</span> + dep + <span class="string">&quot;&#x27;&quot;</span>, ex);</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Create bean instance.</span></span><br><span class="line">    <span class="comment">// 如果是单例的，从缓存中获取共享实例，如果没有共享实例，则创建它</span></span><br><span class="line">    <span class="keyword">if</span> (mbd.isSingleton()) &#123;</span><br><span class="line">      sharedInstance = getSingleton(beanName, () -&gt; &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">          <span class="comment">// 创建Bean</span></span><br><span class="line">          <span class="keyword">return</span> createBean(beanName, mbd, args);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (BeansException ex) &#123;</span><br><span class="line">          <span class="comment">// Explicitly remove instance from singleton cache: It might have been put there</span></span><br><span class="line">          <span class="comment">// eagerly by the creation process, to allow for circular reference resolution.</span></span><br><span class="line">          <span class="comment">// Also remove any beans that received a temporary reference to the bean.</span></span><br><span class="line">          destroySingleton(beanName);</span><br><span class="line">          <span class="keyword">throw</span> ex;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;);</span><br><span class="line">      <span class="comment">// 根据共享实例创建Bean实例，如果共享实例是factoryBean，则用它创建一个Bean</span></span><br><span class="line">      beanInstance = getObjectForBeanInstance(sharedInstance, name, beanName, mbd);</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (mbd.isPrototype()) &#123;</span><br><span class="line">      <span class="comment">// 如果是原型的，则每次都创建新的</span></span><br><span class="line">      <span class="comment">// It&#x27;s a prototype -&gt; create a new instance.</span></span><br><span class="line">      Object prototypeInstance = <span class="keyword">null</span>;</span><br><span class="line">      <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">// 创建前回调：标记该bean正在创建</span></span><br><span class="line">        beforePrototypeCreation(beanName);</span><br><span class="line">        <span class="comment">// 创建Bean</span></span><br><span class="line">        prototypeInstance = createBean(beanName, mbd, args);</span><br><span class="line">      &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        <span class="comment">// 创建后回调：标记该bean已经没在创建</span></span><br><span class="line">        afterPrototypeCreation(beanName);</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="comment">// 根据共享实例创建Bean实例，如果共享实例是factoryBean，则用它创建一个Bean</span></span><br><span class="line">      beanInstance = getObjectForBeanInstance(prototypeInstance, name, beanName, mbd);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="comment">// 原型和单例之外的scope</span></span><br><span class="line">      String scopeName = mbd.getScope();</span><br><span class="line">      <span class="comment">// 从scopes缓存中获取指定的Scope，该对象就是一个Bean持有器</span></span><br><span class="line">      Scope scope = <span class="keyword">this</span>.scopes.get(scopeName);</span><br><span class="line">      <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">// 整个scope只有一个实例，从中取，没有则创建。</span></span><br><span class="line">        Object scopedInstance = scope.get(beanName, () -&gt; &#123;</span><br><span class="line">          <span class="comment">// 创建前回调：标记该bean正在创建</span></span><br><span class="line">          beforePrototypeCreation(beanName);</span><br><span class="line">          <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">// 创建Bean</span></span><br><span class="line">            <span class="keyword">return</span> createBean(beanName, mbd, args);</span><br><span class="line">          &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            <span class="comment">// 创建后回调：标记该bean已经没在创建</span></span><br><span class="line">            afterPrototypeCreation(beanName);</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">        <span class="comment">// 根据共享实例创建Bean实例，如果共享实例是factoryBean，则用它创建一个Bean</span></span><br><span class="line">        beanInstance = getObjectForBeanInstance(scopedInstance, name, beanName, mbd);</span><br><span class="line">      &#125; <span class="keyword">catch</span> (IllegalStateException ex) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> ScopeNotActiveException(beanName, scopeName, ex);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 做最后的调整，如果实例化出来的类型和想要的类型不一致，还要进行一个类型转换</span></span><br><span class="line">  <span class="keyword">return</span> adaptBeanInstance(name, beanInstance, requiredType);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&lt;T&gt; <span class="function">T <span class="title">adaptBeanInstance</span><span class="params">(String name, Object bean, <span class="meta">@Nullable</span> Class&lt;?&gt; requiredType)</span> </span>&#123;</span><br><span class="line">  <span class="comment">// Check if required type matches the type of the actual bean instance.</span></span><br><span class="line">  <span class="keyword">if</span> (requiredType != <span class="keyword">null</span> &amp;&amp; !requiredType.isInstance(bean)) &#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">      Object convertedBean = getTypeConverter().convertIfNecessary(bean, requiredType);</span><br><span class="line">      <span class="keyword">if</span> (convertedBean == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> BeanNotOfRequiredTypeException(name, requiredType, bean.getClass());</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">return</span> (T) convertedBean;</span><br><span class="line">    &#125; <span class="keyword">catch</span> (TypeMismatchException ex) &#123;</span><br><span class="line">      <span class="keyword">throw</span> <span class="keyword">new</span> BeanNotOfRequiredTypeException(name, requiredType, bean.getClass());</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> (T) bean;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上面虽然只是预加载单例Bean的代码，但方法<code>doGetBean()</code>却是获取Bean的通用方法，对此，可以有所总结：</p>
<ul>
<li>单例Bean的创建， 先从缓存中获取；如果没有，再从父容器中获取，如果再没有，则执行创建逻辑</li>
<li>如果一个Bean有依赖的Bean，则该依赖Bean将会首先被创建；如果被依赖的Bean又依赖了原Bean，则构成循环依赖，Spring将会抛出异常</li>
<li>scope的实现只有三种情况<ul>
<li>单例：当<code>BeanDefinition</code>的scope没有值（即默认单例）或为<code>singleton</code>时，为单例，整个容器只维护一份实例</li>
<li>原型：当<code>BeanDefinition</code>的scope为<code>prototye</code>时，为原型，每次都会执行一遍新建Bean的逻辑</li>
<li>其它：当<code>BeanDefinition</code>的scope非上述任何一种时，为其它，实现方式是容器维护一个名为<code>scopes</code>的Map，每个entry的值为<code>Scope</code>对象，它就是一个容器，新建的Bean会放入该容器。构成对同一个<code>Scope</code>只存在一份Bean。</li>
</ul>
</li>
<li>创建完成的Bean实例，并不能直接使用：如果有指定预期的类型，还要调用容器内维护的类型转换器进行一次类型转换，得到最终值</li>
</ul>
<p>对于正常情况下的Bean获取方法如<code>org.springframework.context.support.AbstractApplicationContext#getBean(java.lang.String)</code>，有如下</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> Object <span class="title">getBean</span><span class="params">(String name)</span> <span class="keyword">throws</span> BeansException </span>&#123;</span><br><span class="line">  assertBeanFactoryActive();</span><br><span class="line">  <span class="keyword">return</span> getBeanFactory().getBean(name);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> Object <span class="title">getBean</span><span class="params">(String name)</span> <span class="keyword">throws</span> BeansException </span>&#123;</span><br><span class="line">  <span class="comment">// 可以看到它又是调用了doGetBean()，还是那个通用方法</span></span><br><span class="line">  <span class="keyword">return</span> doGetBean(name, <span class="keyword">null</span>, <span class="keyword">null</span>, <span class="keyword">false</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>可以看到它又是调用了doGetBean()，还是那个通用方法，这里略过不记。</p>
<h3 id="MergedBeanDefinition"><a href="#MergedBeanDefinition" class="headerlink" title="MergedBeanDefinition"></a>MergedBeanDefinition</h3><p>先说明，没有这个类或接口定义，但是前文”如何描述Bean“提到了合并Bean定义的概念，”Bean的创建逻辑“又再次看到了这个概念，它到底什么意思？我们从<code>org.springframework.beans.factory.support.AbstractBeanFactory#getMergedLocalBeanDefinition</code>方法来看</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> RootBeanDefinition <span class="title">getMergedLocalBeanDefinition</span><span class="params">(String beanName)</span> <span class="keyword">throws</span> BeansException </span>&#123;</span><br><span class="line">  <span class="comment">// 先从缓存中获取结果</span></span><br><span class="line">  RootBeanDefinition mbd = <span class="keyword">this</span>.mergedBeanDefinitions.get(beanName);</span><br><span class="line">  <span class="keyword">if</span> (mbd != <span class="keyword">null</span> &amp;&amp; !mbd.stale) &#123;</span><br><span class="line">    <span class="keyword">return</span> mbd;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> getMergedBeanDefinition(beanName, getBeanDefinition(beanName));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">protected</span> RootBeanDefinition <span class="title">getMergedBeanDefinition</span><span class="params">(String beanName, BeanDefinition bd)</span> <span class="keyword">throws</span> BeanDefinitionStoreException </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> getMergedBeanDefinition(beanName, bd, <span class="keyword">null</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 真实的获取mergedBeanDefinition的方法</span></span><br><span class="line"><span class="comment"> * 参数说明</span></span><br><span class="line"><span class="comment"> * beanName: bean的名称</span></span><br><span class="line"><span class="comment"> * bd: bean的定义</span></span><br><span class="line"><span class="comment"> * contaningBd: 包含该bean的bean定义（该bean是一个内部bean）</span></span><br><span class="line"><span class="comment"> **/</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> RootBeanDefinition <span class="title">getMergedBeanDefinition</span><span class="params">(String beanName, BeanDefinition bd, <span class="meta">@Nullable</span> BeanDefinition containingBd)</span> <span class="keyword">throws</span> BeanDefinitionStoreException </span>&#123;</span><br><span class="line">  <span class="keyword">synchronized</span> (<span class="keyword">this</span>.mergedBeanDefinitions) &#123;</span><br><span class="line">    RootBeanDefinition mbd = <span class="keyword">null</span>;</span><br><span class="line">    RootBeanDefinition previous = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Check with full lock now in order to enforce the same merged instance.</span></span><br><span class="line">    <span class="keyword">if</span> (containingBd == <span class="keyword">null</span>) &#123;</span><br><span class="line">      mbd = <span class="keyword">this</span>.mergedBeanDefinitions.get(beanName);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (mbd == <span class="keyword">null</span> || mbd.stale) &#123;</span><br><span class="line">      previous = mbd;</span><br><span class="line">      <span class="comment">// 如果当前Bean定义没有父Bean定义，则创建RootBeanDefinition</span></span><br><span class="line">      <span class="keyword">if</span> (bd.getParentName() == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="comment">// Use copy of given root bean definition.</span></span><br><span class="line">        <span class="keyword">if</span> (bd <span class="keyword">instanceof</span> RootBeanDefinition) &#123;</span><br><span class="line">          mbd = ((RootBeanDefinition) bd).cloneBeanDefinition();</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">          mbd = <span class="keyword">new</span> RootBeanDefinition(bd);</span><br><span class="line">        &#125;</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// 否则，该Bean定义是一个子Bean定义，则需要和父Bean定义进行合并</span></span><br><span class="line">        <span class="comment">// Child bean definition: needs to be merged with parent.</span></span><br><span class="line">        BeanDefinition pbd;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">          String parentBeanName = transformedBeanName(bd.getParentName());</span><br><span class="line">          <span class="comment">// 递归逻辑获取父Bean定义，从当前容器或父容器中获取</span></span><br><span class="line">          <span class="keyword">if</span> (!beanName.equals(parentBeanName)) &#123;</span><br><span class="line">            pbd = getMergedBeanDefinition(parentBeanName);</span><br><span class="line">          &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            BeanFactory parent = getParentBeanFactory();</span><br><span class="line">            <span class="keyword">if</span> (parent <span class="keyword">instanceof</span> ConfigurableBeanFactory) &#123;</span><br><span class="line">              pbd = ((ConfigurableBeanFactory) parent).getMergedBeanDefinition(parentBeanName);</span><br><span class="line">            &#125;</span><br><span class="line">          &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (NoSuchBeanDefinitionException ex) &#123;</span><br><span class="line">          <span class="keyword">throw</span> <span class="keyword">new</span> BeanDefinitionStoreException(bd.getResourceDescription(), beanName,</span><br><span class="line">                                                 <span class="string">&quot;Could not resolve parent bean definition &#x27;&quot;</span> + bd.getParentName() + <span class="string">&quot;&#x27;&quot;</span>, ex);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// Deep copy with overridden values.</span></span><br><span class="line">        mbd = <span class="keyword">new</span> RootBeanDefinition(pbd);</span><br><span class="line">        <span class="comment">// 用子Bean定义覆盖父Bean定义，得到一个”合并“后的Bean定义</span></span><br><span class="line">        mbd.overrideFrom(bd);</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="comment">// Set default singleton scope, if not configured before.</span></span><br><span class="line">      <span class="comment">// 默认设置为单例</span></span><br><span class="line">      <span class="keyword">if</span> (!StringUtils.hasLength(mbd.getScope())) &#123;</span><br><span class="line">        mbd.setScope(SCOPE_SINGLETON);</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="comment">// A bean contained in a non-singleton bean cannot be a singleton itself.</span></span><br><span class="line">      <span class="comment">// Let&#x27;s correct this on the fly here, since this might be the result of</span></span><br><span class="line">      <span class="comment">// parent-child merging for the outer bean, in which case the original inner bean</span></span><br><span class="line">      <span class="comment">// definition will not have inherited the merged outer bean&#x27;s singleton status.</span></span><br><span class="line">      <span class="comment">// bean需要和包含它的bean的scope保持一致</span></span><br><span class="line">      <span class="keyword">if</span> (containingBd != <span class="keyword">null</span> &amp;&amp; !containingBd.isSingleton() &amp;&amp; mbd.isSingleton()) &#123;</span><br><span class="line">        mbd.setScope(containingBd.getScope());</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="comment">// Cache the merged bean definition for the time being</span></span><br><span class="line">      <span class="comment">// (it might still get re-merged later on in order to pick up metadata changes)</span></span><br><span class="line">      <span class="keyword">if</span> (containingBd == <span class="keyword">null</span> &amp;&amp; isCacheBeanMetadata()) &#123;</span><br><span class="line">        <span class="keyword">this</span>.mergedBeanDefinitions.put(beanName, mbd);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 合并后的Bean定义可被标记为stale，标识需要重新被合并，这里执行合并逻辑</span></span><br><span class="line">    <span class="keyword">if</span> (previous != <span class="keyword">null</span>) &#123;</span><br><span class="line">      copyRelevantMergedBeanDefinitionCaches(previous, mbd);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> mbd;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">copyRelevantMergedBeanDefinitionCaches</span><span class="params">(RootBeanDefinition previous, RootBeanDefinition mbd)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (ObjectUtils.nullSafeEquals(mbd.getBeanClassName(), previous.getBeanClassName()) &amp;&amp;</span><br><span class="line">      ObjectUtils.nullSafeEquals(mbd.getFactoryBeanName(), previous.getFactoryBeanName()) &amp;&amp;</span><br><span class="line">      ObjectUtils.nullSafeEquals(mbd.getFactoryMethodName(), previous.getFactoryMethodName())) &#123;</span><br><span class="line">    ResolvableType targetType = mbd.targetType;</span><br><span class="line">    ResolvableType previousTargetType = previous.targetType;</span><br><span class="line">    <span class="keyword">if</span> (targetType == <span class="keyword">null</span> || targetType.equals(previousTargetType)) &#123;</span><br><span class="line">      mbd.targetType = previousTargetType;</span><br><span class="line">      mbd.isFactoryBean = previous.isFactoryBean;</span><br><span class="line">      mbd.resolvedTargetType = previous.resolvedTargetType;</span><br><span class="line">      mbd.factoryMethodReturnType = previous.factoryMethodReturnType;</span><br><span class="line">      mbd.factoryMethodToIntrospect = previous.factoryMethodToIntrospect;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>关键是父Bean定义被子Bean定义覆盖，看<code>org.springframework.beans.factory.support.AbstractBeanDefinition#overrideFrom</code></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 不过你看，貌似也没什么不同，就正常的Bean定义的属性呀</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">overrideFrom</span><span class="params">(BeanDefinition other)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (StringUtils.hasLength(other.getBeanClassName())) &#123;</span><br><span class="line">    setBeanClassName(other.getBeanClassName());</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> (StringUtils.hasLength(other.getScope())) &#123;</span><br><span class="line">    setScope(other.getScope());</span><br><span class="line">  &#125;</span><br><span class="line">  setAbstract(other.isAbstract());</span><br><span class="line">  <span class="keyword">if</span> (StringUtils.hasLength(other.getFactoryBeanName())) &#123;</span><br><span class="line">    setFactoryBeanName(other.getFactoryBeanName());</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> (StringUtils.hasLength(other.getFactoryMethodName())) &#123;</span><br><span class="line">    setFactoryMethodName(other.getFactoryMethodName());</span><br><span class="line">  &#125;</span><br><span class="line">  setRole(other.getRole());</span><br><span class="line">  setSource(other.getSource());</span><br><span class="line">  copyAttributesFrom(other);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (other <span class="keyword">instanceof</span> AbstractBeanDefinition) &#123;</span><br><span class="line">    AbstractBeanDefinition otherAbd = (AbstractBeanDefinition) other;</span><br><span class="line">    <span class="keyword">if</span> (otherAbd.hasBeanClass()) &#123;</span><br><span class="line">      setBeanClass(otherAbd.getBeanClass());</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (otherAbd.hasConstructorArgumentValues()) &#123;</span><br><span class="line">      getConstructorArgumentValues().addArgumentValues(other.getConstructorArgumentValues());</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (otherAbd.hasPropertyValues()) &#123;</span><br><span class="line">      getPropertyValues().addPropertyValues(other.getPropertyValues());</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (otherAbd.hasMethodOverrides()) &#123;</span><br><span class="line">      getMethodOverrides().addOverrides(otherAbd.getMethodOverrides());</span><br><span class="line">    &#125;</span><br><span class="line">    Boolean lazyInit = otherAbd.getLazyInit();</span><br><span class="line">    <span class="keyword">if</span> (lazyInit != <span class="keyword">null</span>) &#123;</span><br><span class="line">      setLazyInit(lazyInit);</span><br><span class="line">    &#125;</span><br><span class="line">    setAutowireMode(otherAbd.getAutowireMode());</span><br><span class="line">    setDependencyCheck(otherAbd.getDependencyCheck());</span><br><span class="line">    setDependsOn(otherAbd.getDependsOn());</span><br><span class="line">    setAutowireCandidate(otherAbd.isAutowireCandidate());</span><br><span class="line">    setPrimary(otherAbd.isPrimary());</span><br><span class="line">    copyQualifiersFrom(otherAbd);</span><br><span class="line">    setInstanceSupplier(otherAbd.getInstanceSupplier());</span><br><span class="line">    setNonPublicAccessAllowed(otherAbd.isNonPublicAccessAllowed());</span><br><span class="line">    setLenientConstructorResolution(otherAbd.isLenientConstructorResolution());</span><br><span class="line">    <span class="keyword">if</span> (otherAbd.getInitMethodName() != <span class="keyword">null</span>) &#123;</span><br><span class="line">      setInitMethodName(otherAbd.getInitMethodName());</span><br><span class="line">      setEnforceInitMethod(otherAbd.isEnforceInitMethod());</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (otherAbd.getDestroyMethodName() != <span class="keyword">null</span>) &#123;</span><br><span class="line">      setDestroyMethodName(otherAbd.getDestroyMethodName());</span><br><span class="line">      setEnforceDestroyMethod(otherAbd.isEnforceDestroyMethod());</span><br><span class="line">    &#125;</span><br><span class="line">    setSynthetic(otherAbd.isSynthetic());</span><br><span class="line">    setResource(otherAbd.getResource());</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">else</span> &#123;</span><br><span class="line">    getConstructorArgumentValues().addArgumentValues(other.getConstructorArgumentValues());</span><br><span class="line">    getPropertyValues().addPropertyValues(other.getPropertyValues());</span><br><span class="line">    setLazyInit(other.isLazyInit());</span><br><span class="line">    setResourceDescription(other.getResourceDescription());</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>要点总结：所谓合并，就是有父子关系的<code>BeanDefinition</code>的合并，将他们合并为一个<code>BeanDefinition</code>，合并逻辑是：用子<code>BeanDefinition</code>覆盖父<code>BeanDefinition</code>，最终结果用<code>RootBeanDefinition</code>表示。</p>
<h3 id="自动注入"><a href="#自动注入" class="headerlink" title="自动注入"></a>自动注入</h3><blockquote>
<p>自动注入这块的代码实在太多，这里分成几个部分分别来说</p>
</blockquote>
<p>到现在为止，我们还没看到自动注入，<code>BeanPostProcessor</code>等的执行逻辑，它们都在<code>org.springframework.beans.factory.support.AbstractAutowireCapableBeanFactory#createBean(java.lang.String, org.springframework.beans.factory.support.RootBeanDefinition, java.lang.Object[])</code>中，前文创建Bean的源码有调用它</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> Object <span class="title">createBean</span><span class="params">(String beanName, RootBeanDefinition mbd, <span class="meta">@Nullable</span> Object[] args)</span> <span class="keyword">throws</span> BeanCreationException </span>&#123;</span><br><span class="line">  RootBeanDefinition mbdToUse = mbd;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Make sure bean class is actually resolved at this point, and</span></span><br><span class="line">  <span class="comment">// clone the bean definition in case of a dynamically resolved Class</span></span><br><span class="line">  <span class="comment">// which cannot be stored in the shared merged bean definition.</span></span><br><span class="line">  Class&lt;?&gt; resolvedClass = resolveBeanClass(mbd, beanName);</span><br><span class="line">  <span class="keyword">if</span> (resolvedClass != <span class="keyword">null</span> &amp;&amp; !mbd.hasBeanClass() &amp;&amp; mbd.getBeanClassName() != <span class="keyword">null</span>) &#123;</span><br><span class="line">    mbdToUse = <span class="keyword">new</span> RootBeanDefinition(mbd);</span><br><span class="line">    mbdToUse.setBeanClass(resolvedClass);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Prepare method overrides.</span></span><br><span class="line">  <span class="comment">// 不用管</span></span><br><span class="line">  mbdToUse.prepareMethodOverrides();</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Give BeanPostProcessors a chance to return a proxy instead of the target bean instance.</span></span><br><span class="line">  <span class="comment">// 在某些情况下，获得的Bean可能是一个代理，此时并不需要真正执行Bean的创建逻辑，InstantiationAwareBeanPostProcessor就是用来做这个事的</span></span><br><span class="line">  Object bean = resolveBeforeInstantiation(beanName, mbdToUse);</span><br><span class="line">  <span class="keyword">if</span> (bean != <span class="keyword">null</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> bean;</span><br><span class="line">  &#125;</span><br><span class="line">	<span class="comment">// 如果没有什么额外设置，就真的去创建Bean</span></span><br><span class="line">  Object beanInstance = doCreateBean(beanName, mbdToUse, args);</span><br><span class="line">  <span class="keyword">return</span> beanInstance;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>这里唯一需要注意的点：可以通过<code>InstantiationAwareBeanPostProcessor</code>提供一个代理实例，这为Spy之类的测试功能提供了方便，使得他们可以伪造bean，构建测试环境。</li>
</ul>
<h4 id="创建实例前的操作"><a href="#创建实例前的操作" class="headerlink" title="创建实例前的操作"></a>创建实例前的操作</h4><p>对<code>resolveBeforeInstantiation</code>，有</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> Object <span class="title">resolveBeforeInstantiation</span><span class="params">(String beanName, RootBeanDefinition mbd)</span> </span>&#123;</span><br><span class="line">  Object bean = <span class="keyword">null</span>;</span><br><span class="line">  <span class="keyword">if</span> (!Boolean.FALSE.equals(mbd.beforeInstantiationResolved)) &#123;</span><br><span class="line">    <span class="comment">// Make sure bean class is actually resolved at this point.</span></span><br><span class="line">    <span class="keyword">if</span> (!mbd.isSynthetic() &amp;&amp; hasInstantiationAwareBeanPostProcessors()) &#123;</span><br><span class="line">      <span class="comment">// 确定Bean的类型</span></span><br><span class="line">      Class&lt;?&gt; targetType = determineTargetType(beanName, mbd);</span><br><span class="line">      <span class="keyword">if</span> (targetType != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="comment">// 应用InstantiationAwareBeanPostProcessor，产生的一般都是代理</span></span><br><span class="line">        bean = applyBeanPostProcessorsBeforeInstantiation(targetType, beanName);</span><br><span class="line">        <span class="keyword">if</span> (bean != <span class="keyword">null</span>) &#123;</span><br><span class="line">          <span class="comment">// 如果产生了代理，就当成已经实例化，应用所有后置处理器。注意这里为什么要调用后置处理器，因为上面产生的代理将会直接返回，不会走bean创建逻辑了</span></span><br><span class="line">          bean = applyBeanPostProcessorsAfterInitialization(bean, beanName);</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    mbd.beforeInstantiationResolved = (bean != <span class="keyword">null</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> bean;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 应用InstantiationAwareBeanPostProcessor.postProcessBeforeInstantiation，该接口专门用于实例化之前调用，以便我们能够返回一个目标对象的代理</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> Object <span class="title">applyBeanPostProcessorsBeforeInstantiation</span><span class="params">(Class&lt;?&gt; beanClass, String beanName)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">for</span> (InstantiationAwareBeanPostProcessor bp : getBeanPostProcessorCache().instantiationAware) &#123;</span><br><span class="line">    Object result = bp.postProcessBeforeInstantiation(beanClass, beanName);</span><br><span class="line">    <span class="keyword">if</span> (result != <span class="keyword">null</span>) &#123;</span><br><span class="line">      <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 实例化后调用所有的后置处理器</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> Object <span class="title">applyBeanPostProcessorsAfterInitialization</span><span class="params">(Object existingBean, String beanName)</span> <span class="keyword">throws</span> BeansException </span>&#123;</span><br><span class="line">  Object result = existingBean;</span><br><span class="line">  <span class="keyword">for</span> (BeanPostProcessor processor : getBeanPostProcessors()) &#123;</span><br><span class="line">    Object current = processor.postProcessAfterInitialization(result, beanName);</span><br><span class="line">    <span class="keyword">if</span> (current == <span class="keyword">null</span>) &#123;</span><br><span class="line">      <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">    result = current;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>注意点同上</li>
</ul>
<h4 id="创建实例操作总览"><a href="#创建实例操作总览" class="headerlink" title="创建实例操作总览"></a>创建实例操作总览</h4><p>对创建的实际操作，有</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> Object <span class="title">doCreateBean</span><span class="params">(String beanName, RootBeanDefinition mbd, <span class="meta">@Nullable</span> Object[] args)</span> <span class="keyword">throws</span> BeanCreationException </span>&#123;</span><br><span class="line">  <span class="comment">// Instantiate the bean.</span></span><br><span class="line">  <span class="comment">// 创建的Bean并不是直接以对象的形式存在，而是以BeanWrapper的形式存在的</span></span><br><span class="line">  BeanWrapper instanceWrapper = <span class="keyword">null</span>;</span><br><span class="line">  <span class="keyword">if</span> (mbd.isSingleton()) &#123;</span><br><span class="line">    <span class="comment">// 如果是单例，从缓存中移除BeanWrapper</span></span><br><span class="line">    instanceWrapper = <span class="keyword">this</span>.factoryBeanInstanceCache.remove(beanName);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> (instanceWrapper == <span class="keyword">null</span>) &#123;</span><br><span class="line">    <span class="comment">// 真实创建步骤</span></span><br><span class="line">    instanceWrapper = createBeanInstance(beanName, mbd, args);</span><br><span class="line">  &#125;</span><br><span class="line">  Object bean = instanceWrapper.getWrappedInstance();</span><br><span class="line">  Class&lt;?&gt; beanType = instanceWrapper.getWrappedClass();</span><br><span class="line">  <span class="keyword">if</span> (beanType != NullBean.class) &#123;</span><br><span class="line">    <span class="comment">// 回填最终信息</span></span><br><span class="line">    mbd.resolvedTargetType = beanType;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Allow post-processors to modify the merged bean definition.</span></span><br><span class="line">  <span class="keyword">synchronized</span> (mbd.postProcessingLock) &#123;</span><br><span class="line">    <span class="keyword">if</span> (!mbd.postProcessed) &#123;</span><br><span class="line">      <span class="comment">// 应用所有的MergedBeanDefinitionPostProcessor</span></span><br><span class="line">      applyMergedBeanDefinitionPostProcessors(mbd, beanType, beanName);</span><br><span class="line">      mbd.postProcessed = <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Eagerly cache singletons to be able to resolve circular references</span></span><br><span class="line">  <span class="comment">// even when triggered by lifecycle interfaces like BeanFactoryAware.</span></span><br><span class="line">  <span class="comment">// 提前暴露单例Bean引用，主要为解决循环引用问题</span></span><br><span class="line">  <span class="keyword">boolean</span> earlySingletonExposure = (mbd.isSingleton() &amp;&amp; <span class="keyword">this</span>.allowCircularReferences &amp;&amp; isSingletonCurrentlyInCreation(beanName));</span><br><span class="line">  <span class="keyword">if</span> (earlySingletonExposure) &#123;</span><br><span class="line">    addSingletonFactory(beanName, () -&gt; getEarlyBeanReference(beanName, mbd, bean));</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Initialize the bean instance.</span></span><br><span class="line">  Object exposedObject = bean;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 执行Bean注入</span></span><br><span class="line">  populateBean(beanName, mbd, instanceWrapper);</span><br><span class="line">  <span class="comment">// 初始化Bean</span></span><br><span class="line">  exposedObject = initializeBean(beanName, exposedObject, mbd);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (earlySingletonExposure) &#123;</span><br><span class="line">    <span class="comment">// 循环依赖检查：正常来说，提前暴露那个对象，和初始化后的bean对象，应该是一个，否则就说明出现了问题</span></span><br><span class="line">    Object earlySingletonReference = getSingleton(beanName, <span class="keyword">false</span>);</span><br><span class="line">    <span class="keyword">if</span> (earlySingletonReference != <span class="keyword">null</span>) &#123;</span><br><span class="line">      <span class="keyword">if</span> (exposedObject == bean) &#123;</span><br><span class="line">        exposedObject = earlySingletonReference;</span><br><span class="line">      &#125; <span class="keyword">else</span> <span class="keyword">if</span> (!<span class="keyword">this</span>.allowRawInjectionDespiteWrapping &amp;&amp; hasDependentBean(beanName)) &#123;</span><br><span class="line">        String[] dependentBeans = getDependentBeans(beanName);</span><br><span class="line">        Set&lt;String&gt; actualDependentBeans = <span class="keyword">new</span> LinkedHashSet&lt;&gt;(dependentBeans.length);</span><br><span class="line">        <span class="keyword">for</span> (String dependentBean : dependentBeans) &#123;</span><br><span class="line">          <span class="keyword">if</span> (!removeSingletonIfCreatedForTypeCheckOnly(dependentBean)) &#123;</span><br><span class="line">            actualDependentBeans.add(dependentBean);</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (!actualDependentBeans.isEmpty()) &#123;</span><br><span class="line">          <span class="keyword">throw</span> ... ...</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Register bean as disposable.</span></span><br><span class="line">  <span class="comment">// 将该bean注册到对应Scope的销毁回调上</span></span><br><span class="line">  registerDisposableBeanIfNecessary(beanName, bean, mbd);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> exposedObject;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>注意点1：创建Bean的步骤：创建、执行注入、执行初始化操作</li>
<li>注意点2：循环引用的解决方式</li>
</ul>
<h5 id="循环引用的解决方式"><a href="#循环引用的解决方式" class="headerlink" title="循环引用的解决方式"></a>循环引用的解决方式</h5><p>需要注意的是，这里有两种循环引用的方式</p>
<ul>
<li><p><code>Scope</code>为单例时，则如”创建实例操作总览“中的代码那样，确切来说，应该这么梳理</p>
<p>首先，Spring维护三个有关单例缓存</p>
<ul>
<li><code>singletonObjects</code>：用于维护已经创建好的单例对象</li>
<li><code>earlySingletonObjects</code>：用于维护创建了但尚未执行自动注入和初始化的单例对象</li>
<li><code>singletonFactories</code>：用于维护单例对象产生的工厂实例</li>
</ul>
<p>然后来看注入的具体方法，比如按照name注入，它还是调用了<code>getBean</code>方法获取Bean，其中会调用<code>getSingleton</code>方法获取实例对象</p>
<ul>
<li>先从<code>singletonObjects</code>中获取已经创建好的单例对象</li>
<li>再尝试从<code>earlySingletonObjects</code>中获取创建到一般的单例对象</li>
<li>再尝试用对应的<code>singletonFactories</code>创建出一个单例对象，注意该对象会加入<code>earlySingletonObjects</code>，所以其实为了理解方便，<code>singletonFactories</code>您可以暂时忽略</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> Object <span class="title">getSingleton</span><span class="params">(String beanName, <span class="keyword">boolean</span> allowEarlyReference)</span> </span>&#123;</span><br><span class="line">  <span class="comment">// 已经简化成这样</span></span><br><span class="line">  singletonObject = <span class="keyword">this</span>.singletonObjects.get(beanName);</span><br><span class="line">  <span class="keyword">if</span> (singletonObject == <span class="keyword">null</span>) &#123;</span><br><span class="line">    singletonObject = <span class="keyword">this</span>.earlySingletonObjects.get(beanName);</span><br><span class="line">    <span class="keyword">if</span> (singletonObject == <span class="keyword">null</span>) &#123;</span><br><span class="line">      ObjectFactory&lt;?&gt; singletonFactory = <span class="keyword">this</span>.singletonFactories.get(beanName);</span><br><span class="line">      <span class="keyword">if</span> (singletonFactory != <span class="keyword">null</span>) &#123;</span><br><span class="line">        singletonObject = singletonFactory.getObject();</span><br><span class="line">        <span class="keyword">this</span>.earlySingletonObjects.put(beanName, singletonObject);</span><br><span class="line">        <span class="keyword">this</span>.singletonFactories.remove(beanName);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> singletonObject;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>然后再看创建Bean时干了什么（截取前文的代码）：增加了一个<code>singletonFactory</code>，结合前面的分析，其实就是把刚创建但还没有注入属性和初始化的bean放在了<code>earlySingletonObjects</code>中，使得如果有循环依赖时能够直接获取到该bean。避免死循环。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (earlySingletonExposure) &#123;</span><br><span class="line">  <span class="comment">// getEarlyBeanReference方法，其实就是直接将传入的bean传回来了</span></span><br><span class="line">  addSingletonFactory(beanName, () -&gt; getEarlyBeanReference(beanName, mbd, bean));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>总结来说，这里的重点是将bean的创建和初始化（包括注入）分开进行，保有一个半初始化的状态，使得能够注入半初始化状态的Bean。</p>
<p><strong>但是，这是setter注入时才可以这么做，构造器注入又当如何呢？</strong>事实上，因为构造器注入时，当前对象尚未创建完成，没法有一个半初始化状态，因此构造器注入不允许循环依赖。</p>
</li>
<li><p><code>Scope</code>为原型时，参考<code>AbstractBeanFactory.doCreate.273行</code>，这里有检查当前线程下同名的原型Bean是否正在创建。Spring是一个同步框架，在创建原型Bean时，同一个线程不可能同时创建两个原型Bean，那么很明显了，就如注释所说，这里是不允许原型Bean循环引用。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Fail if we&#x27;re already creating this bean instance:</span></span><br><span class="line"><span class="comment">// We&#x27;re assumably within a circular reference.</span></span><br><span class="line"><span class="keyword">if</span> (isPrototypeCurrentlyInCreation(beanName)) &#123;</span><br><span class="line">  <span class="keyword">throw</span> <span class="keyword">new</span> BeanCurrentlyInCreationException(beanName);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>为什么原型时不支持循环依赖？因为Spring不会缓存任何有关原型的状态，虽然它也能有中间状态，但Spring并不缓存它，这是一个技术上可以实现，但Spring的设计思想上不允许存在的场景：所谓原型，每次获取Bean都要创建一个新的，那么当循环依赖时，应该获得的是一个与”我“完全不同的Bean。</p>
</li>
</ul>
<h4 id="BeanWrapper是什么"><a href="#BeanWrapper是什么" class="headerlink" title="BeanWrapper是什么"></a>BeanWrapper是什么</h4><p>该类不是给我们直接使用的，而是在容器内部流通。用于提供实际Bean实例的分析和操作，如针对属性的操作、查询等。它常用的只有一个实现类<code>BeanWrapperImpl</code>。了解它有助于源码的查看，这里我们简要看一下接口定义</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">BeanWrapper</span> <span class="keyword">extends</span> <span class="title">ConfigurablePropertyAccessor</span> </span>&#123;</span><br><span class="line">	<span class="comment">// 获取真实的Bean实例</span></span><br><span class="line">	<span class="function">Object <span class="title">getWrappedInstance</span><span class="params">()</span></span>;</span><br><span class="line">	<span class="comment">// 获取真实的Bean类</span></span><br><span class="line">	Class&lt;?&gt; getWrappedClass();</span><br><span class="line">	<span class="comment">// 获取所有实例的属性描述符</span></span><br><span class="line">	PropertyDescriptor[] getPropertyDescriptors();</span><br><span class="line">	<span class="comment">// 获取指定属性的属性描述符</span></span><br><span class="line">	<span class="function">PropertyDescriptor <span class="title">getPropertyDescriptor</span><span class="params">(String propertyName)</span> <span class="keyword">throws</span> InvalidPropertyException</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="创建实例的确切操作"><a href="#创建实例的确切操作" class="headerlink" title="创建实例的确切操作"></a>创建实例的确切操作</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> BeanWrapper <span class="title">createBeanInstance</span><span class="params">(String beanName, RootBeanDefinition mbd, <span class="meta">@Nullable</span> Object[] args)</span> </span>&#123;</span><br><span class="line">  <span class="comment">// Make sure bean class is actually resolved at this point.</span></span><br><span class="line">  <span class="comment">// 解析真实的bean类对象</span></span><br><span class="line">  Class&lt;?&gt; beanClass = resolveBeanClass(mbd, beanName);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 如果BeanDefinitino有提供用于创建实例的Supplier，则直接用它创建。Supplier的应用场景，有待探索</span></span><br><span class="line">  Supplier&lt;?&gt; instanceSupplier = mbd.getInstanceSupplier();</span><br><span class="line">  <span class="keyword">if</span> (instanceSupplier != <span class="keyword">null</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> obtainFromSupplier(instanceSupplier, beanName);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 如果有指定工厂方法，直接通过工厂方法创建</span></span><br><span class="line">  <span class="keyword">if</span> (mbd.getFactoryMethodName() != <span class="keyword">null</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> instantiateUsingFactoryMethod(beanName, mbd, args);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Shortcut when re-creating the same bean...</span></span><br><span class="line">  <span class="keyword">boolean</span> resolved = <span class="keyword">false</span>;</span><br><span class="line">  <span class="keyword">boolean</span> autowireNecessary = <span class="keyword">false</span>;</span><br><span class="line">  <span class="keyword">if</span> (args == <span class="keyword">null</span>) &#123;</span><br><span class="line">    <span class="keyword">synchronized</span> (mbd.constructorArgumentLock) &#123;</span><br><span class="line">      <span class="keyword">if</span> (mbd.resolvedConstructorOrFactoryMethod != <span class="keyword">null</span>) &#123;</span><br><span class="line">        resolved = <span class="keyword">true</span>;</span><br><span class="line">        autowireNecessary = mbd.constructorArgumentsResolved;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 如果BeanDefinition的构造器已经被解析出来了，则直接用他们创建</span></span><br><span class="line">  <span class="keyword">if</span> (resolved) &#123;</span><br><span class="line">    <span class="keyword">if</span> (autowireNecessary) &#123;</span><br><span class="line">      <span class="comment">// 通过构造器创建，并注入构造器参数</span></span><br><span class="line">      <span class="keyword">return</span> autowireConstructor(beanName, mbd, <span class="keyword">null</span>, <span class="keyword">null</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="comment">// 直接使用无参构造器创建</span></span><br><span class="line">      <span class="keyword">return</span> instantiateBean(beanName, mbd);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 如果有SmartInstantiationAwareBeanPostProcessor提供构造器，则使用该构造器创建</span></span><br><span class="line">  Constructor&lt;?&gt;[] ctors = determineConstructorsFromBeanPostProcessors(beanClass, beanName);</span><br><span class="line">  <span class="keyword">if</span> (ctors != <span class="keyword">null</span> || mbd.getResolvedAutowireMode() == AUTOWIRE_CONSTRUCTOR ||</span><br><span class="line">      mbd.hasConstructorArgumentValues() || !ObjectUtils.isEmpty(args)) &#123;</span><br><span class="line">    <span class="keyword">return</span> autowireConstructor(beanName, mbd, ctors, args);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 使用默认构造器创建</span></span><br><span class="line">  ctors = mbd.getPreferredConstructors();</span><br><span class="line">  <span class="keyword">if</span> (ctors != <span class="keyword">null</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> autowireConstructor(beanName, mbd, ctors, <span class="keyword">null</span>);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 直接使用无参构造器创建</span></span><br><span class="line">  <span class="keyword">return</span> instantiateBean(beanName, mbd);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>创建备选方式的顺序<ol>
<li>提前设置的<code>Supplier</code></li>
<li>指定的工厂方法</li>
<li>使用<code>BeanDefinition</code>提前解析好的构造器创建</li>
<li>使用<code>SmartInstantiationAwareBeanPostProcessor</code>提供的构造器创建</li>
<li>使用类自带的有参构造器创建，参数来自容器，自动注入</li>
<li>使用类自带的无参构造器创建</li>
</ol>
</li>
</ul>
<h5 id="按有参构造器注入并创建"><a href="#按有参构造器注入并创建" class="headerlink" title="按有参构造器注入并创建"></a>按有参构造器注入并创建</h5><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> BeanWrapper <span class="title">autowireConstructor</span><span class="params">(String beanName, RootBeanDefinition mbd, <span class="meta">@Nullable</span> Constructor&lt;?&gt;[] chosenCtors, <span class="meta">@Nullable</span> Object[] explicitArgs)</span> </span>&#123;</span><br><span class="line">  BeanWrapperImpl bw = <span class="keyword">new</span> BeanWrapperImpl();</span><br><span class="line">  <span class="comment">// 这里初始化只是注入了类型转换相关内容</span></span><br><span class="line">  <span class="keyword">this</span>.beanFactory.initBeanWrapper(bw);</span><br><span class="line"></span><br><span class="line">  Constructor&lt;?&gt; constructorToUse = <span class="keyword">null</span>;</span><br><span class="line">  ArgumentsHolder argsHolderToUse = <span class="keyword">null</span>;</span><br><span class="line">  Object[] argsToUse = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (explicitArgs != <span class="keyword">null</span>) &#123;</span><br><span class="line">    <span class="comment">// 给了args就直接用</span></span><br><span class="line">    argsToUse = explicitArgs;</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="comment">// 没给args，就从BeanDefinition中找到args拿出来用</span></span><br><span class="line">    Object[] argsToResolve = <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">synchronized</span> (mbd.constructorArgumentLock) &#123;</span><br><span class="line">      constructorToUse = (Constructor&lt;?&gt;) mbd.resolvedConstructorOrFactoryMethod;</span><br><span class="line">      <span class="keyword">if</span> (constructorToUse != <span class="keyword">null</span> &amp;&amp; mbd.constructorArgumentsResolved) &#123;</span><br><span class="line">        <span class="comment">// Found a cached constructor...</span></span><br><span class="line">        argsToUse = mbd.resolvedConstructorArguments;</span><br><span class="line">        <span class="keyword">if</span> (argsToUse == <span class="keyword">null</span>) &#123;</span><br><span class="line">          argsToResolve = mbd.preparedConstructorArguments;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (argsToResolve != <span class="keyword">null</span>) &#123;</span><br><span class="line">      argsToUse = resolvePreparedArguments(beanName, mbd, bw, constructorToUse, argsToResolve);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (constructorToUse == <span class="keyword">null</span> || argsToUse == <span class="keyword">null</span>) &#123;</span><br><span class="line">    <span class="comment">// Take specified constructors, if any.</span></span><br><span class="line">    Constructor&lt;?&gt;[] candidates = chosenCtors;</span><br><span class="line">    <span class="comment">// 获取类的所有构造方法作为候选</span></span><br><span class="line">    <span class="keyword">if</span> (candidates == <span class="keyword">null</span>) &#123;</span><br><span class="line">      Class&lt;?&gt; beanClass = mbd.getBeanClass();</span><br><span class="line">      candidates = (mbd.isNonPublicAccessAllowed() ? beanClass.getDeclaredConstructors() : beanClass.getConstructors());</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 如果对象只有一个无参构造器，则可以直接创建对象，不需要走自动注入</span></span><br><span class="line">    <span class="keyword">if</span> (candidates.length == <span class="number">1</span> &amp;&amp; explicitArgs == <span class="keyword">null</span> &amp;&amp; !mbd.hasConstructorArgumentValues()) &#123;</span><br><span class="line">      Constructor&lt;?&gt; uniqueCandidate = candidates[<span class="number">0</span>];</span><br><span class="line">      <span class="keyword">if</span> (uniqueCandidate.getParameterCount() == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">synchronized</span> (mbd.constructorArgumentLock) &#123;</span><br><span class="line">          mbd.resolvedConstructorOrFactoryMethod = uniqueCandidate;</span><br><span class="line">          mbd.constructorArgumentsResolved = <span class="keyword">true</span>;</span><br><span class="line">          mbd.resolvedConstructorArguments = EMPTY_ARGS;</span><br><span class="line">        &#125;</span><br><span class="line">        bw.setBeanInstance(instantiate(beanName, mbd, uniqueCandidate, EMPTY_ARGS));</span><br><span class="line">        <span class="keyword">return</span> bw;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Need to resolve the constructor.</span></span><br><span class="line">    <span class="comment">// 需要自动注入的判断标准：有构造器，或者BeanDefinition的注入模式为构造器注入</span></span><br><span class="line">    <span class="keyword">boolean</span> autowiring = (chosenCtors != <span class="keyword">null</span> || mbd.getResolvedAutowireMode() == AutowireCapableBeanFactory.AUTOWIRE_CONSTRUCTOR);</span><br><span class="line">    ConstructorArgumentValues resolvedValues = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> minNrOfArgs;</span><br><span class="line">    <span class="keyword">if</span> (explicitArgs != <span class="keyword">null</span>) &#123;</span><br><span class="line">      minNrOfArgs = explicitArgs.length;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      ConstructorArgumentValues cargs = mbd.getConstructorArgumentValues();</span><br><span class="line">      resolvedValues = <span class="keyword">new</span> ConstructorArgumentValues();</span><br><span class="line">      minNrOfArgs = resolveConstructorArguments(beanName, mbd, bw, cargs, resolvedValues);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    AutowireUtils.sortConstructors(candidates);</span><br><span class="line">    <span class="keyword">int</span> minTypeDiffWeight = Integer.MAX_VALUE;</span><br><span class="line">    Set&lt;Constructor&lt;?&gt;&gt; ambiguousConstructors = <span class="keyword">null</span>;</span><br><span class="line">    Deque&lt;UnsatisfiedDependencyException&gt; causes = <span class="keyword">null</span>;</span><br><span class="line">    <span class="comment">// 寻找要用哪个构造器创建Bean</span></span><br><span class="line">    <span class="keyword">for</span> (Constructor&lt;?&gt; candidate : candidates) &#123;</span><br><span class="line">      <span class="keyword">int</span> parameterCount = candidate.getParameterCount();</span><br><span class="line"></span><br><span class="line">      ArgumentsHolder argsHolder;</span><br><span class="line">      Class&lt;?&gt;[] paramTypes = candidate.getParameterTypes();</span><br><span class="line">      <span class="keyword">if</span> (resolvedValues != <span class="keyword">null</span>) &#123;</span><br><span class="line">        String[] paramNames = ConstructorPropertiesChecker.evaluate(candidate, parameterCount);</span><br><span class="line">        <span class="keyword">if</span> (paramNames == <span class="keyword">null</span>) &#123;</span><br><span class="line">          ParameterNameDiscoverer pnd = <span class="keyword">this</span>.beanFactory.getParameterNameDiscoverer();</span><br><span class="line">          <span class="keyword">if</span> (pnd != <span class="keyword">null</span>) &#123;</span><br><span class="line">            paramNames = pnd.getParameterNames(candidate);</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 这里在容器中寻找符合要求的bean，构建出符合要求的参数，以便在后面使用</span></span><br><span class="line">        argsHolder = createArgumentArray(beanName, mbd, resolvedValues, bw, paramTypes, paramNames, getUserDeclaredConstructor(candidate), autowiring, candidates.length == <span class="number">1</span>);</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// Explicit arguments given -&gt; arguments length must match exactly.</span></span><br><span class="line">        <span class="keyword">if</span> (parameterCount != explicitArgs.length) &#123;</span><br><span class="line">          <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        argsHolder = <span class="keyword">new</span> ArgumentsHolder(explicitArgs);</span><br><span class="line">      &#125;</span><br><span class="line">			<span class="comment">// 权重计算规则：将给的参数类型和实际构造器对应位置的参数进行类型对比，越符合得分越高。</span></span><br><span class="line">      <span class="keyword">int</span> typeDiffWeight = (mbd.isLenientConstructorResolution() ?  argsHolder.getTypeDifferenceWeight(paramTypes) : argsHolder.getAssignabilityWeight(paramTypes));</span><br><span class="line">      <span class="comment">// Choose this constructor if it represents the closest match.</span></span><br><span class="line">      <span class="comment">// 冒泡法找出最符合要求那个，如果两个权重一致，则加入 ”无法区分“ 的列表</span></span><br><span class="line">      <span class="keyword">if</span> (typeDiffWeight &lt; minTypeDiffWeight) &#123;</span><br><span class="line">        constructorToUse = candidate;</span><br><span class="line">        argsHolderToUse = argsHolder;</span><br><span class="line">        argsToUse = argsHolder.arguments;</span><br><span class="line">        minTypeDiffWeight = typeDiffWeight;</span><br><span class="line">        ambiguousConstructors = <span class="keyword">null</span>;</span><br><span class="line">      &#125; <span class="keyword">else</span> <span class="keyword">if</span> (constructorToUse != <span class="keyword">null</span> &amp;&amp; typeDiffWeight == minTypeDiffWeight) &#123;</span><br><span class="line">        <span class="keyword">if</span> (ambiguousConstructors == <span class="keyword">null</span>) &#123;</span><br><span class="line">          ambiguousConstructors = <span class="keyword">new</span> LinkedHashSet&lt;&gt;();</span><br><span class="line">          ambiguousConstructors.add(constructorToUse);</span><br><span class="line">        &#125;</span><br><span class="line">        ambiguousConstructors.add(candidate);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 最终没有构造器被选中，报错</span></span><br><span class="line">    <span class="keyword">if</span> (constructorToUse == <span class="keyword">null</span>) &#123;</span><br><span class="line">      <span class="keyword">throw</span> <span class="keyword">new</span> BeanCreationException(......);</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (ambiguousConstructors != <span class="keyword">null</span> &amp;&amp; !mbd.isLenientConstructorResolution()) &#123;</span><br><span class="line">      <span class="comment">// 最终有多个构造器符合条件，无法区分用哪个，也报错</span></span><br><span class="line">      <span class="keyword">throw</span> <span class="keyword">new</span> BeanCreationException(......);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  Assert.state(argsToUse != <span class="keyword">null</span>, <span class="string">&quot;Unresolved constructor arguments&quot;</span>);</span><br><span class="line">  <span class="comment">// 利用反射创建Bean实例</span></span><br><span class="line">  bw.setBeanInstance(instantiate(beanName, mbd, constructorToUse, argsToUse));</span><br><span class="line">  <span class="keyword">return</span> bw;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>Spring会先从容器中找出满足类型要求的参数组合，然后找出与这些参数类型最为匹配的构造器，用以创建实例</li>
<li>可以想见，只要有精确类型的bean被创建，就一定能够实例化成功，因为不可能有完全一样参数类型的构造器嘛</li>
</ul>
<h5 id="使用无参构造器创建"><a href="#使用无参构造器创建" class="headerlink" title="使用无参构造器创建"></a>使用无参构造器创建</h5><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> BeanWrapper <span class="title">instantiateBean</span><span class="params">(String beanName, RootBeanDefinition mbd)</span> </span>&#123;</span><br><span class="line">  <span class="comment">// 这里不用再追进去看了，它就是获取了类的无参构造方法，然后通过反射实例化</span></span><br><span class="line">  Object beanInstance = getInstantiationStrategy().instantiate(mbd, beanName, <span class="keyword">this</span>);</span><br><span class="line">  <span class="comment">// 包装成BeanWrapper</span></span><br><span class="line">  BeanWrapper bw = <span class="keyword">new</span> BeanWrapperImpl(beanInstance);</span><br><span class="line">  initBeanWrapper(bw);</span><br><span class="line">  <span class="keyword">return</span> bw;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="自动注入逻辑的执行"><a href="#自动注入逻辑的执行" class="headerlink" title="自动注入逻辑的执行"></a>自动注入逻辑的执行</h4><p>对自动注入的逻辑，即<code>populateBean()</code>，有</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 执行Bean注入</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">populateBean</span><span class="params">(String beanName, RootBeanDefinition mbd, <span class="meta">@Nullable</span> BeanWrapper bw)</span> </span>&#123;</span><br><span class="line">  <span class="comment">// Give any InstantiationAwareBeanPostProcessors the opportunity to modify the</span></span><br><span class="line">  <span class="comment">// state of the bean before properties are set. This can be used, for example,</span></span><br><span class="line">  <span class="comment">// to support styles of field injection.</span></span><br><span class="line">  <span class="keyword">if</span> (!mbd.isSynthetic() &amp;&amp; hasInstantiationAwareBeanPostProcessors()) &#123;</span><br><span class="line">    <span class="comment">// 应用InstantiationAwareBeanPostProcessor，在实例刚刚创建后，属性被设置之前执行</span></span><br><span class="line">    <span class="keyword">for</span> (InstantiationAwareBeanPostProcessor bp : getBeanPostProcessorCache().instantiationAware) &#123;</span><br><span class="line">      <span class="keyword">if</span> (!bp.postProcessAfterInstantiation(bw.getWrappedInstance(), beanName)) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  PropertyValues pvs = (mbd.hasPropertyValues() ? mbd.getPropertyValues() : <span class="keyword">null</span>);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 自定注入模式：自动检测、按名字、按类型；</span></span><br><span class="line">  <span class="keyword">int</span> resolvedAutowireMode = mbd.getResolvedAutowireMode();</span><br><span class="line">  <span class="keyword">if</span> (resolvedAutowireMode == AUTOWIRE_BY_NAME || resolvedAutowireMode == AUTOWIRE_BY_TYPE) &#123;</span><br><span class="line">    MutablePropertyValues newPvs = <span class="keyword">new</span> MutablePropertyValues(pvs);</span><br><span class="line">    <span class="comment">// Add property values based on autowire by name if applicable.</span></span><br><span class="line">    <span class="keyword">if</span> (resolvedAutowireMode == AUTOWIRE_BY_NAME) &#123;</span><br><span class="line">      <span class="comment">// 按名称注入</span></span><br><span class="line">      autowireByName(beanName, mbd, bw, newPvs);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// Add property values based on autowire by type if applicable.</span></span><br><span class="line">    <span class="keyword">if</span> (resolvedAutowireMode == AUTOWIRE_BY_TYPE) &#123;</span><br><span class="line">      <span class="comment">// 按类型注入</span></span><br><span class="line">      autowireByType(beanName, mbd, bw, newPvs);</span><br><span class="line">    &#125;</span><br><span class="line">    pvs = newPvs;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">boolean</span> hasInstAwareBpps = hasInstantiationAwareBeanPostProcessors();</span><br><span class="line">  <span class="keyword">boolean</span> needsDepCheck = (mbd.getDependencyCheck() != AbstractBeanDefinition.DEPENDENCY_CHECK_NONE);</span><br><span class="line"></span><br><span class="line">  PropertyDescriptor[] filteredPds = <span class="keyword">null</span>;</span><br><span class="line">  <span class="keyword">if</span> (hasInstAwareBpps) &#123;</span><br><span class="line">    <span class="keyword">if</span> (pvs == <span class="keyword">null</span>) &#123;</span><br><span class="line">      pvs = mbd.getPropertyValues();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 应用InstantiationAwareBeanPostProcessor.postProcessProperties和postProcessPropertyValues方法</span></span><br><span class="line">    <span class="keyword">for</span> (InstantiationAwareBeanPostProcessor bp : getBeanPostProcessorCache().instantiationAware) &#123;</span><br><span class="line">      PropertyValues pvsToUse = bp.postProcessProperties(pvs, bw.getWrappedInstance(), beanName);</span><br><span class="line">      <span class="keyword">if</span> (pvsToUse == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (filteredPds == <span class="keyword">null</span>) &#123;</span><br><span class="line">          filteredPds = filterPropertyDescriptorsForDependencyCheck(bw, mbd.allowCaching);</span><br><span class="line">        &#125;</span><br><span class="line">        pvsToUse = bp.postProcessPropertyValues(pvs, filteredPds, bw.getWrappedInstance(), beanName);</span><br><span class="line">        <span class="keyword">if</span> (pvsToUse == <span class="keyword">null</span>) &#123;</span><br><span class="line">          <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">      pvs = pvsToUse;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> (needsDepCheck) &#123;</span><br><span class="line">    <span class="keyword">if</span> (filteredPds == <span class="keyword">null</span>) &#123;</span><br><span class="line">      filteredPds = filterPropertyDescriptorsForDependencyCheck(bw, mbd.allowCaching);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 依赖检查：检查是否所有需要的属性都已被设置</span></span><br><span class="line">    checkDependencies(beanName, mbd, filteredPds, pvs);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> (pvs != <span class="keyword">null</span>) &#123;</span><br><span class="line">    <span class="comment">// 真正地去应用这些属性</span></span><br><span class="line">    applyPropertyValues(beanName, mbd, bw, pvs);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 按照名称注入，就是从容器中找出指定名称的bean，然后加到暂存的属性集中，以便后面使用</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">autowireByName</span><span class="params">(String beanName, AbstractBeanDefinition mbd, BeanWrapper bw, MutablePropertyValues pvs)</span> </span>&#123;</span><br><span class="line">  String[] propertyNames = unsatisfiedNonSimpleProperties(mbd, bw);</span><br><span class="line">  <span class="keyword">for</span> (String propertyName : propertyNames) &#123;</span><br><span class="line">    <span class="keyword">if</span> (containsBean(propertyName)) &#123;</span><br><span class="line">      <span class="comment">// 获取指定名称的Bean</span></span><br><span class="line">      Object bean = getBean(propertyName);</span><br><span class="line">      pvs.add(propertyName, bean);</span><br><span class="line">      <span class="comment">// 注册Bean依赖缓存</span></span><br><span class="line">      registerDependentBean(propertyName, beanName);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 按类型注入，稍微复杂一点，大致就是从容器找出符合类型的所有bean，再按照一定规则得到确切的那个</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">autowireByType</span><span class="params">(String beanName, AbstractBeanDefinition mbd, BeanWrapper bw, MutablePropertyValues pvs)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  TypeConverter converter = getCustomTypeConverter();</span><br><span class="line">  <span class="keyword">if</span> (converter == <span class="keyword">null</span>) &#123;</span><br><span class="line">    converter = bw;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  Set&lt;String&gt; autowiredBeanNames = <span class="keyword">new</span> LinkedHashSet&lt;&gt;(<span class="number">4</span>);</span><br><span class="line">  String[] propertyNames = unsatisfiedNonSimpleProperties(mbd, bw);</span><br><span class="line">  <span class="keyword">for</span> (String propertyName : propertyNames) &#123;</span><br><span class="line">    PropertyDescriptor pd = bw.getPropertyDescriptor(propertyName);</span><br><span class="line">    <span class="comment">// Don&#x27;t try autowiring by type for type Object: never makes sense,</span></span><br><span class="line">    <span class="comment">// even if it technically is a unsatisfied, non-simple property.</span></span><br><span class="line">    <span class="keyword">if</span> (Object.class != pd.getPropertyType()) &#123;</span><br><span class="line">      <span class="comment">// 获取属性的set方法</span></span><br><span class="line">      MethodParameter methodParam = BeanUtils.getWriteMethodParameter(pd);</span><br><span class="line">      <span class="comment">// Do not allow eager init for type matching in case of a prioritized post-processor.</span></span><br><span class="line">      <span class="keyword">boolean</span> eager = !(bw.getWrappedInstance() <span class="keyword">instanceof</span> PriorityOrdered);</span><br><span class="line">      DependencyDescriptor desc = <span class="keyword">new</span> AutowireByTypeDependencyDescriptor(methodParam, eager);</span><br><span class="line">      Object autowiredArgument = resolveDependency(desc, beanName, autowiredBeanNames, converter);</span><br><span class="line">      <span class="keyword">if</span> (autowiredArgument != <span class="keyword">null</span>) &#123;</span><br><span class="line">        pvs.add(propertyName, autowiredArgument);</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">for</span> (String autowiredBeanName : autowiredBeanNames) &#123;</span><br><span class="line">        <span class="comment">// 注册Bean依赖缓存</span></span><br><span class="line">        registerDependentBean(autowiredBeanName, beanName);</span><br><span class="line">      &#125;</span><br><span class="line">      autowiredBeanNames.clear();</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="实例初始化的操作"><a href="#实例初始化的操作" class="headerlink" title="实例初始化的操作"></a>实例初始化的操作</h4><p>对初始化的逻辑有</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 初始化Bean</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> Object <span class="title">initializeBean</span><span class="params">(String beanName, Object bean, <span class="meta">@Nullable</span> RootBeanDefinition mbd)</span> </span>&#123;</span><br><span class="line">  <span class="comment">// 调用xxxAware，注入对应内容，这里管的有：BeanNameAware、BeanClassLoaderAware、BeanFactoryAware三个</span></span><br><span class="line">  invokeAwareMethods(beanName, bean);</span><br><span class="line">  Object wrappedBean = bean;</span><br><span class="line">  <span class="keyword">if</span> (mbd == <span class="keyword">null</span> || !mbd.isSynthetic()) &#123;</span><br><span class="line">    <span class="comment">// 应用所有的BeanPostProcessor.postProcessBeforeInitialization方法</span></span><br><span class="line">    wrappedBean = applyBeanPostProcessorsBeforeInitialization(wrappedBean, beanName);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 调用初始化方法，这里管的有：InitializingBean.afterPropertiesSet、自定义的init方法</span></span><br><span class="line">  invokeInitMethods(beanName, wrappedBean, mbd);</span><br><span class="line">  <span class="keyword">if</span> (mbd == <span class="keyword">null</span> || !mbd.isSynthetic()) &#123;</span><br><span class="line">    <span class="comment">// 应用所有BeanPostProcessor.postProcessAfterInitialization方法</span></span><br><span class="line">    wrappedBean = applyBeanPostProcessorsAfterInitialization(wrappedBean, beanName);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> wrappedBean;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>实例化包含内容<ul>
<li><code>BeanxxxAware</code>接口的调用</li>
<li><code>BeanPostProcessor.postProcessBeforeInitialization</code>的调用</li>
<li><code>InitializingBean.afterPropertiesSet</code>的调用</li>
<li>自定义初始化方法的调用</li>
<li><code>BeanPostProcessor.postProcessAfterInitialization</code>的调用</li>
</ul>
</li>
</ul>
<h4 id="根据依赖类型得到依赖实例的操作"><a href="#根据依赖类型得到依赖实例的操作" class="headerlink" title="根据依赖类型得到依赖实例的操作"></a>根据依赖类型得到依赖实例的操作</h4><p>在执行自动注入逻辑时，有用到如下方法，我们一起来看看它干了什么：<code>org.springframework.beans.factory.config.AutowireCapableBeanFactory#resolveDependency(org.springframework.beans.factory.config.DependencyDescriptor, java.lang.String, java.util.Set&lt;java.lang.String&gt;, org.springframework.beans.TypeConverter)</code></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">javaxInjectProviderClass = ClassUtils.forName(<span class="string">&quot;javax.inject.Provider&quot;</span>, DefaultListableBeanFactory.class.getClassLoader());</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 在当前容器下，解析指定的依赖所对应的Bean</span></span><br><span class="line"><span class="comment"> * desciptor: 依赖描述类，该依赖可以是字段、方法、构造器依赖，该描述类包含了这些参数信息</span></span><br><span class="line"><span class="comment"> * requestingBeanName: 声明该依赖的bean名称</span></span><br><span class="line"><span class="comment"> * autowiredBeanNames: 一个放结果的地方，用来存找到的依赖的bean名称</span></span><br><span class="line"><span class="comment"> * typeConverter: 需要用到的类型转换器</span></span><br><span class="line"><span class="comment"> * 返回值：返回依赖的Bean</span></span><br><span class="line"><span class="comment"> **/</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> Object <span class="title">resolveDependency</span><span class="params">(DependencyDescriptor descriptor, <span class="meta">@Nullable</span> String requestingBeanName, <span class="meta">@Nullable</span> Set&lt;String&gt; autowiredBeanNames, <span class="meta">@Nullable</span> TypeConverter typeConverter)</span> <span class="keyword">throws</span> BeansException </span>&#123;</span><br><span class="line">  <span class="comment">// 初始化参数名搜索器</span></span><br><span class="line">  descriptor.initParameterNameDiscovery(getParameterNameDiscoverer());</span><br><span class="line">  <span class="keyword">if</span> (Optional.class == descriptor.getDependencyType()) &#123;</span><br><span class="line">    <span class="comment">// 如果依赖的类型是Optional的，则按照对应逻辑创建</span></span><br><span class="line">    <span class="keyword">return</span> createOptionalDependency(descriptor, requestingBeanName);</span><br><span class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span> (ObjectFactory.class == descriptor.getDependencyType() || ObjectProvider.class == descriptor.getDependencyType()) &#123;</span><br><span class="line">    <span class="comment">// 如果依赖的类型是工厂或Provider（也是工厂的一种），则返回DependencyObjectProvider</span></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> DependencyObjectProvider(descriptor, requestingBeanName);</span><br><span class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span> (javaxInjectProviderClass == descriptor.getDependencyType()) &#123;</span><br><span class="line">    <span class="comment">// 如果依赖的类型是javax.inject.Provider，则按照JSR330解析</span></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> Jsr330Factory().createDependencyProvider(descriptor, requestingBeanName);</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="comment">// 如果支持延迟创建，则解析结果是一个代理</span></span><br><span class="line">    Object result = getAutowireCandidateResolver().getLazyResolutionProxyIfNecessary(descriptor, requestingBeanName);</span><br><span class="line">    <span class="keyword">if</span> (result == <span class="keyword">null</span>) &#123;</span><br><span class="line">      <span class="comment">// 这才是真正的创建</span></span><br><span class="line">      result = doResolveDependency(descriptor, requestingBeanName, autowiredBeanNames, typeConverter);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> Object <span class="title">doResolveDependency</span><span class="params">(DependencyDescriptor descriptor, <span class="meta">@Nullable</span> String beanName, <span class="meta">@Nullable</span> Set&lt;String&gt; autowiredBeanNames, <span class="meta">@Nullable</span> TypeConverter typeConverter)</span> <span class="keyword">throws</span> BeansException </span>&#123;</span><br><span class="line">  <span class="comment">// 获取该依赖的类型</span></span><br><span class="line">  Class&lt;?&gt; type = descriptor.getDependencyType();</span><br><span class="line">  <span class="comment">// 获取用户设置注入时显式指定的值，比如@Qualifier中的值，这里的suggest是用户建议的意思，并非自动推算出来的</span></span><br><span class="line">  Object value = getAutowireCandidateResolver().getSuggestedValue(descriptor);</span><br><span class="line">  <span class="keyword">if</span> (value != <span class="keyword">null</span>) &#123;</span><br><span class="line">    <span class="comment">// 如果建议值为字符串，则解析该字符串，并从容器中获取解析后对应的name的容器</span></span><br><span class="line">    <span class="keyword">if</span> (value <span class="keyword">instanceof</span> String) &#123;</span><br><span class="line">      <span class="comment">// 解析字符串，这意味着该字符串可以是SPEL表达式</span></span><br><span class="line">      String strVal = resolveEmbeddedValue((String) value);</span><br><span class="line">      BeanDefinition bd = (beanName != <span class="keyword">null</span> &amp;&amp; containsBean(beanName) ? getMergedBeanDefinition(beanName) : <span class="keyword">null</span>);</span><br><span class="line">      <span class="comment">// 获取最终值，这里的BeanDefinition传进去只是为了获取scope值</span></span><br><span class="line">      value = evaluateBeanDefinitionString(strVal, bd);</span><br><span class="line">    &#125;</span><br><span class="line">    TypeConverter converter = (typeConverter != <span class="keyword">null</span> ? typeConverter : getTypeConverter());</span><br><span class="line">    <span class="comment">// 类型转换</span></span><br><span class="line">    <span class="keyword">return</span> converter.convertIfNecessary(value, type, descriptor.getTypeDescriptor());</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 尝试将Bean当做集合类型取解析</span></span><br><span class="line">  Object multipleBeans = resolveMultipleBeans(descriptor, beanName, autowiredBeanNames, typeConverter);</span><br><span class="line">  <span class="keyword">if</span> (multipleBeans != <span class="keyword">null</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> multipleBeans;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 从整个容器中获取符合要求的bean</span></span><br><span class="line">  Map&lt;String, Object&gt; matchingBeans = findAutowireCandidates(beanName, type, descriptor);</span><br><span class="line">  <span class="keyword">if</span> (matchingBeans.isEmpty()) &#123;</span><br><span class="line">    <span class="keyword">if</span> (isRequired(descriptor)) &#123;</span><br><span class="line">      raiseNoMatchingBeanFound(type, descriptor.getResolvableType(), descriptor);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 还是找不到，就是null</span></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  String autowiredBeanName;</span><br><span class="line">  Object instanceCandidate;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 如果匹配到的bean个数大于1，则需要做一个挑选</span></span><br><span class="line">  <span class="keyword">if</span> (matchingBeans.size() &gt; <span class="number">1</span>) &#123;</span><br><span class="line">    <span class="comment">// 首先根据Primary进行挑选，然后根据Priority进行排序挑选，最后根据找到的name和依赖的name是否一致进行挑选</span></span><br><span class="line">    autowiredBeanName = determineAutowireCandidate(matchingBeans, descriptor);</span><br><span class="line">    <span class="comment">// 当没有Primary，又没有实现Priority，名字又不匹配时，就可能找不到</span></span><br><span class="line">    <span class="keyword">if</span> (autowiredBeanName == <span class="keyword">null</span>) &#123;</span><br><span class="line">      <span class="keyword">if</span> (isRequired(descriptor) || !indicatesMultipleBeans(type)) &#123;</span><br><span class="line">        <span class="comment">// 有可能描述符有自己定义的应办法</span></span><br><span class="line">        <span class="keyword">return</span> descriptor.resolveNotUnique(descriptor.getResolvableType(), matchingBeans);</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// In case of an optional Collection/Map, silently ignore a non-unique case:</span></span><br><span class="line">        <span class="comment">// possibly it was meant to be an empty collection of multiple regular beans</span></span><br><span class="line">        <span class="comment">// (before 4.3 in particular when we didn&#x27;t even look for collection beans).</span></span><br><span class="line">        <span class="comment">// 描述符都没有，那就诶null</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 这就是匹配到的那个</span></span><br><span class="line">    instanceCandidate = matchingBeans.get(autowiredBeanName);</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="comment">// We have exactly one match.</span></span><br><span class="line">    <span class="comment">// 刚好有一个匹配时，一切都很美好</span></span><br><span class="line">    Map.Entry&lt;String, Object&gt; entry = matchingBeans.entrySet().iterator().next();</span><br><span class="line">    autowiredBeanName = entry.getKey();</span><br><span class="line">    instanceCandidate = entry.getValue();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (autowiredBeanNames != <span class="keyword">null</span>) &#123;</span><br><span class="line">    <span class="comment">// 将找到的bean name放到接收集合中</span></span><br><span class="line">    autowiredBeanNames.add(autowiredBeanName);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> (instanceCandidate <span class="keyword">instanceof</span> Class) &#123;</span><br><span class="line">    <span class="comment">// 解析得到最终的实例</span></span><br><span class="line">    instanceCandidate = descriptor.resolveCandidate(autowiredBeanName, type, <span class="keyword">this</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  Object result = instanceCandidate;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">protected</span> Map&lt;String, Object&gt; <span class="title">findAutowireCandidates</span><span class="params">(<span class="meta">@Nullable</span> String beanName, Class&lt;?&gt; requiredType, DependencyDescriptor descriptor)</span> </span>&#123;</span><br><span class="line">  <span class="comment">// 获取当前容器和所有父容器中指定类型的所有bean名字，作为候选</span></span><br><span class="line">  String[] candidateNames = BeanFactoryUtils.beanNamesForTypeIncludingAncestors(<span class="keyword">this</span>, requiredType, <span class="keyword">true</span>, descriptor.isEager());</span><br><span class="line">  Map&lt;String, Object&gt; result = CollectionUtils.newLinkedHashMap(candidateNames.length);</span><br><span class="line">  <span class="keyword">for</span> (Map.Entry&lt;Class&lt;?&gt;, Object&gt; classObjectEntry : <span class="keyword">this</span>.resolvableDependencies.entrySet()) &#123;</span><br><span class="line">    Class&lt;?&gt; autowiringType = classObjectEntry.getKey();</span><br><span class="line">    <span class="keyword">if</span> (autowiringType.isAssignableFrom(requiredType)) &#123;</span><br><span class="line">      Object autowiringValue = classObjectEntry.getValue();</span><br><span class="line">      autowiringValue = AutowireUtils.resolveAutowiringValue(autowiringValue, requiredType);</span><br><span class="line">      <span class="keyword">if</span> (requiredType.isInstance(autowiringValue)) &#123;</span><br><span class="line">        result.put(ObjectUtils.identityToString(autowiringValue), autowiringValue);</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">for</span> (String candidate : candidateNames) &#123;</span><br><span class="line">    <span class="comment">// 如果这些候选bean开启了自动注入开关</span></span><br><span class="line">    <span class="keyword">if</span> (!isSelfReference(beanName, candidate) &amp;&amp; isAutowireCandidate(candidate, descriptor)) &#123;</span><br><span class="line">      <span class="comment">// 加入候选</span></span><br><span class="line">      addCandidateEntry(result, candidate, descriptor, requiredType);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  ... ...</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">addCandidateEntry</span><span class="params">(Map&lt;String, Object&gt; candidates, String candidateName, DependencyDescriptor descriptor, Class&lt;?&gt; requiredType)</span> </span>&#123;</span><br><span class="line">  <span class="comment">// 下面就是不同类型的描述符的不同解析方式，这里不深究。</span></span><br><span class="line">  <span class="keyword">if</span> (descriptor <span class="keyword">instanceof</span> MultiElementDescriptor) &#123;</span><br><span class="line">    Object beanInstance = descriptor.resolveCandidate(candidateName, requiredType, <span class="keyword">this</span>);</span><br><span class="line">    <span class="keyword">if</span> (!(beanInstance <span class="keyword">instanceof</span> NullBean)) &#123;</span><br><span class="line">      candidates.put(candidateName, beanInstance);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span> (containsSingleton(candidateName) || (descriptor <span class="keyword">instanceof</span> StreamDependencyDescriptor &amp;&amp; ((StreamDependencyDescriptor) descriptor).isOrdered())) &#123;</span><br><span class="line">    Object beanInstance = descriptor.resolveCandidate(candidateName, requiredType, <span class="keyword">this</span>);</span><br><span class="line">    candidates.put(candidateName, (beanInstance <span class="keyword">instanceof</span> NullBean ? <span class="keyword">null</span> : beanInstance));</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    candidates.put(candidateName, getType(candidateName));</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="小结-2"><a href="#小结-2" class="headerlink" title="小结"></a>小结</h3><p>Bean的创建，可说是重中之重，因为它关系到Spring的生命周期，这是面试中超高频率被问到的问题。有了上面的分析，我们可以自己总结一波创建过程会经过哪些关键过程，这其实有两种case</p>
<p><strong>case1</strong></p>
<ol>
<li>首先执行<code>InstantiationAwareBeanPostProcessor.postProcessBeforeInstantiation()</code>提供一个创建代理的机会，如果代理创建成功</li>
<li>执行所有的<code>BeanPostProcessor.postProcessAfterInitialization()</code>方法</li>
<li>对于预加载的单例Bean，还会调用<code>SmartInitializingSingleton.afterSingletonsInstantiated()</code></li>
<li>结束</li>
</ol>
<p><strong>case2</strong></p>
<ol>
<li>实例化Bean<ol>
<li>尝试使用指定的工厂方法创建</li>
<li>尝试使用构造方法创建，如果使用有参构造方法，构造方法的参数会被自动注入</li>
</ol>
</li>
<li>应用<code>InstantiationAwareBeanPostProcessor.postProcessAfterInstantiation()</code></li>
<li>对需要的属性进行自动注入，按名称或类型从容器中寻找符合要求的Bean，注入</li>
<li>调用<code>BeanNameAware、BeanClassLoaderAware、BeanFactoryAware</code></li>
<li>应用<code>BeanPostProcessor.postProcessBeforeInitialization()</code></li>
<li>应用<code>InitializingBean.afterPropertiesSet()</code></li>
<li>应用自定义init方法</li>
<li>应用<code>BeanPostProcessor.postProcessAfterInitialization</code></li>
<li>对于预加载的单例Bean，还会调用<code>SmartInitializingSingleton.afterSingletonsInstantiated()</code></li>
<li>结束</li>
</ol>
<p>注意这里讨论的是Spring中Bean的生命周期，而不是Spring的生命周期，如果是后者，请翻看第一篇文章分析。</p>
<h2 id="如何销毁Bean"><a href="#如何销毁Bean" class="headerlink" title="如何销毁Bean"></a>如何销毁Bean</h2><p>JVM中的对象，通过可达性分析，垃圾回收机制，进行回收；Spring中的Bean对象，总是被容器持有，岂不是永远不可能被垃圾回收？这个想法是正确的，这种设计也是合理的。但要注意到有一个前提：<code>Scope</code>，正因为有它的存在，Bean的生命周期管理才变得方便。</p>
<ul>
<li>对于<code>Scope</code>为单例的Bean，容器全局唯一，被容器引用，当然不会也不能被销毁</li>
<li>对于<code>Scope</code>为原型的Bean，创建完成后容器内部并没有引用，交给应用程序，这和普通new出来的对象一致，是能够被回收的</li>
<li>对于<code>Scope</code>为其它的Bean，则看<code>Scope</code>而定，<code>Scope</code>销毁，Bean对象一并被回收，这种情况没见过；要不然就交给<code>Scope</code>自己处理了，这倒是见过，比如web里面的Request或Session范围的Scope，它是将Bean对象保存在<code>HttpServletRequest</code>或<code>HttpSession</code>中，即生命周期随请求或Session的销毁而结束。</li>
</ul>
<p>我们关注两个点：随容器一起销毁的Bean如何销毁；生命周期不跟随容器的Bean如何销毁</p>
<h3 id="被容器销毁"><a href="#被容器销毁" class="headerlink" title="被容器销毁"></a>被容器销毁</h3><p>容器的销毁方法</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">doClose</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="comment">// Check whether an actual close attempt is necessary...</span></span><br><span class="line">  <span class="keyword">if</span> (<span class="keyword">this</span>.active.get() &amp;&amp; <span class="keyword">this</span>.closed.compareAndSet(<span class="keyword">false</span>, <span class="keyword">true</span>)) &#123;</span><br><span class="line">    <span class="comment">// 发布容器关闭事件</span></span><br><span class="line">    publishEvent(<span class="keyword">new</span> ContextClosedEvent(<span class="keyword">this</span>));</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 调用生命周期处理器的关闭方法.</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">this</span>.lifecycleProcessor != <span class="keyword">null</span>) &#123;</span><br><span class="line">      <span class="keyword">this</span>.lifecycleProcessor.onClose();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 重头戏：销毁Bean</span></span><br><span class="line">    destroyBeans();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Close the state of this context itself.</span></span><br><span class="line">    <span class="comment">// 其实没干啥</span></span><br><span class="line">    closeBeanFactory();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Let subclasses do some final clean-up if they wish...</span></span><br><span class="line">    <span class="comment">// 容器的生命周期方法</span></span><br><span class="line">    onClose();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Switch to inactive.</span></span><br><span class="line">    <span class="keyword">this</span>.active.set(<span class="keyword">false</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">destroyBeans</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  getBeanFactory().destroySingletons();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">destroySingletons</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  String[] disposableBeanNames;</span><br><span class="line">  <span class="keyword">synchronized</span> (<span class="keyword">this</span>.disposableBeans) &#123;</span><br><span class="line">    disposableBeanNames = StringUtils.toStringArray(<span class="keyword">this</span>.disposableBeans.keySet());</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = disposableBeanNames.length - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line">    destroySingleton(disposableBeanNames[i]);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">destroySingleton</span><span class="params">(String beanName)</span> </span>&#123;</span><br><span class="line">  ... ... </span><br><span class="line">  destroyBean(beanName, disposableBean);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">destroyBean</span><span class="params">(String beanName, <span class="meta">@Nullable</span> DisposableBean bean)</span> </span>&#123;</span><br><span class="line">  ... ...</span><br><span class="line">  bean.destroy();</span><br><span class="line">  ... ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>可以看到，容器关闭时，只销毁了单例Bean，调用了两个有关生命周期的方法</p>
<ul>
<li><code>LifyCycle.close()</code></li>
<li><code>DisposableBean.destroy()</code></li>
</ul>
<p>但还有一种Bean的销毁回调没有被我们看到：自定义销毁方法的调用</p>
<h3 id="被JVM销毁"><a href="#被JVM销毁" class="headerlink" title="被JVM销毁"></a>被JVM销毁</h3><p>正如注解方法<code>org.springframework.context.annotation.Bean#destroyMethod</code>上的注释而言，只有生命周期被容器完全控制的Bean才能正常被容器调用各种销毁方法，也就是单例，其它<code>Scope</code>都无法保证。因此类似原型、上面说的Session之类的生命周期方法，都是不能被正常调用的，因为容器管不了他们呀。</p>
<blockquote>
<p>Note: Only invoked on beans whose lifecycle is under the full control of the factory, which is always the case for singletons but not guaranteed for any other scope.</p>
</blockquote>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>这文章写了三天你能信？？？</p>
<p>总结一下，本文从源码的角度，介绍了Spring如何描述Bean，如何在容器创建时扫描Bean，在不同的时机如何创建Bean，Bean的循环依赖的解决方式，自动注入的逻辑，不同<code>Scope</code>的Bean的销毁场景等问题。但已就算是走马观花，不过今后遇到问题时应该很快能够定位问题吧🤔。</p>
<h3 id="命名规则"><a href="#命名规则" class="headerlink" title="命名规则"></a>命名规则</h3><ul>
<li>xxxxProvider：Provider算是策略模式+抽象工厂模式的结合。所谓抽象工厂模式，意味着它封装了创建实例的过程；所谓策略模式，意味着它可以被当做策略传入其它以他为基础的类中。比如<code>ClassPathScanningCandidateComponentProvider</code>之于<code>AnnotationConfigApplicationContext</code>。</li>
</ul>
<h3 id="下一篇写什么"><a href="#下一篇写什么" class="headerlink" title="下一篇写什么"></a>下一篇写什么</h3><p>Spring源码剖析 - 强大的<code>BeanPostProcessor</code></p>
]]></content>
      <categories>
        <category>Spring</category>
      </categories>
      <tags>
        <tag>Spring</tag>
      </tags>
  </entry>
  <entry>
    <title>我可能是个调包侠</title>
    <url>/2022/08/07/invoker/</url>
    <content><![CDATA[<p>这两天用go写一点点东西，发现自己的编码速度真慢，原因还是对常用API不熟悉，文件操作、压缩解压缩、进程启动、http服务操作，貌似一点都不知道。于是只能翻手册，一点点看，突然间想到一个事情——我该不会是个调包侠吧🤔。</p>
<span id="more"></span>

<p>你看，这句话包含了多重意思</p>
<ol>
<li>该不会。。。吧，这个句型充满了惊讶，说明没有心理准备</li>
<li>看得出来我对调包侠很不屑，对自己和它练习在一起感到不快</li>
<li>之前从来没有这样想过自己，所以是”突然“</li>
</ol>
<p>既然想到了，就得认证面对这个想法。况且以后我还是会不熟练地用go，如果这种想法频繁冒出可能会影响自信心，还是得解决一下。</p>
<p>首先，什么是调包侠。凭我自己的理解，凡不自己造轮子，直接调用API的，都应当算作调包侠。这可不得了——敢情我从入行软件开始从来都是个调包侠，想到这里不仅悲从中来。好面子，不服输，我怎么能是调包侠呢？我要是，那大家不都是吗？所有做业务的人都是调包侠，你要基本的文件、网络操作，有封装好的库，你要做业务，还有Spring、GIN这些网络框架。那你说，开发人员干了啥？从头到尾，不就是在学习各种API，然后按业务组合、上线，如此循环往复。</p>
<p>”大家都是调包侠“这个结论得出后，总算松了口气，至少我不孤单。你看，我的劣根性好要命呀哈哈。</p>
<p>可是不对呀，既然大家都是，那为何网络上充满了对调包侠的嘲讽？难道他们不做业务吗？</p>
<p>我去逛了逛知乎，他们说，调包侠也分三六九等</p>
<ul>
<li>初等：基本知道API，能调通，能完成业务，但无法熟练使用</li>
<li>中等：灵活应用各种API，能够以最佳组合方式完成业务需求</li>
<li>高级：精通各种API，必要时能够自己修改</li>
</ul>
<p>又说：”鄙视的不是调包侠，而是只会调包不明就里的调包侠“。那就是，大家鄙视初等调包侠咯。</p>
<p>所以，大家鄙视的是初等调包侠。那么问题来了，我属于哪一等？很明显，在go上，我属于被鄙视的初等，真是令人沮丧呢😛。</p>
]]></content>
      <categories>
        <category>随笔</category>
      </categories>
      <tags>
        <tag>随笔</tag>
      </tags>
  </entry>
  <entry>
    <title>WebSocket啊喂</title>
    <url>/2021/09/03/WebSocket%E5%95%8A%E5%96%82-websocket-a-wei/</url>
    <content><![CDATA[<blockquote>
<p>本文主要包含三部分</p>
<ul>
<li>WebSocket协议、STOMP协议、SockJS协议三部分的理论介绍</li>
<li>使用Spring实现一个简单的消息推送服务</li>
<li>使用Postman调试STOMP服务</li>
</ul>
</blockquote>
<p>WebSocket我们大概都知道是个啥东西，原理上挺简单，使用起来却没那么容易。因为我们会发现，无论是Spring的WebSocket部分的手册，还是网络上的一大票文章，无不涉及到三个关键词——WebSocket、SockJS、STOMP。以至于我们想找一篇介绍只使用WebSocket构建服务的文章都十分困难。究其原因，我想大致有这么几个</p>
<ul>
<li>WebSocket协议在数据层面还是太底层了，需要STOMP这样的应用层协议供大家使用；而STOMP又涵盖了消息中心的大部分使用场景，因此变得很必要。</li>
<li>对前端来说，sockjs-client库很多时候是接入WebSocket的较好的方式，于是SockJS协议映入眼帘。</li>
</ul>
<span id="more"></span>

<p>所以，无论如何，这三个协议本身，我们是必须搞清楚的。</p>
<h2 id="WebSocket"><a href="#WebSocket" class="headerlink" title="WebSocket"></a>WebSocket</h2><p>十分建议详细阅读一下WebSocket的协议标准——<a href="https://www.rfc-editor.org/rfc/pdfrfc/rfc6455.txt.pdf">RFC6455</a></p>
<p>关于WebSocket需要明白的重点</p>
<ul>
<li>由HTTP升级而来</li>
<li>与HTTP共用端口，即80和443(HTTPS)</li>
<li>升级后CS之间通信与HTTP无任何关系，而是采用类似TCP的二进制帧进行的</li>
</ul>
<h3 id="WebSocket的设计哲学"><a href="#WebSocket的设计哲学" class="headerlink" title="WebSocket的设计哲学"></a>WebSocket的设计哲学</h3><ul>
<li>设计足够简单，使得能够被用来支撑其它应用，如STOMP。STOMP之于WebSocket，好比HTTP之于TCP。</li>
<li>相较于TCP，它仅仅是被赋予了web的一些特性。如：origin安全模型、类似http 的uri地址模型等</li>
<li>其它。。。就没有其它了</li>
</ul>
<h3 id="协议介绍"><a href="#协议介绍" class="headerlink" title="协议介绍"></a>协议介绍</h3><p>一个完整的WebSocket通信流程包括：握手 -&gt; 全双工通信 -&gt; 关闭连接</p>
<h4 id="握手"><a href="#握手" class="headerlink" title="握手"></a>握手</h4><p>握手是纯HTTP请求，这为WebSocket鉴权带来了方便。我们依旧可以使用之前HTTP体系下的鉴权方式。</p>
<p>客户端握手请求示例</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line">GET /chat HTTP/1.1</span><br><span class="line">Host: server.example.com</span><br><span class="line">Upgrade: websocket</span><br><span class="line">Connection: Upgrade</span><br><span class="line">Sec-WebSocket-Key: dGhlIHNhbXBsZSBub25jZQ==</span><br><span class="line">Origin: http://example.com</span><br><span class="line">Sec-WebSocket-Protocol: chat, superchat</span><br><span class="line">Sec-WebSocket-Version: 13</span><br></pre></td></tr></table></figure>

<p>服务端响应示例</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line">HTTP/1.1 101 Switching Protocols</span><br><span class="line">Upgrade: websocket</span><br><span class="line">Connection: Upgrade</span><br><span class="line">Sec-WebSocket-Accept: s3pPLMBiTxaQ9kYGzzhZRbK+xOo=</span><br><span class="line">Sec-WebSocket-Protocol: chat</span><br></pre></td></tr></table></figure>

<p>对比较陌生的请求头予以说明</p>
<table>
<thead>
<tr>
<th>请求头</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>Upgrade: websocket</td>
<td>表明协议升级的目标协议。<br />如果有注意到，从HTTP1.1升级到HTTP2.0，也是采用一样的方式</td>
</tr>
<tr>
<td>Connection: Upgrade</td>
<td>表明本次请求是协议升级</td>
</tr>
<tr>
<td>Sec-WebSocket-Key: dGhlIHNhbXBsZSBub25jZQ==</td>
<td>客户端生成的随机数的BASE64编码结果</td>
</tr>
<tr>
<td>Sec-WebSocket-Accept: s3pPLMBiTxaQ9kYGzzhZRbK+xOo=</td>
<td>服务端根据客户端给的随机数通过固定的算法计算出的结果；<br />客户端收到后会以相同的算法计算结果并对比，以证明这是一个合法的响应</td>
</tr>
<tr>
<td>Sec-WebSocket-Protocol: chat, superchat</td>
<td>子协议选择，客户端列出可选子协议，服务端选择支持的子协议<br />由于WebSocket过于底层，因此支持子协议以适应不同应用场景</td>
</tr>
<tr>
<td>Sec-WebSocket-Version: 13</td>
<td>WebSocket版本</td>
</tr>
<tr>
<td>HTTP/1.1 101 Switching Protocols</td>
<td>101表示升级成功，即握手成功</td>
</tr>
</tbody></table>
<h4 id="协议帧"><a href="#协议帧" class="headerlink" title="协议帧"></a>协议帧</h4><p>握手成功之后就是正常的通信。WebSocket通信时以帧为单位进行数据的收发，一条完整的信息可能被分为多个帧进行传输，到远端后再被拼接在一次。</p>
<p>协议帧结构如下，是不是很熟悉，有点TCP协议帧的味道。这也是说它很底层的原因。各bit的详细含义，参见RFC</p>
<p><img src="https://gdz.oss-cn-shenzhen.aliyuncs.com/halo/image-20210902223211949.png" alt="image-20210902223211949"></p>
<h4 id="协议帧类型"><a href="#协议帧类型" class="headerlink" title="协议帧类型"></a>协议帧类型</h4><p>WebSocket协议帧有两种类型：数据帧和控制帧。数据帧顾名思义，用于传输数据；我们这里重点关注数据帧</p>
<ul>
<li>Close：用于关闭连接</li>
<li>Ping：心跳发起</li>
<li>Pong：心跳响应，Ping、Pong总是成对出现</li>
</ul>
<p>注意，协议虽然定义了新跳帧，但是否使用，需要使用者决定。</p>
<h2 id="SockJS"><a href="#SockJS" class="headerlink" title="SockJS"></a>SockJS</h2><p>同样，十分建议阅读一下SockJS的协议标准——<a href="https://sockjs.github.io/sockjs-protocol/sockjs-protocol-0.3.3.html">它并非ITEF拟定的，而是一个开源项目</a></p>
<p>我们知道，早在WebSocket出现之前，从服务端向客户端推数据这个需求，就一直存在。其中最常用的尝试就有轮询、长轮询等，后面又有了EventSource之类的机制。而SockJS，就是集合了现今所有这类方式的库（包含websocket）。如今，SockJS已经成为了一个协议标准，主流语言都有了支持的库，尤其是web前端。</p>
<p>简单地说，SocketJS定义了一个服务端必须有哪些HTTP端点，以便使用不同的通信方式。定义了帧结构，用于传输数据</p>
<h3 id="端点"><a href="#端点" class="headerlink" title="端点"></a>端点</h3><p>这里列出关键的端点，省略了域名和base url</p>
<ul>
<li><p>/info：用于查询客户端支持的通信方式，如是否支持WebSocket。可以理解为通信协商</p>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line"># 这里展示一个典型地info响应</span><br><span class="line">&#123;</span><br><span class="line">  <span class="attr">&quot;entropy&quot;</span>:<span class="number">2143307232</span>,</span><br><span class="line">  <span class="attr">&quot;origins&quot;</span>:[</span><br><span class="line">    <span class="string">&quot;*:*&quot;</span></span><br><span class="line">  ],</span><br><span class="line">  <span class="attr">&quot;cookie_needed&quot;</span>:<span class="literal">true</span>,</span><br><span class="line">  <span class="attr">&quot;websocket&quot;</span>:<span class="literal">true</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>/(server_id)/(session_id)/websocket：暴露的websocket端点，用于websocket通信</p>
</li>
<li><p>/(server_id)/(session_id)/xhr，/(server_id)/(session_id)/xhr_send：暴露的长连接端点，用于ajax长连接</p>
</li>
<li><p>/(server_id)/(session_id)/eventsource：eventsource端点</p>
</li>
<li><p>/websocket：这是一个外挂，该端点直接走裸的websocket协议，这为SockJS服务端直接使用WebSocket客户端库提供了条件</p>
</li>
</ul>
<p>SockJS协议通信分为两步：访问/info询问支持的通信方式；访问对应的端点进行通信</p>
<h3 id="帧结构"><a href="#帧结构" class="headerlink" title="帧结构"></a>帧结构</h3><p>SockJS是一个协议，也有自己的帧定义，但它的帧定义足够简单，就几个字符</p>
<ul>
<li>o：通信开启帧</li>
<li>h：心跳帧，服务端下发</li>
<li>a：消息数组</li>
<li>c：通信关闭帧</li>
</ul>
<h3 id="SockJS的缺点"><a href="#SockJS的缺点" class="headerlink" title="SockJS的缺点"></a>SockJS的缺点</h3><ul>
<li>出于安全原因，在协议层面就不支持自定义请求头，我们应该能发现所有sockjs客户端库都无法添加请求头吧。<a href="https://github.com/sockjs/sockjs-client/issues/196">原因看这</a></li>
<li>与WebSocket是包含关系，而非兼容关系。如果一个服务端暴露SockJS服务，客户端是没办法直接将这个端点用在WebSocket库的，而是要通过SockJS暴露出的websocket原生端点进行访问（即base url/websocket），不大友好</li>
</ul>
<h2 id="STOMP"><a href="#STOMP" class="headerlink" title="STOMP"></a>STOMP</h2><p>再次，十分建议阅读一下STOMP的协议标准——<a href="https://stomp.github.io/stomp-specification-1.2.html">它也是一个开源项目</a></p>
<p>STOMP是一个高级的应用协议，用于异步消息传输，支持点对点发送、发布订阅等消息传递方式。它的设计哲学就是足够简单，这也体现在协议长度上，如果看过AMQP、MQTT之类的消息协议，就能体会什么叫简单。</p>
<h3 id="帧结构-1"><a href="#帧结构-1" class="headerlink" title="帧结构"></a>帧结构</h3><p>这是它的帧结构，就是纯文本帧。包含命令、头部、body三部分。最后以ascii为0的字符结尾。</p>
<ul>
<li>命令：表明帧类型</li>
<li>头部：额外的帧属性，如心跳配置、content-type等</li>
<li>body：消息体，只有消息帧时才有</li>
</ul>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line">COMMAND</span><br><span class="line">header1:value1</span><br><span class="line">header2:value2</span><br><span class="line"></span><br><span class="line">Body^@</span><br></pre></td></tr></table></figure>

<h3 id="帧类型"><a href="#帧类型" class="headerlink" title="帧类型"></a>帧类型</h3><p>帧类型也足够简单</p>
<table>
<thead>
<tr>
<th>Side</th>
<th>命令</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>客户端</td>
<td>CONNECT</td>
<td>发起连接</td>
</tr>
<tr>
<td></td>
<td>DISCONNECT</td>
<td>断开连接</td>
</tr>
<tr>
<td></td>
<td>SEND</td>
<td>发送消息</td>
</tr>
<tr>
<td></td>
<td>SUBSCRIBE</td>
<td>订阅</td>
</tr>
<tr>
<td></td>
<td>UNSUBSCRIBE</td>
<td>取消订阅</td>
</tr>
<tr>
<td></td>
<td>ACK/NACK</td>
<td>响应</td>
</tr>
<tr>
<td></td>
<td>BEGIN/COMMIT/ABORT</td>
<td>事务相关</td>
</tr>
<tr>
<td>服务端</td>
<td>CONNECTED</td>
<td>连接成功</td>
</tr>
<tr>
<td></td>
<td>MESSAGE</td>
<td>发送订阅的消息给客户端</td>
</tr>
<tr>
<td></td>
<td>RECEIPT</td>
<td>凭据，如果客户端需要的话</td>
</tr>
<tr>
<td></td>
<td>ERROR</td>
<td>错误通报</td>
</tr>
</tbody></table>
<h2 id="所以这三个协议的关系？"><a href="#所以这三个协议的关系？" class="headerlink" title="所以这三个协议的关系？"></a>所以这三个协议的关系？</h2><p>WebSocket、SockJS、STOMP三者，从前往后，层级依次上升，就像洋葱，WebSocket在里面，SockJS其次，STOMP在最外面。如果我们使用建立在SockJS协议上的STOMP服务，而SockJS又选择WebSocket作为底层的通信协议。在通信过程中，STOMP帧会被组装成SockJS的帧；SockJS的帧会被组装成WebSocket的帧；再深一点，WebSocket的帧会被组装成TCP的帧；TCP的帧被组装成IP层的帧，然后传输；到远端后执行相反操作。</p>
<p>从分类上说，WebSocket和SockJS都只是通用的数据传输协议；而STOMP是一种消息协议，抽象层级更高。</p>
<h2 id="心跳"><a href="#心跳" class="headerlink" title="心跳"></a>心跳</h2><p>三个协议都定义了心跳，其中</p>
<ul>
<li>WebSocket只定义了心跳帧，但发送的时机与策略，由具体实现来定。目前来看，默认情况下WebSocket库是不会自动发送心跳的，需调用者手动发送</li>
<li>SockJS规定服务端必须发送心跳，默认25秒一次，可配，不需要调用者手动开启</li>
<li>STOMP也定义了心跳，默认不开启，一般实现库都有提供，只需手动配置开启即可。需要说明的是，开启了STOMP的心跳，会关闭掉SockJS的心跳。</li>
</ul>
<h2 id="Spring实现一个消息推送服务"><a href="#Spring实现一个消息推送服务" class="headerlink" title="Spring实现一个消息推送服务"></a>Spring实现一个消息推送服务</h2><p>Spring对WebSocket的支持看<a href="https://docs.spring.io/spring-framework/docs/4.3.x/spring-framework-reference/html/websocket.html">这里</a>。</p>
<p>我们实现一个简单的需求</p>
<ul>
<li>暴露STOMP端点</li>
<li>提供主题，供用户订阅，支持对单个用户广播。即，需要鉴权</li>
<li>提供一个STOMP地址，用户向该地址发送数据时，从其订阅的主体下发消息</li>
</ul>
<h3 id="配置"><a href="#配置" class="headerlink" title="配置"></a>配置</h3><p>配置类如下，这不是一个完全可用的类，直接复制很可能无法正常运行。</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 配置类</span></span><br><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="meta">@EnableWebSocketMessageBroker</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">WebSocketConfig</span> : <span class="type">WebSocketMessageBrokerConfigurer &#123;</span></span></span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">lateinit</span> <span class="keyword">var</span> objectMapper: ObjectMapper</span><br><span class="line"></span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">registerStompEndpoints</span><span class="params">(registry: <span class="type">StompEndpointRegistry</span>)</span></span> &#123;</span><br><span class="line">      	<span class="comment">// 暴露STOMP端点</span></span><br><span class="line">        registry.addEndpoint(<span class="string">&quot;/stomp&quot;</span>)</span><br><span class="line">      			<span class="comment">// 添加握手拦截器，用于做权限验证</span></span><br><span class="line">            .addInterceptors(AuthHandshakeInterceptor(objectMapper))</span><br><span class="line">      			<span class="comment">// 握手处理器</span></span><br><span class="line">            .setHandshakeHandler(AuthHandshakeHandler())</span><br><span class="line">            .setAllowedOriginPatterns(<span class="string">&quot;*&quot;</span>)</span><br><span class="line">            .withSockJS()</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">configureMessageBroker</span><span class="params">(registry: <span class="type">MessageBrokerRegistry</span>)</span></span> &#123;</span><br><span class="line">        <span class="comment">// 用于发送心跳的调度器，一定要有。其它层级协议的心跳不能替代STOMP层级的心跳</span></span><br><span class="line">        <span class="keyword">val</span> scheduler = TaskSchedulerBuilder().build().apply &#123; initialize() &#125;</span><br><span class="line">        registry.enableSimpleBroker(<span class="string">&quot;/topic&quot;</span>).setTaskScheduler(scheduler)</span><br><span class="line">        registry.setApplicationDestinationPrefixes(<span class="string">&quot;/app&quot;</span>)</span><br><span class="line">        <span class="comment">// 订阅/user/打头的destination时，STOMP可自动将每个用户对应一个主题，实现向指定用户发送消息的能力</span></span><br><span class="line">        registry.setUserDestinationPrefix(<span class="string">&quot;/user/&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="class"><span class="keyword">class</span> <span class="title">AuthHandshakeInterceptor</span></span>(<span class="keyword">val</span> objectMapper: ObjectMapper) : HandshakeInterceptor &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">beforeHandshake</span><span class="params">(request: <span class="type">ServerHttpRequest</span>, response: <span class="type">ServerHttpResponse</span>, wsHandler: <span class="type">WebSocketHandler</span>, attributes: <span class="type">MutableMap</span>&lt;<span class="type">String</span>, Any&gt;)</span></span>: <span class="built_in">Boolean</span> &#123;</span><br><span class="line">      	<span class="comment">// 从request的header或query中提取用户，具体逻辑自己实现</span></span><br><span class="line">        <span class="keyword">val</span> user = request.parseUser(objectMapper)</span><br><span class="line">        <span class="keyword">if</span> (user == <span class="literal">null</span>) &#123;</span><br><span class="line">          	<span class="comment">// </span></span><br><span class="line">            <span class="keyword">val</span> error = ResErrCode.NEED_AUTHORIZE</span><br><span class="line">            response.setStatusCode(error.httpStatus)</span><br><span class="line">            response.headers.contentType = MediaType.APPLICATION_JSON</span><br><span class="line">            response.body.write(objectMapper.writeValueAsBytes(R.fail(error)))</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">        &#125;</span><br><span class="line">        attributes[<span class="string">&quot;user&quot;</span>] = user</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">afterHandshake</span><span class="params">(request: <span class="type">ServerHttpRequest</span>, response: <span class="type">ServerHttpResponse</span>, wsHandler: <span class="type">WebSocketHandler</span>, exception: <span class="type">Exception</span>?)</span></span> &#123;</span><br><span class="line">			<span class="comment">// 这里啥也没做</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="class"><span class="keyword">class</span> <span class="title">AuthHandshakeHandler</span> : <span class="type">DefaultHandshakeHandler</span></span>() &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">determineUser</span><span class="params">(request: <span class="type">ServerHttpRequest</span>, wsHandler: <span class="type">WebSocketHandler</span>, attributes: <span class="type">MutableMap</span>&lt;<span class="type">String</span>, Any&gt;)</span></span>: Principal? &#123;</span><br><span class="line">        <span class="keyword">return</span> attributes[<span class="string">&quot;user&quot;</span>] <span class="keyword">as</span> Principal?</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h3><ul>
<li><p>暴露接收用户信息的地址。</p>
<p>这里的关键在于MessageMapping和SendToUser两个注解的使用，它们能够直接在Controller中使用。</p>
<p>前者将用户发送的消息导入；后者将方法返回的内容发送给对应的用户。</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Controller</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">WebSocketController</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 手动触发拉取通知，随便发个啥，都会触发一次拉取通知</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@MessageMapping(<span class="meta-string">&quot;/triggerPullNotification&quot;</span>)</span></span><br><span class="line">    <span class="meta">@SendToUser(destinations = [<span class="meta-string">&quot;topic/pullNotification&quot;</span>])</span></span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">echo</span><span class="params">(income: <span class="type">String</span>, principal: <span class="type">Principal</span>)</span></span>: Any &#123;</span><br><span class="line">        log.info(<span class="string">&quot;trigger pull notification manually: user &#123;&#125;; message: &#123;&#125;&quot;</span>, principal.name, income)</span><br><span class="line">        <span class="keyword">return</span> STOMP_USER_PULL_NOTIFICATION_PAYLOAD</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上面的例子，STOMP客户端向/app/triggerPullNotification发送消息时，会进入echo方法，发送的内容被传递到income参数中，发送消息的用户被传递到principal参数中。echo返回的对象会被发送给订阅了/user/topic/pullNotification主题的当前session的用户，即触发这个消息的用户。</p>
</li>
<li><p>在其他地方向指定用户发送消息</p>
<p>这里的关键是注入SimpMessagingTemplate</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ExampleService</span></span>(<span class="keyword">val</span> stomp: SimpMessagingTemplate) &#123;</span><br><span class="line">  </span><br><span class="line">  <span class="function"><span class="keyword">fun</span> <span class="title">test</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="comment">// 这里是你的自由逻辑</span></span><br><span class="line">    ...</span><br><span class="line">    <span class="comment">// 发送给某个用户</span></span><br><span class="line">    stomp.convertAndSendToUser(<span class="number">12345</span>, <span class="string">&quot;/topic/pullNotification&quot;</span>, <span class="string">&quot;your payload&quot;</span>)</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="测试连接"><a href="#测试连接" class="headerlink" title="测试连接"></a>测试连接</h3><p>JS测试脚本</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 连接并订阅</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">connect</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">const</span> socket = <span class="keyword">new</span> SockJS(<span class="string">&#x27;https://apitest.wemore.com/mylogs/stomp?X-5E-TOKEN=qhMtjBjVozY3zYLrOfMStgvffeFjBofY&#x27;</span>);</span><br><span class="line">    stompClient = Stomp.over(socket);</span><br><span class="line">    stompClient.connect(&#123;</span><br><span class="line">    &#125;, <span class="function"><span class="keyword">function</span> (<span class="params">frame</span>) </span>&#123;</span><br><span class="line">        setConnected(<span class="literal">true</span>);</span><br><span class="line">        stompClient.subscribe(<span class="string">&#x27;/user/topic/pullNotification&#x27;</span>, <span class="function"><span class="keyword">function</span> (<span class="params">data</span>) </span>&#123;</span><br><span class="line">            <span class="comment">// console.log(&#x27;received: &#x27; + data);</span></span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 发送消息给服务端</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">trigger</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    stompClient.send(<span class="string">&quot;/app/triggerPullNotification&quot;</span>, &#123;&#125;, <span class="built_in">JSON</span>.stringify(&#123;<span class="string">&#x27;name&#x27;</span>: <span class="string">&#x27;啥呀&#x27;</span>&#125;));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>使用Chrome进行测试，在点击连接时，我们能看到先通过info询问，再调用websocket</p>
<p><img src="https://gdz.oss-cn-shenzhen.aliyuncs.com/halo/image-20210903174636617.png" alt="image-20210903174636617"></p>
<p>info的响应</p>
<p><img src="https://gdz.oss-cn-shenzhen.aliyuncs.com/halo/image-20210903174721948.png" alt="image-20210903174721948"></p>
<p>websocket的消息流：可以看到就是SockJS帧套STOMP帧。</p>
<p><img src="https://gdz.oss-cn-shenzhen.aliyuncs.com/halo/image-20210903174749633.png" alt="image-20210903174749633"></p>
<p>其中的[“\n”]和a[“\n”]是STOMP的心跳，我们把视线转移到console看得更为直观，它详细地展示了STOMP的通信过程</p>
<p><img src="https://gdz.oss-cn-shenzhen.aliyuncs.com/halo/image-20210903174948448.png" alt="image-20210903174948448"></p>
<p>此时如果我们再触发一次消息，可以观察到消息的发出和接收</p>
<p><img src="https://gdz.oss-cn-shenzhen.aliyuncs.com/halo/image-20210903175110240.png" alt="image-20210903175110240"></p>
<h3 id="强调几点"><a href="#强调几点" class="headerlink" title="强调几点"></a>强调几点</h3><ol>
<li><p><code>HandShakeIntercepter</code>和<code>HandShakeHandler</code>的区别</p>
<ul>
<li><p><code>HandShakeIntercepter</code>前者能够拦截握手的请求，并且可操作直接对握手请求进行响应</p>
</li>
<li><p><code>HandShakeHandler</code>用于处理握手成功后的细节问题，尤其是允许我们自己设置当前session的用户</p>
</li>
<li><p>我们在<code>HandShakeIntercepter</code>进行鉴权；在<code>HandShakeHandler</code>将鉴权得来的用户设置为当前session的用户</p>
</li>
</ul>
</li>
<li><p>心跳</p>
<p>STOMP服务端的心跳一定要配：如果客户端直接采用了WebSocket连接，没有心跳配置，连接可能随时会断</p>
</li>
<li><p>标记用户</p>
<p>这是Spring Stomp为我们提供的方便的功能。它使得我们可以方便地只发送消息给订阅某个主题的单个用户。要完成它，必须有这么几步</p>
<ul>
<li><p>注入我们的用户逻辑，可以迁入Spring Security，也可以自定义。本文中我们在<code>HandShakeHandler</code>中将自己用户体系中的user传递给了Stomp作为用户标记。记得给user实现Principal接口哦。</p>
</li>
<li><p>配置用户地址前缀。并不是每个主题都能支持这样的功能的，我们需要设置一个固定的前缀，那么订阅了这些指定前缀主题的用户，就具有了被标记的能力</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">configureMessageBroker</span><span class="params">(registry: <span class="type">MessageBrokerRegistry</span>)</span></span> &#123;</span><br><span class="line">  			... ...</span><br><span class="line">        <span class="comment">// 订阅/user/打头的destination时，STOMP可自动将每个用户对应一个主题，实现向指定用户发送消息的能力</span></span><br><span class="line">        registry.setUserDestinationPrefix(<span class="string">&quot;/user&quot;</span>)</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></li>
<li><p>使用规则</p>
<p>需要对地址<code>/topic/pullNotification</code>赋予用户标记的能力，在配置OK后，使用方法</p>
<ul>
<li>客户端订阅地址：<code>/user/topic/pullNotification</code></li>
<li>服务端向指定用户发送消息时，使用：<code>stomp.convertAndSendToUser(12345, &quot;/topic/pullNotification&quot;, &quot;your payload&quot;)</code></li>
</ul>
</li>
</ul>
</li>
</ol>
<h2 id="用Postman调试STOMP服务"><a href="#用Postman调试STOMP服务" class="headerlink" title="用Postman调试STOMP服务"></a>用Postman调试STOMP服务</h2><p>Postman提供WebSocket调试功能，但却不支持调试STOMP服务，这让人感到可惜。但是，如果我们实在想要直接用Postman访问STOMP服务的话。依在下愚见，唯一的办法就是，硬用。即，手动编辑STOMP帧，然后发送。</p>
<p>手动编辑有个问题，STOMP帧是以ASCII码表中值为0的字符结尾的，即<code>&#39;\u0000&#39;</code>，无法通过文本表达。于是只能通过二进制发送。</p>
<p>以上面的服务为例，我们要订阅一个STOMP服务，首先要连接上STOMP端点，然后发送CONNECT帧，然后是SUBSCRIBE帧，帧的二进制编码通过代码生成</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">val</span> connectMessage = <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        CONNECT</span></span><br><span class="line"><span class="string">        heart-beat:5000,5000</span></span><br><span class="line"><span class="string">        accept-version:1.2</span></span><br><span class="line"><span class="string">        host:127.0.0.1</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span>.trimIndent()</span><br><span class="line"></span><br><span class="line">    <span class="keyword">val</span> subscription = <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        SUBSCRIBE</span></span><br><span class="line"><span class="string">        id:0</span></span><br><span class="line"><span class="string">        destination:/user/topic/pullNotification</span></span><br><span class="line"><span class="string">        ack:client</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span>.trimIndent()</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">fun</span> String.<span class="title">generate</span><span class="params">()</span></span>: String &#123;</span><br><span class="line">        <span class="keyword">val</span> builder = StringBuilder()</span><br><span class="line">        builder.append(<span class="keyword">this</span>)</span><br><span class="line">        builder.append(<span class="string">&#x27;\n&#x27;</span>)</span><br><span class="line">        builder.append(<span class="string">&#x27;\n&#x27;</span>)</span><br><span class="line">        builder.append(<span class="string">&#x27;\u0000&#x27;</span>)</span><br><span class="line">        <span class="keyword">return</span> builder.toString().toByteArray().joinToString(separator = <span class="string">&quot;&quot;</span>) &#123; String.format(<span class="string">&quot;%02x&quot;</span>, it) &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    println(connectMessage.generate()) <span class="comment">// 434f4e4e4543540a6163636570742d76657273696f6e3a312e320a686f73743a3132372e302e302e310a0a00</span></span><br><span class="line">    println(subscription.generate()) <span class="comment">// 5355425343524942450a69643a300a64657374696e6174696f6e3a2f757365722f746f7069632f70756c6c4e6f74696669636174696f6e0a61636b3a636c69656e740a0a00</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上面暴露的是SockJS服务，我们有两种方式连接websocket</p>
<ul>
<li>使用SockJS暴露的原生WebSocket端点，即/websocket</li>
<li>使用SockJS协议内容的WebSocket端点，即/server_id/sessioin_id/websocket</li>
</ul>
<p>我们用第一种，然后步骤是</p>
<ol>
<li><p>输入ws端点：wss://&lt;我的域名&gt;/stomp/websocket，点击连接</p>
</li>
<li><p>以二进制格式发送连接帧，重点是选择二进制哦</p>
<p><img src="https://gdz.oss-cn-shenzhen.aliyuncs.com/halo/%E4%BC%81%E4%B8%9A%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_160e941c-6adc-4459-96bf-bbba2d15e4ad.png" alt="企业微信截图_160e941c-6adc-4459-96bf-bbba2d15e4ad"></p>
<p>出现如下响应，说明连接成功</p>
<p><img src="https://gdz.oss-cn-shenzhen.aliyuncs.com/halo/%E4%BC%81%E4%B8%9A%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_293f66bf-25ab-49c4-8312-2f8cba9da8e5.png" alt="企业微信截图_293f66bf-25ab-49c4-8312-2f8cba9da8e5"></p>
</li>
<li><p>发送订阅帧</p>
</li>
<li><p>使用刚才的脚本触发一次echo，你就可以看到我们能够正常收到消息了</p>
<p><img src="https://gdz.oss-cn-shenzhen.aliyuncs.com/halo/image-20210903181047727.png" alt="image-20210903181047727"></p>
</li>
</ol>
<h3 id="有一个问题"><a href="#有一个问题" class="headerlink" title="有一个问题"></a>有一个问题</h3><p>你会发现，通过Postman尽管连上了，但在最后一次通信的60s后，连接自动断开了！！！</p>
<p><img src="https://gdz.oss-cn-shenzhen.aliyuncs.com/halo/%E4%BC%81%E4%B8%9A%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_26269104-19a8-4c63-82dc-af94ce05534e.png" alt="企业微信截图_26269104-19a8-4c63-82dc-af94ce05534e"></p>
<p>这是因为我们没发心跳呀啊啊啊啊啊啊啊啊啊。由于我将服务部署在nginx后，我们的nginx设置为60s不活动的TCP连接都将被关闭。</p>
<p>如何解决呢，要解决，只有两个方法</p>
<ul>
<li>60s内发心跳续命</li>
<li>不停进行消息通信</li>
</ul>
<p>反正就是不停发就行了。</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>要使用WebSocket，那么SockJS和STOMP都是必须了解的，最好的了解方式是去看协议。</p>
<p>文中的示例代码，不能直接用，只能当做参考。</p>
<p>Postman调试STOMP？可以用来熟悉协议，但实际用来调试，还是算了吧。</p>
<p>本文重点：三种协议关键点介绍、Spring的STOMP用户标记功能、通过Postman学习STOMP协议帧。</p>
<h2 id="参考文档"><a href="#参考文档" class="headerlink" title="参考文档"></a>参考文档</h2><ol>
<li><a href="https://www.rfc-editor.org/rfc/pdfrfc/rfc6455.txt.pdf">RFC6455</a></li>
<li><a href="https://sockjs.github.io/sockjs-protocol/sockjs-protocol-0.3.3.html">SockJS Protocol</a></li>
<li><a href="https://stomp.github.io/stomp-specification-1.2.html">STOMP Specification</a></li>
<li><a href="https://docs.spring.io/spring-framework/docs/4.3.x/spring-framework-reference/html/websocket.html">Spring WebSocket</a></li>
</ol>
]]></content>
      <categories>
        <category>网络基础</category>
      </categories>
      <tags>
        <tag>WebSocket</tag>
      </tags>
  </entry>
  <entry>
    <title>Spring源码解析 - ApplicationContext</title>
    <url>/2021/11/16/Spring%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90-ApplicationContext/</url>
    <content><![CDATA[<h1 id="Spring源码剖析-ApplicationContext"><a href="#Spring源码剖析-ApplicationContext" class="headerlink" title="Spring源码剖析 - ApplicationContext"></a>Spring源码剖析 - ApplicationContext</h1><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>实话说，Spring虽火，但我的使用经验却不多。这和我的实际工作经历有一定关系，前几年初入软件这行，项目使用Struts1，第一次使用Spring，还是在同时期的外快项目，非常表面。换公司后直接转向Vertx技术栈，近一年多虽然又转向Spring，但手上的Spring项目并不复杂，也没抽时间好好过一遍Spring。于是，Spring成了心病，你可以说它千万好坏，但首先得掌握它，这一点我做的不好，所以是时候研究一下它。</p>
<p>Spring说简单也简单，本质上就一个依赖注入、面向切面的框架；Spring MVC也只是针对Web应用场景的抽象，会定义Controller、Servier、Repository就会用；Spring Boot就是一个快捷启动方式。说复杂也复杂，Spring太大了，人们常说Spring上手容易，精通难，没错，但有点废话，我印象中没有几门技术精通起来是容易的。</p>
<p>Spring的大，一是体现在功能的全面，同一件事提供多种处理方式，对老手是利器，对新手就抓瞎；二是体现在源码上，Spring的源码很大，抽象层次很多：比如BeanFactory有ConfiurableBeanFactory、HierarchicalBeanFactory等抽象，ApplicationContext也有很多。基础知识涉及也较多：如果要了解Spring Web的工作配置原理，首先要了解Servlet规范；要了解AOP，首先要了解JDK动态代理、CGLib的区别，最好还了解一下ASM，因为Spring读取Bean时也有用到；要了解资源国际化，你首先要了解JDK提供的ResourceBundle；三也体现在手册上，Spring的手册写得很好，但是很长，有尝试过通过读手册来学习Spring，但手册大而全，没有重点，不会讲原理，用的时候翻翻还行，深入探究就不管用了。</p>
<span id="more"></span>

<h2 id="方式方法"><a href="#方式方法" class="headerlink" title="方式方法"></a>方式方法</h2><p>先整体，再局部。明白DI的原理，先要了解Spring是如何运行起来的，我相信很多人在CRUD太久之后，甚至连Spring是如何跑起来的都忘了。</p>
<p>我们主要探究Spring容器的运行方式、主要组件；Spring Web的运行方式；Spring Boot的运行方式。其余部分，无非是基于Spring的基本机制，实现了某项成熟的技术或规范（比如Spring Web），可以分阶段研究。</p>
<p>目前来说，大致可以分为这么几个部分，本文是第一部分</p>
<ul>
<li><code>ApplicationContext</code>拆解</li>
<li>如何管理Bean、DI</li>
<li>AOP怎么做的</li>
<li>SpringBoot是怎么Boot的、AutoConfigure如何实现的</li>
</ul>
<h2 id="总览"><a href="#总览" class="headerlink" title="总览"></a>总览</h2><p>一个基本的Spring应用，可以这么写</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.gitee.floyd.springme.core</span><br><span class="line"></span><br><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Bean1</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Bean2</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">  	<span class="comment">// 创建容器，并指定扫描Bean的包名</span></span><br><span class="line">    <span class="keyword">val</span> context = AnnotationConfigApplicationContext(<span class="string">&quot;com.gitee.floyd.springme.core&quot;</span>)</span><br><span class="line">  	<span class="comment">// 通过类获取Bean</span></span><br><span class="line">    println(context.getBean(Bean1::<span class="keyword">class</span>.java))</span><br><span class="line">  	<span class="comment">// 通过name获取Bean</span></span><br><span class="line">    println(context.getBean(<span class="string">&quot;bean2&quot;</span>))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>很显然，这里的关键是<code>AnnotationConfigApplicationContext</code>，大家都知道，这是基于注解进行配置的上下文，对应的还有<code>ClasspathXmlConfigApplicationContext</code>，但它已经过时了，不在我们的讨论范围。</p>
<p><img src="https://gdz.oss-cn-shenzhen.aliyuncs.com/local/%E6%88%AA%E5%B1%8F2021-11-13%20%E4%B8%8A%E5%8D%8811.47.42.png" alt="截屏2021-11-13 上午11.47.42"></p>
<p>如上是该类的主要继承图，包含了Spring的大部分组件，我们都看一遍</p>
<ul>
<li><code>BeanFactory</code>：Bean工厂，容器的核心</li>
<li><code>Environment</code>：环境，包括环境变量，各种配置资源</li>
<li><code>ApplicationEvent</code>：容器内事件机制</li>
<li><code>ResourceLoader</code>：资源加载</li>
<li><code>MessageSource</code>：消息加载，可用于资源国际化</li>
<li><code>LifeCycle</code>：生命周期管理机制</li>
<li><code>AnnotationConfigRegistry</code>、<code>BeanDefinitionRegistry</code>：几个注册器</li>
<li>各层次的<code>ApplicationContext</code>：容器的实现逻辑</li>
</ul>
<h2 id="关键组件"><a href="#关键组件" class="headerlink" title="关键组件"></a>关键组件</h2><h3 id="BeanFactory"><a href="#BeanFactory" class="headerlink" title="BeanFactory"></a>BeanFactory</h3><p>首先看<code>BeanFactory</code>本身，其能力很简单，就是Bean的管理，主要包括如下。注意<strong>它并不包含Bean的创建</strong>哦。</p>
<ul>
<li>根据name、类名等获取Bean</li>
<li>判断Bean是否存在、是否单例、是否原型、别名</li>
<li>获取Bean的类型</li>
</ul>
<p><img src="https://gdz.oss-cn-shenzhen.aliyuncs.com/local/%E6%88%AA%E5%B1%8F2021-11-13%20%E4%B8%8B%E5%8D%884.22.07.png" alt="截屏2021-11-13 下午4.22.07"></p>
<p><code>BeanFactory</code>总共有五个直接或间接的子类</p>
<p><img src="https://gdz.oss-cn-shenzhen.aliyuncs.com/local/%E6%88%AA%E5%B1%8F2021-11-13%20%E4%B8%8B%E5%8D%884.06.56.png" alt="截屏2021-11-13 下午4.06.56"></p>
<ul>
<li><p><code>HierechicalBeanFactory</code></p>
<p>让<code>BeanFactory</code>变得有继承关系，它让容器也变得有层级关系，其创建Bean的关系类似类加载器，这样做的好处是每一层的容器只需要关注自己的Bean管理</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">HierarchicalBeanFactory</span> <span class="keyword">extends</span> <span class="title">BeanFactory</span> </span>&#123;</span><br><span class="line">  <span class="comment">// 获取父工厂</span></span><br><span class="line">	<span class="function">BeanFactory <span class="title">getParentBeanFactory</span><span class="params">()</span></span>;</span><br><span class="line">  <span class="comment">// 判断当前工厂是否包含指定name的Bean</span></span><br><span class="line">	<span class="function"><span class="keyword">boolean</span> <span class="title">containsLocalBean</span><span class="params">(String name)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p><code>ListableBeanFactory</code></p>
<p>让<code>BeanFactory</code>拥有List的能力，增加了批量获取Bean的能力，<strong>与BeanFactory相比，还多了根据注解获取Bean的能力</strong></p>
<p><img src="https://gdz.oss-cn-shenzhen.aliyuncs.com/local/%E6%88%AA%E5%B1%8F2021-11-13%20%E4%B8%8B%E5%8D%884.23.55.png" alt="截屏2021-11-13 下午4.23.55"></p>
</li>
<li><p><code>AutowireCapableBeanFactory</code></p>
<p>具有自动注入能力的<code>BeanFactory</code>，让<code>BeanFactory</code>有创建Bean、初始化Bean、注入Bean、配置Bean、对Bean应用<code>PostProcessor</code>、销毁Bean的能力，换言之，拥有了管理Bean的生命周期的能力。</p>
<p>不过需要注意的是，这个接口对于目前基于注解的容器来说，已经没有使用了，去看他的继承关系就知道，那还是远古时期的XmlBeanFactory有用，所以了解一下就好。</p>
<p><img src="https://gdz.oss-cn-shenzhen.aliyuncs.com/local/%E6%88%AA%E5%B1%8F2021-11-13%20%E4%B8%8B%E5%8D%884.38.24.png" alt="截屏2021-11-13 下午4.38.24"></p>
</li>
<li><p><code>ConfigurableBeanFactory</code></p>
<p>提供了各种配置方法，配置的项目都是<code>BeanFactory</code>在容器管理生命周期中所需的，具体来说，包括</p>
<ul>
<li><code>Bean的ClassLoader</code>，用于加载Bean</li>
<li>设置是否存储元信息</li>
<li>设置<code>BeanExpressionResolver</code></li>
<li>设置<code>ConversionService</code></li>
<li>添加<code>PropertyEditorRegistrar</code></li>
<li>注册对某个类型的<code>PropertyEditor</code></li>
<li>设置<code>TypeConverter</code></li>
<li>添加<code>StringValueResolver</code>，用于解析内嵌的字符串值</li>
<li><code>resolveEmbeddedValue</code>，用上面的解析器解析内嵌的值</li>
<li>添加<code>BeanPostProcessor</code></li>
<li>注册<code>Scope</code></li>
<li>设置<code>ApplicationStartup</code></li>
<li>获取<code>AccessControlContext</code></li>
<li>获取合并后的<code>BeanDefinition</code></li>
<li>注册Bean之间的依赖关系</li>
<li>销毁Bean</li>
<li>销毁所有单例</li>
</ul>
<p>上面一些组件可以留待以后详细探究。</p>
</li>
<li><p><code>ConfigurableListableBeanFactory</code></p>
<p>他就是为ListableBeanFactory提供各种配置方法</p>
<p><img src="https://gdz.oss-cn-shenzhen.aliyuncs.com/local/%E6%88%AA%E5%B1%8F2021-11-13%20%E4%B8%8B%E5%8D%884.45.27.png" alt="截屏2021-11-13 下午4.45.27"></p>
</li>
</ul>
<p>小结：<code>BeanFactory</code>及其各种派生接口，都是围绕Bean创建、维护、容器组件注入所展开，依据能力进行了拆分。</p>
<h3 id="Environment"><a href="#Environment" class="headerlink" title="Environment"></a>Environment</h3><p>一个完整的<code>Environment</code>派生关系如下，从上面BeanFactory个子接口命名规则我们大概可以猜出</p>
<ul>
<li><code>PropertyResolver</code>：属性解析器，提供基础的键值对获取能力</li>
<li><code>Environment</code>：Spring环境的抽象，对应profile，如生产、测试、QA环境</li>
<li><code>ConfigurableEnvironment</code>：提供配置设置和获取能力，这其中最为重要的是<code>getPropertySources()</code>方法，<code>MutablePropertySources</code>作为返回值，这意味着它维护的是多个配置源，比如<ul>
<li>系统属性</li>
<li>系统变量</li>
<li><code>application.properties</code>设置的变量等</li>
</ul>
</li>
<li><code>AbstractEnvironmen</code>t：环境的基本实现</li>
<li><code>StandardEnvironment</code>：环境的标准实现</li>
<li>其它三个Web相关的<code>Environment</code>：将Servlet中相关的属性也加入<code>Environment</code>中</li>
</ul>
<p><img src="https://gdz.oss-cn-shenzhen.aliyuncs.com/local/%E6%88%AA%E5%B1%8F2021-11-13%20%E4%B8%8B%E5%8D%885.01.45.png" alt="截屏2021-11-13 下午5.01.45"></p>
<p>既然<code>Environment</code>就这么几个类，我们完全可以看看它的工作原理：假设创建了一个<code>ApplicationServletEnvironment</code>实例，我们看看它本身的初始化过程和获取一个环境变量所需的步骤。</p>
<h4 id="初始化"><a href="#初始化" class="headerlink" title="初始化"></a>初始化</h4><p>按照构造方法依次追踪下去</p>
<ul>
<li>创建<code>MutablePropertySources</code>并赋予<code>propertySources</code>属性，以便永久持有</li>
<li><code>StandardServletEnvironment</code>的配置<ul>
<li>向<code>propertySources</code>中添加<code>servletConfigInitParams</code>、<code>servletContextInitParams</code>、<code>jndiProperties</code>三个属性源</li>
</ul>
</li>
<li><code>StandardEnvironment</code>的配置<ul>
<li>向<code>propertySources</code>中添加<code>systemProperties</code>、<code>systemEnvironment</code>两个属性源</li>
</ul>
</li>
<li>完毕</li>
</ul>
<h4 id="获取变量"><a href="#获取变量" class="headerlink" title="获取变量"></a>获取变量</h4><p>关键逻辑在<code>org.springframework.core.env.PropertySourcesPropertyResolver#getProperty(java.lang.String, java.lang.Class&lt;T&gt;, boolean)</code>中</p>
<p>从<code>propertySources</code>中按顺序迭代，找到第一个匹配的key，取出</p>
<ul>
<li>解析取出值的占位符，<strong>占位符对应的值只可能从系统属性、系统环境变量、ServletContext的InitParam中获取</strong>，并不能随处获取</li>
<li>如果获取的目标并非字符串，则会使用<code>ConversionService</code>进行转换，这个<code>ConversionService</code>可以自己设置，否则使用默认的<code>DefaultConversionService</code></li>
</ul>
<h4 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h4><p>可以看一下最开始的例子中<code>Environment</code>是什么样子，可见，它只是一个StandardEnvironment，于是只有系统属性和系统环境两个配置源。</p>
<p><img src="https://gdz.oss-cn-shenzhen.aliyuncs.com/local/%E6%88%AA%E5%B1%8F2021-11-13%20%E4%B8%8B%E5%8D%885.39.50.png" alt="截屏2021-11-13 下午5.39.50"></p>
<p>小结：当然，任何<code>Environment</code>的调用者都能够往里塞环境变量源，这里并不能看到全貌，还需要具体应用具体分析。</p>
<h3 id="ApplicationEvent"><a href="#ApplicationEvent" class="headerlink" title="ApplicationEvent"></a>ApplicationEvent</h3><p>Spring的事件机制比较简单，只是涉及到几个关键的类</p>
<ul>
<li><code>ApplicationEvent</code></li>
<li><code>ApplicationEvnetPublisher</code></li>
<li><code>ApplicationEventMulticaster</code></li>
</ul>
<p><code>ApplicationEventMulticaster</code>是关键。它被<code>AbstractApplicationContext</code>持有，并在<code>AbstractApplicationContext</code>中完成消息的发送。它的组成也比较简单，就是监听器和事件的粘合剂：持有批量监听器，发送消息调用<code>multicastEvent()</code>。</p>
<p><img src="https://gdz.oss-cn-shenzhen.aliyuncs.com/local/%E6%88%AA%E5%B1%8F2021-11-13%20%E4%B8%8B%E5%8D%885.54.08.png" alt="截屏2021-11-13 下午5.54.08"></p>
<p>广播消息的逻辑如下。可见，消息的发送，不一定是异步的，也可能是同步的，取决于是否提供了线程池。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">multicastEvent</span><span class="params">(<span class="keyword">final</span> ApplicationEvent event, <span class="meta">@Nullable</span> ResolvableType eventType)</span> </span>&#123;</span><br><span class="line">		ResolvableType type = (eventType != <span class="keyword">null</span> ? eventType : resolveDefaultEventType(event));</span><br><span class="line">  	<span class="comment">// 获取Executor</span></span><br><span class="line">		Executor executor = getTaskExecutor();</span><br><span class="line">		<span class="keyword">for</span> (ApplicationListener&lt;?&gt; listener : getApplicationListeners(event, type)) &#123;</span><br><span class="line">      <span class="comment">// 如果存在Executor，则向其中提交一个任务，异步广播</span></span><br><span class="line">			<span class="keyword">if</span> (executor != <span class="keyword">null</span>) &#123;</span><br><span class="line">				executor.execute(() -&gt; invokeListener(listener, event));</span><br><span class="line">			&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// 否则，同步广播</span></span><br><span class="line">				invokeListener(listener, event);</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>

<h3 id="ResourceLoader"><a href="#ResourceLoader" class="headerlink" title="ResourceLoader"></a>ResourceLoader</h3><p>资源加载器。</p>
<h4 id="Resource"><a href="#Resource" class="headerlink" title="Resource"></a>Resource</h4><p>首先，什么是资源<code>Resource</code>：一切资源的抽象定义，一个资源有这些特征</p>
<ul>
<li>可开启</li>
<li>可判断是否存在</li>
<li>可获取内容长度</li>
<li>可获取读取它的Channel</li>
<li>具体的资源由他扩展而来</li>
</ul>
<p>我们可以看一下Spring中定义了多少种资源。</p>
<p><img src="https://gdz.oss-cn-shenzhen.aliyuncs.com/local/%E6%88%AA%E5%B1%8F2021-11-13%20%E4%B8%8B%E5%8D%886.01.48.png" alt="截屏2021-11-13 下午6.01.48"></p>
<p>一个最典型的<code>Resource</code>就是文件，当它是文件时，一切都很好办了；另一个典型的<code>Resource</code>是网络数据，比如<code>MultipartFileResource</code>，通过输入流读取它就行了；也可能仅仅是一个路径构成的资源，比如<code>PathResource</code>。</p>
<h4 id="ResourceLoader-1"><a href="#ResourceLoader-1" class="headerlink" title="ResourceLoader"></a>ResourceLoader</h4><p>资源加载器，Spring中主要实现如下<br><img src="https://gdz.oss-cn-shenzhen.aliyuncs.com/local/%E6%88%AA%E5%B1%8F2021-11-13%20%E4%B8%8B%E5%8D%886.06.36.png" alt="截屏2021-11-13 下午6.06.36"></p>
<ul>
<li><p><code>ResourceLoader</code>是最抽象的接口，只定义了根据位置获取资源的方法</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function">Resource <span class="title">getResource</span><span class="params">(String location)</span></span>;</span><br></pre></td></tr></table></figure></li>
<li><p><code>ResourcePatternResolver</code>更进一步，定义了根据匹配规则返回一批资源的方法</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Resource[] getResources(String locationPattern) <span class="keyword">throws</span> IOException;</span><br></pre></td></tr></table></figure></li>
<li><p><code>DefaultResourceLoader</code>定义了加载器的基本实现，它的派生类只是具体小众应用场景的扩展，内容很少，这里可以忽略</p>
<p>重点关注<code>getResource(String location)</code>的实现逻辑</p>
<ul>
<li>如果待解析的location以<code>/</code>开头，则解析成<code>ClassPathContextResource</code>。</li>
<li>如果以<code>classpath:</code>开头，则解析成<code>ClassPathResource</code></li>
<li>否则以URL来解析这个字符串，最终被解析成<code>FileUrlResource</code>或<code>UrlResource</code></li>
</ul>
</li>
<li><p><code>PathMatchingResourcePatternResolver</code>，这是<code>ResourcePatternResolver</code>的唯一实现，默认采用Ant风格的匹配规则对资源路径进行匹配。</p>
<p>重点关注<code>Resource[] getResources(String locationPattern)</code>的实现逻辑</p>
<ul>
<li>如果以<code>classpath*:</code>开头，<ul>
<li>如果路径部分是通配符，则查找通配符匹配的资源</li>
<li>否则，在所有的包路径下查找精确匹配的资源</li>
</ul>
</li>
<li>否则<ul>
<li>如果路径部分是通配符，则查找通配符匹配的资源</li>
<li>否则，退化为<code>DefaultResourceLoader.getResource()</code></li>
</ul>
</li>
</ul>
</li>
</ul>
<h4 id="那些前缀"><a href="#那些前缀" class="headerlink" title="那些前缀"></a>那些前缀</h4><ul>
<li><code>classpath:</code> 在当前包的类路径下查找</li>
<li><code>classpath*:</code> 在整个项目包含的包的类路径下查找</li>
<li><code>file:</code> 在文件系统中查找</li>
<li><code>jar:</code> 在jar文件中查找</li>
<li><code>war:</code> 在war文件中查找</li>
</ul>
<p>这些前缀，可别用惯了就忘记了，它们只属于Spring，JDK是不认识的。</p>
<h4 id="小结-1"><a href="#小结-1" class="headerlink" title="小结"></a>小结</h4><p>资源加载，最底层很多时候用的都是<code>ClassLoader</code>去实现，因此，对<code>ClassLoader</code>的了解还是很重要的。</p>
<h3 id="MessageSource"><a href="#MessageSource" class="headerlink" title="MessageSource"></a>MessageSource</h3><p><img src="https://gdz.oss-cn-shenzhen.aliyuncs.com/local/%E6%88%AA%E5%B1%8F2021-11-13%20%E4%B8%8B%E5%8D%886.42.00.png" alt="截屏2021-11-13 下午6.42.00"></p>
<h4 id="资源国际化"><a href="#资源国际化" class="headerlink" title="资源国际化"></a>资源国际化</h4><p>消息资源，这是用来做资源国际化的，你看接口定义就知道了：获取消息</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">MessageSource</span> </span>&#123;</span><br><span class="line">	<span class="function">String <span class="title">getMessage</span><span class="params">(String code, <span class="meta">@Nullable</span> Object[] args, <span class="meta">@Nullable</span> String defaultMessage, Locale locale)</span></span>;</span><br><span class="line">	<span class="function">String <span class="title">getMessage</span><span class="params">(String code, <span class="meta">@Nullable</span> Object[] args, Locale locale)</span> <span class="keyword">throws</span> NoSuchMessageException</span>;</span><br><span class="line">	<span class="function">String <span class="title">getMessage</span><span class="params">(MessageSourceResolvable resolvable, Locale locale)</span> <span class="keyword">throws</span> NoSuchMessageException</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这里重点理它的参数，举个例子，我们定义两个文件</p>
<figure class="highlight properties"><table><tr><td class="code"><pre><span class="line"><span class="comment"># message.properties文件中</span></span><br><span class="line"><span class="attr">hello</span>=<span class="string">hello，$&#123;name&#125;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment"># message_zh_CN.priperties</span></span><br><span class="line"><span class="attr">hello</span>=<span class="string">你好，$&#123;name&#125;</span></span><br></pre></td></tr></table></figure>

<ul>
<li>code：就是在配置文件中设置的key，对应上面的hello</li>
<li>args：文本中需要填充的参数，对应上面的name</li>
<li>locale：目标地区，对应上面的zh_CN</li>
</ul>
<h4 id="ResourceBundle"><a href="#ResourceBundle" class="headerlink" title="ResourceBundle"></a>ResourceBundle</h4><p>上面我们看到，Spring提供的主要实现就是<code>ResourceBundleMessageSource</code>，因此理解<code>ResourceBundle</code>是关键。</p>
<p><code>ResourceBundle</code>，直译为资源包。它包含了一系列与<code>Locale</code>相关的资源包，可根据当前Locale获取不同的内容。JDK官方有两个子类：<code>PropertyResourceBundle</code>和<code>ListResourceBundle</code>，前者使用List的形式提供数据，后者使用properties文件的形式提供，当然我们也可以提供我们自己的。它的使用方法，必须有一个baseName，比如message，具体的<code>Locale</code>要有具体的后缀，比如<code>message_zh_CN</code>。如果是<code>PropertyResourceBundle</code>，对应的就是<code>message.properties</code>和<code>message_zh_CN.properties</code>。</p>
<p>那么，它是怎么工作的呢？我们从<code>ResourceBundle.getBundle</code>看起，通过一系列跟踪，可以来到：<code>java.util.ResourceBundle.Control#newBundle</code>，发现它的逻辑大致如下</p>
<ul>
<li>根据baseName和locale构建BundleName</li>
<li>如果待加载的资源格式是<code>java.class</code>，则直接用反射获取类名为BundleName的资源类，并构建对象</li>
<li>如果待加载的资源格式是<code>java.properties</code>，则用类加载器加载类路劲下的<code>BundleName.properties</code></li>
<li>默认情况下，这两种资源格式都被包含，也就是说，如果同时拥有一个实现了<code>ResourceBundle</code>的<code>BundleName类</code>和<code>BundleName.properties</code>，前者会被优先探测到。</li>
</ul>
<p>剩下的逻辑就很好理解了，<code>ResourceBundle</code>实现类维护键值对缓存，提供对应locale的值的查询。</p>
<p>再来看<code>ResourceBundleMessageSource</code>，忽略掉各种花里胡哨的抽象类、接口之类的，直接看这个类</p>
<ul>
<li><code>loadBundle</code>方法展示了它直接使用了<code>PropertyResourceBundle</code>这个类</li>
<li><code>MessageSourceControl</code>展示了它在读取properties文件时多加了一点配置：编码方式</li>
</ul>
<h4 id="小结-2"><a href="#小结-2" class="headerlink" title="小结"></a>小结</h4><p>Spring为我们提供了资源国际化的抽象，底层使用了JDK的<code>ResourceBundle</code>实现。</p>
<h3 id="LifeCycle"><a href="#LifeCycle" class="headerlink" title="LifeCycle"></a>LifeCycle</h3><p>生命周期抽象。可以是Bean去实现它，也可以是<code>ApplicationContext</code>去实现它，它依赖的是容器在启动和关闭时发送相应信号，相关处理器回调对应的生命周期方法；对应的有<code>SmartLifeCycle</code>，它在<code>ApplicationContext</code>刷新时会自动调用<code>start()</code>方法。</p>
<p>生命周期管理的逻辑，在<code>DefaultLifecycleProcessor</code>中，我们来瞅瞅。重点关注三个方法</p>
<ul>
<li><code>onStart（）</code><ul>
<li>从<code>BeanFactory</code>中获取所有类型为<code>LifeCycle</code>的Bean</li>
<li>将所有<code>Bean</code>按照<code>phase</code>值分组</li>
<li>按照分组<code>phase</code>从小到大调用<code>bean</code>的<code>start()</code>方法，分组内启动顺序，按<code>bean</code>名称的排序来</li>
</ul>
</li>
<li><code>onRefresh()</code><ul>
<li>和<code>start()</code>一样，唯一的差别是，只处理实现了<code>SmartLifecycle</code>接口且<code>SmartLifecycle.isAutoStartup()</code>为true的接口。</li>
</ul>
</li>
<li><code>onClose()</code><ul>
<li>从<code>BeanFactory</code>中获取所有类型为<code>LifeCycle</code>的<code>Bean</code></li>
<li>将所有<code>Bean</code>按照<code>phase</code>值分组</li>
<li>按照相反顺序调用<code>stop()</code>方法，分组内启动顺序，按<code>bean</code>名称的反序来</li>
</ul>
</li>
</ul>
<p>那么，谁去启动<code>DefaultLifecycleProcessor</code>的呢？答案是<code>AbstractApplicationContext</code>，它在初始化时候创建了<code>DefaultLifecycleProcessor</code>，调用了<code>onRefresh()</code>方法，关闭时调用了<code>onClose()</code>方法。</p>
<p>小结：<code>LifeCycle</code>的工作原理还算简单。</p>
<h3 id="AnnotationConfigRegistry"><a href="#AnnotationConfigRegistry" class="headerlink" title="AnnotationConfigRegistry"></a>AnnotationConfigRegistry</h3><p>注解配置注册器，负责注册配置Bean，与众不同的是，它还提供了scan方法，扫描包名下的所有被注解配置的Bean。<strong>如果要了解扫描逻辑，去看它的方法实现</strong>。但这不是本文的重点，本文重点在于总览。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">AnnotationConfigRegistry</span> </span>&#123;</span><br><span class="line">   <span class="function"><span class="keyword">void</span> <span class="title">register</span><span class="params">(Class&lt;?&gt;... componentClasses)</span></span>;</span><br><span class="line">   <span class="function"><span class="keyword">void</span> <span class="title">scan</span><span class="params">(String... basePackages)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="BeanDefinitionRegistry"><a href="#BeanDefinitionRegistry" class="headerlink" title="BeanDefinitionRegistry"></a>BeanDefinitionRegistry</h3><p><img src="https://gdz.oss-cn-shenzhen.aliyuncs.com/local/%E6%88%AA%E5%B1%8F2021-11-13%20%E4%B8%8B%E5%8D%888.16.04.png" alt="截屏2021-11-13 下午8.16.04"></p>
<p>别名注册器和Bean定义注册器，顾名思义，这里不赘述。</p>
<h3 id="ApplicationContext"><a href="#ApplicationContext" class="headerlink" title="ApplicationContext"></a>ApplicationContext</h3><p>对<code>ApplicationContext</code>接口，它本身并没有什么实质性的方法，只是对各种能力的集合。从接口继承上看，所谓<code>ApplicationContext</code>，就是拥有如下六种能力的上下文</p>
<ul>
<li>具有管理、批量管理、按层级关系管理Bean的能力</li>
<li>具有资源国际化的能力</li>
<li>具有资源解析器的能力，而且还是通配符匹配的资源解析器</li>
<li>具有事件发送的能力</li>
<li>具有管理<code>Environment</code>的能力</li>
</ul>
<p><img src="https://gdz.oss-cn-shenzhen.aliyuncs.com/local/%E6%88%AA%E5%B1%8F2021-11-13%20%E4%B8%8B%E5%8D%888.25.03.png" alt="截屏2021-11-13 下午8.25.03"></p>
<p>再看它们的派生类</p>
<p><img src="https://gdz.oss-cn-shenzhen.aliyuncs.com/local/%E6%88%AA%E5%B1%8F2021-11-13%20%E4%B8%8B%E5%8D%888.23.17.png" alt="截屏2021-11-13 下午8.23.17"></p>
<ul>
<li><p><code>ConfigurableApplicationContext</code></p>
<p>提供将相应组件注入的能力，包括</p>
<ul>
<li>应用ID</li>
<li>父上下文</li>
<li><code>Environment</code>实例</li>
<li><code>ApplicationStartup</code></li>
<li>添加<code>BeanFactoryPostProcessor</code></li>
<li>添加<code>ApplicationListener</code></li>
<li>设置<code>ClassLoader</code></li>
<li>注册关闭钩子等</li>
</ul>
</li>
<li><p><code>AbstractApplicationContext</code></p>
<p>这里实现了上下文的主要逻辑，即实现了所有接口的方法，把接口的能力兑现。它采用模板方法模式，定义了几乎所有逻辑，将最为关键的三个方法留给子类去执行：提供<code>BeanFactory</code>。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">refreshBeanFactory</span><span class="params">()</span> <span class="keyword">throws</span> BeansException, IllegalStateException</span>;</span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">closeBeanFactory</span><span class="params">()</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> ConfigurableListableBeanFactory <span class="title">getBeanFactory</span><span class="params">()</span> <span class="keyword">throws</span> IllegalStateException</span>;</span><br></pre></td></tr></table></figure>

<p>从这里还可以看出一点，<code>AbstractApplicationContext</code>几乎全都使用了代理模式，实现了相应的接口，但实际执行对应方法的实例都是注入进来的，而不是自己实现。这是很大的优点：<strong>将具体逻辑的实现交给具体的组件组做，<code>ApplicationContext</code>要做的就是将他们组织起来，并完成<code>ApplicationContex</code>t独有的逻辑</strong>，对外提供的服务。它做了什么，下文”启动流程“将进行拆解。</p>
</li>
<li><p><code>GenericApplicationContext</code></p>
<p>这是一个通用的<code>ApplicationContext</code>，直接能用，它提供了<code>AbstractApplicationContext</code>唯一缺少的<code>BeanFactory</code>，可传入，否则直接使用<code>DefaultListableBeanFactory</code></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">GenericApplicationContext</span><span class="params">()</span> </span>&#123;</span><br><span class="line">   <span class="keyword">this</span>.beanFactory = <span class="keyword">new</span> DefaultListableBeanFactory();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>GenericApplicationContext</code>不止实现了<code>AbstractApplicationContext</code>，还实现了<code>BeanDefinitionRegistry</code>，使得能够向<code>beanFactory</code>直接注入<code>BeanDefinition</code>。也就是说，要让<code>beanFactory</code>被注入<code>Bean</code>，有两种方法</p>
<ul>
<li>直接传入已经准备好的<code>BeanFactory</code></li>
<li>调用<code>BeanDefinitionRegistry</code>定义的注册方法，动态向其中注入Bean</li>
</ul>
</li>
<li><p><code>AnnotationConfigApplicationContext</code></p>
<pre><code>  这里就用了第二种方法，`BeanFactory`直接使用默认的`DefaultListableBeanFactory`，然后使用`AnnotatedBeanDefinitionReader`和`ClassPathBeanDefinitionScanner`向其中注入Bean定义。**关于注解扫描Bean的原理，后面单独起一篇文章描述，本文跳过**。
  
  还有更多具体的上下文实现，都是通过这种方式，不信你看
</code></pre>
</li>
</ul>
<p><img src="https://gdz.oss-cn-shenzhen.aliyuncs.com/local/%E6%88%AA%E5%B1%8F2021-11-13%20%E4%B8%8B%E5%8D%889.00.58.png" alt="截屏2021-11-13 下午9.00.58"></p>
<h2 id="未提及，但重要"><a href="#未提及，但重要" class="headerlink" title="未提及，但重要"></a>未提及，但重要</h2><p>如下组件，虽然并不是ApplicationContext继承树中的直接部分，但会成为理解的绊脚石，这里将其踢开。</p>
<h3 id="PropertyEditor相关"><a href="#PropertyEditor相关" class="headerlink" title="PropertyEditor相关"></a>PropertyEditor相关</h3><p>registrar是登记员；registry是登记簿。</p>
<ul>
<li><p><code>PropertyEditor</code></p>
<p>首先要理解什么是<code>PropertyEditor</code>，它是JDK中的定义，它一般的用途，是用来支持GUI组件的属性修改，但也可以只实现两个方法，用来做类型转换</p>
<blockquote>
<p>Simple PropertyEditors may only support the getAsText and setAsText methods and need not support (say) paintValue or getCustomEditor. More complex types may be unable to support getAsText and setAsText but will instead support paintValue and getCustomEditor.</p>
</blockquote>
<p>我们重点关注它的四个方法：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">PropertyEditor</span> </span>&#123;</span><br><span class="line">  <span class="comment">// 设置值</span></span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">setValue</span><span class="params">(Object value)</span></span>;</span><br><span class="line">  <span class="comment">// 获取值</span></span><br><span class="line">  <span class="function">Object <span class="title">getValue</span><span class="params">()</span></span>;</span><br><span class="line">  <span class="comment">// 将值作为文本获取</span></span><br><span class="line">  <span class="function">String <span class="title">getAsText</span><span class="params">()</span></span>;</span><br><span class="line">  <span class="comment">// 设置文本，并存成值</span></span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">setAsText</span><span class="params">(String text)</span> <span class="keyword">throws</span> java.lang.IllegalArgumentException</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>不知道上面在说什么？看看JDK提供的实现类PropertyEditorSupport。这里，有一个幕后对象value，可与<code>String</code>互转。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">PropertyEditorSupport</span> <span class="keyword">implements</span> <span class="title">PropertyEditor</span> </span>&#123;</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">private</span> Object value;</span><br><span class="line">  </span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setValue</span><span class="params">(Object value)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.value = value;</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="function"><span class="keyword">public</span> Object <span class="title">getValue</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> value;</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="function"><span class="keyword">public</span> String <span class="title">getAsText</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> (<span class="keyword">this</span>.value != <span class="keyword">null</span>)</span><br><span class="line">      ? <span class="keyword">this</span>.value.toString()</span><br><span class="line">      : <span class="keyword">null</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setAsText</span><span class="params">(String text)</span> <span class="keyword">throws</span> java.lang.IllegalArgumentException </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (value <span class="keyword">instanceof</span> String) &#123;</span><br><span class="line">      setValue(text);</span><br><span class="line">      <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> java.lang.IllegalArgumentException(text);</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>还是不知道？那我们看一下Spring的实现类<code>CurrencyEditor</code>：它将<code>Currency</code>对象与<code>String</code>互转。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CurrencyEditor</span> <span class="keyword">extends</span> <span class="title">PropertyEditorSupport</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setAsText</span><span class="params">(String text)</span> <span class="keyword">throws</span> IllegalArgumentException </span>&#123;</span><br><span class="line">		setValue(Currency.getInstance(text));</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> String <span class="title">getAsText</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		Currency value = (Currency) getValue();</span><br><span class="line">		<span class="keyword">return</span> (value != <span class="keyword">null</span> ? value.getCurrencyCode() : <span class="string">&quot;&quot;</span>);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>看到这里，想必已有所知晓，Spring的实现类是利用它来进行对象与String的相互转换。不信你看<code>org.springframework.beans.TypeConverterDelegate#doConvertTextValue</code>方法</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> Object <span class="title">doConvertTextValue</span><span class="params">(<span class="meta">@Nullable</span> Object oldValue, String newTextValue, PropertyEditor editor)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">try</span> &#123;</span><br><span class="line">      <span class="comment">// 先尝试直接设置值</span></span><br><span class="line">			editor.setValue(oldValue);</span><br><span class="line">		&#125; <span class="keyword">catch</span> (Exception ex) &#123;</span><br><span class="line">			<span class="keyword">if</span> (logger.isDebugEnabled()) &#123;</span><br><span class="line">				logger.debug(<span class="string">&quot;PropertyEditor [&quot;</span> + editor.getClass().getName() + <span class="string">&quot;] does not support setValue call&quot;</span>, ex);</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">  	<span class="comment">// 再直接塞入字符串</span></span><br><span class="line">		editor.setAsText(newTextValue);</span><br><span class="line">  	<span class="comment">// 最后取出来的是个对象，转换逻辑在具体的实现类中</span></span><br><span class="line">		<span class="keyword">return</span> editor.getValue();</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>

<p>Spring自定义的<code>PropertyEditor</code>非常多，多数在<code>org.springframework.beans.propertyeditors</code>包中，继承关系如下（这里仅选取几个典型的）</p>
<p><img src="https://gdz.oss-cn-shenzhen.aliyuncs.com/local/%E6%88%AA%E5%B1%8F2021-11-13%20%E4%B8%8B%E5%8D%8810.19.08.png" alt="截屏2021-11-13 下午10.19.08"></p>
</li>
<li><p><code>PropertyEditorRegistrar</code></p>
<p> 登记员，策略模式，将<code>PropertyEditor</code>注册到指定的<code>PropertyEditorRegistry</code>。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">registerCustomEditors</span><span class="params">(PropertyEditorRegistry registry)</span></span>;</span><br></pre></td></tr></table></figure>

<p> 它其实是一堆<code>PropertyEditor</code>的持有器，它的唯一实现类<code>ResourceEditorRegistrar</code>，就是这样注册了一堆</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">registerCustomEditors</span><span class="params">(PropertyEditorRegistry registry)</span> </span>&#123;</span><br><span class="line">  ResourceEditor baseEditor = <span class="keyword">new</span> ResourceEditor(<span class="keyword">this</span>.resourceLoader, <span class="keyword">this</span>.propertyResolver);</span><br><span class="line">  doRegisterEditor(registry, Resource.class, baseEditor);</span><br><span class="line">  doRegisterEditor(registry, ContextResource.class, baseEditor);</span><br><span class="line">  doRegisterEditor(registry, InputStream.class, <span class="keyword">new</span> InputStreamEditor(baseEditor));</span><br><span class="line">  doRegisterEditor(registry, InputSource.class, <span class="keyword">new</span> InputSourceEditor(baseEditor));</span><br><span class="line">  doRegisterEditor(registry, File.class, <span class="keyword">new</span> FileEditor(baseEditor));</span><br><span class="line">  doRegisterEditor(registry, Path.class, <span class="keyword">new</span> PathEditor(baseEditor));</span><br><span class="line">  doRegisterEditor(registry, Reader.class, <span class="keyword">new</span> ReaderEditor(baseEditor));</span><br><span class="line">  doRegisterEditor(registry, URL.class, <span class="keyword">new</span> URLEditor(baseEditor));</span><br><span class="line"></span><br><span class="line">  ClassLoader classLoader = <span class="keyword">this</span>.resourceLoader.getClassLoader();</span><br><span class="line">  doRegisterEditor(registry, URI.class, <span class="keyword">new</span> URIEditor(classLoader));</span><br><span class="line">  doRegisterEditor(registry, Class.class, <span class="keyword">new</span> ClassEditor(classLoader));</span><br><span class="line">  doRegisterEditor(registry, Class[].class, <span class="keyword">new</span> ClassArrayEditor(classLoader));</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (<span class="keyword">this</span>.resourceLoader <span class="keyword">instanceof</span> ResourcePatternResolver) &#123;</span><br><span class="line">    doRegisterEditor(registry, Resource[].class,</span><br><span class="line">                     <span class="keyword">new</span> ResourceArrayPropertyEditor((ResourcePatternResolver) <span class="keyword">this</span>.resourceLoader, <span class="keyword">this</span>.propertyResolver));</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<ul>
<li><p><code>PropertyEditorRegistry</code></p>
<p>登记册，<code>PropertyEditor</code>的集合，对它陌生，对它的实现类，你看<code>DataBinder</code>，你肯定熟悉。</p>
<p><img src="https://gdz.oss-cn-shenzhen.aliyuncs.com/local/%E6%88%AA%E5%B1%8F2021-11-13%20%E4%B8%8B%E5%8D%8810.56.43.png" alt="截屏2021-11-13 下午10.56.43"></p>
<p> 这里主要说明一下<code>PropertyEditorRegistrySupport</code>，它是一个基本实现，默认已经注册了很多类型的<code>PropertyEditor</code>。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">  <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">createDefaultEditors</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  		<span class="keyword">this</span>.defaultEditors = <span class="keyword">new</span> HashMap&lt;&gt;(<span class="number">64</span>);</span><br><span class="line">  </span><br><span class="line">  		<span class="comment">// Simple editors, without parameterization capabilities.</span></span><br><span class="line">  		<span class="comment">// The JDK does not contain a default editor for any of these target types.</span></span><br><span class="line">  		<span class="keyword">this</span>.defaultEditors.put(Charset.class, <span class="keyword">new</span> CharsetEditor());</span><br><span class="line">  		<span class="keyword">this</span>.defaultEditors.put(Class.class, <span class="keyword">new</span> ClassEditor());</span><br><span class="line">  		<span class="keyword">this</span>.defaultEditors.put(Class[].class, <span class="keyword">new</span> ClassArrayEditor());</span><br><span class="line">  		<span class="keyword">this</span>.defaultEditors.put(Currency.class, <span class="keyword">new</span> CurrencyEditor());</span><br><span class="line">  		<span class="keyword">this</span>.defaultEditors.put(File.class, <span class="keyword">new</span> FileEditor());</span><br><span class="line">  		<span class="keyword">this</span>.defaultEditors.put(InputStream.class, <span class="keyword">new</span> InputStreamEditor());</span><br><span class="line">  		<span class="keyword">if</span> (!shouldIgnoreXml) &#123;</span><br><span class="line">  			<span class="keyword">this</span>.defaultEditors.put(InputSource.class, <span class="keyword">new</span> InputSourceEditor());</span><br><span class="line">  		&#125;</span><br><span class="line">  		<span class="keyword">this</span>.defaultEditors.put(Locale.class, <span class="keyword">new</span> LocaleEditor());</span><br><span class="line">  		<span class="keyword">this</span>.defaultEditors.put(Path.class, <span class="keyword">new</span> PathEditor());</span><br><span class="line">  		<span class="keyword">this</span>.defaultEditors.put(Pattern.class, <span class="keyword">new</span> PatternEditor());</span><br><span class="line">  		<span class="keyword">this</span>.defaultEditors.put(Properties.class, <span class="keyword">new</span> PropertiesEditor());</span><br><span class="line">  		<span class="keyword">this</span>.defaultEditors.put(Reader.class, <span class="keyword">new</span> ReaderEditor());</span><br><span class="line">  		<span class="keyword">this</span>.defaultEditors.put(Resource[].class, <span class="keyword">new</span> ResourceArrayPropertyEditor());</span><br><span class="line">  		<span class="keyword">this</span>.defaultEditors.put(TimeZone.class, <span class="keyword">new</span> TimeZoneEditor());</span><br><span class="line">  		<span class="keyword">this</span>.defaultEditors.put(URI.class, <span class="keyword">new</span> URIEditor());</span><br><span class="line">  		<span class="keyword">this</span>.defaultEditors.put(URL.class, <span class="keyword">new</span> URLEditor());</span><br><span class="line">  		<span class="keyword">this</span>.defaultEditors.put(UUID.class, <span class="keyword">new</span> UUIDEditor());</span><br><span class="line">  		<span class="keyword">this</span>.defaultEditors.put(ZoneId.class, <span class="keyword">new</span> ZoneIdEditor());</span><br><span class="line">  </span><br><span class="line">  		<span class="comment">// Default instances of collection editors.</span></span><br><span class="line">  		<span class="comment">// Can be overridden by registering custom instances of those as custom editors.</span></span><br><span class="line">  		<span class="keyword">this</span>.defaultEditors.put(Collection.class, <span class="keyword">new</span> CustomCollectionEditor(Collection.class));</span><br><span class="line">  		<span class="keyword">this</span>.defaultEditors.put(Set.class, <span class="keyword">new</span> CustomCollectionEditor(Set.class));</span><br><span class="line">  		<span class="keyword">this</span>.defaultEditors.put(SortedSet.class, <span class="keyword">new</span> CustomCollectionEditor(SortedSet.class));</span><br><span class="line">  		<span class="keyword">this</span>.defaultEditors.put(List.class, <span class="keyword">new</span> CustomCollectionEditor(List.class));</span><br><span class="line">  		<span class="keyword">this</span>.defaultEditors.put(SortedMap.class, <span class="keyword">new</span> CustomMapEditor(SortedMap.class));</span><br><span class="line">  </span><br><span class="line">  		<span class="comment">// Default editors for primitive arrays.</span></span><br><span class="line">  		<span class="keyword">this</span>.defaultEditors.put(<span class="keyword">byte</span>[].class, <span class="keyword">new</span> ByteArrayPropertyEditor());</span><br><span class="line">  		<span class="keyword">this</span>.defaultEditors.put(<span class="keyword">char</span>[].class, <span class="keyword">new</span> CharArrayPropertyEditor());</span><br><span class="line">  </span><br><span class="line">  		<span class="comment">// The JDK does not contain a default editor for char!</span></span><br><span class="line">  		<span class="keyword">this</span>.defaultEditors.put(<span class="keyword">char</span>.class, <span class="keyword">new</span> CharacterEditor(<span class="keyword">false</span>));</span><br><span class="line">  		<span class="keyword">this</span>.defaultEditors.put(Character.class, <span class="keyword">new</span> CharacterEditor(<span class="keyword">true</span>));</span><br><span class="line">  </span><br><span class="line">  		<span class="comment">// Spring&#x27;s CustomBooleanEditor accepts more flag values than the JDK&#x27;s default editor.</span></span><br><span class="line">  		<span class="keyword">this</span>.defaultEditors.put(<span class="keyword">boolean</span>.class, <span class="keyword">new</span> CustomBooleanEditor(<span class="keyword">false</span>));</span><br><span class="line">  		<span class="keyword">this</span>.defaultEditors.put(Boolean.class, <span class="keyword">new</span> CustomBooleanEditor(<span class="keyword">true</span>));</span><br><span class="line">  </span><br><span class="line">  		<span class="comment">// The JDK does not contain default editors for number wrapper types!</span></span><br><span class="line">  		<span class="comment">// Override JDK primitive number editors with our own CustomNumberEditor.</span></span><br><span class="line">  		<span class="keyword">this</span>.defaultEditors.put(<span class="keyword">byte</span>.class, <span class="keyword">new</span> CustomNumberEditor(Byte.class, <span class="keyword">false</span>));</span><br><span class="line">  		<span class="keyword">this</span>.defaultEditors.put(Byte.class, <span class="keyword">new</span> CustomNumberEditor(Byte.class, <span class="keyword">true</span>));</span><br><span class="line">  		<span class="keyword">this</span>.defaultEditors.put(<span class="keyword">short</span>.class, <span class="keyword">new</span> CustomNumberEditor(Short.class, <span class="keyword">false</span>));</span><br><span class="line">  		<span class="keyword">this</span>.defaultEditors.put(Short.class, <span class="keyword">new</span> CustomNumberEditor(Short.class, <span class="keyword">true</span>));</span><br><span class="line">  		<span class="keyword">this</span>.defaultEditors.put(<span class="keyword">int</span>.class, <span class="keyword">new</span> CustomNumberEditor(Integer.class, <span class="keyword">false</span>));</span><br><span class="line">  		<span class="keyword">this</span>.defaultEditors.put(Integer.class, <span class="keyword">new</span> CustomNumberEditor(Integer.class, <span class="keyword">true</span>));</span><br><span class="line">  		<span class="keyword">this</span>.defaultEditors.put(<span class="keyword">long</span>.class, <span class="keyword">new</span> CustomNumberEditor(Long.class, <span class="keyword">false</span>));</span><br><span class="line">  		<span class="keyword">this</span>.defaultEditors.put(Long.class, <span class="keyword">new</span> CustomNumberEditor(Long.class, <span class="keyword">true</span>));</span><br><span class="line">  		<span class="keyword">this</span>.defaultEditors.put(<span class="keyword">float</span>.class, <span class="keyword">new</span> CustomNumberEditor(Float.class, <span class="keyword">false</span>));</span><br><span class="line">  		<span class="keyword">this</span>.defaultEditors.put(Float.class, <span class="keyword">new</span> CustomNumberEditor(Float.class, <span class="keyword">true</span>));</span><br><span class="line">  		<span class="keyword">this</span>.defaultEditors.put(<span class="keyword">double</span>.class, <span class="keyword">new</span> CustomNumberEditor(Double.class, <span class="keyword">false</span>));</span><br><span class="line">  		<span class="keyword">this</span>.defaultEditors.put(Double.class, <span class="keyword">new</span> CustomNumberEditor(Double.class, <span class="keyword">true</span>));</span><br><span class="line">  		<span class="keyword">this</span>.defaultEditors.put(BigDecimal.class, <span class="keyword">new</span> CustomNumberEditor(BigDecimal.class, <span class="keyword">true</span>));</span><br><span class="line">  		<span class="keyword">this</span>.defaultEditors.put(BigInteger.class, <span class="keyword">new</span> CustomNumberEditor(BigInteger.class, <span class="keyword">true</span>));</span><br><span class="line">  </span><br><span class="line">  		<span class="comment">// Only register config value editors if explicitly requested.</span></span><br><span class="line">  		<span class="keyword">if</span> (<span class="keyword">this</span>.configValueEditorsActive) &#123;</span><br><span class="line">  			StringArrayPropertyEditor sae = <span class="keyword">new</span> StringArrayPropertyEditor();</span><br><span class="line">  			<span class="keyword">this</span>.defaultEditors.put(String[].class, sae);</span><br><span class="line">  			<span class="keyword">this</span>.defaultEditors.put(<span class="keyword">short</span>[].class, sae);</span><br><span class="line">  			<span class="keyword">this</span>.defaultEditors.put(<span class="keyword">int</span>[].class, sae);</span><br><span class="line">  			<span class="keyword">this</span>.defaultEditors.put(<span class="keyword">long</span>[].class, sae);</span><br><span class="line">  		&#125;</span><br><span class="line">  	&#125;</span><br><span class="line"></span><br><span class="line">小结：`PropertyEditor`，是Spring中类型转换的基础之一。</span><br><span class="line"></span><br><span class="line">### ConversionService</span><br><span class="line"></span><br><span class="line">上面我们看到的`PropertyEditor`，用来作为文本与对象之间的转换，而这里的`ConversionService`，则是用来作普通类型之间的转换。首先要补充两个概念</span><br><span class="line"></span><br><span class="line">- `Converter`</span><br><span class="line"></span><br><span class="line">  转换器，只定义了一个convert抽象方法，如果我们要定义自己的类型转换器，直接实现它，然后通过注入获取到`ConversoinService`，注册给它就好。</span><br><span class="line"></span><br><span class="line">  ```java</span><br><span class="line">  <span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Converter</span>&lt;<span class="title">S</span>, <span class="title">T</span>&gt; </span>&#123;</span><br><span class="line">  	<span class="meta">@Nullable</span></span><br><span class="line">  	<span class="function">T <span class="title">convert</span><span class="params">(S source)</span></span>;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>

<p>Spring中有大量的实现了它的转换器</p>
<p><img src="https://gdz.oss-cn-shenzhen.aliyuncs.com/local/%E6%88%AA%E5%B1%8F2021-11-14%20%E4%B8%8A%E5%8D%8810.06.46.png" alt="截屏2021-11-14 上午10.06.46"></p>
</li>
<li><p><code>ConverterFactory</code></p>
<p>只定义了一个根据类型获取Converter的方法</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">ConverterFactory</span>&lt;<span class="title">S</span>, <span class="title">R</span>&gt; </span>&#123;</span><br><span class="line">	&lt;T extends R&gt; <span class="function">Converter&lt;S, T&gt; <span class="title">getConverter</span><span class="params">(Class&lt;T&gt; targetType)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p><code>ConversionService</code></p>
<p>顾名思义，它是组织做类型转换的地方，内部包含一批<code>Converter</code>实例，转换时从中找出类型对应的，执行转换即可。</p>
<p><img src="https://gdz.oss-cn-shenzhen.aliyuncs.com/local/%E6%88%AA%E5%B1%8F2021-11-14%20%E4%B8%8A%E5%8D%8810.02.50.png" alt="截屏2021-11-14 上午10.02.50"></p>
<p>其主要接口实现在<code>GenericConversionService</code>，默认实现是<code>DefaultConversionService</code>，这里注册了大量默认的<code>Converter</code></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">addDefaultConverters</span><span class="params">(ConverterRegistry converterRegistry)</span> </span>&#123;</span><br><span class="line">  addScalarConverters(converterRegistry);</span><br><span class="line">  addCollectionConverters(converterRegistry);</span><br><span class="line"></span><br><span class="line">  converterRegistry.addConverter(<span class="keyword">new</span> ByteBufferConverter((ConversionService) converterRegistry));</span><br><span class="line">  converterRegistry.addConverter(<span class="keyword">new</span> StringToTimeZoneConverter());</span><br><span class="line">  converterRegistry.addConverter(<span class="keyword">new</span> ZoneIdToTimeZoneConverter());</span><br><span class="line">  converterRegistry.addConverter(<span class="keyword">new</span> ZonedDateTimeToCalendarConverter());</span><br><span class="line"></span><br><span class="line">  converterRegistry.addConverter(<span class="keyword">new</span> ObjectToObjectConverter());</span><br><span class="line">  converterRegistry.addConverter(<span class="keyword">new</span> IdToEntityConverter((ConversionService) converterRegistry));</span><br><span class="line">  converterRegistry.addConverter(<span class="keyword">new</span> FallbackObjectToStringConverter());</span><br><span class="line">  converterRegistry.addConverter(<span class="keyword">new</span> ObjectToOptionalConverter((ConversionService) converterRegistry));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">addCollectionConverters</span><span class="params">(ConverterRegistry converterRegistry)</span> </span>&#123;</span><br><span class="line">  ConversionService conversionService = (ConversionService) converterRegistry;</span><br><span class="line"></span><br><span class="line">  converterRegistry.addConverter(<span class="keyword">new</span> ArrayToCollectionConverter(conversionService));</span><br><span class="line">  converterRegistry.addConverter(<span class="keyword">new</span> CollectionToArrayConverter(conversionService));</span><br><span class="line"></span><br><span class="line">  converterRegistry.addConverter(<span class="keyword">new</span> ArrayToArrayConverter(conversionService));</span><br><span class="line">  converterRegistry.addConverter(<span class="keyword">new</span> CollectionToCollectionConverter(conversionService));</span><br><span class="line">  converterRegistry.addConverter(<span class="keyword">new</span> MapToMapConverter(conversionService));</span><br><span class="line"></span><br><span class="line">  converterRegistry.addConverter(<span class="keyword">new</span> ArrayToStringConverter(conversionService));</span><br><span class="line">  converterRegistry.addConverter(<span class="keyword">new</span> StringToArrayConverter(conversionService));</span><br><span class="line"></span><br><span class="line">  converterRegistry.addConverter(<span class="keyword">new</span> ArrayToObjectConverter(conversionService));</span><br><span class="line">  converterRegistry.addConverter(<span class="keyword">new</span> ObjectToArrayConverter(conversionService));</span><br><span class="line"></span><br><span class="line">  converterRegistry.addConverter(<span class="keyword">new</span> CollectionToStringConverter(conversionService));</span><br><span class="line">  converterRegistry.addConverter(<span class="keyword">new</span> StringToCollectionConverter(conversionService));</span><br><span class="line"></span><br><span class="line">  converterRegistry.addConverter(<span class="keyword">new</span> CollectionToObjectConverter(conversionService));</span><br><span class="line">  converterRegistry.addConverter(<span class="keyword">new</span> ObjectToCollectionConverter(conversionService));</span><br><span class="line"></span><br><span class="line">  converterRegistry.addConverter(<span class="keyword">new</span> StreamConverter(conversionService));</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">addScalarConverters</span><span class="params">(ConverterRegistry converterRegistry)</span> </span>&#123;</span><br><span class="line">  converterRegistry.addConverterFactory(<span class="keyword">new</span> NumberToNumberConverterFactory());</span><br><span class="line"></span><br><span class="line">  converterRegistry.addConverterFactory(<span class="keyword">new</span> StringToNumberConverterFactory());</span><br><span class="line">  converterRegistry.addConverter(Number.class, String.class, <span class="keyword">new</span> ObjectToStringConverter());</span><br><span class="line"></span><br><span class="line">  converterRegistry.addConverter(<span class="keyword">new</span> StringToCharacterConverter());</span><br><span class="line">  converterRegistry.addConverter(Character.class, String.class, <span class="keyword">new</span> ObjectToStringConverter());</span><br><span class="line"></span><br><span class="line">  converterRegistry.addConverter(<span class="keyword">new</span> NumberToCharacterConverter());</span><br><span class="line">  converterRegistry.addConverterFactory(<span class="keyword">new</span> CharacterToNumberFactory());</span><br><span class="line"></span><br><span class="line">  converterRegistry.addConverter(<span class="keyword">new</span> StringToBooleanConverter());</span><br><span class="line">  converterRegistry.addConverter(Boolean.class, String.class, <span class="keyword">new</span> ObjectToStringConverter());</span><br><span class="line"></span><br><span class="line">  converterRegistry.addConverterFactory(<span class="keyword">new</span> StringToEnumConverterFactory());</span><br><span class="line">  converterRegistry.addConverter(<span class="keyword">new</span> EnumToStringConverter((ConversionService) converterRegistry));</span><br><span class="line"></span><br><span class="line">  converterRegistry.addConverterFactory(<span class="keyword">new</span> IntegerToEnumConverterFactory());</span><br><span class="line">  converterRegistry.addConverter(<span class="keyword">new</span> EnumToIntegerConverter((ConversionService) converterRegistry));</span><br><span class="line"></span><br><span class="line">  converterRegistry.addConverter(<span class="keyword">new</span> StringToLocaleConverter());</span><br><span class="line">  converterRegistry.addConverter(Locale.class, String.class, <span class="keyword">new</span> ObjectToStringConverter());</span><br><span class="line"></span><br><span class="line">  converterRegistry.addConverter(<span class="keyword">new</span> StringToCharsetConverter());</span><br><span class="line">  converterRegistry.addConverter(Charset.class, String.class, <span class="keyword">new</span> ObjectToStringConverter());</span><br><span class="line"></span><br><span class="line">  converterRegistry.addConverter(<span class="keyword">new</span> StringToCurrencyConverter());</span><br><span class="line">  converterRegistry.addConverter(Currency.class, String.class, <span class="keyword">new</span> ObjectToStringConverter());</span><br><span class="line"></span><br><span class="line">  converterRegistry.addConverter(<span class="keyword">new</span> StringToPropertiesConverter());</span><br><span class="line">  converterRegistry.addConverter(<span class="keyword">new</span> PropertiesToStringConverter());</span><br><span class="line"></span><br><span class="line">  converterRegistry.addConverter(<span class="keyword">new</span> StringToUUIDConverter());</span><br><span class="line">  converterRegistry.addConverter(UUID.class, String.class, <span class="keyword">new</span> ObjectToStringConverter());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<p>小结：<code>ConversionService</code>是Spring类型转换的基础之二</p>
<h3 id="TypeConverter"><a href="#TypeConverter" class="headerlink" title="TypeConverter"></a>TypeConverter</h3><p>类型转换器，只定义了三个用于类型转换的接口</p>
<p><img src="https://gdz.oss-cn-shenzhen.aliyuncs.com/local/%E6%88%AA%E5%B1%8F2021-11-14%20%E4%B8%8A%E5%8D%889.35.37.png" alt="截屏2021-11-14 上午9.35.37"></p>
<p>刨除干扰项，它的主要实现类如下，有两个分支</p>
<p><img src="https://gdz.oss-cn-shenzhen.aliyuncs.com/local/%E6%88%AA%E5%B1%8F2021-11-14%20%E4%B8%8A%E5%8D%889.37.59.png" alt="截屏2021-11-14 上午9.37.59"></p>
<ul>
<li><p><code>TypeConverterSupport</code>这边：主要实现逻辑委托给了TypeConverterDelegate，它内部的实现逻辑是</p>
<ul>
<li>首先尝试使用<code>ConversionService</code>进行转换</li>
<li>然后尝试用<code>PropertyEditor</code>转换</li>
</ul>
</li>
<li><p><code>DataBinder</code>这边，则是使用了代理模式，将类型转换代理给内部维护的TypeConverter实例</p>
<p>当然，**<code>DataBind</code>的逻辑还比较复杂，后面单独开一篇文章来说。**</p>
</li>
</ul>
<p>小结：<code>TypeConverter</code>应该是Spring中类型转换的门面担当。</p>
<h3 id="BeanExpressionResolver"><a href="#BeanExpressionResolver" class="headerlink" title="BeanExpressionResolver"></a>BeanExpressionResolver</h3><p>Bean用到的表达式解析器，如下，其中，<code>BeanExpressionContext</code>仅包含Bean所在环境的容器和<code>Scope</code>。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">BeanExpressionResolver</span> </span>&#123;</span><br><span class="line">	<span class="function">Object <span class="title">evaluate</span><span class="params">(<span class="meta">@Nullable</span> String value, BeanExpressionContext evalContext)</span> <span class="keyword">throws</span> BeansException</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>它只有一个实现类<code>StandardBeanExpressionResolver</code></p>
<p><img src="https://gdz.oss-cn-shenzhen.aliyuncs.com/local/%E6%88%AA%E5%B1%8F2021-11-14%20%E4%B8%8A%E5%8D%8810.32.11.png" alt="截屏2021-11-14 上午10.32.11"></p>
<p>关键逻辑如下：解析出<code>Expression</code>，构建<code>EvaluationContext</code>，获取解析结果</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> Object <span class="title">evaluate</span><span class="params">(<span class="meta">@Nullable</span> String value, BeanExpressionContext evalContext)</span> <span class="keyword">throws</span> BeansException </span>&#123;</span><br><span class="line">  expr = <span class="keyword">this</span>.expressionParser.parseExpression(value, <span class="keyword">this</span>.beanExpressionParserContext);</span><br><span class="line">  StandardEvaluationContext sec = <span class="keyword">this</span>.evaluationCache.get(evalContext);</span><br><span class="line">  <span class="keyword">if</span> (sec == <span class="keyword">null</span>) &#123;</span><br><span class="line">    sec = <span class="keyword">new</span> StandardEvaluationContext(evalContext);</span><br><span class="line">    sec.addPropertyAccessor(<span class="keyword">new</span> BeanExpressionContextAccessor());</span><br><span class="line">    sec.addPropertyAccessor(<span class="keyword">new</span> BeanFactoryAccessor());</span><br><span class="line">    sec.addPropertyAccessor(<span class="keyword">new</span> MapAccessor());</span><br><span class="line">    sec.addPropertyAccessor(<span class="keyword">new</span> EnvironmentAccessor());</span><br><span class="line">    sec.setBeanResolver(<span class="keyword">new</span> BeanFactoryResolver(evalContext.getBeanFactory()));</span><br><span class="line">    sec.setTypeLocator(<span class="keyword">new</span> StandardTypeLocator(evalContext.getBeanFactory().getBeanClassLoader()));</span><br><span class="line">    ConversionService conversionService = evalContext.getBeanFactory().getConversionService();</span><br><span class="line">    <span class="keyword">if</span> (conversionService != <span class="keyword">null</span>) &#123;</span><br><span class="line">      sec.setTypeConverter(<span class="keyword">new</span> StandardTypeConverter(conversionService));</span><br><span class="line">    &#125;</span><br><span class="line">    customizeEvaluationContext(sec);</span><br><span class="line">    <span class="keyword">this</span>.evaluationCache.put(evalContext, sec);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> expr.getValue(sec);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>于是这里引出了Spring的表达式相关抽象，关键有三个接口</p>
<ul>
<li><p><code>Expression</code></p>
<p><img src="https://gdz.oss-cn-shenzhen.aliyuncs.com/local/%E6%88%AA%E5%B1%8F2021-11-14%20%E4%B8%8A%E5%8D%8810.36.40.png" alt="截屏2021-11-14 上午10.36.40"></p>
<p>它就只有几类方法</p>
<ul>
<li><code>getExpressionString()</code>：获取源表达式字符串</li>
<li><code>getValue(xxx)</code>：在指定的<code>EvaluationContext</code>中，获取根据表达式计算出实际的对象</li>
<li><code>getValueType(xxx)</code>：在指定的<code>EvaluationContext</code>中，获取得到的值的类型</li>
<li><code>getValueTypeDescriptor(xxx)</code>：在指定的<code>EvaluationContext</code>中，获取得到的值的类型描述对象</li>
<li><code>setValue(xxx)</code>：为当前表达式设置一个值</li>
<li><code>isWritable()</code>：当前表达式是否可写，即是否可以调用<code>setValue(xxx)</code></li>
</ul>
<p>其默认实现就三种</p>
<ul>
<li><code>SpelExpression</code>：SPEL表达式，这个不用多说</li>
<li><code>LiteralExpression</code>：常量表达式，表达式本身就是值，不会经过任何转换</li>
<li><code>CompositeStringExpression</code>：内部维护多个Expression实例，但解析结果是这些表达式解析结果的字符串相加</li>
</ul>
</li>
<li><p><code>ExpressionParser</code></p>
<p>表达式解析器，即将字符串解析为<code>Expression</code>对象。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">ExpressionParser</span> </span>&#123;</span><br><span class="line">   <span class="function">Expression <span class="title">parseExpression</span><span class="params">(String expressionString)</span> <span class="keyword">throws</span> ParseException</span>;</span><br><span class="line">   <span class="function">Expression <span class="title">parseExpression</span><span class="params">(String expressionString, ParserContext context)</span> <span class="keyword">throws</span> ParseException</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>其主要解析逻辑在<code>TemplateAwareExpressionParser</code>，决定了一个字符串是被解析成SPEL表达式还是别的什么。其具体过程，不是本文深究的内容。</p>
<p><img src="https://gdz.oss-cn-shenzhen.aliyuncs.com/local/%E6%88%AA%E5%B1%8F2021-11-14%20%E4%B8%8A%E5%8D%8811.01.59.png" alt="截屏2021-11-14 上午11.01.59"></p>
</li>
<li><p><code>EvaluationContext</code></p>
<p>表达式计算上下文，主要是持有类型转换、Bean解析器、属性访问器等工具，一个典型的实现是<code>StandardEvaluationContext</code>。</p>
</li>
</ul>
<p>小结：Spring中的表达式实现，多半还是SPEL表达式的解析结果。</p>
<h3 id="xxxPostProcessor"><a href="#xxxPostProcessor" class="headerlink" title="xxxPostProcessor"></a>xxxPostProcessor</h3><ul>
<li><p><code>BeanPostProcessor</code></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">BeanPostProcessor</span> </span>&#123;</span><br><span class="line">   <span class="function"><span class="keyword">default</span> Object <span class="title">postProcessBeforeInitialization</span><span class="params">(Object bean, String beanName)</span> <span class="keyword">throws</span> BeansException </span>&#123;</span><br><span class="line">      <span class="keyword">return</span> bean;</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="function"><span class="keyword">default</span> Object <span class="title">postProcessAfterInitialization</span><span class="params">(Object bean, String beanName)</span> <span class="keyword">throws</span> BeansException </span>&#123;</span><br><span class="line">      <span class="keyword">return</span> bean;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在Bean初始化前和初始化后执行一些操作。</p>
<p>问题：Spring会有多少个<code>PostProcessor</code>，我们自定义的如何加入呢？</p>
<p>答：容器启动时，会从容器中寻找所有<code>BeanPostProcessor</code>，然后注册，所以不大好说有多少个；我们自定义的，实现<code>BeanPostProcessor</code>接口就好。</p>
</li>
<li><p><code>BeanFactoryPostProcessor</code></p>
<p>针对<code>BeanFactory</code>执行一些操作。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">BeanFactoryPostProcessor</span> </span>&#123;</span><br><span class="line">   <span class="function"><span class="keyword">void</span> <span class="title">postProcessBeanFactory</span><span class="params">(ConfigurableListableBeanFactory beanFactory)</span> <span class="keyword">throws</span> BeansException</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="ApplicationStartup"><a href="#ApplicationStartup" class="headerlink" title="ApplicationStartup"></a>ApplicationStartup</h3><p>这是一个没有太多”实质用处”的抽象，并不是说它真的没用，它只是一个用来做启动标识的抽象。</p>
<h2 id="启动流程"><a href="#启动流程" class="headerlink" title="启动流程"></a>启动流程</h2><p>前面将几乎所有组件都介绍了一遍，为的就是在分析启动流程时候能够更加顺利。再次回顾前面的启动代码，我们只是实例化了上下文，然后就能使用了</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">val</span> context = AnnotationConfigApplicationContext(<span class="string">&quot;com.gitee.floyd.springme.core&quot;</span>)</span><br><span class="line">    context.getBean(Bean1::<span class="keyword">class</span>.java)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>看构造方法</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">AnnotationConfigApplicationContext</span><span class="params">(String... basePackages)</span> </span>&#123;</span><br><span class="line">  <span class="comment">// 调用无参构造</span></span><br><span class="line">  <span class="keyword">this</span>();</span><br><span class="line">  <span class="comment">// 扫描bean</span></span><br><span class="line">  scan(basePackages);</span><br><span class="line">  <span class="comment">// 刷新</span></span><br><span class="line">  refresh();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">AnnotationConfigApplicationContext</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="comment">// 前面说过。Startup只是一个标记，没用，我们可以忽略掉</span></span><br><span class="line">  StartupStep createAnnotatedBeanDefReader = <span class="keyword">this</span>.getApplicationStartup().start(<span class="string">&quot;spring.context.annotated-bean-reader.create&quot;</span>);</span><br><span class="line">  <span class="comment">// 构建AnnotatedBeanDefinitionReader</span></span><br><span class="line">  <span class="keyword">this</span>.reader = <span class="keyword">new</span> AnnotatedBeanDefinitionReader(<span class="keyword">this</span>);</span><br><span class="line">  createAnnotatedBeanDefReader.end();</span><br><span class="line">  <span class="comment">// 构建ClassPathBeanDefinitionScanner</span></span><br><span class="line">  <span class="keyword">this</span>.scanner = <span class="keyword">new</span> ClassPathBeanDefinitionScanner(<span class="keyword">this</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">scan</span><span class="params">(String... basePackages)</span> </span>&#123;</span><br><span class="line">  <span class="comment">// 步骤标记，忽略</span></span><br><span class="line">  StartupStep scanPackages = <span class="keyword">this</span>.getApplicationStartup().start(<span class="string">&quot;spring.context.base-packages.scan&quot;</span>)</span><br><span class="line">    .tag(<span class="string">&quot;packages&quot;</span>, () -&gt; Arrays.toString(basePackages));</span><br><span class="line">  <span class="comment">// 扫描bean</span></span><br><span class="line">  <span class="keyword">this</span>.scanner.scan(basePackages);</span><br><span class="line">  scanPackages.end();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>总结下来就是</p>
<ul>
<li>创建<code>AnnotatedBeanDefinitionReader</code>、<code>ClassPathBeanDefinitionScanner</code></li>
<li>调用<code>ClassPathBeanDefinitionScanner</code>的scan方法完成扫描</li>
<li>调用<code>AbstractApplicationContext</code>的<code>refresh()</code>方法完成容器刷新</li>
</ul>
<p>结合前文<code>ApplicationContext</code>继承拓扑图，可进一步看到，Spring将容器的Bean定义的加载工作放到具体实现来做，加载完成后，再调用基层的<code>refresh()</code>做容器刷新，应用加载到的Bean定义，分层非常明显。</p>
<p>扫描的逻辑，其实有点复杂，我们以后再分析，这里重点关注<code>refresh()</code>干了什么。原本的注解说明了一切</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">refresh</span><span class="params">()</span> <span class="keyword">throws</span> BeansException, IllegalStateException </span>&#123;</span><br><span class="line">  <span class="keyword">synchronized</span> (<span class="keyword">this</span>.startupShutdownMonitor) &#123;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// Prepare this context for refreshing.</span></span><br><span class="line">    prepareRefresh();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Tell the subclass to refresh the internal bean factory.</span></span><br><span class="line">    ConfigurableListableBeanFactory beanFactory = obtainFreshBeanFactory();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Prepare the bean factory for use in this context.</span></span><br><span class="line">    prepareBeanFactory(beanFactory);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 生命周期方法1，子类可以在此修改beanFactory</span></span><br><span class="line">    postProcessBeanFactory(beanFactory);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Invoke factory processors registered as beans in the context.</span></span><br><span class="line">    invokeBeanFactoryPostProcessors(beanFactory);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Register bean processors that intercept bean creation.</span></span><br><span class="line">    registerBeanPostProcessors(beanFactory);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Initialize message source for this context.</span></span><br><span class="line">    initMessageSource();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Initialize event multicaster for this context.</span></span><br><span class="line">    initApplicationEventMulticaster();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 生命周期方法2，beanFactory相关已经准备的差不多了，属性也都齐全，可以在这里做些啥了</span></span><br><span class="line">    onRefresh();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Check for listener beans and register them.</span></span><br><span class="line">    registerListeners();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Instantiate all remaining (non-lazy-init) singletons.</span></span><br><span class="line">    finishBeanFactoryInitialization(beanFactory);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Last step: publish corresponding event.</span></span><br><span class="line">    finishRefresh();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>逐项分析重要步骤</p>
<h3 id="准备刷新"><a href="#准备刷新" class="headerlink" title="准备刷新"></a>准备刷新</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">prepareRefresh</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="comment">// Switch to active.</span></span><br><span class="line">  <span class="keyword">this</span>.startupDate = System.currentTimeMillis();</span><br><span class="line">  <span class="keyword">this</span>.closed.set(<span class="keyword">false</span>);</span><br><span class="line">  <span class="keyword">this</span>.active.set(<span class="keyword">true</span>);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 初始化属性源，子类实现，是针对Environment的初始化逻辑</span></span><br><span class="line">  initPropertySources();</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 验证必须的属性，这个暂时没找到出处</span></span><br><span class="line">  <span class="comment">// see ConfigurablePropertyResolver#setRequiredProperties</span></span><br><span class="line">  getEnvironment().validateRequiredProperties();</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 清理事件监听器</span></span><br><span class="line">  <span class="keyword">if</span> (<span class="keyword">this</span>.earlyApplicationListeners == <span class="keyword">null</span>) &#123;</span><br><span class="line">    <span class="keyword">this</span>.earlyApplicationListeners = <span class="keyword">new</span> LinkedHashSet&lt;&gt;(<span class="keyword">this</span>.applicationListeners);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="keyword">this</span>.applicationListeners.clear();</span><br><span class="line">    <span class="keyword">this</span>.applicationListeners.addAll(<span class="keyword">this</span>.earlyApplicationListeners);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">this</span>.earlyApplicationEvents = <span class="keyword">new</span> LinkedHashSet&lt;&gt;();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>要点：初始化属性源，前面分析过<code>Environment</code>，包含很多属性源，除了默认的系统属性和系统环境变量，子<code>ApplicationContext</code>还会初始化自己的属性源，比如后面将要分析的<code>GenericWebApplicationContext</code>，就进行了实现：它添加了<code>servletContextInitParams</code>和<code>servletConfigInitParams</code>两个属性源。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// GenericWebApplicationContext中</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">initPropertySources</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  ConfigurableEnvironment env = getEnvironment();</span><br><span class="line">  <span class="keyword">if</span> (env <span class="keyword">instanceof</span> ConfigurableWebEnvironment) &#123;</span><br><span class="line">    ((ConfigurableWebEnvironment) env).initPropertySources(<span class="keyword">this</span>.servletContext, <span class="keyword">null</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// ConfigurableWebEnvironment中</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">initPropertySources</span><span class="params">(<span class="meta">@Nullable</span> ServletContext servletContext, <span class="meta">@Nullable</span> ServletConfig servletConfig)</span> </span>&#123;</span><br><span class="line">  WebApplicationContextUtils.initServletPropertySources(getPropertySources(), servletContext, servletConfig);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// WebApplicationContextUtils中</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">initServletPropertySources</span><span class="params">(MutablePropertySources sources,</span></span></span><br><span class="line"><span class="params"><span class="function">                                              <span class="meta">@Nullable</span> ServletContext servletContext, <span class="meta">@Nullable</span> ServletConfig servletConfig)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  Assert.notNull(sources, <span class="string">&quot;&#x27;propertySources&#x27; must not be null&quot;</span>);</span><br><span class="line">  String name = StandardServletEnvironment.SERVLET_CONTEXT_PROPERTY_SOURCE_NAME;</span><br><span class="line">  <span class="keyword">if</span> (servletContext != <span class="keyword">null</span> &amp;&amp; sources.get(name) <span class="keyword">instanceof</span> StubPropertySource) &#123;</span><br><span class="line">    sources.replace(name, <span class="keyword">new</span> ServletContextPropertySource(name, servletContext));</span><br><span class="line">  &#125;</span><br><span class="line">  name = StandardServletEnvironment.SERVLET_CONFIG_PROPERTY_SOURCE_NAME;</span><br><span class="line">  <span class="keyword">if</span> (servletConfig != <span class="keyword">null</span> &amp;&amp; sources.get(name) <span class="keyword">instanceof</span> StubPropertySource) &#123;</span><br><span class="line">    sources.replace(name, <span class="keyword">new</span> ServletConfigPropertySource(name, servletConfig));</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="准备BeanFactory"><a href="#准备BeanFactory" class="headerlink" title="准备BeanFactory"></a>准备BeanFactory</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">prepareBeanFactory</span><span class="params">(ConfigurableListableBeanFactory beanFactory)</span> </span>&#123;</span><br><span class="line">  <span class="comment">// Tell the internal bean factory to use the context&#x27;s class loader etc.</span></span><br><span class="line">  beanFactory.setBeanClassLoader(getClassLoader());</span><br><span class="line">  <span class="keyword">if</span> (!shouldIgnoreSpel) &#123;</span><br><span class="line">    <span class="comment">// 注册表达式解析器</span></span><br><span class="line">    beanFactory.setBeanExpressionResolver(<span class="keyword">new</span> StandardBeanExpressionResolver(beanFactory.getBeanClassLoader()));</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 注册一批属性编辑器，用于做类型转换</span></span><br><span class="line">  beanFactory.addPropertyEditorRegistrar(<span class="keyword">new</span> ResourceEditorRegistrar(<span class="keyword">this</span>, getEnvironment()));</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Configure the bean factory with context callbacks.</span></span><br><span class="line">  <span class="comment">// 添加ApplicationContextAwareProcessor作为后置处理器</span></span><br><span class="line">  beanFactory.addBeanPostProcessor(<span class="keyword">new</span> ApplicationContextAwareProcessor(<span class="keyword">this</span>));</span><br><span class="line">  <span class="comment">// xxxxAware接口将不参与依赖注入</span></span><br><span class="line">  beanFactory.ignoreDependencyInterface(EnvironmentAware.class);</span><br><span class="line">  beanFactory.ignoreDependencyInterface(EmbeddedValueResolverAware.class);</span><br><span class="line">  beanFactory.ignoreDependencyInterface(ResourceLoaderAware.class);</span><br><span class="line">  beanFactory.ignoreDependencyInterface(ApplicationEventPublisherAware.class);</span><br><span class="line">  beanFactory.ignoreDependencyInterface(MessageSourceAware.class);</span><br><span class="line">  beanFactory.ignoreDependencyInterface(ApplicationContextAware.class);</span><br><span class="line">  beanFactory.ignoreDependencyInterface(ApplicationStartupAware.class);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 如下类型的注入，将使用这里注册的实例</span></span><br><span class="line">  beanFactory.registerResolvableDependency(BeanFactory.class, beanFactory);</span><br><span class="line">  beanFactory.registerResolvableDependency(ResourceLoader.class, <span class="keyword">this</span>);</span><br><span class="line">  beanFactory.registerResolvableDependency(ApplicationEventPublisher.class, <span class="keyword">this</span>);</span><br><span class="line">  beanFactory.registerResolvableDependency(ApplicationContext.class, <span class="keyword">this</span>);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 添加监听器Bean侦测器</span></span><br><span class="line">  beanFactory.addBeanPostProcessor(<span class="keyword">new</span> ApplicationListenerDetector(<span class="keyword">this</span>));</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Detect a LoadTimeWeaver and prepare for weaving, if found.</span></span><br><span class="line">  <span class="keyword">if</span> (!NativeDetector.inNativeImage() &amp;&amp; beanFactory.containsBean(LOAD_TIME_WEAVER_BEAN_NAME)) &#123;</span><br><span class="line">    <span class="comment">// 添加加载时间处理器</span></span><br><span class="line">    beanFactory.addBeanPostProcessor(<span class="keyword">new</span> LoadTimeWeaverAwareProcessor(beanFactory));</span><br><span class="line">    <span class="comment">// Set a temporary ClassLoader for type matching.</span></span><br><span class="line">    beanFactory.setTempClassLoader(<span class="keyword">new</span> ContextTypeMatchClassLoader(beanFactory.getBeanClassLoader()));</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Register default environment beans.</span></span><br><span class="line">  <span class="keyword">if</span> (!beanFactory.containsLocalBean(ENVIRONMENT_BEAN_NAME)) &#123;</span><br><span class="line">    beanFactory.registerSingleton(ENVIRONMENT_BEAN_NAME, getEnvironment());</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> (!beanFactory.containsLocalBean(SYSTEM_PROPERTIES_BEAN_NAME)) &#123;</span><br><span class="line">    beanFactory.registerSingleton(SYSTEM_PROPERTIES_BEAN_NAME, getEnvironment().getSystemProperties());</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> (!beanFactory.containsLocalBean(SYSTEM_ENVIRONMENT_BEAN_NAME)) &#123;</span><br><span class="line">    beanFactory.registerSingleton(SYSTEM_ENVIRONMENT_BEAN_NAME, getEnvironment().getSystemEnvironment());</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> (!beanFactory.containsLocalBean(APPLICATION_STARTUP_BEAN_NAME)) &#123;</span><br><span class="line">    beanFactory.registerSingleton(APPLICATION_STARTUP_BEAN_NAME, getApplicationStartup());</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li><p>要点1：<code>ApplicationContextAware</code>、<code>ApplicationListener</code>的注册、<code>LoadTimeWeaverAware</code>，都是通过后置处理器完成的</p>
</li>
<li><p>要点2：注册了几个环境变量相关的单例，方便应用中直接使用</p>
<ul>
<li><code>environment</code></li>
<li><code>systemProperties</code></li>
<li><code>systemEnvironment</code></li>
<li><code>applicationStartup</code></li>
</ul>
</li>
<li><p>要点3：<strong>暂时未发现<code>BeanPostProcessor</code>在何时何地被调动，猜测是Bean创建时，待查。</strong></p>
</li>
</ul>
<h3 id="应用BeanFactoryPostProcessor"><a href="#应用BeanFactoryPostProcessor" class="headerlink" title="应用BeanFactoryPostProcessor"></a>应用BeanFactoryPostProcessor</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">invokeBeanFactoryPostProcessors</span><span class="params">(ConfigurableListableBeanFactory beanFactory)</span> </span>&#123;</span><br><span class="line">   PostProcessorRegistrationDelegate.invokeBeanFactoryPostProcessors(beanFactory, getBeanFactoryPostProcessors());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>要点，调用<code>getBeanFactoryPostProcessors()</code>获取后置处理器，而正常流程里是没有这个选项的，因此它只可能来自子类，在上下文启动的生命周期方法中添加，比如<code>postProcessBeanFactory()</code></p>
<h3 id="注册BeanPostProcessor"><a href="#注册BeanPostProcessor" class="headerlink" title="注册BeanPostProcessor"></a>注册BeanPostProcessor</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">registerBeanPostProcessors</span><span class="params">(ConfigurableListableBeanFactory beanFactory)</span> </span>&#123;</span><br><span class="line">  PostProcessorRegistrationDelegate.registerBeanPostProcessors(beanFactory, <span class="keyword">this</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">registerBeanPostProcessors</span><span class="params">(ConfigurableListableBeanFactory beanFactory, AbstractApplicationContext applicationContext)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 获取所有类型为BeanPostProcessor的Bean</span></span><br><span class="line">  String[] postProcessorNames = beanFactory.getBeanNamesForType(BeanPostProcessor.class, <span class="keyword">true</span>, <span class="keyword">false</span>);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">int</span> beanProcessorTargetCount = beanFactory.getBeanPostProcessorCount() + <span class="number">1</span> + postProcessorNames.length;</span><br><span class="line">  <span class="comment">// 添加一个Bean检查器，它会检查beanFactory中实际后置器的数量</span></span><br><span class="line">  beanFactory.addBeanPostProcessor(<span class="keyword">new</span> BeanPostProcessorChecker(beanFactory, beanProcessorTargetCount));</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Separate between BeanPostProcessors that implement PriorityOrdered, Ordered, and the rest.</span></span><br><span class="line">  <span class="comment">// 将这些后置处理器分为三部分：实现了PriorityOrdered, Ordered, 其它</span></span><br><span class="line">  List&lt;BeanPostProcessor&gt; priorityOrderedPostProcessors = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">  List&lt;BeanPostProcessor&gt; internalPostProcessors = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">  List&lt;String&gt; orderedPostProcessorNames = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">  List&lt;String&gt; nonOrderedPostProcessorNames = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">  <span class="keyword">for</span> (String ppName : postProcessorNames) &#123;</span><br><span class="line">    <span class="keyword">if</span> (beanFactory.isTypeMatch(ppName, PriorityOrdered.class)) &#123;</span><br><span class="line">      BeanPostProcessor pp = beanFactory.getBean(ppName, BeanPostProcessor.class);</span><br><span class="line">      priorityOrderedPostProcessors.add(pp);</span><br><span class="line">      <span class="keyword">if</span> (pp <span class="keyword">instanceof</span> MergedBeanDefinitionPostProcessor) &#123;</span><br><span class="line">        internalPostProcessors.add(pp);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (beanFactory.isTypeMatch(ppName, Ordered.class)) &#123;</span><br><span class="line">      orderedPostProcessorNames.add(ppName);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">      nonOrderedPostProcessorNames.add(ppName);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// First, register the BeanPostProcessors that implement PriorityOrdered.</span></span><br><span class="line">  sortPostProcessors(priorityOrderedPostProcessors, beanFactory);</span><br><span class="line">  registerBeanPostProcessors(beanFactory, priorityOrderedPostProcessors);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Next, register the BeanPostProcessors that implement Ordered.</span></span><br><span class="line">  List&lt;BeanPostProcessor&gt; orderedPostProcessors = <span class="keyword">new</span> ArrayList&lt;&gt;(orderedPostProcessorNames.size());</span><br><span class="line">  <span class="keyword">for</span> (String ppName : orderedPostProcessorNames) &#123;</span><br><span class="line">    BeanPostProcessor pp = beanFactory.getBean(ppName, BeanPostProcessor.class);</span><br><span class="line">    orderedPostProcessors.add(pp);</span><br><span class="line">    <span class="keyword">if</span> (pp <span class="keyword">instanceof</span> MergedBeanDefinitionPostProcessor) &#123;</span><br><span class="line">      internalPostProcessors.add(pp);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  sortPostProcessors(orderedPostProcessors, beanFactory);</span><br><span class="line">  registerBeanPostProcessors(beanFactory, orderedPostProcessors);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Now, register all regular BeanPostProcessors.</span></span><br><span class="line">  List&lt;BeanPostProcessor&gt; nonOrderedPostProcessors = <span class="keyword">new</span> ArrayList&lt;&gt;(nonOrderedPostProcessorNames.size());</span><br><span class="line">  <span class="keyword">for</span> (String ppName : nonOrderedPostProcessorNames) &#123;</span><br><span class="line">    BeanPostProcessor pp = beanFactory.getBean(ppName, BeanPostProcessor.class);</span><br><span class="line">    nonOrderedPostProcessors.add(pp);</span><br><span class="line">    <span class="keyword">if</span> (pp <span class="keyword">instanceof</span> MergedBeanDefinitionPostProcessor) &#123;</span><br><span class="line">      internalPostProcessors.add(pp);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  registerBeanPostProcessors(beanFactory, nonOrderedPostProcessors);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Finally, re-register all internal BeanPostProcessors.</span></span><br><span class="line">  sortPostProcessors(internalPostProcessors, beanFactory);</span><br><span class="line">  registerBeanPostProcessors(beanFactory, internalPostProcessors);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Re-register post-processor for detecting inner beans as ApplicationListeners,</span></span><br><span class="line">  <span class="comment">// moving it to the end of the processor chain (for picking up proxies etc).</span></span><br><span class="line">  beanFactory.addBeanPostProcessor(<span class="keyword">new</span> ApplicationListenerDetector(applicationContext));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>要点1：优先处理实现了<code>PriorityOrdered</code>的处理器，其次是<code>Ordered</code>，其实吃没有实现排序接口的</li>
<li>要点2：实现了<code>MergedBeanDefinitionPostProcessor</code>的处理器将被重新注册，即位置移到最后面</li>
<li>要点3：<code>ApplicationListenerDetector</code>将被重新注册</li>
</ul>
<h3 id="初始化MessageSource"><a href="#初始化MessageSource" class="headerlink" title="初始化MessageSource"></a>初始化MessageSource</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">initMessageSource</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  ConfigurableListableBeanFactory beanFactory = getBeanFactory();</span><br><span class="line">  <span class="comment">// 如果容器中已经定义了messageSource，则直接使用它</span></span><br><span class="line">  <span class="keyword">if</span> (beanFactory.containsLocalBean(MESSAGE_SOURCE_BEAN_NAME)) &#123;</span><br><span class="line">    <span class="keyword">this</span>.messageSource = beanFactory.getBean(MESSAGE_SOURCE_BEAN_NAME, MessageSource.class);</span><br><span class="line">    <span class="comment">// Make MessageSource aware of parent MessageSource.</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">this</span>.parent != <span class="keyword">null</span> &amp;&amp; <span class="keyword">this</span>.messageSource <span class="keyword">instanceof</span> HierarchicalMessageSource) &#123;</span><br><span class="line">      HierarchicalMessageSource hms = (HierarchicalMessageSource) <span class="keyword">this</span>.messageSource;</span><br><span class="line">      <span class="keyword">if</span> (hms.getParentMessageSource() == <span class="keyword">null</span>) &#123;</span><br><span class="line">        hms.setParentMessageSource(getInternalParentMessageSource());</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 否则直接使用DelegatingMessageSource实例，它是一个空的内容，仅仅是为了调用不出错。</span></span><br><span class="line">  <span class="keyword">else</span> &#123;</span><br><span class="line">    DelegatingMessageSource dms = <span class="keyword">new</span> DelegatingMessageSource();</span><br><span class="line">    dms.setParentMessageSource(getInternalParentMessageSource());</span><br><span class="line">    <span class="keyword">this</span>.messageSource = dms;</span><br><span class="line">    <span class="comment">// 向容器中注入刚刚创建的MessageSource</span></span><br><span class="line">    beanFactory.registerSingleton(MESSAGE_SOURCE_BEAN_NAME, <span class="keyword">this</span>.messageSource);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>要点1：我们可以自定义<code>MessageSource</code>注入到容器</li>
<li>要点2：如果不注入一个<code>MessageSource</code>，<code>getMessage()</code>将不会返回内容</li>
</ul>
<p>好奇：前面我们分析了<code>MessageSource</code>，明明使用的<code>ResourceBundleMessageSource</code>，这里却不是这样的？</p>
<h3 id="初始化事件广播器"><a href="#初始化事件广播器" class="headerlink" title="初始化事件广播器"></a>初始化事件广播器</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">initApplicationEventMulticaster</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  ConfigurableListableBeanFactory beanFactory = getBeanFactory();</span><br><span class="line">	<span class="comment">// 如果容器中存在了applicationEventMulticaster，则直接使用</span></span><br><span class="line">  <span class="keyword">if</span> (beanFactory.containsLocalBean(APPLICATION_EVENT_MULTICASTER_BEAN_NAME)) &#123;</span><br><span class="line">    <span class="keyword">this</span>.applicationEventMulticaster =</span><br><span class="line">      beanFactory.getBean(APPLICATION_EVENT_MULTICASTER_BEAN_NAME, ApplicationEventMulticaster.class);、</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 否则，使用SimpleApplicationEventMulticaster</span></span><br><span class="line">  <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="keyword">this</span>.applicationEventMulticaster = <span class="keyword">new</span> SimpleApplicationEventMulticaster(beanFactory);</span><br><span class="line">    beanFactory.registerSingleton(APPLICATION_EVENT_MULTICASTER_BEAN_NAME, <span class="keyword">this</span>.applicationEventMulticaster);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>要点1：<code>SimpleApplicationEventMulticaster</code>是没有线程池的，事件是同步调用的。</p>
<h3 id="注册事件监听器"><a href="#注册事件监听器" class="headerlink" title="注册事件监听器"></a>注册事件监听器</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">registerListeners</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="comment">// 先注册之前手动添加的监听器</span></span><br><span class="line">  <span class="keyword">for</span> (ApplicationListener&lt;?&gt; listener : getApplicationListeners()) &#123;</span><br><span class="line">    getApplicationEventMulticaster().addApplicationListener(listener);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Do not initialize FactoryBeans here: We need to leave all regular beans</span></span><br><span class="line">  <span class="comment">// uninitialized to let post-processors apply to them!</span></span><br><span class="line">  <span class="comment">// 从容器中找出监听器，注册，注意现在不要获取实例，因为还没应用后置处理器</span></span><br><span class="line">  String[] listenerBeanNames = getBeanNamesForType(ApplicationListener.class, <span class="keyword">true</span>, <span class="keyword">false</span>);</span><br><span class="line">  <span class="keyword">for</span> (String listenerBeanName : listenerBeanNames) &#123;</span><br><span class="line">    getApplicationEventMulticaster().addApplicationListenerBean(listenerBeanName);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 前面积攒了一堆现在就要发的事件，但是因为没有初始化广播器而没发，这里发一下</span></span><br><span class="line">  Set&lt;ApplicationEvent&gt; earlyEventsToProcess = <span class="keyword">this</span>.earlyApplicationEvents;</span><br><span class="line">  <span class="keyword">this</span>.earlyApplicationEvents = <span class="keyword">null</span>;</span><br><span class="line">  <span class="keyword">if</span> (!CollectionUtils.isEmpty(earlyEventsToProcess)) &#123;</span><br><span class="line">    <span class="keyword">for</span> (ApplicationEvent earlyEvent : earlyEventsToProcess) &#123;</span><br><span class="line">      getApplicationEventMulticaster().multicastEvent(earlyEvent);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>要点1：监听器来自两方面，一个是初始化过程中添加的，二是容器中注入的Bean</p>
<h3 id="BeanFactory初始化的收尾工作"><a href="#BeanFactory初始化的收尾工作" class="headerlink" title="BeanFactory初始化的收尾工作"></a>BeanFactory初始化的收尾工作</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">finishBeanFactoryInitialization</span><span class="params">(ConfigurableListableBeanFactory beanFactory)</span> </span>&#123;</span><br><span class="line">   <span class="comment">// Initialize conversion service for this context.</span></span><br><span class="line">   <span class="keyword">if</span> (beanFactory.containsBean(CONVERSION_SERVICE_BEAN_NAME) &amp;&amp;</span><br><span class="line">         beanFactory.isTypeMatch(CONVERSION_SERVICE_BEAN_NAME, ConversionService.class)) &#123;</span><br><span class="line">      beanFactory.setConversionService(</span><br><span class="line">            beanFactory.getBean(CONVERSION_SERVICE_BEAN_NAME, ConversionService.class));</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="comment">// Register a default embedded value resolver if no BeanFactoryPostProcessor</span></span><br><span class="line">   <span class="comment">// (such as a PropertySourcesPlaceholderConfigurer bean) registered any before:</span></span><br><span class="line">   <span class="comment">// at this point, primarily for resolution in annotation attribute values.</span></span><br><span class="line">   <span class="keyword">if</span> (!beanFactory.hasEmbeddedValueResolver()) &#123;</span><br><span class="line">      beanFactory.addEmbeddedValueResolver(strVal -&gt; getEnvironment().resolvePlaceholders(strVal));</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="comment">// Initialize LoadTimeWeaverAware beans early to allow for registering their transformers early.</span></span><br><span class="line">   String[] weaverAwareNames = beanFactory.getBeanNamesForType(LoadTimeWeaverAware.class, <span class="keyword">false</span>, <span class="keyword">false</span>);</span><br><span class="line">   <span class="keyword">for</span> (String weaverAwareName : weaverAwareNames) &#123;</span><br><span class="line">      getBean(weaverAwareName);</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="comment">// Stop using the temporary ClassLoader for type matching.</span></span><br><span class="line">   beanFactory.setTempClassLoader(<span class="keyword">null</span>);</span><br><span class="line"></span><br><span class="line">   <span class="comment">// Allow for caching all bean definition metadata, not expecting further changes.</span></span><br><span class="line">   beanFactory.freezeConfiguration();</span><br><span class="line"></span><br><span class="line">   <span class="comment">// Instantiate all remaining (non-lazy-init) singletons.</span></span><br><span class="line">   beanFactory.preInstantiateSingletons();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>要点1：取出<code>ConversionService</code></li>
<li>要点2：<code>EmbeddedValueResolver</code>，暂时看不懂</li>
<li>要点3：<code>LoadTimeWeaverAware</code>，也暂时看不懂</li>
<li>要点4：初始化所有非延迟加载的单例Bean</li>
</ul>
<h3 id="整个刷新的收尾工作"><a href="#整个刷新的收尾工作" class="headerlink" title="整个刷新的收尾工作"></a>整个刷新的收尾工作</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">finishRefresh</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="comment">// Clear context-level resource caches (such as ASM metadata from scanning).</span></span><br><span class="line">  clearResourceCaches();</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 初始化LifecycleProcessor</span></span><br><span class="line">  initLifecycleProcessor();</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 调用LifecycleProcessor的onRefresh生命周期方法</span></span><br><span class="line">  getLifecycleProcessor().onRefresh();</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 发送上下文刷新完成的事件</span></span><br><span class="line">  publishEvent(<span class="keyword">new</span> ContextRefreshedEvent(<span class="keyword">this</span>));</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">initLifecycleProcessor</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  ConfigurableListableBeanFactory beanFactory = getBeanFactory();</span><br><span class="line">  <span class="keyword">if</span> (beanFactory.containsLocalBean(LIFECYCLE_PROCESSOR_BEAN_NAME)) &#123;</span><br><span class="line">    <span class="keyword">this</span>.lifecycleProcessor = beanFactory.getBean(LIFECYCLE_PROCESSOR_BEAN_NAME, LifecycleProcessor.class);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="comment">// 默认使用DefaultLifecycleProcessor</span></span><br><span class="line">    DefaultLifecycleProcessor defaultProcessor = <span class="keyword">new</span> DefaultLifecycleProcessor();</span><br><span class="line">    defaultProcessor.setBeanFactory(beanFactory);</span><br><span class="line">    <span class="keyword">this</span>.lifecycleProcessor = defaultProcessor;</span><br><span class="line">    beanFactory.registerSingleton(LIFECYCLE_PROCESSOR_BEAN_NAME, <span class="keyword">this</span>.lifecycleProcessor);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>要点：<code>LifecycleProcessor</code>是在这里创建的</p>
<h3 id="小结-3"><a href="#小结-3" class="headerlink" title="小结"></a>小结</h3><p>总结一下，<code>ApplicationContext</code>初始化时，大致做了下面这些事，也就是说，前面”关键组件“中提到的内容，这里都进行了初始化。</p>
<ul>
<li><p>初始化了<code>Environment</code>的属性源</p>
</li>
<li><p>注册了表达式解析器，用于解析Bean中出现的表达式，SPEL表达式也包含在其中。</p>
</li>
<li><p>注册了Bean后置处理器，分优先级，优先<code>ProirityOrdered</code>，其次<code>Ordered</code>，最后是其它。</p>
</li>
<li><p>初始化了<code>MessageSource</code></p>
</li>
<li><p>创建了事件广播器，事件监听器，并将二者进行结合</p>
</li>
<li><p>注册了生命周期处理器，用于处理<code>Lifecycle</code>相关内容</p>
</li>
<li><p>注册了<code>ConversionService</code>、<code>PropertyEditor</code>，用于类型转换</p>
</li>
</ul>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>这篇文章虽然很长，但内容覆盖其实没多少：解读了一下主要组件，看了看容器启动时的行为。就这，还留了Bean抽象和管理的尾巴留待今后探索。但它花了我很长时间，准备用了一周的工作日业余时间，写用了一整天。各种小组件，真的很多，而且都是自己抽象的。不过说到底，还是我太菜🤔。</p>
<p><strong>一些类的命名方式</strong></p>
<ul>
<li>xxxxSupport：一般是针对xxxx接口的基本实现类，如PropertyEditorRegistrySupport</li>
<li>xxxxDelegate：针对xxxx功能的帮助类，如TypeConverterDelegate</li>
<li>Abstractxxxx：模板方法的体现，实现了xxxx的大部分功能，只有小部分让子类实现</li>
<li>xxxxRegistry：注册器，持有xxxx的一个集合器，支持向其中注册添加</li>
<li>xxxxResolver：解析器，一般用来解析特性的xxxx对象或字符串</li>
</ul>
]]></content>
      <categories>
        <category>Spring</category>
      </categories>
      <tags>
        <tag>Spring</tag>
      </tags>
  </entry>
  <entry>
    <title>k3s+rancher初体验</title>
    <url>/2022/04/21/k3s-rancher%E5%88%9D%E4%BD%93%E9%AA%8C/</url>
    <content><![CDATA[<blockquote>
<p>记一记k3s+rancher搭建遇到的问题，使用感受。</p>
</blockquote>
<span id="more"></span>

<h1 id="事情经过"><a href="#事情经过" class="headerlink" title="事情经过"></a>事情经过</h1><p>因为一个临时的发布需求，购买了一台临时的海外ECS。虽然都在阿里云上，但由于不同地域，因此并不能将其加到现有ACK管理，于是我有以下几种选择</p>
<ul>
<li><p>方案一：ECS裸用，使用进程管理工具如superctl对应用发布进行管理；或者直接用docker管理</p>
</li>
<li><p>方案二：新建同地域ACK，将ECS作为工作节点加入</p>
</li>
<li><p>方案三：也别用ECS了，直接建一个该地域的ASK吧</p>
</li>
<li><p>方案四：自建K8s，但要足够轻量</p>
</li>
</ul>
<p>方案一不好管控，不停机方案比较难搞；方案二、方案三的附加费用可能比这台ECS还高；方案四，有k3s这种易于安装，占用资源低的k8s版本，值得一试。</p>
<p>ACK有Web UI，新建的k3s也得有一个UI管理界面吧，不然命令行管理可不大人道。于是又有几个选择</p>
<ul>
<li>lens</li>
<li>rancher</li>
<li>kubesphere</li>
</ul>
<p>lens的优点在于简洁，但它是本地客户端，无法给别人使用，且资源编辑时只能编辑yaml文件，不够友好；rancher和阿里云提供的Web UI类似，将k8s资源一一映射为具体的UI组件；kubesphere更加抽象，对无k8s基础的人来过更加友好。</p>
<p>rancher和k3s是一家，选用rancher。至此，我们有了k3s+rancher这对组合</p>
<h1 id="手册"><a href="#手册" class="headerlink" title="手册"></a>手册</h1><p>使用前先读手册，可以避免绝大多数坑，不要想一下子成功，那样只会花费更多时间，还会怀疑自己的智商，或者抱怨设计不易用。易用不易用，你已经用了。</p>
<ul>
<li><a href="https://docs.rancher.cn/docs/k3s/_index/">K3S</a> ，重点关注几个点<ul>
<li><a href="https://docs.rancher.cn/docs/k3s/quick-start/_index">安装方式</a> ，注意有国内安装方式</li>
<li>安装好后的<a href="https://docs.rancher.cn/docs/k3s/cluster-access/_index">集群访问方式</a></li>
<li><a href="https://docs.rancher.cn/docs/k3s/storage/_index">卷和存储</a> ：了解如何使用本地磁盘作为存储卷（而不是云盘）</li>
<li><a href="https://docs.rancher.cn/docs/k3s/networking/_index">网络</a>：了解如何使用本地端口暴露一个Service（而不是负载均衡）</li>
</ul>
</li>
<li><a href="https://docs.rancher.cn/rancher2.5/">Rancher</a> ，关注以下<ul>
<li><a href="https://docs.rancher.cn/docs/rancher2.5/overview/architecture/_index">Rancher是什么</a>：Rancher是一个容器编排管理平台——管理管理容器的平台。核心优势是能够托管多个平台的K8s</li>
<li><a href="https://docs.rancher.cn/docs/rancher2.5/installation/other-installation-methods/single-node-docker/_index/">裸机安装，直接docker run</a></li>
<li><a href="https://docs.rancher.cn/docs/rancher2.5/installation/install-rancher-on-k8s/_index/">安装在k8s集群内</a></li>
</ul>
</li>
</ul>
<h1 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h1><h2 id="安装K3s"><a href="#安装K3s" class="headerlink" title="安装K3s"></a>安装K3s</h2><p>一键安装，但要注意的是加上安装节点所在的IP地址，否则在导出kubeconfig使用时会报证书不可用</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">curl -sLS https://get.k3s.io | INSTALL_K3S_EXEC=&#x27;server --tls-san 198.11.180.138&#x27; sh -</span><br></pre></td></tr></table></figure>

<h2 id="安装Rancher"><a href="#安装Rancher" class="headerlink" title="安装Rancher"></a>安装Rancher</h2><p>同样是一键安装，没有特殊注意事项。</p>
<p>如果是安装在集群，需要用ingress将rancher-server暴露出来。</p>
<p>不过我的安装过程是，安装在k3s -&gt; 卸载后安装rancher agent -&gt; rancher server安装在单独的机器，因此遇到过一些问题，下一节记录</p>
<h2 id="问题记录"><a href="#问题记录" class="headerlink" title="问题记录"></a>问题记录</h2><p><strong>问题：从集群中删除rancher server时，几个命名空间无法删除</strong></p>
<p>参考<a href="https://www.xtplayer.cn/kubernetes/forces-delete-terminated-namespace/#rancher-%E8%87%AA%E5%AE%9A%E4%B9%89-k8s-%E9%9B%86%E7%BE%A4%E6%88%96%E8%80%85%E5%AF%BC%E5%85%A5-rancher-%E7%AE%A1%E7%90%86%E7%9A%84-k8s-%E9%9B%86%E7%BE%A4">这篇文章</a>解决。因为卡在依赖资源的删除上。</p>
<p><strong>问题：删除rancher-server，重新安装rancher-agent时，报错，报错内容如下</strong></p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">Error from server (InternalError): error when creating &quot;STDIN&quot;: Internal error occurred: failed calling webhook &quot;rancher.cattle.io&quot;: failed to call webhook: Post &quot;https://rancher-webhook.cattle-system.svc:443/v1/webhook/mutation?timeout=10s&quot;: service &quot;rancher-webhook&quot; not found</span><br></pre></td></tr></table></figure>

<p>参考<a href="https://forums.rancher.com/t/rancher-webhook-fails-due-to-not-existing-rancher-webhook-tls-secret/36211/2">这篇文章</a>解决，主要是重新安装时有一个资源不会被重建，这里删除然后重新执行安装命令。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">kubectl delete -n cattle-system MutatingWebhookConfiguration rancher.cattle.io</span><br></pre></td></tr></table></figure>

<p>这一问题在官方手册得以佐证：<a href="https://docs.rancher.cn/docs/rancher2.5/releases/v2.5.12/">https://docs.rancher.cn/docs/rancher2.5/releases/v2.5.12/</a></p>
<p><img src="https://gdz.oss-cn-shenzhen.aliyuncs.com/local/image-20220421185559558.png" alt="image-20220421185559558"></p>
<p><strong>问题：安装rancher-agent启动时提示ca token找不到</strong></p>
<p>再次执行rancher删除命令，完成后重新安装</p>
<p><strong>问题：安装rancher-agent启动时提示<code>the server could not find the requested resource</code></strong></p>
<p>是rancher 2.5.12不支持k8s 1.21及以上：<a href="https://forums.rancher.com/t/install-fail-the-server-could-not-find-the-requested-resource/20974/2">https://forums.rancher.com/t/install-fail-the-server-could-not-find-the-requested-resource/20974/2</a></p>
<p><img src="https://gdz.oss-cn-shenzhen.aliyuncs.com/local/image-20220421185707248.png" alt="image-20220421185707248"></p>
<p>解决方法是切换到rancher 2.6</p>
<p><strong>问题：rancher 2.6没有切换中文的按钮</strong></p>
<p>自己添加cookie</p>
<p><img src="https://gdz.oss-cn-shenzhen.aliyuncs.com/local/image-20220421185748342.png" alt="image-20220421185748342"></p>
<h1 id="使用体验"><a href="#使用体验" class="headerlink" title="使用体验"></a>使用体验</h1><h2 id="K3s"><a href="#K3s" class="headerlink" title="K3s"></a>K3s</h2><p>如果我们把k3s当做单机的增强，那它简直是完美，应用管理用的k8s的方式，端口、ip地址等却还是依照单机的方式，还要啥自行车。目前为止，使用下来唯一的不便是traefik ingress controller替换nginx ingress controller带来的，需要使用Middleware进行路径前缀截断。</p>
<h2 id="Racher"><a href="#Racher" class="headerlink" title="Racher"></a>Racher</h2><p>类似各大云厂商的Web UI，Rancher的UI与K8s资源基本上是一一对应的，差别就在于呈现方式了。算是风格问题，这方面，我认为优缺点如下</p>
<ul>
<li><p>优点：多命名空间可同页展示</p>
</li>
<li><p>优点：控制台和日志同页显示，查看方便</p>
<p><img src="https://gdz.oss-cn-shenzhen.aliyuncs.com/local/image-20220421191229102.png" alt="image-20220421191229102"></p>
</li>
<li><p>缺点：页面跳转太多，一些短小配置的编写如ingress都要跳转新的页面，使用者容易失焦，不如阿里云</p>
</li>
<li><p>缺点：页面没有按照资源的从属关系引导，如从deployment进入pod，没有按钮回到deployment页</p>
<img src="https://gdz.oss-cn-shenzhen.aliyuncs.com/local/image-20220421191549227.png" alt="image-20220421191549227" style="zoom:80%;" /></li>
<li><p>缺点：应用页面显示内容太少，仅显示了应用引用的资源，未显示引用应用的资源如service、ingress（有，但是不显示），不如阿里云</p>
</li>
</ul>
<p><strong>总的来说，就是操作链不完整，中途会断</strong></p>
<h1 id="所有集群都用Rancher统一管理好不好"><a href="#所有集群都用Rancher统一管理好不好" class="headerlink" title="所有集群都用Rancher统一管理好不好"></a>所有集群都用Rancher统一管理好不好</h1><p>首先，我觉得rancher并不好用。用不用都看情况。</p>
<p>如果用Rancher统一管理，我能想到的理由是</p>
<ul>
<li>跨云平台统一管理K8s，减少登录多个云账号的麻烦</li>
</ul>
<p>如果不用Rancher管理，我能想到的理由是</p>
<ul>
<li>UI交互不够友好</li>
<li>各云厂商有针对自己的K8s实现在Web UI上做优化，使用Rancher可能抹平这个优点</li>
</ul>
]]></content>
      <categories>
        <category>运维</category>
      </categories>
      <tags>
        <tag>rancher</tag>
        <tag>k3s</tag>
      </tags>
  </entry>
  <entry>
    <title>pipenv - python包管理和虚拟环境工具</title>
    <url>/2019/12/07/pipenv%20-%20python%E5%8C%85%E7%AE%A1%E7%90%86%E5%92%8C%E8%99%9A%E6%8B%9F%E7%8E%AF%E5%A2%83%E5%B7%A5%E5%85%B7-pipenv-python%E5%8C%85%E7%AE%A1%E7%90%86%E5%92%8C%E8%99%9A%E6%8B%9F%E7%8E%AF%E5%A2%83%E5%B7%A5%E5%85%B7/</url>
    <content><![CDATA[<p>Pipenv是一个包管理和虚拟环境工具，致力于将所有的打包工具（bundler, composer, npm, cargo, yarn等）中的优点带到python世界。它将pip和virtualenv结合起来，为每个project创建一个虚拟环境，同时通过Pipfile指定需要安装的依赖，并自动解析依赖的依赖，生成的Pipfile.lock将各依赖版本锁定，以使各个环境保持一致。</p>
<span id="more"></span>
<h2 id="简单使用"><a href="#简单使用" class="headerlink" title="简单使用"></a>简单使用</h2><p>假设场景：创建一个新项目，访问某度，输出访问结果。使用Pycharm创建，目录结构和代码如下。</p>
<p><img src="image-20191207113857861.png" alt="image-20191207113857861"></p>
<ul>
<li><p>安装pipenv</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">python3.8 -m pip install pipenv</span><br></pre></td></tr></table></figure></li>
<li><p>安装依赖</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">pipenv install requests</span><br></pre></td></tr></table></figure>

<p>初次安装依赖会先初始化虚拟环境，然后将requests写入Pipfile文件并下载，整个安装过程控制台输出如下</p>
<p><img src="image-20191207114240569.png" alt="image-20191207114240569"></p>
<p>安装完成后目录结构：新生成Pipfile和Pipfile.lock两个文件</p>
<p><img src="image-20191207114424866.png" alt="image-20191207114424866"></p>
</li>
<li><p>运行代码</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">pipenv run python test.py</span><br></pre></td></tr></table></figure>

<p><img src="image-20191207114905560.png" alt="image-20191207114905560"></p>
</li>
</ul>
<p>可以看到，非常简单，但还是不免出错，这里列出我遇到过的问题</p>
<ul>
<li><p>pip安装后找不到pipenv命令</p>
<p>这和pipenv的安装没有关系，是python配置的问题，可通过绝对路径调用，新安装的命令位置一般在pip对应的python安装位置的bin目录下。</p>
</li>
<li><p>运行pipenv run python时将virtualenv目录定位到/root/.local/share/..目录下，导致Permission deny</p>
<p>由于暂时不了解pipenv确定虚拟环境安装目录的依据，因此我的解决方案时让他安装在一个明确的位置——项目目录，方式是设置环境变量PIPENV_VENV_IN_project=”true”</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">export PIPENV_VENV_IN_project=&quot;true&quot;</span><br></pre></td></tr></table></figure></li>
</ul>
<h2 id="执行结果分析"><a href="#执行结果分析" class="headerlink" title="执行结果分析"></a>执行结果分析</h2><h3 id="虚拟环境"><a href="#虚拟环境" class="headerlink" title="虚拟环境"></a>虚拟环境</h3><p>初次运行时pipenv会在某个位置为当前项目创建一个唯一的虚拟环境，该位置一般为执行用户的目录，上例中是/home/floyd/.local/share/virtualenvs/demo-G7_K1YDZ。如果觉得该位置不好，也可以设置系统环境变量PIPENV_VENV_IN_project=”true”建立在当前项目目录，这是我比较倾向的方式，方便管理。</p>
<p>一旦虚拟环境安装完成，后面所有针对pipenv的操作均是在该环境中进行，包括库的安装、任务的执行等。注意这种<strong>非全局性</strong>，这样OK，保证了隔离性，但也意味着我们必须对每个项目重新安装一次相同的依赖，很麻烦，尤其是经常需要创建多个项目的场景；使用IDE时也会带来问题：IDE默认解释器是全局的，因此即使使用pipenv安装完成，也会报import错误，因为全局python的路径中并无该库，这会造成一定程度上的困扰。</p>
<h3 id="Pipfile"><a href="#Pipfile" class="headerlink" title="Pipfile"></a>Pipfile</h3><p>通过pipenv install安装的依赖会写入此文件，本例中初始内容如下。pipfile有着较为丰富的表现力，可以直接修改然后运行pipenv install裸命令完全按照该文件进行下载。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">[[source]]</span><br><span class="line">name = <span class="string">&quot;pypi&quot;</span></span><br><span class="line">url = <span class="string">&quot;https://pypi.org/simple&quot;</span></span><br><span class="line">verify_ssl = true</span><br><span class="line"></span><br><span class="line">[dev-packages]</span><br><span class="line"></span><br><span class="line">[packages]</span><br><span class="line">requests = <span class="string">&quot;*&quot;</span></span><br><span class="line"></span><br><span class="line">[requires]</span><br><span class="line">python_version = <span class="string">&quot;3.8&quot;</span></span><br></pre></td></tr></table></figure>

<p>我们能操作的事项较多，例如可以自由更换源，设置dev和prod环境依赖的不同，指定目标python版本等，甚至可以指定多个源，每个依赖使用指定的源进行下载。如下展示了我的一个正式项目中的配置</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[[source]]</span><br><span class="line">url = &quot;https://pypi.tuna.tsinghua.edu.cn/simple/&quot;</span><br><span class="line">verify_ssl = true</span><br><span class="line">name = &quot;pypi&quot;</span><br><span class="line"></span><br><span class="line">[packages]</span><br><span class="line">aliyun-log-python-sdk = &#123;version = &quot;*&quot;&#125;</span><br><span class="line">aliyun-python-sdk-core-v3 = &#123;version = &quot;*&quot;&#125;</span><br><span class="line">celery = &#123;version = &quot;*&quot;&#125;</span><br><span class="line">Django = &#123;version = &quot;==2.2.4&quot;&#125;</span><br><span class="line">django-admin = &#123;version = &quot;*&quot;&#125;</span><br><span class="line">django-postgres-extensions = &#123;version = &quot;*&quot;&#125;</span><br><span class="line">django_pgjsonb = &#123;version = &quot;*&quot;&#125;</span><br><span class="line">peewee = &#123;version = &quot;*&quot;&#125;</span><br><span class="line">psycopg2 = &#123;version = &quot;*&quot;&#125;</span><br><span class="line">PyYAML = &#123;version = &quot;*&quot;&#125;</span><br><span class="line">requests = &#123;version = &quot;*&quot;&#125;</span><br><span class="line">redis = &#123;version = &quot;*&quot;&#125;</span><br><span class="line">oss2 = &#123;version = &quot;*&quot;&#125;</span><br><span class="line">fake_useragent = &#123;version = &quot;*&quot;&#125;</span><br><span class="line">lxml = &#123;version = &quot;*&quot;&#125;</span><br><span class="line">eventlet = &#123;version = &quot;*&quot;&#125;</span><br><span class="line"></span><br><span class="line">[requires]</span><br><span class="line">python_version = &quot;3&quot;</span><br></pre></td></tr></table></figure>

<p>更多配置可参考<a href="https://pipenv.kennethreitz.org/en/latest/basics/#example-pipfile-pipfile-lock">官方手册</a></p>
<h3 id="Pipfile-lock"><a href="#Pipfile-lock" class="headerlink" title="Pipfile.lock"></a>Pipfile.lock</h3><p>一个Pipfile.lock文件如下，它固定了所有依赖和运行环境等内容，由Pipfile生成，不归我们修改，这里仅做展示。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    <span class="string">&quot;_meta&quot;</span>: &#123;</span><br><span class="line">        <span class="string">&quot;hash&quot;</span>: &#123;</span><br><span class="line">            <span class="string">&quot;sha256&quot;</span>: <span class="string">&quot;acbc8c4e7f2f98f1059b2a93d581ef43f4aa0c9741e64e6253adff8e35fbd99e&quot;</span></span><br><span class="line">        &#125;,</span><br><span class="line">        <span class="string">&quot;pipfile-spec&quot;</span>: <span class="number">6</span>,</span><br><span class="line">        <span class="string">&quot;requires&quot;</span>: &#123;</span><br><span class="line">            <span class="string">&quot;python_version&quot;</span>: <span class="string">&quot;3.8&quot;</span></span><br><span class="line">        &#125;,</span><br><span class="line">        <span class="string">&quot;sources&quot;</span>: [</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="string">&quot;name&quot;</span>: <span class="string">&quot;pypi&quot;</span>,</span><br><span class="line">                <span class="string">&quot;url&quot;</span>: <span class="string">&quot;https://pypi.org/simple&quot;</span>,</span><br><span class="line">                <span class="string">&quot;verify_ssl&quot;</span>: true</span><br><span class="line">            &#125;</span><br><span class="line">        ]</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="string">&quot;default&quot;</span>: &#123;</span><br><span class="line">        <span class="string">&quot;certifi&quot;</span>: &#123;</span><br><span class="line">            <span class="string">&quot;hashes&quot;</span>: [</span><br><span class="line">                <span class="string">&quot;sha256:017c25db2a153ce562900032d5bc68e9f191e44e9a0f762f373977de9df1fbb3&quot;</span>,</span><br><span class="line">                <span class="string">&quot;sha256:25b64c7da4cd7479594d035c08c2d809eb4aab3a26e5a990ea98cc450c320f1f&quot;</span></span><br><span class="line">            ],</span><br><span class="line">            <span class="string">&quot;version&quot;</span>: <span class="string">&quot;==2019.11.28&quot;</span></span><br><span class="line">        &#125;,</span><br><span class="line">        <span class="string">&quot;chardet&quot;</span>: &#123;</span><br><span class="line">            <span class="string">&quot;hashes&quot;</span>: [</span><br><span class="line">                <span class="string">&quot;sha256:84ab92ed1c4d4f16916e05906b6b75a6c0fb5db821cc65e70cbd64a3e2a5eaae&quot;</span>,</span><br><span class="line">                <span class="string">&quot;sha256:fc323ffcaeaed0e0a02bf4d117757b98aed530d9ed4531e3e15460124c106691&quot;</span></span><br><span class="line">            ],</span><br><span class="line">            <span class="string">&quot;version&quot;</span>: <span class="string">&quot;==3.0.4&quot;</span></span><br><span class="line">        &#125;,</span><br><span class="line">        <span class="string">&quot;idna&quot;</span>: &#123;</span><br><span class="line">            <span class="string">&quot;hashes&quot;</span>: [</span><br><span class="line">                <span class="string">&quot;sha256:c357b3f628cf53ae2c4c05627ecc484553142ca23264e593d327bcde5e9c3407&quot;</span>,</span><br><span class="line">                <span class="string">&quot;sha256:ea8b7f6188e6fa117537c3df7da9fc686d485087abf6ac197f9c46432f7e4a3c&quot;</span></span><br><span class="line">            ],</span><br><span class="line">            <span class="string">&quot;version&quot;</span>: <span class="string">&quot;==2.8&quot;</span></span><br><span class="line">        &#125;,</span><br><span class="line">        <span class="string">&quot;requests&quot;</span>: &#123;</span><br><span class="line">            <span class="string">&quot;hashes&quot;</span>: [</span><br><span class="line">                <span class="string">&quot;sha256:11e007a8a2aa0323f5a921e9e6a2d7e4e67d9877e85773fba9ba6419025cbeb4&quot;</span>,</span><br><span class="line">                <span class="string">&quot;sha256:9cf5292fcd0f598c671cfc1e0d7d1a7f13bb8085e9a590f48c010551dc6c4b31&quot;</span></span><br><span class="line">            ],</span><br><span class="line">            <span class="string">&quot;index&quot;</span>: <span class="string">&quot;pypi&quot;</span>,</span><br><span class="line">            <span class="string">&quot;version&quot;</span>: <span class="string">&quot;==2.22.0&quot;</span></span><br><span class="line">        &#125;,</span><br><span class="line">        <span class="string">&quot;urllib3&quot;</span>: &#123;</span><br><span class="line">            <span class="string">&quot;hashes&quot;</span>: [</span><br><span class="line">                <span class="string">&quot;sha256:a8a318824cc77d1fd4b2bec2ded92646630d7fe8619497b142c84a9e6f5a7293&quot;</span>,</span><br><span class="line">                <span class="string">&quot;sha256:f3c5fd51747d450d4dcf6f923c81f78f811aab8205fda64b0aba34a4e48b0745&quot;</span></span><br><span class="line">            ],</span><br><span class="line">            <span class="string">&quot;version&quot;</span>: <span class="string">&quot;==1.25.7&quot;</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="string">&quot;develop&quot;</span>: &#123;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="Pycharm配置pipenv"><a href="#Pycharm配置pipenv" class="headerlink" title="Pycharm配置pipenv"></a>Pycharm配置pipenv</h1><blockquote>
<p>更新于次日</p>
</blockquote>
<p>上面的例子说到，安装pipenv并创建虚拟环境后，新安装的库不会在全局解释器中生效，导致Pycharm无法给予正确的提示，非常不便。而Pycharm实际上是提供将解释器设置为pipenv的方式，可以解决这个问题。这里以已经存在的项目为例进行pipenv环境配置，按下列方式进入设置界面</p>
<p>File =&gt; Settings =&gt; Project:{你的项目名} =&gt; Project Intercepter</p>
<p><img src="image-20191209145003311.png" alt="image-20191209145003311"></p>
<p>点击图中标记设置图片，选择“Add”，来到解释器添加界面。选择Pipenv Environment。两项需要填写：</p>
<ul>
<li>Base intercepter: 选择你安装pipenv的python可执行文件</li>
<li>Pipenv executable: 选择你事先安装的pipenv的执行文件</li>
</ul>
<p><img src="image-20191209145341432.png" alt="image-20191209145341432"></p>
<blockquote>
<ul>
<li>注意事项1： 在Pycharm中添加pipenv环境前必须先手动将原先生成的virtualenv文件夹删除，否则会出现环境设置失败的情况。</li>
<li>注意事项2： 该配置方式在IDEA中同样适用，因为Pycharm本就是IDEA的子集</li>
</ul>
</blockquote>
<h1 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h1><ol>
<li><a href="https://pipenv.kennethreitz.org/en/latest/install/">pipenv官方手册</a></li>
<li><a href="https://www.jetbrains.com/help/idea/pipenv.html">Configure Pipenv environments（IntelliJ IDEA官方手册）</a></li>
</ol>
]]></content>
      <categories>
        <category>编程语言</category>
        <category>工具</category>
      </categories>
      <tags>
        <tag>pipenv</tag>
      </tags>
  </entry>
  <entry>
    <title>java时间 - java.time介绍</title>
    <url>/2020/04/11/java%E6%97%B6%E9%97%B4%20-%20java.time%E4%BB%8B%E7%BB%8D-java%E6%97%B6%E9%97%B4-javatime%E4%BB%8B%E7%BB%8D/</url>
    <content><![CDATA[<p>Java8中引入了新的库java.time，提供更为好用的日志API，从此不再在Date、Calendar这些类中纠结。本文基于<a href="https://docs.oracle.com/javase/8/docs/api/java/time/package-summary.html">java.time API文档</a>进行记录和总结。</p>
<span id="more"></span>

<h1 id="包简介"><a href="#包简介" class="headerlink" title="包简介"></a>包简介</h1><p>该包下的类定义了基础的日期-时间概念，包括instant、duration、date、time、time-zone、period等，他们都是基于ISO日历系统。</p>
<p>所有的类都是不可变的，意味着它们是线程安全的</p>
<p>各个子包的作用</p>
<ul>
<li>java.time.temporal 取得底层字段</li>
<li>java.time.format 解析字符串或格式化</li>
<li>java.time.chrono 中立的日历API</li>
</ul>
<h1 id="API介绍"><a href="#API介绍" class="headerlink" title="API介绍"></a>API介绍</h1><h2 id="核心API"><a href="#核心API" class="headerlink" title="核心API"></a>核心API</h2><h3 id="Instant"><a href="#Instant" class="headerlink" title="Instant"></a>Instant</h3><p>本质上是一个数字时间戳，即在时间线上的某一点，某一时刻。使用可以从Clock中取得。打印日志或持久化时标记时间很有用。曾和System.currentMillis()关联</p>
<p>Instant是与java.util.Date. ZonedDateTime同等的类</p>
<p>Instant的组成，包含一个long用于存储epoch秒数，即1970-01-01T00:00:00Z到现在的秒数；还有一个int用于存储纳秒。</p>
<h3 id="Clock"><a href="#Clock" class="headerlink" title="Clock"></a>Clock</h3><p>Clock提供访问当前Instant，带时区的日期和时间</p>
<p>他可以替代System.currentMillis()和TimeZone.getDefault()，用于获取当前的毫秒数和默认时区</p>
<p>时钟不是必须的，因为上面的LocalDate等类都有一个now()方法。Clock存在的意义在于允许我们将时间当做对象进行传递，因为一个Clock对象包含了比较全面的信息。</p>
<h3 id="LocalDate"><a href="#LocalDate" class="headerlink" title="LocalDate"></a>LocalDate</h3><p>仅有日期，可用于存储生日之类的数据</p>
<p>它不存储时间或时区，它仅仅是对日期的描述，不能代表时间线上的一个瞬间</p>
<p>在日期上的操作支持很好，可以访问年、月、日、年中日等</p>
<h3 id="LocalTime"><a href="#LocalTime" class="headerlink" title="LocalTime"></a>LocalTime</h3><p>仅有时间，没有日期，即所谓的wall time</p>
<h3 id="LocalDateTime"><a href="#LocalDateTime" class="headerlink" title="LocalDateTime"></a>LocalDateTime</h3><p>存储日期和时间，精确度为纳秒</p>
<p>它不存储时区，因此不能代表时间线上的一个瞬间</p>
<h3 id="ZonedDateTime"><a href="#ZonedDateTime" class="headerlink" title="ZonedDateTime"></a>ZonedDateTime</h3><p>带时区的日期和时间，在将ZoneId带入计算时非常有用。尽可能不要使用它，带有时区将使得应用变得复杂。</p>
<p>ZonedDateTime是和java.util.GregorianCalendar同等的类</p>
<h3 id="Duration"><a href="#Duration" class="headerlink" title="Duration"></a>Duration</h3><p>两个时间的差，纳秒计</p>
<h3 id="Period"><a href="#Period" class="headerlink" title="Period"></a>Period</h3><p>表示对人类有意义的一段时间，比如一年、一天</p>
<h2 id="API命名约定"><a href="#API命名约定" class="headerlink" title="API命名约定"></a>API命名约定</h2><p>java.time提供了丰富但统一的API，不同前缀代表不同意思</p>
<ul>
<li>of - 静态工厂方法</li>
<li>parse - 用于解析的静态方法</li>
<li>get - 获取</li>
<li>is - 检查是否为true</li>
<li>with - setter的不可变等价方法</li>
<li>plus - 向一个对象增加</li>
<li>minus - 减少</li>
<li>to - 将一个对象转换为另一个类型</li>
<li>at - 将一个对象和另一个对象结合，例如将LocalDate和LocalTime结合成LocalDateTime</li>
</ul>
<h1 id="闰秒的处理"><a href="#闰秒的处理" class="headerlink" title="闰秒的处理"></a>闰秒的处理</h1><p>太阳日的长度是人类测量时间的标准方法，通常一个太阳日被分为24小时60分钟60秒，形成86400秒。</p>
<p>现代计时是以原子钟为基础，它精确地定义了一个名为SI second的东西代表1秒（这是铯原子跃迁的时间），SI second非常接近86400分之一天。</p>
<p>SI second和太阳时的关系，在于前者是观测地球自转得来，是绝对意义上的准确时间；后者是计时得来的，和地球自转无关。在计算机系统中使用的时间就是计时得来。</p>
<p>然而，地球自转并不绝对稳定，使得一天的长度会发生变化；随着时间的推移，地球自转变慢，一天的平均时间边长，导致SI second和太阳时出现偏差。</p>
<p>UTC time-scale是将额外变化的时间捆绑成整秒的标准做法。现在的UTC时间于1972年提出，引入闰秒的概念，然而闰秒的定义是复杂的。鉴于此，java.time中的API定义了自己的time-scale</p>
<p>Java time-scale将每个日历日精确地划分为86400个细分，即秒。 这些秒数可能与 SI second不同。</p>
<p>Java time-scale对不同时间段的定义略有不同，每个时间段都基于作为公民时间基础的协商一致的国际时间表。 每当修改或替换国际商定的时间表时，必须为其定义新的 Java time-scale。</p>
<p>截止2013年，Java time-scale分为两部分</p>
<ul>
<li>1972-11-03至今，java time-scale和UTC一致，与UTC没有闰秒的时间相同，对于闰秒的天，闰秒被平均分配在一天的最后1000秒中，以保证每天看起来还是86400秒。即意味着这天的最后1000秒，java的每一秒都比普通的时间快或慢1ms</li>
<li>1972-11-03之前，UTC时间尚未提出，世界协商时间为UT1，相当于格林威治上的太阳时，由于没有闰秒的说法，java的time-sclae和世界协商时间一致。</li>
</ul>
<h1 id="时区ID"><a href="#时区ID" class="headerlink" title="时区ID"></a>时区ID</h1><p>时区ID在整个系统中是唯一的，总共有三种时区ID</p>
<ul>
<li><p>最简单的时区ID，以+或-开头。</p>
</li>
<li><p>带有前缀的和偏移量后缀的时区ID。如GMT+2、UTC+01:00，合法的前缀有GMT、UTC、UT。由于它有固定偏移量，因此可以调用ZoneId.normalized()标准化成一个ZoneOffset</p>
</li>
<li><p>基于地理区域的ID。必须由两个以上字符组成，且不能是UTC、GMT、UT、+、- 。基于地理区域的ID的转换规则是被定义在配置中的，由ZoneRulesProvider实现。</p>
<p>翻看ZoneRulesProvider的手册，发现对时区的配置可以自定义，按照指定的规则来即可。默认情况下，它使用了位于java home的lib文件夹下tzdb.dat文件中定义的数据加载规则。我们可以覆盖这个操作，通过设置系统变量java.time.zone.DefaultZoneRulesProvider</p>
</li>
</ul>
<p>时区由政府部门指定，且修改频繁。有好几个组织做这件事。Java默认使用IANA Time Zone Database (TZDB)的规则，其它组织包括IATA和微软。每个组织的区域ID都不一样，我们遵循默认的TZDB就好。</p>
<h2 id="时区相关类"><a href="#时区相关类" class="headerlink" title="时区相关类"></a>时区相关类</h2><ul>
<li><p>OffsetTime</p>
<p>存储相对于UTC时间的时间和偏移量，如’11:30+01:00’</p>
</li>
<li><p>OffsetDateTime</p>
<p>存储相对于UTC时间的日期时间和偏移量，如’2010-12-03T11:30+01:00’，精度也是纳秒</p>
<p>Offsetdatetime、 ZonedDateTime 和 Instant都能存储时间线上的一个瞬间，因为他们有时区或偏移量</p>
</li>
<li><p>如上两个Offset类最初是被设计用来支持网络协议和数据库操作的。因为很多数据库不支持’Europe/Paris这样的时区，但支持+02:00这样的偏移量</p>
</li>
<li><p>ZoneId</p>
<p>时区ID，是用来确定Instant和LocalDateTime之间的转换规则的，有两种ZoneID</p>
<ol>
<li>固定偏移量，相对于UTC时间，如东八区。对应子类ZoneOffset</li>
<li>地理区域，如Europe/Paris，用于对应UTC时间某个偏移量的地区，对应子类ZoneRegion</li>
</ol>
<p>实际规则由ZoneRules类描述。</p>
<p>ZoneRules定义了每个时区的时区偏移规则。这些规则对时区的历史和未来转换建模，Zoneoffsettransition用于过去时间的转换；Zoneoffsettransitionrule基于算法对未来实现转换。</p>
</li>
</ul>
<h1 id="参考文档"><a href="#参考文档" class="headerlink" title="参考文档"></a>参考文档</h1><ol>
<li><a href="https://docs.oracle.com/javase/8/docs/api/java/time/package-summary.html">java.time Java doc</a></li>
<li><a href="https://coolshell.cn/articles/7804.html">关于闰秒 - 陈皓</a></li>
</ol>
]]></content>
      <categories>
        <category>后端</category>
      </categories>
      <tags>
        <tag>时间库</tag>
      </tags>
  </entry>
  <entry>
    <title>Shell编程概览</title>
    <url>/2022/01/09/%E2%80%99shell%E2%80%98/</url>
    <content><![CDATA[<blockquote>
<p>shell常用，却从未引起重视，用到啥就查啥，甚至语法都不记得。在这样一次次的”现查“中，浪费了大量的时间。索性花上一个周末的时间，相对系统第学学它，毕竟它也不复杂。</p>
</blockquote>
<p>本文没有太多内容，正文是一张图。</p>
<p>我到B站随便找了个视频，就<a href="https://www.bilibili.com/video/BV1sq4y1K7nM">它</a>，看了下，收获颇丰。算是系统梳理吧，整个思维导图，助记。</p>
<span id="more"></span>

<p>说起来，shell也不复杂，掌握的大知识点不会超过10个。</p>
<p>图片如下，思维导图<a href="https://www.processon.com/view/link/61dada8de0b34d1be7e4ffad">本导在这</a>。</p>
<p>gocha …</p>
<p><img src="https://gdz.oss-cn-shenzhen.aliyuncs.com/local/Shell%E7%BC%96%E7%A8%8B.png" alt="Shell编程"></p>
]]></content>
      <categories>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>shell</tag>
      </tags>
  </entry>
  <entry>
    <title>容器化基石 - namespace和cgroup</title>
    <url>/2021/12/05/namespace%E5%92%8Ccgroup/</url>
    <content><![CDATA[<blockquote>
<p>本文目的是让读者对namespace和cgroup有具象的认识，并不会深入。当然，由于笔者Linux知识有限，也无法深入。</p>
</blockquote>
<p>“容器是一个与宿主机系统共享内核但与操作系统中的其它进程资源隔离的执行环境”，这是理解容器技术的核心。这句话可以翻译的更直白一点：容器是一个环境，该环境内运行的进程和操作系统中的其它进程是一样的，享受同样的硬件资源，唯一的差别是，该环境内的进程看不到其它进程的存在，操作也不会相互影响，即所谓的隔离；多个容器的运行，就是在各自的隔离环境中运行各自的进程。</p>
<span id="more"></span>

<p>容器只是一个抽象的逻辑概念，具有上述特性的就可以叫做容器，这些特性的实现，依赖于Linux操作系统提供的namespace和cgroup。namespace提供了资源隔离，保证不同namespace之前的资源操作不相互影响；cgroup提供资源限制，保障一个group内的资源使用不会超过预设。</p>
<h2 id="namespace"><a href="#namespace" class="headerlink" title="namespace"></a>namespace</h2><p>资源隔离，一个完整的运行环境，即一个所谓的容器，需要隔离的资源包括哪些呢？大致有如下几类</p>
<ul>
<li>隔离文件系统：文件操作相互不影响</li>
<li>隔离网络：容器需要有独立的IP、端口、路由规则等</li>
<li>隔离主机名：容器需要在网络中标识自己</li>
<li>隔离进程间通信：消息队列、共享内存等</li>
<li>隔离用户权限：容器内应该有完整的用户权限</li>
<li>隔离PID：容器内的PID与宿主机的PID需要隔离</li>
</ul>
<p>针对每一类，Linux在namespace上都提供了隔离支持，即有六种不同类型的namespace，每种对应不同的资源。</p>
<p><img src="https://gdz.oss-cn-shenzhen.aliyuncs.com/local/image-20211205121601427.png" alt="image-20211205121601427"></p>
<p>namespace存在的目的，就是为了实现“轻量级虚拟化服务”（即容器），这是内核级别的支持。处于同一个namespace下的进程，相互可感知，可见；处于不同namespace下的进程，完全看不到对方的存在，就像是在一个独立的操作系统中一样。</p>
<p>启动一个容器，只需要在一个全新的namespace中创建该容器的进程即可，对此，Linux通过API的方式提供支持</p>
<ul>
<li>clone()：创建一个独立的namespace的进程</li>
<li>setns()：将当前进程加入一个已经存在的namespace</li>
<li>unshare()：在原先进程上进行资源隔离，即原先进程还是处于原来的namespace，但是其创建出来的子进程在新的namespace中</li>
</ul>
<p>为此，我们可以写一个简单的代码来体验和验证资源隔离，有如下c代码</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// namespace.c</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> _GNU_SOURCE</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/wait.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sched.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;signal.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> STACK_SIZE (1024 * 1024)</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">char</span> child_stack[STACK_SIZE];</span><br><span class="line"></span><br><span class="line"><span class="keyword">char</span>* <span class="keyword">const</span> child_args[] = &#123;</span><br><span class="line">  <span class="string">&quot;/bin/bash&quot;</span>,</span><br><span class="line">  <span class="literal">NULL</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 在新的进程中</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">child_main</span><span class="params">(<span class="keyword">void</span>* args)</span> </span>&#123;</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;在子进程中!\n&quot;</span>);</span><br><span class="line">  <span class="comment">// 设置新的hostname</span></span><br><span class="line">  <span class="built_in">sethostname</span>(<span class="string">&quot;NewNamespace&quot;</span>, <span class="number">12</span>);</span><br><span class="line">  <span class="comment">// 执行bash，进入bash控制台，只有我们输入exit时才会退出bash程序，结束当前函数</span></span><br><span class="line">  <span class="built_in">execv</span>(child_args[<span class="number">0</span>], child_args);</span><br><span class="line">  <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;程序开始: \n&quot;</span>);</span><br><span class="line">  <span class="comment">// 创建子进程，子进程进行全面的资源隔离</span></span><br><span class="line">  <span class="keyword">int</span> child_pid = <span class="built_in">clone</span>(child_main, child_stack + STACK_SIZE, </span><br><span class="line">                        CLONE_NEWIPC | </span><br><span class="line">                        CLONE_NEWUTS | </span><br><span class="line">                        CLONE_NEWPID | </span><br><span class="line">                        CLONE_NEWNS | </span><br><span class="line">                        CLONE_NEWNET |</span><br><span class="line">                        CLONE_NEWUSER |</span><br><span class="line">                        SIGCHLD, <span class="literal">NULL</span>);</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;%d&quot;</span>, CLONE_NEWUTS);</span><br><span class="line">  <span class="comment">// 等待子进程结束</span></span><br><span class="line">  <span class="built_in">waitpid</span>(child_pid, <span class="literal">NULL</span>, <span class="number">0</span>);</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;已退出 \n&quot;</span>);</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在linux下编译并执行（注意：需要root用于才能执行成功）</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 编译并执行</span></span><br><span class="line">root@10-9-175-15:/home/ubuntu/docker-learn<span class="comment"># gcc -Wall namespace.c -o namespace.o &amp;&amp; ./namespace.o </span></span><br><span class="line">程序开始: </span><br><span class="line">在子进程中!</span><br><span class="line"><span class="comment"># 输出当前进程号</span></span><br><span class="line">nobody@NewNamespace:/home/ubuntu/docker-learn$ <span class="built_in">echo</span> $$</span><br><span class="line">1</span><br><span class="line"><span class="comment"># 退出bash，进程退出</span></span><br><span class="line">nobody@NewNamespace:/home/ubuntu/docker-learn$ <span class="built_in">exit</span></span><br><span class="line"><span class="built_in">exit</span></span><br><span class="line">67108864已退出</span><br></pre></td></tr></table></figure>

<p>可以看到，在新的进程中</p>
<ul>
<li>用户名由root变成了nobody，用户已经隔离</li>
<li>hostname变成了我们自己设置的NewNamespace，说明主机名进行了隔离</li>
<li>进程号为1，说明PID进行了隔离。关于PID=1在Linux中非常重要，称作init进程，有特权，起特殊作用</li>
</ul>
<p>其它几种资源隔离也有相应的验证方式，但并不妨碍理解，这里就不深究。不过由此，我们已经能够想见，类似docker、containerd、runc这类的容器实现，都是基于类似如上调用，在隔离的namespace中创建进程。</p>
<h2 id="cgroup"><a href="#cgroup" class="headerlink" title="cgroup"></a>cgroup</h2><p>namespace负责了资源隔离，但不同namespace中的资源不能无限消耗，否则很容易因为容器内程序的bug或恶意攻击导致资源耗尽，威胁其它容器的进程。于是需要有资源限制，这需要cgroup，cgroup不仅能做资源限制，还能记录资源使用统计（这个功能可以用来做。。。云服务收费），还能做任务挂起、恢复等操作。</p>
<p>cgroup中有这么几个概念：</p>
<ul>
<li><p>task：任务，标识一个进程</p>
</li>
<li><p>cgroup：控制组，表示按某种资源控制标准划分的任务组，可以包含一个或多个子系统</p>
</li>
<li><p>subsystem：子系统，即资源调度控制器，如CPU子系统、内存子系统。详细来说，docker使用了如下几种</p>
<ul>
<li>blkio：为块设备设定输入输出限制，如磁盘</li>
<li>cpu：对cpu的调度</li>
<li>cpuacct：自动生成cgroup中任务对CPU资源使用情况的报告</li>
<li>cpuset：可为cgroup中的任务分配独立的cpu和内存</li>
<li>devices：开启或关闭cgroup中任务对设备的访问</li>
<li>freezer：挂起或恢复cgroup中的任务</li>
<li>memory：设定cgroup中任务对内存使用量的限定，并生成他们对内存资源的使用报告</li>
<li>perf_event：使cgroup中的任务可以进行统一的性能测试</li>
<li>net_cls：它使用等级标识符标记网络数据包，以允许Linux流量控制程序识别从具体cgroup中生成的数据包</li>
</ul>
</li>
<li><p>hierarchy：层级关系，由一系列cgroup按照树状结构组成</p>
</li>
</ul>
<p>我们可以查看当前系统有多少种子系统</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">root@10-9-175-15:/home/ubuntu/docker-learn# mount -t cgroup</span><br><span class="line">cgroup on /sys/fs/cgroup/systemd type cgroup (rw,nosuid,nodev,noexec,relatime,xattr,name=systemd)</span><br><span class="line">cgroup on /sys/fs/cgroup/perf_event type cgroup (rw,nosuid,nodev,noexec,relatime,perf_event)</span><br><span class="line">cgroup on /sys/fs/cgroup/net_cls,net_prio type cgroup (rw,nosuid,nodev,noexec,relatime,net_cls,net_prio)</span><br><span class="line">cgroup on /sys/fs/cgroup/memory type cgroup (rw,nosuid,nodev,noexec,relatime,memory)</span><br><span class="line">cgroup on /sys/fs/cgroup/pids type cgroup (rw,nosuid,nodev,noexec,relatime,pids)</span><br><span class="line">cgroup on /sys/fs/cgroup/cpu,cpuacct type cgroup (rw,nosuid,nodev,noexec,relatime,cpu,cpuacct)</span><br><span class="line">cgroup on /sys/fs/cgroup/freezer type cgroup (rw,nosuid,nodev,noexec,relatime,freezer)</span><br><span class="line">cgroup on /sys/fs/cgroup/cpuset type cgroup (rw,nosuid,nodev,noexec,relatime,cpuset)</span><br><span class="line">cgroup on /sys/fs/cgroup/rdma type cgroup (rw,nosuid,nodev,noexec,relatime,rdma)</span><br><span class="line">cgroup on /sys/fs/cgroup/hugetlb type cgroup (rw,nosuid,nodev,noexec,relatime,hugetlb)</span><br><span class="line">cgroup on /sys/fs/cgroup/blkio type cgroup (rw,nosuid,nodev,noexec,relatime,blkio)</span><br><span class="line">cgroup on /sys/fs/cgroup/devices type cgroup (rw,nosuid,nodev,noexec,relatime,devices)</span><br></pre></td></tr></table></figure>

<p>可以看到，每个子系统在文件系统上对应了一个文件夹，下面我们看看一个运行中的docker容器的cgroup长什么样:</p>
<p>查看到本地运行的docker容器，可以看到一个id为ee4a4efd4a5b的容器</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">root@10-9-175-15:/home/ubuntu/docker-learn# docker ps</span><br><span class="line">CONTAINER ID   IMAGE          COMMAND                  CREATED         STATUS        PORTS                                      NAMES</span><br><span class="line">ee4a4efd4a5b   halohub/halo   &quot;/bin/sh -c &#x27;java -X…&quot;   10 months ago   Up 22 hours   0.0.0.0:8090-&gt;8090/tcp, :::8090-&gt;8090/tcp  halo</span><br></pre></td></tr></table></figure>

<p>查看其对应的cpu限制配置，在<code>/sys/fs/cgroup/cpu/docker/ee4a4efd4a5b2a9a6e8154bc4336bf2a7f1528205e9f53adb8443868adad7eeb</code>中</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">root@10-9-175-15:/sys/fs/cgroup/cpu/docker/ee4a4efd4a5b2a9a6e8154bc4336bf2a7f1528205e9f53adb8443868adad7eeb# ls</span><br><span class="line">cgroup.clone_children  cpuacct.usage         cpuacct.usage_percpu_sys   cpuacct.usage_user  cpu.shares      cpu.uclamp.min</span><br><span class="line">cgroup.procs           cpuacct.usage_all     cpuacct.usage_percpu_user  cpu.cfs_period_us   cpu.stat        notify_on_release</span><br><span class="line">cpuacct.stat           cpuacct.usage_percpu  cpuacct.usage_sys          cpu.cfs_quota_us    cpu.uclamp.max  tasks</span><br><span class="line"></span><br><span class="line">root@10-9-175-15:/sys/fs/cgroup/cpu/docker# tree ee4a4efd4a5b2a9a6e8154bc4336bf2a7f1528205e9f53adb8443868adad7eeb</span><br><span class="line">ee4a4efd4a5b2a9a6e8154bc4336bf2a7f1528205e9f53adb8443868adad7eeb</span><br><span class="line">├── cgroup.clone_children</span><br><span class="line">├── cgroup.procs</span><br><span class="line">├── cpuacct.stat</span><br><span class="line">├── cpuacct.usage</span><br><span class="line">├── cpuacct.usage_all</span><br><span class="line">├── cpuacct.usage_percpu</span><br><span class="line">├── cpuacct.usage_percpu_sys</span><br><span class="line">├── cpuacct.usage_percpu_user</span><br><span class="line">├── cpuacct.usage_sys</span><br><span class="line">├── cpuacct.usage_user</span><br><span class="line">├── cpu.cfs_period_us</span><br><span class="line">├── cpu.cfs_quota_us</span><br><span class="line">├── cpu.shares</span><br><span class="line">├── cpu.stat</span><br><span class="line">├── cpu.uclamp.max</span><br><span class="line">├── cpu.uclamp.min</span><br><span class="line">├── notify_on_release</span><br><span class="line">└── tasks</span><br></pre></td></tr></table></figure>

<p>可以看到有很多文件，每个文件对应一项cpu配置或监控值。注意tasks文件，是受到cgroup管理的任务，随便查看一个比如<code>cpu.cfs_quota_us</code>，即cpu配额。默认为-1，表示不限制</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">root@10-9-175-15:/sys/fs/cgroup/cpu/docker/ee4a4efd4a5b2a9a6e8154bc4336bf2a7f1528205e9f53adb8443868adad7eeb# cat cpu.cfs_quota_us </span><br><span class="line">-1</span><br></pre></td></tr></table></figure>

<p>当然我们自己也能将自己的进程添加cgroup进行限制，方法是在对应的子系统文件中创建文件夹，系统会自动在文件夹下添加上述配置文件，我们向tasks添加任务，并向指定文件中添加配置即可。</p>
<p>具体就不描述了，可以参考<a href="https://tech.meituan.com/2015/03/31/cgroups.html">这篇文章</a>和<a href="https://man7.org/linux/man-pages/man7/cgroups.7.html">官方手册</a>。</p>
<h2 id="结尾"><a href="#结尾" class="headerlink" title="结尾"></a>结尾</h2><p>可以看到，有了namespace和cgroup，在创建进程时和平时创建进程没什么两样，这样得到的容器是非常轻量的。容器和进程创建，可以类比携程和方法调用，都是利用普通的方式达成轻量快速的目标。</p>
<p>话说回来。每当看这些内容，都会感觉到自己Linux知识的匮乏，因此Linux的学习，还是很有必要的。其中最主要的，还是进程管理方式、Linux网络、文件系统等。</p>
]]></content>
      <categories>
        <category>容器</category>
      </categories>
      <tags>
        <tag>namespace</tag>
        <tag>cgroup</tag>
      </tags>
  </entry>
  <entry>
    <title>任务心态的反思</title>
    <url>/2021/08/29/%E4%BB%BB%E5%8A%A1%E5%BF%83%E6%80%81%E7%9A%84%E5%8F%8D%E6%80%9D-ren-wu-xin-tai-de-fan-si/</url>
    <content><![CDATA[<p>我们都会有一种认知闭合需求，即在做某件事时，只要有一个自认为合理的判定其完成的标准，我们就会认为这件事已经完成，从而丧失对它的兴趣。</p>
<p>这种心态，也叫做任务心态。</p>
<span id="more"></span>

<p>最为典型的，莫过于工作时的打工人心态——一件事，无论有没有达到自己期望的完成效果，但只要领导说完成了，我们就会认定它完成了，几乎也不会再花什么时间去弥补任务完成和自己的期望之间的差距。</p>
<p>还有日常所谓打卡，当然不是指所有人，至少对大多数人是这样的，打卡所定的目标，会对学习效果大打折扣，如果我们没有时间，会为了完成打卡敷衍了事，如果我们有充裕的时间，在早早地完成了打卡任务后，学习激情会几乎归于零，导致浪费接下来的时间，其效果是非常差的。</p>
<p>所以我总是说，只要是flag，是一定会倒的。</p>
<p>说这件事时，感觉是在自己啪啪打脸，随随便便就能举出一大堆</p>
<ul>
<li><p>上周写代码时，涉及到一个查询方案，在临上线前，我还会左思右想，到底如何做能够使得查询效率最高，其过程非常沉醉。但因为客观原因被临时上线使用，在线上也能够正常运行。于是我停下了继续探寻的脚步。在内心把这个任务标记为completed。</p>
<p>  但如果我能够继续探寻，对自己带来的提升，可能比之前想那么久，带来的都大。</p>
</li>
<li><p>读一本书，或者看一篇文档时，我通常是以一篇笔记或大纲梳理结尾。完成后就几乎不会再去碰它了，直到以后用到，这种时候差不多就是下次换工作面试。也就是几乎不再看它。</p>
<p>  这其实是一种损失，如果我再次基础之上进行进一步的反思，将其应用于自己之前的知识体系，这是能够带给自己真正提升的。</p>
</li>
</ul>
<p>说这些不是在否定自己，在看到相关书籍之前，我就已经隐隐约约觉察到一些问题，并在某些方面做出了反映。这是反思，提醒以后自己要做的好一点。以真正求取学问为目的，目的要纯粹，在不应该的地方，不要抱有任务心态。</p>
<p>看书时不要盯着页码，学习时不要盯着时间，写代码时不要盯着deadline，要明确自己做一件事的真正目的，眼光放长远。做到最自己负责。</p>
]]></content>
      <categories>
        <category>生活</category>
        <category>随想</category>
      </categories>
      <tags>
        <tag>日志</tag>
      </tags>
  </entry>
  <entry>
    <title>几种常用登录的调试方式</title>
    <url>/2022/07/12/%E5%87%A0%E7%A7%8D%E5%B8%B8%E7%94%A8%E7%99%BB%E5%BD%95%E7%9A%84%E8%B0%83%E8%AF%95%E6%96%B9%E5%BC%8F/</url>
    <content><![CDATA[<p>三方登录常需要客户端和服务端共同完成，对OAuth2，客户端获取授权码，服务端用授权码换取访问凭证；对OIDC，客户端获取ID Token，服务端验证其正确性用以登录之类的场景。但两端又常非同一个开发人员，服务端逻辑写好后需要客户端配合获取授权码或ID Token作为输入进行调试验证。这样效率太过低下，协调上会有困难。</p>
<p>最好是服务端能够自己获取输入参数，这里介绍常见的四种登录方式的简单调试方法：微信登录、Apple ID登录、Google登录、Facebook登录。</p>
<span id="more"></span>

<blockquote>
<p>本文的独特之处在于：</p>
<ul>
<li>不介绍登录方式，只介绍调试方式。登录方式网上大把文章</li>
<li>其它文章在介绍登录开发方式时，涉及到客户端往往比较正式，对后端程序员有一定门槛，我们需要一种快速简单的方式</li>
</ul>
</blockquote>
<h2 id="微信登录"><a href="#微信登录" class="headerlink" title="微信登录"></a>微信登录</h2><h3 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h3><p>微信登录遵循标准的OAuth 2.0协议，完整流程参考<a href="https://developers.weixin.qq.com/doc/oplatform/Website_App/WeChat_Login/Wechat_Login.html">这里</a>。</p>
<p>客户端负责：向微信服务器获取Authorization Code</p>
<p>服务端负责：用Authorization Code向微信服务器换Access Token</p>
<p>最快的方式是通过web应用的方式去访问，我们只需要构建一个url即可，如下</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">https://open.weixin.qq.com/connect/qrconnect?appid=你的appid&amp;redirect_uri=登录成功后你的重定向地址&amp;response_type=code&amp;scope=snsapi_login&amp;state=任意字符串#wechat_redirect</span><br></pre></td></tr></table></figure>

<h3 id="配置"><a href="#配置" class="headerlink" title="配置"></a>配置</h3><p>在<a href="https://open.weixin.qq.com/cgi-bin/applist?t=manage/list&page=0&num=20&openapptype=512&token=5cc982517a1152dce9872d3905f83476e762da4b&lang=zh_CN">微信开发者平台</a>创建一个web应用，两个注意事项</p>
<ul>
<li>appid即为下图框一的内容</li>
<li>回调地址必须在设置的回调域内；具体的回调子路径随便写，反正我们要的是回调地址后加的code参数</li>
</ul>
<img src="https://gdz.oss-cn-shenzhen.aliyuncs.com/local/image-20220712173418094.png" alt="image-20220712173735912" style="zoom:80%;" />

<p>如下即可得到code</p>
<img src="https://gdz.oss-cn-shenzhen.aliyuncs.com/local/image-20220712173735912.png" alt="image-20220712173735912" style="zoom:80%;" />

<h2 id="Sign-In-With-Apple"><a href="#Sign-In-With-Apple" class="headerlink" title="Sign In With Apple"></a>Sign In With Apple</h2><h3 id="原理-1"><a href="#原理-1" class="headerlink" title="原理"></a>原理</h3><p>Apple登录遵循标准的Open ID Connect 1.0协议</p>
<p>客户端负责：获取Identity Token</p>
<p>服务端负责：验证Identity Token</p>
<p>还是构建Web应用来做，<a href="https://developer.apple.com/documentation/sign_in_with_apple/sign_in_with_apple_js/configuring_your_webpage_for_sign_in_with_apple">参考文档</a>，整个html只如下即可，需要我们填写client id和重定向地址两个参数。</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">html</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">script</span> <span class="attr">type</span>=<span class="string">&quot;text/javascript&quot;</span> <span class="attr">src</span>=<span class="string">&quot;https://appleid.cdn-apple.com/appleauth/static/jsapi/appleid/1/en_US/appleid.auth.js&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">&quot;appleid-signin&quot;</span> <span class="attr">data-color</span>=<span class="string">&quot;black&quot;</span> <span class="attr">data-border</span>=<span class="string">&quot;true&quot;</span> <span class="attr">data-type</span>=<span class="string">&quot;sign in&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">script</span> <span class="attr">type</span>=<span class="string">&quot;text/javascript&quot;</span>&gt;</span><span class="javascript"></span></span><br><span class="line"><span class="javascript">      AppleID.auth.init(&#123;</span></span><br><span class="line"><span class="javascript">        <span class="attr">clientId</span> : <span class="string">&#x27;你的client id&#x27;</span>,</span></span><br><span class="line"><span class="javascript">        <span class="attr">scope</span> : <span class="string">&#x27;name email&#x27;</span>,</span></span><br><span class="line"><span class="javascript">        <span class="attr">redirectURI</span> : <span class="string">&#x27;授权成功后的回调地址&#x27;</span>,</span></span><br><span class="line"><span class="javascript">        <span class="attr">state</span> : <span class="string">&#x27;任意字符串&#x27;</span>,</span></span><br><span class="line"><span class="javascript">        <span class="attr">nonce</span> : <span class="string">&#x27;任意字符串&#x27;</span>,</span></span><br><span class="line"><span class="javascript">        <span class="attr">usePopup</span> : <span class="literal">false</span></span></span><br><span class="line"><span class="javascript">      &#125;);</span></span><br><span class="line"><span class="javascript">    </span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h3 id="配置-1"><a href="#配置-1" class="headerlink" title="配置"></a>配置</h3><p>Apple的配置比较麻烦， 具体参考如下文档</p>
<ul>
<li><a href="https://help.apple.com/developer-account/?lang=zh-ch#/devde676e696">https://help.apple.com/developer-account/?lang=zh-ch#/devde676e696</a></li>
<li><a href="https://help.apple.com/developer-account/?lang=zh-ch#/dev1c0e25352">https://help.apple.com/developer-account/?lang=zh-ch#/dev1c0e25352</a></li>
</ul>
<p>具体来说，要先配置App Id，再配Service Id（Service Id需要关联App Id）。配置完成后</p>
<p>client id即为Service Id对应的Identifier</p>
<img src="https://gdz.oss-cn-shenzhen.aliyuncs.com/local/image-20220712175821565.png" alt="image-20220712175821565" style="zoom:80%;" />

<p>回调地址必须在Service Id下的Sign In With Apple中</p>
<img src="https://gdz.oss-cn-shenzhen.aliyuncs.com/local/image-20220712175929103.png" alt="image-20220712175929103" style="zoom:80%;" />

<p>这里回调地址也不必真实存在，我们只要抓取请求时携带的数据即可，与微信登录稍有不同的是，这里将参数携带在body中了。</p>
<img src="https://gdz.oss-cn-shenzhen.aliyuncs.com/local/image-20220712180229448.png" alt="image-20220712180229448" style="zoom:80%;" />

<h2 id="Sign-In-With-Google"><a href="#Sign-In-With-Google" class="headerlink" title="Sign In With Google"></a>Sign In With Google</h2><h3 id="原理-2"><a href="#原理-2" class="headerlink" title="原理"></a>原理</h3><p>Google登录也是标准的Open ID Connect，它提供JS库进行快捷登录，参考<a href="https://developers.google.com/identity/sign-in/web">这里</a>。</p>
<p>客户端负责：获取Identity Token</p>
<p>服务端负责：验证Identity Token</p>
<p>还是构建web请求，html如下，这里唯一需要配置的是client id</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">html</span> <span class="attr">lang</span>=<span class="string">&quot;en&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">name</span>=<span class="string">&quot;google-signin-scope&quot;</span> <span class="attr">content</span>=<span class="string">&quot;profile email&quot;</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 这里是唯一需要我们填写的参数：client id --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">name</span>=<span class="string">&quot;google-signin-client_id&quot;</span> <span class="attr">content</span>=<span class="string">&quot;YOUR_CLIENT_ID.apps.googleusercontent.com&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">&quot;https://apis.google.com/js/platform.js&quot;</span> <span class="attr">async</span> <span class="attr">defer</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;g-signin2&quot;</span> <span class="attr">data-onsuccess</span>=<span class="string">&quot;onSignIn&quot;</span> <span class="attr">data-theme</span>=<span class="string">&quot;dark&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="javascript"></span></span><br><span class="line"><span class="javascript">      <span class="function"><span class="keyword">function</span> <span class="title">onSignIn</span>(<span class="params">googleUser</span>) </span>&#123;</span></span><br><span class="line"><span class="javascript">        <span class="comment">// Useful data for your client-side scripts:</span></span></span><br><span class="line"><span class="javascript">        <span class="keyword">var</span> profile = googleUser.getBasicProfile();</span></span><br><span class="line"><span class="javascript">        <span class="built_in">console</span>.log(<span class="string">&quot;ID: &quot;</span> + profile.getId()); <span class="comment">// Don&#x27;t send this directly to your server!</span></span></span><br><span class="line"><span class="javascript">        <span class="built_in">console</span>.log(<span class="string">&#x27;Full Name: &#x27;</span> + profile.getName());</span></span><br><span class="line"><span class="javascript">        <span class="built_in">console</span>.log(<span class="string">&#x27;Given Name: &#x27;</span> + profile.getGivenName());</span></span><br><span class="line"><span class="javascript">        <span class="built_in">console</span>.log(<span class="string">&#x27;Family Name: &#x27;</span> + profile.getFamilyName());</span></span><br><span class="line"><span class="javascript">        <span class="built_in">console</span>.log(<span class="string">&quot;Image URL: &quot;</span> + profile.getImageUrl());</span></span><br><span class="line"><span class="javascript">        <span class="built_in">console</span>.log(<span class="string">&quot;Email: &quot;</span> + profile.getEmail());</span></span><br><span class="line"><span class="javascript"></span></span><br><span class="line"><span class="javascript">        <span class="comment">// The ID token you need to pass to your backend:</span></span></span><br><span class="line"><span class="javascript">        <span class="keyword">var</span> id_token = googleUser.getAuthResponse().id_token;</span></span><br><span class="line"><span class="javascript">        <span class="built_in">console</span>.log(<span class="string">&quot;ID Token: &quot;</span> + id_token);</span></span><br><span class="line"><span class="javascript">      &#125;</span></span><br><span class="line"><span class="javascript">    </span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h3 id="配置-2"><a href="#配置-2" class="headerlink" title="配置"></a>配置</h3><p>在<a href="https://console.cloud.google.com/apis/credentials">google开发者平台</a>创建web应用，需要填写js来源和重定向URL。</p>
<img src="https://gdz.oss-cn-shenzhen.aliyuncs.com/local/image-20220712180615269.png" alt="image-20220712180615269" style="zoom:80%;" />

<p>几点注意事项</p>
<ul>
<li>请求时，google服务器会检查js的请求来源，因此需要将上述html文件放在服务器端访问</li>
<li>请求成功后，上述文件不会跳转重定向地址，而是在控制台打印信息</li>
</ul>
<p>调用成功的结果如下</p>
<p><img src="https://gdz.oss-cn-shenzhen.aliyuncs.com/local/image-20220712180958408.png" alt="image-20220712180958408"></p>
<h2 id="Sign-In-With-Facebook"><a href="#Sign-In-With-Facebook" class="headerlink" title="Sign In With Facebook"></a>Sign In With Facebook</h2><h3 id="原理-3"><a href="#原理-3" class="headerlink" title="原理"></a>原理</h3><p>Facebook的token比较复杂，它发放的是一个相对短时的access token，后端调用debug token接口来验证它。尽管原理不同，但接口表现上一致</p>
<p>客户端负责：获取access token</p>
<p>服务端负责：验证access token</p>
<p>使用上，facebook提供了一个<a href="https://developers.facebook.com/tools/explorer">API探索工具</a>，它能够直接生成access token，我们可以直接使用</p>
<img src="https://gdz.oss-cn-shenzhen.aliyuncs.com/local/image-20220712181434257.png" alt="image-20220712181434257" style="zoom:80%;" />

<h3 id="配置-3"><a href="#配置-3" class="headerlink" title="配置"></a>配置</h3><p>按facebook的流程正常创建应用即可，在API探索工具中可直接选择对应的应用</p>
<h2 id="写在最后"><a href="#写在最后" class="headerlink" title="写在最后"></a>写在最后</h2><ul>
<li>通过构建web请求可以得到服务端输入，用以验证服务端逻辑，较为简便。前后端联调时，只需要调试前端逻辑和登录配置。可提升效率</li>
<li>需要注意的是，在各三方登录平台每创建一个新应用，服务端配置也要相应更改</li>
</ul>
]]></content>
      <categories>
        <category>业务</category>
      </categories>
      <tags>
        <tag>Sign In With Apple</tag>
        <tag>Sign In With Google</tag>
        <tag>Sign In With Facebook</tag>
        <tag>微信登录</tag>
      </tags>
  </entry>
  <entry>
    <title>刻意练习</title>
    <url>/2021/11/23/%E5%88%BB%E6%84%8F%E7%BB%83%E4%B9%A0/</url>
    <content><![CDATA[<blockquote>
<p>读《刻意练习—如何从新手到大师》有感，读于2021年11月22日晚，写于2021年11月23日晚。</p>
</blockquote>
<p>《刻意练习—如何从新手到大师》被归类为心理学著作，但我是将它当做方法论书籍来看的。它已经在书架上待了两个月，迟迟不翻，多半还是因为书名。在我看来，书名可以分为两部分：第一部分“刻意练习”，看起来是一本务实的书；第二部分“如何从新手到大师”，颇有“21天学会单片机”的意味，虽没有强调速成，但还是极具诱惑力的标题，成功学意味明显。直觉告诉我它是一本垃圾书籍。</p>
<span id="more"></span>

<p>最终还是看了，毕竟豆瓣7.8分，借鉴《如何阅读一本书》中的方法，只是速览，选取有价值的章节详细阅读，其余部分略读。</p>
<p>全书来看，大致分为三个部分：第一部分铺垫，将天才拉下神坛，强调大量有目的地练习带来的积极效果；第二部分，谈论刻意练习的适用范围，以及方式方法问题；第三部分，揭露传说的幕后，让人们回归理性思考，破解传说，给普通人以信心，颇有《批判性思考指南》的意味。总结起来就是让读者相信刻意练习是有用的，然后告诉读者刻意练习的方法，最后为读者注入信心，有头有尾，挺好。</p>
<p>于我，天然相信练习的作用，也有一定的思辨能力，只想要方式方法，所以，取第二部分就OK。</p>
<p>总结如下：</p>
<p>首先，区分知识和技能，知识是正确方法的信息，比如理论知识的学习；而技能注重提高绩效和表现，比如手工；刻意练习适用于后者。知道Go语言的语法算知识，能用它写代码解决实际问题算技能；知道杀球上网算知识，实战中能用出来才算技能。带片面一点的理解，就是知道和做到的区别。纯粹地知道不需要练习，做到才需要练习。我们的目的，就是练习如何做到。</p>
<p>其次，什么样的练习才能算是刻意练习呢？书中提出一套所谓“黄金标准”，我们可以对照</p>
<ul>
<li>不只是有目的性地练习，而是使用一套已经被证明行之有效的训练方法进行训练</li>
<li>练习发生在舒适区外，刚好超出能力范围之外</li>
<li>有目标，但不只是一个宏大的目标，而是要被拆分成一个个阶段性的确切的小目标</li>
<li>需要有反馈，反馈首先来自导师，步上正轨之后反馈来自自己</li>
</ul>
<p>上面太散了，理一下思路：</p>
<p><strong>寻找客体—我要练习什么</strong></p>
<p>这包含两部分：我要练习什么技能；该项技能我应该练习哪部分。对前者，人的精力是有限的，不可贪心，一般来说是自己的本职工作+爱好，如果自己完全不喜欢一件事，练习起来痛苦且无意义；对于后者，应选取生疏点专项练习，因为熟练的点，再练也只是熟练。无目的地打无数场球，球技也得不到大的提升，而是要针对弱项专门练习，比如脚步、比如网前球；反复写同一个场景的业务代码，编码能力也不会有所提升，而是要针对特定场景，运用设计模式，反复练习。</p>
<p><strong>思考方法—我要如何练习</strong></p>
<p>反馈很重要，反馈很重要，反馈很重要，重要的事情说三遍！！！</p>
<p>最好是去找一个导师，导师一定是业内杰出人士，最好是一对一教学，这是为了获得最为及时有效的反馈。市面上大量面向成人的辅导课程的存在，不无道理。当然，现实中有一个直接的导师不切实际。可以退而求其次，主动追求反馈。寻找业内杰出人士作为榜样。与比自己水平高的对手比赛，过程中留意自己的缺点；运动时使用录像设备记录，对比标准动作；通过论坛提问、文章评论的方式，获得技术反馈。有反馈，才会觉得是在做一件事；没有反馈，大多数时候都会不了了之，难以坚持。</p>
<p>有针对性地练习，王牌飞行计划。</p>
<p>练习的最终目的是实践应用，分片式的练习不结合实战，最后也只是一小片而已。所谓王牌飞行计划，是指越战期间美军针对海军飞行员因缺乏实战导致战损率高的问题而指定的实战训练计划，由专业教官在实战中模拟敌人进行训练，并将结果反馈，促使飞行员不断精进战斗技巧，最终大大降低战损。也就是说，创造实战环境。这一点，个人认为在技术学习中还挺有用的，我们不可能实际遇到那么多问题，此时创造场景就显得尤为重要，甚至，创造场景可以花费更长时间。</p>
<p><strong>如何坚持—寻找坚持的动机</strong></p>
<p>学习一项技能最大的敌人往往不是效率不够高，而是无法坚持。要保持动机，要么强化继续前进的理由；要么弱化停下脚步的理由。</p>
<p>强化前进的理由，可以是成就感、虚荣心、功利心，怎样都没关系，只要不违法，且能够让你前进，都可取。有一个很好的方式—积极的反馈，可能是写完博客之后带来的满足感、可能是论坛中别人积极地评价、可能是产品上线后带来的成就感。总之，多创造积极的反馈结果，对坚持很有益处。</p>
<p>弱化停止的方式，别让自己闲下来，在最容易懈怠的时候，安排固定的练习任务，不给自己停下脚步的理由。</p>
<p>最重要的是，不要着急，杰出者有几个阶段：产生兴趣-&gt;变得认真-&gt;全身心投入-&gt;开拓创新，在产生创新性进展之前，有三个漫长的阶段需要经历，所以保持耐心，量变终会产生质变。</p>
]]></content>
      <categories>
        <category>随笔</category>
      </categories>
      <tags>
        <tag>读书</tag>
      </tags>
  </entry>
  <entry>
    <title>iptables详解</title>
    <url>/2022/07/18/iptables/</url>
    <content><![CDATA[<blockquote>
<p>为什么需要学习iptables ?<br>Linux防火墙、NAT、Kubernetes等很多地方都用到iptables，了解它很重要。</p>
</blockquote>
<blockquote>
<p>本文主要信息来源是<a href="https://www.netfilter.org/projects/iptables/index.html">netfilter官网</a>推荐的<a href="https://www.frozentux.net/iptables-tutorial/iptables-tutorial.html">iptables教程</a>。</p>
</blockquote>
<blockquote>
<p>本文目的：了解iptables原理；了解iptables配置方法，看懂iptables配置脚本</p>
</blockquote>
<span id="more"></span>

<h2 id="什么是iptables"><a href="#什么是iptables" class="headerlink" title="什么是iptables"></a>什么是iptables</h2><p>iptables经常被与netfilter一同提起。</p>
<p>netfilter是一个工作在Linux内核层面的网络数据包处理框架，提供了包过滤、地址或端口转换、包修改等功能；具体来说，就是在数据包处理路径上的特定位置触发对应的hook，这就是我们常说的5个chain、4个table。</p>
<p>iptables是一个工作在用户态的命令行工具，用于在上述chain和table上配置规则集，以自定义包过滤规则、地址转换规则等。常见的用途如实现防火墙。</p>
<h2 id="学习iptables，是在学什么"><a href="#学习iptables，是在学什么" class="headerlink" title="学习iptables，是在学什么"></a>学习iptables，是在学什么</h2><p>首先，学习网络协议栈基础知识，需要精确到数据包结构；其次，学习chain和table的详细组成、写作方式；最后，学习iptables命令的使用方法。</p>
<h2 id="网络基础-TCP-IP协议栈"><a href="#网络基础-TCP-IP协议栈" class="headerlink" title="网络基础 - TCP/IP协议栈"></a>网络基础 - TCP/IP协议栈</h2><p>TCP/IP是老生常谈了，不过多少次重复都不为过。</p>
<h3 id="概览"><a href="#概览" class="headerlink" title="概览"></a>概览</h3><p>我们常说的TCP/IP协议栈，或者TCP/IP Stack，指的就是TCP/IP构成的多层模型，在Linux中，就是指内核对该多层模型的实现。该协议到底分为几层，没有一个明确的共识，一般来说是四层，如下:</p>
<p><img src="https://gdz.oss-cn-shenzhen.aliyuncs.com/local/image-20220719101624353.png" alt="image-20220719101624353"></p>
<p>也有说五层的，还有OSI标准的7层，它们实际对应关系如下</p>
<p><img src="https://gdz.oss-cn-shenzhen.aliyuncs.com/local/image-20220719122814357.png" alt="image-20220719122814357"></p>
<p>理论来说，iptables应该工作在二层，即网络互联层，但实际上它也提供三层（传输层）的跟踪配置能力，因此，我们需要详细了解的协议主要有IP、ICMP、TCP、UDP、SCTP。控制为主，而控制主要集中在数据包头部，因此会详细解析头部字段含义。</p>
<h3 id="IP协议"><a href="#IP协议" class="headerlink" title="IP协议"></a>IP协议</h3><p>IP是无状态协议，主要解决数据去哪的问题。头部分析如下</p>
<img src="https://gdz.oss-cn-shenzhen.aliyuncs.com/local/image-20220719102205190.png" alt="image-20220719102205190" style="zoom:80%;" />

<p>含义解读如下</p>
<table>
<thead>
<tr>
<th>段</th>
<th>含义</th>
</tr>
</thead>
<tbody><tr>
<td>Version</td>
<td>版本。0100 - IPV4   0110 IPV6</td>
</tr>
<tr>
<td>IHL</td>
<td>Internet Header Length，IP头长度，单位：word(即32 bit)。<br />为啥需要这个呢，因为Options的长度可选，所有要用它来确定总长</td>
</tr>
<tr>
<td>TOS/DSCP/ECN</td>
<td>TOS: Type Od Service, 总共八位，它们主要是在路由器等硬件设施上使用，每位的含义如下<br />0-2：优先字段<br />3：正常或者低延迟<br />4：正常或者高吞吐量<br />5：正常或高可靠性<br />6-7：预留<br /><br />这部分还经过了两个迭代：DSCP和ECN，这里不深入<br />DSCP: Differentiated Services Code Point 差异化服务码点<br />ECN: Explicit Congestion Notification 显式阻塞通知</td>
</tr>
<tr>
<td>Total Length</td>
<td>整个IP数据包的总长度，包括头部。单位为字节</td>
</tr>
<tr>
<td>Identification</td>
<td>唯一标识。用于数据分片后再组装时的识别。和Offset结合一起使用</td>
</tr>
<tr>
<td>Flags</td>
<td>分片标识<br />bit 0：保留<br />bit 1：当前数据包是否可分片。 0-不可分片，1-可分片<br />bit 2：当前数据包是否是分片的最后一片。0-是最后一个，1-后面还有</td>
</tr>
<tr>
<td>Fragment Offset</td>
<td>分片位移</td>
</tr>
<tr>
<td>Time To Live</td>
<td>有效期。单位：跳。每经过一次转发，TTL减一，当为0时会被销毁。<br />用于避免一个包陷入死循环转发</td>
</tr>
<tr>
<td>Protocol</td>
<td>上一层数据的协议。如TCP、UDP等</td>
</tr>
<tr>
<td>Header Checksum</td>
<td>头部校验和。每经过一跳都会重新计算，因为TTL变了</td>
</tr>
<tr>
<td>Source Address</td>
<td>源地址</td>
</tr>
<tr>
<td>Destination Address</td>
<td>目标地址</td>
</tr>
<tr>
<td>Options</td>
<td>可选项，最长可占40个字节。可以包含时间戳、SACK等</td>
</tr>
<tr>
<td>Padding</td>
<td>由于头部是按照word为单位的，所以如果Options的长度不足一个word，则需要Padding补齐</td>
</tr>
</tbody></table>
<blockquote>
<p>那么问题来了，Source Address子弹只有四个字节，那么IPV6怎么表示呢？</p>
<p>IPV6的头部和IPV4不一样，具体来说有两点</p>
<ul>
<li>地址字段用128位表示，而不是现在的32位</li>
<li>Options字段取消了，取而代之的各种扩展头。如TCP扩展头、路由扩展头等，当然从实际作用来说和IPV4差不多</li>
</ul>
<p><img src="https://gdz.oss-cn-shenzhen.aliyuncs.com/local/image-20220719103526725.png" alt="image-20220719103526725"></p>
</blockquote>
<h3 id="ICMP协议"><a href="#ICMP协议" class="headerlink" title="ICMP协议"></a>ICMP协议</h3><p>ICMP用于主机到主机或主机到网关之间的基本错误报告。</p>
<p>ICMP有点特殊，从作用上看，它是构建在IP协议之上，但是其包结构有何IP类似。并且，<strong>ICMP是IP的不可分割的一部分，每个IP的实现都必须包含ICMP</strong>。</p>
<p><img src="https://gdz.oss-cn-shenzhen.aliyuncs.com/local/image-20220719103605971.png" alt="image-20220719103605971"></p>
<table>
<thead>
<tr>
<th>字段</th>
<th>含义</th>
</tr>
</thead>
<tbody><tr>
<td>头部字段</td>
<td>和IP协议的头部字段一样，我们就不再赘述</td>
</tr>
<tr>
<td>Type</td>
<td>ICMP类型</td>
</tr>
<tr>
<td>Code</td>
<td>ICMP类型下的具体代码</td>
</tr>
</tbody></table>
<p>Type和Code的组合有很多种，参考附件：<a href="https://www.frozentux.net/iptables-tutorial/iptables-tutorial.html#ICMPTYPES">https://www.frozentux.net/iptables-tutorial/iptables-tutorial.html#ICMPTYPES</a></p>
<p>不同的类型拥有不同的报文body，常见的类型如下</p>
<ul>
<li><p>Echo</p>
<p>echo请求type=8，回复type=0</p>
<p><img src="https://gdz.oss-cn-shenzhen.aliyuncs.com/local/image-20220719103656948.png" alt="image-20220719103656948"></p>
<ul>
<li>id：echo请求的序列号，恢复时针对序列号恢复</li>
<li>sn：主机序列号，递增</li>
<li>data：默认为空。也可以包含用户指定的数据</li>
</ul>
</li>
<li><p>目标不可达</p>
<p>type=3，Code可能是0-15，代表了各种不可达的原因</p>
<p><img src="https://gdz.oss-cn-shenzhen.aliyuncs.com/local/image-20220719103711401.png" alt="image-20220719103711401"></p>
</li>
</ul>
<h3 id="TCP协议"><a href="#TCP协议" class="headerlink" title="TCP协议"></a>TCP协议</h3><p>TCP是有状态协议，简要描述一下TCP协议的三个过程</p>
<ul>
<li>握手：客户端发送SYN包，服务端恢复SYN/ACK表示接收，或者SYN/RST表示拒绝，客户端收到接受的包后，再发送一个ACK数据包。至此连接建立，握手成功</li>
<li>数据发送：客户端每发送一个数据包，服务端都要响应ACK表示收到，否则客户端会重试</li>
<li>挥手：一端发送FIN包，表示要结束连接；另一端回复FIN/ACK，此时FIN发送端不能再发送任何数据，但是接收端可以，此时只是关闭了单向数据传送；如果要关闭另一个方向的传送，反向重复上述操作即可。</li>
</ul>
<p>要注意，握手是在确定双方都同一传输数据；挥手也是在确定双方都同意关闭连接。而由于挥手时存在半关闭状态，自己的连接是否关闭只有自己说了算（因为只要自己才知道是否还有数据没传输完），所以需要自己发起FIN请求。</p>
<p>TCP的头部如下</p>
<p><img src="https://gdz.oss-cn-shenzhen.aliyuncs.com/local/image-20220719103900113.png" alt="image-20220719103900113"></p>
<table>
<thead>
<tr>
<th>段</th>
<th>含义</th>
</tr>
</thead>
<tbody><tr>
<td>Source Port</td>
<td>源端口。端口对应的是进程。IP+Port能够定位到指定主机的指定进程。</td>
</tr>
<tr>
<td>Destination Port</td>
<td>目标端口</td>
</tr>
<tr>
<td>Sequence Number</td>
<td>序号，安全传输的保证，标识每一个数据包，接收方响应ACK时带上SN，就知道改包是否被正常接收</td>
</tr>
<tr>
<td>Acknowledgement Number</td>
<td>与上面的序号对应。这是在响应时候确认那个序号的包被成功接收</td>
</tr>
<tr>
<td>Data Offset</td>
<td>标识标头长度。它标记的是正文数据Data开始位置的word偏移数量。word即32位</td>
</tr>
<tr>
<td>Reserved</td>
<td>保留</td>
</tr>
<tr>
<td>cwr</td>
<td>Congestion Window Reduced，用于发送方通知接收方数据拥塞窗口减小</td>
</tr>
<tr>
<td>ece</td>
<td>ECN的回声。前面说过，ECN是阻塞通知的意思</td>
</tr>
<tr>
<td>urg</td>
<td>是否使用紧急指针字段</td>
</tr>
<tr>
<td>ack</td>
<td>标识这个数据包是对收到的另一个数据包的回复</td>
</tr>
<tr>
<td>psh</td>
<td>PUSH，告诉中间主机将数据发送给最终目标主机，无论是否发生拥塞</td>
</tr>
<tr>
<td>rst</td>
<td>RESET，告诉另一端断开TCP连接，主要是异常断开</td>
</tr>
<tr>
<td>syn</td>
<td>同步序列号位，建立连接时使用</td>
</tr>
<tr>
<td>fin</td>
<td>发起关闭连接时使用</td>
</tr>
<tr>
<td>Window</td>
<td>接收方用该字段告诉发送方目前允许接收多少数据。这是在一个ACK报文中一起携带的</td>
</tr>
<tr>
<td>Checksum</td>
<td>校验和</td>
</tr>
<tr>
<td>urgent Pointer</td>
<td>如果连接中有重要数据需要接收方立即处理，通过urg标识和紧急指针，后者标识了紧急数据的结束位置</td>
</tr>
<tr>
<td>Options</td>
<td>选项，有专门的TCP选项</td>
</tr>
<tr>
<td>Padding</td>
<td>头部不足一个word时，补0</td>
</tr>
<tr>
<td>Data</td>
<td>正文数据</td>
</tr>
</tbody></table>
<h3 id="UDP协议"><a href="#UDP协议" class="headerlink" title="UDP协议"></a>UDP协议</h3><p>它是无状态的，没有任何的错误检测。适合查询/响应类应用，如DNS。</p>
<p>TCP协议虽然可靠，但是可靠机制带来了很多开销，相对地，UDP非常地简单，仅包含数据传输，因此我们可以在其上构建我们自己的协议。比如HTTP3.0的QUIC协议，正如其全称 Quick UDP Internet Connection 表示的含义一样。</p>
<p><img src="https://gdz.oss-cn-shenzhen.aliyuncs.com/local/image-20220719103958646.png" alt="image-20220719103958646"></p>
<p>有关QUIC协议和HTTP3.0的内容，这篇文章不错：[<a href="https://blog.51cto.com/u_6315133/3122045]">https://blog.51cto.com/u_6315133/3122045]</a>(</p>
<h3 id="SCTP协议"><a href="#SCTP协议" class="headerlink" title="SCTP协议"></a>SCTP协议</h3><p>这也是一个传输层协议，类似TCP和UDP。它也是一个面向连接的可靠的协议，与TCP不同的是，它提供了更高的可靠性。</p>
<ul>
<li>SCTP面向消息，支持单个消息称帧。而TCP是面向字节的。</li>
<li>全双工传输</li>
<li>多流功能：即常说的多路复用功能，类似HTTP2，分为多个stream，每个stream都由stream id标识，丢包也只会影响该stream的数据，其它stream不受影响。这样可以提高传输效率。</li>
<li>多宿主功能：指的是一个SCTP端点可以对应多个IP地址，其中有一个为主，其它的为副。当主IP接收失败时，会重发到副IP地址。</li>
<li>能够通过INIT快防止DoS攻击</li>
</ul>
<p>SCTP通讯的三个过程</p>
<ul>
<li><p>初始化和关联</p>
<ul>
<li>发起方发送INIT，接收方响应INIT-ACK，INIT-ACK中带有Cookie配置信息</li>
<li>发起方发送COOKIE-ECHO进行初始连线，接收方响应COOKIE-ACK。然后就可以发送数据了。</li>
</ul>
<blockquote>
<p>这里的COOKIE机制可以防止TCP机制的SYN攻击，TCP协议中，发起方发送SYN，接收方响应SYN/ACK后，发起方不回应ACK，此时接收方会等待一段时间。如果发起方发送大量这种请求，就形成了SYNC攻击（DoS攻击的一种）</p>
</blockquote>
</li>
<li><p>数据发送和控制会话</p>
<ul>
<li>数据发送时用DATA块，响应时用SACK块。这个和TCP差不多</li>
<li>HEARTBEAT 和 HEARTBEAT ACK块用于保持连接不断开</li>
<li>ERROR用于传输过程中的错误通知</li>
</ul>
</li>
<li><p>关闭和中止</p>
<ul>
<li>优雅关闭用 SHUTDOWN块。SCTP没有TCP那样的半关闭状态，当一端发起关闭时，另一端就不能发送数据了。取而代之它的关闭流程如下<ul>
<li>发起方发送所有缓冲区的数据，然后发送SHUTDOWN块</li>
<li>接收方搜到SHUTDOWN块，发送本地缓冲区所有的数据，发送SHUTDOWN ACK</li>
<li>发起方收到后，发送SHUTDOWN COMPLETE，至此关闭完成</li>
</ul>
</li>
<li>强制关闭用ABORT块。缓冲区的所有数据被丢球，接收方也一样</li>
</ul>
</li>
</ul>
<p>SCTP连接和终止图示如下</p>
<img src="https://gdz.oss-cn-shenzhen.aliyuncs.com/local/image-20220719104233033.png" alt="image-20220719104233033" style="zoom:80%;" />

<blockquote>
<p>怎么看，都有点像四层协议的部分特性下放到三层来了</p>
</blockquote>
<p>SCTP的头部分为通用头部和具体块的结构（有多种类型的块，每个块的结构不一样）。</p>
<p><img src="https://gdz.oss-cn-shenzhen.aliyuncs.com/local/image-20220719104652695.png" alt="image-20220719104652695"></p>
<p>通用头部如下。其中Verification Tag用于验证数据包是否来自正确的发送者。</p>
<p><img src="https://gdz.oss-cn-shenzhen.aliyuncs.com/local/image-20220719104703558.png" alt="image-20220719104703558"></p>
<p>块结构如下</p>
<p><img src="https://gdz.oss-cn-shenzhen.aliyuncs.com/local/image-20220719104713873.png" alt="image-20220719104713873"></p>
<p>块类型如下</p>
<p><img src="https://gdz.oss-cn-shenzhen.aliyuncs.com/local/image-20220719104843440.png" alt="image-20220719104843440"></p>
<p>这里列举建立连接时的四个块</p>
<ul>
<li><p>INIT</p>
<p><img src="https://gdz.oss-cn-shenzhen.aliyuncs.com/local/image-20220719105736501.png" alt="image-20220719105736501"></p>
</li>
<li><p>INIT ACK</p>
<p><img src="https://gdz.oss-cn-shenzhen.aliyuncs.com/local/image-20220719105750559.png" alt="image-20220719105750559"></p>
<p>ACK和INIT完全相同，只是添加了Cookie和一些其它参数。Cookie参数结构如下。可见Cookie就是一个随机二进制值。</p>
<p><img src="https://gdz.oss-cn-shenzhen.aliyuncs.com/local/image-20220719105822180.png" alt="image-20220719105822180"></p>
</li>
<li><p>COOKIE ECHO</p>
<p><img src="https://gdz.oss-cn-shenzhen.aliyuncs.com/local/image-20220719105829871.png" alt="image-20220719105829871"></p>
</li>
<li><p>COOKIE ACK</p>
<p><img src="https://gdz.oss-cn-shenzhen.aliyuncs.com/local/image-20220719105843772.png" alt="image-20220719105843772"></p>
</li>
</ul>
<h2 id="理解iptables"><a href="#理解iptables" class="headerlink" title="理解iptables"></a>理解iptables</h2><h3 id="IP过滤"><a href="#IP过滤" class="headerlink" title="IP过滤"></a>IP过滤</h3><p>IP过滤就是决定数据包如何处理的过程。Linux操作系统的netfilter/iptables是IP过滤的一种实现，也可以称作防火墙。一些物理网络防火墙设备也是这个原理。</p>
<p>至于iptables，字面理解，它是工作在IP层执行IP包过滤的，但是实际实现并不严格，它还能根据更高层的TCP等协议和更底层的MAC协议过滤数据包。即跨越了一、二、三层。甚至增加插件后，iptables和netfilter能够在四层进行过滤。这就是iptables远比看起来的复杂。</p>
<h3 id="概念介绍"><a href="#概念介绍" class="headerlink" title="概念介绍"></a>概念介绍</h3><ul>
<li><p>chain：即五个hook位置，为什么叫做chain？因为执行到该hook时，实际上是在该位置的rule链上进行遍历。</p>
<ul>
<li>PREROUTING</li>
<li>INPUT</li>
<li>FORWARD</li>
<li>OUTPUT</li>
<li>POSTROUTING</li>
</ul>
</li>
<li><p>table：规定了几个记录rule的表</p>
<ul>
<li><p>raw</p>
<p>只做一件事：为数据包添加标记，表明该包不被跟踪</p>
</li>
<li><p>mangle</p>
<p>如下事项只能在Mangle表中做，其它地方不能做</p>
<ul>
<li>TOS：修改IP报文头的TOS字段，这能够影响路由决策。</li>
<li>TTL：修改IP报文的TTL</li>
<li>MARK：为报文添加特殊标识，这能够影响路由决策，也可以影响带宽限制</li>
<li>SECMARK：添加安全标识</li>
<li>CONNSECMARK：同上，也是一些安全标识</li>
</ul>
</li>
<li><p>nat</p>
<p>只能用来做地址转换</p>
<ul>
<li>DNAT：修改目标IP地址</li>
<li>SNAT：修改源IP地址，用以隐藏本机地址</li>
<li>MASQUERADE：类似SNAT，但更耗费性能</li>
<li>REDIRECT</li>
</ul>
</li>
<li><p>filter</p>
<p>用于过滤数据包，以任何我们想要的方式。这是我们操作的最多的地方</p>
</li>
</ul>
</li>
<li><p>rule：一条声明式规则，声明了什么时什么样的包执行什么样的操作</p>
</li>
<li><p>match：匹配规则，iptables可以按照各种包的特征进行匹配</p>
</li>
</ul>
<p>用一个图来解释chain和table的关系</p>
<img src="https://gdz.oss-cn-shenzhen.aliyuncs.com/local/image-20220719121029628.png" alt="image-20220719121029628" style="zoom:60%;" />

<p>下面这张图可能是更常见的</p>
<img src="https://gdz.oss-cn-shenzhen.aliyuncs.com/local/image-20220719121305203.png" alt="image-20220719121305203" style="zoom:80%;" />

<h3 id="连接状态跟踪"><a href="#连接状态跟踪" class="headerlink" title="连接状态跟踪"></a>连接状态跟踪</h3><p>这是iptables中的一个特殊部分。在 iptables 中，数据包可以与处于四种不同所谓状态的跟踪连接相关联</p>
<ul>
<li>NEW</li>
<li>ESTABLISHED</li>
<li>RELATED</li>
<li>INVALID</li>
</ul>
<p>这些是由内核框架conntrack完成的。它实时跟踪记录了传输层连接的状态，<strong>在配置匹配条件时，匹配指定状态的连接的所有数据包</strong>。</p>
<p>以TCP为例，状态变化如下。</p>
<img src="https://gdz.oss-cn-shenzhen.aliyuncs.com/local/image-20220719112747161.png" alt="image-20220719112747161" style="zoom:50%;" />

<p>如果有开启连接跟踪，在<code>/proc/net/ip_conntrack</code>文件中能够看到信息，比如</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">tcp      6 431999 ESTABLISHED src=192.168.1.5 dst=192.168.1.35 \</span><br><span class="line">     sport=1031 dport=23 src=192.168.1.35 dst=192.168.1.5 \</span><br><span class="line">     sport=23 dport=1031 [ASSURED] use=1</span><br></pre></td></tr></table></figure>

<p>从左到右依次是：协议、一个十进制编码、记录过期时间(s)、状态值、入方向上的地址和端口信息、反向地址和端口信息、预期返回的包数量</p>
<h3 id="iptables命令"><a href="#iptables命令" class="headerlink" title="iptables命令"></a>iptables命令</h3><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">iptables [-t table] command [match] [target/jump]</span><br></pre></td></tr></table></figure>

<p>如上是iptables的常见语法。从左到右依次是 表名、命令、匹配规则、目标操作或跳转目标。其中table可选，如果不指定，默认就是filter表。</p>
<h4 id="命令"><a href="#命令" class="headerlink" title="命令"></a>命令</h4><table>
<thead>
<tr>
<th>命令</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>-A <br />–append</td>
<td>将规则rule到指定chain的最后<br />iptables -A INPUT …</td>
</tr>
<tr>
<td></td>
<td></td>
</tr>
<tr>
<td>-D <br />–drop</td>
<td>将rule从执行chain中删除。两种使用方式 <br />1. 指定完整的规则 <br />2. 指定规则的序号：序号chain中从上到下依次递增，1开始 <br />iptables -D INPUT –dport 80 -j DROP, iptables -D INPUT 1</td>
</tr>
<tr>
<td>-R <br />–replace</td>
<td>替换指定位置的rule <br />iptables -R INPUT 1 -s 192.168.0.1 -j DROP</td>
</tr>
<tr>
<td>-I <br />–insert</td>
<td>向chain中的指定位置插入rule <br />iptables -I INPUT 1 –dport 80 -j ACCEPT</td>
</tr>
<tr>
<td>-L <br />–list</td>
<td>列出指定chain中的所有rule <br />iptables -L INPUT</td>
</tr>
<tr>
<td>-F <br />–flush</td>
<td>清空指定chain上的所有rule，和一条一条删除效果一样，只不过更快 <br />iptables -F INPUT</td>
</tr>
<tr>
<td>-Z <br />–zero</td>
<td>清空指定chain上的计数器。这些计数器用于计量包数和字节数 <br />iptables -Z INPUT</td>
</tr>
<tr>
<td>-N<br />–new-chain</td>
<td>创建一个新的chain <br />iptables -N allowed</td>
</tr>
<tr>
<td>-X <br />–delete-chain</td>
<td>删除置顶chain，只有已经被清空的chain，即没有任何rule的chain才能被删除 <br />内建的chain如INPUT等是无法被删除的 <br />iptables -X allowed</td>
</tr>
<tr>
<td>-P <br />–policy</td>
<td>为chain设置默认的target或policy，在该chain上，任何没有被rule匹配到的包，都会应用该默认规则。 <br />只有两个合法的target：DROP 和 ACCEPT <br />iptables -P INPUT DROP</td>
</tr>
<tr>
<td>-E <br />–rename-chain</td>
<td>重命名chain <br />iptables -E allowed disallowed</td>
</tr>
</tbody></table>
<blockquote>
<p>新建chain有什么用？</p>
<p>只有前文所述5个chain是内建的，用户自建的chain并不会被自动hook到数据流中。只能通过以jump的形式从一个已有的chain跳入，待执行完后再跳回。所以新建的chain其实就是一个相对独立的规则集而已（这也是它的最大用途），对内核透明。</p>
</blockquote>
<h4 id="匹配规则"><a href="#匹配规则" class="headerlink" title="匹配规则"></a>匹配规则</h4><p>match是语法最为复杂的一部分，不同的协议有不同的匹配规则。</p>
<p><strong>通用match</strong></p>
<table>
<thead>
<tr>
<th>匹配项</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>-p —protocol</td>
<td>指定协议 <br />- 协议只能是 /etc/protocols 文件中存在的，否则会报错 <br />- 可以正向也可以反向。 <br />iptables -A INPUT -p ! tcp 表示非tcp</td>
</tr>
<tr>
<td>-s  —src  —source</td>
<td>来源IP，可以有多种形式。也可以用 ! 运算符反向指定 <br />- 单个IP形式 192.168.0.0 <br />- CIDR形式 192.168.0.0/24 <br />- 子网掩码形式  192.168.0.0/255.255.255.0</td>
</tr>
<tr>
<td>-d —dst —destination</td>
<td>同上，反向而已</td>
</tr>
<tr>
<td>-i —in-interface</td>
<td>指定包的来源接口，如en0。 <br />- 只能在INPUT FORWARD PREROUTING 三个chain使用 <br />- 允许通配，+表示所有接口,en+表示en开头的所有接口</td>
</tr>
<tr>
<td>-o —out-interface</td>
<td>同上，反向而已</td>
</tr>
<tr>
<td>-f —fragment</td>
<td>匹配分段数据包的第二、第三。。。段 <br />如果不指定，就只会匹配未分段的数据包或者分段数据包的第一段</td>
</tr>
</tbody></table>
<p><strong>隐式match</strong></p>
<ul>
<li><p>tcp match</p>
<p>如下匹配仅对 -p tcp 的情况下有效</p>
<table>
<thead>
<tr>
<th>匹配项</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>-p —protocol</td>
<td>源端口，可以指定端口号或service，service必须在 /etc/services 文件中存在 <br />可以指定具体端口，也可以指定端口范围 比如 22:80，标识22到80的所有端口 也可以使用取反</td>
</tr>
<tr>
<td>—dport —destination-port</td>
<td>目标端口，语法同上</td>
</tr>
<tr>
<td>—tcp-flags</td>
<td>匹配tcp标记，如SYN/RST/ACK/FIN等，也可用ALL、NONE</td>
</tr>
<tr>
<td>—syn</td>
<td>遗留语法，和 —tcp-flags SYN,FIN,ACK SYN一个效果</td>
</tr>
<tr>
<td>—tcp-option</td>
<td>根据tcp选项匹配</td>
</tr>
</tbody></table>
</li>
<li><p>icmp match</p>
<p>只对 -p icmp 的情况有效，它只有一个参数</p>
<p>—icmp-type，即匹配icmp类型</p>
</li>
<li><p>其它协议的match</p>
</li>
</ul>
<p><strong>显式match</strong></p>
<p>显示匹配就是需要通过-m 或 —match的形式指定的参数</p>
<p>比如地址匹配，地址被Linux分为很多类型，根据地址类型的参数有两个，如下</p>
<ul>
<li><p>—src-type</p>
<p>iptables -A INPUT -m addrtype –src-type UNICAST</p>
</li>
<li><p>—dst-type</p>
<p>iptables -A INPUT -m addrtype –dst-type UNICAST</p>
</li>
</ul>
<blockquote>
<p>还有好多match，如果需要，可以到<a href="https://www.frozentux.net/iptables-tutorial/iptables-tutorial.html#MATCHES">这里查询</a></p>
</blockquote>
<h4 id="目标或跳转"><a href="#目标或跳转" class="headerlink" title="目标或跳转"></a>目标或跳转</h4><p>target/jumps告诉如何处理与规则匹配到的包</p>
<ul>
<li><p>什么是target，即两个基本的target：ACCEPT和DROP</p>
</li>
<li><p>什么是jump呢？原理：上面介绍过了，用iptables -N能够创建新的chain，可以在新的chain上定义自己的规则集，但这个chain并非内建的几个chain之一，因此不会被自动执行，此时就需要jump，语法如下</p>
<p>iptables -A INPUT -p tcp -j <your_chain></p>
<p><strong>上面在INPUT chain中添加了一条rule，将所有tcp协议的包都跳转到自定义chain上，当自定义chain的所有table都执行完成时，它会跳转回原来的chain，即INPUT chain</strong></p>
</li>
</ul>
<p>下面列举所有的target</p>
<table>
<thead>
<tr>
<th>target</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>ACCEPT</td>
<td>接受，接受的意思就是啥都不做，放它过去<br />一旦一个包被接受了，统一table和同一chain的后续规则将被忽略。<br />但其它table仍然可以对这个包进行处理</td>
</tr>
<tr>
<td>DROP</td>
<td>直接丢弃</td>
</tr>
<tr>
<td>CLASSIFY</td>
<td>将包分类，只对mangle表有效<br />iptables -t mangle -A POSTROUTING -p tcp –dport 80 -j CLASSIFY –set-class 20:10</td>
</tr>
<tr>
<td>CONNMARK</td>
<td>将整个连接都做上标记，所有表都可用<br />iptables -t nat -A PREROUTING -p tcp –dport 80 -j CONNMARK –set-mark 4</td>
</tr>
<tr>
<td>MARK</td>
<td>标记匹配到的数据包</td>
</tr>
<tr>
<td>DNAT</td>
<td>指定DNAT的目标地址。只能在nat表的PREROUTING和OUTPUT链中使用<br />iptables -t nat -A PREROUTING -p tcp -d 15.45.23.67 –dport 80 -j DNAT –to-destination 192.168.1.1-192.168.1.10</td>
</tr>
<tr>
<td>SNAT</td>
<td>指定SNAT的源地址。只能在nat表的PREROUTING链使用</td>
</tr>
<tr>
<td>LOG</td>
<td>记录日志，日志记录是通过syslogd实现的<br />iptables -t nat -A POSTROUTING -p tcp -o eth0 -j SNAT –to-source 194.236.50.155-194.236.50.160:1024-32000<br />iptables -A FORWARD -p tcp -j LOG –log-level debug<br />iptables -A INPUT -p tcp -j LOG –log-prefix “输入数据包”</td>
</tr>
<tr>
<td>TTL</td>
<td>设置TTL，只能在mangle表使用<br />iptables -t mangle -A PREROUTING -i eth0 -j TTL –ttl-set 64</td>
</tr>
</tbody></table>
<h2 id="例子分析"><a href="#例子分析" class="headerlink" title="例子分析"></a>例子分析</h2><p>通过<code>iptables-save -c</code>可以将本机的iptables规则集保存到文件，我们将一台布有K3S的机器的规则集贴出来看看</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">ubuntu@VM-20-5-ubuntu:~$ sudo iptables-save -c</span><br><span class="line"><span class="meta">#</span><span class="bash"> Generated by iptables-save v1.8.4 on Mon Jul 18 11:32:54 2022</span></span><br><span class="line">*raw</span><br><span class="line">:PREROUTING ACCEPT [8488585:2225268588]</span><br><span class="line">:OUTPUT ACCEPT [8430728:2167338664]</span><br><span class="line">COMMIT</span><br><span class="line"><span class="meta">#</span><span class="bash"> Completed on Mon Jul 18 11:32:54 2022</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> Generated by iptables-save v1.8.4 on Mon Jul 18 11:32:54 2022</span></span><br><span class="line">*mangle</span><br><span class="line">:PREROUTING ACCEPT [8703414:2282115687]</span><br><span class="line">:INPUT ACCEPT [8703414:2282115687]</span><br><span class="line">:FORWARD ACCEPT [0:0]</span><br><span class="line">:OUTPUT ACCEPT [8643746:2222781964]</span><br><span class="line">:POSTROUTING ACCEPT [8643746:2222781964]</span><br><span class="line">:KUBE-KUBELET-CANARY - [0:0]</span><br><span class="line">:KUBE-PROXY-CANARY - [0:0]</span><br><span class="line">COMMIT</span><br><span class="line"><span class="meta">#</span><span class="bash"> Completed on Mon Jul 18 11:32:54 2022</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> Generated by iptables-save v1.8.4 on Mon Jul 18 11:32:54 2022</span></span><br><span class="line">*nat</span><br><span class="line">:PREROUTING ACCEPT [542:19886]</span><br><span class="line">:INPUT ACCEPT [542:19886]</span><br><span class="line">:OUTPUT ACCEPT [450:29065]</span><br><span class="line">:POSTROUTING ACCEPT [450:29065]</span><br><span class="line">:DOCKER - [0:0]</span><br><span class="line">:KUBE-KUBELET-CANARY - [0:0]</span><br><span class="line">:KUBE-MARK-DROP - [0:0]</span><br><span class="line">:KUBE-MARK-MASQ - [0:0]</span><br><span class="line">:KUBE-NODEPORTS - [0:0]</span><br><span class="line">:KUBE-POSTROUTING - [0:0]</span><br><span class="line">:KUBE-PROXY-CANARY - [0:0]</span><br><span class="line">:KUBE-SEP-VD5CM36UTN4SSMVL - [0:0]</span><br><span class="line">:KUBE-SERVICES - [0:0]</span><br><span class="line">:KUBE-SVC-NPX46M4PTMTKRN6Y - [0:0]</span><br><span class="line">[402612:15051273] -A PREROUTING -m comment --comment &quot;kubernetes service portals&quot; -j KUBE-SERVICES</span><br><span class="line">[402687:15057430] -A PREROUTING -m addrtype --dst-type LOCAL -j DOCKER</span><br><span class="line">[314443:20327485] -A OUTPUT -m comment --comment &quot;kubernetes service portals&quot; -j KUBE-SERVICES</span><br><span class="line">[1:60] -A OUTPUT ! -d 127.0.0.0/8 -m addrtype --dst-type LOCAL -j DOCKER</span><br><span class="line">[314471:20329366] -A POSTROUTING -m comment --comment &quot;kubernetes postrouting rules&quot; -j KUBE-POSTROUTING</span><br><span class="line">[0:0] -A POSTROUTING -s 172.17.0.0/16 ! -o docker0 -j MASQUERADE</span><br><span class="line">[0:0] -A DOCKER -i docker0 -j RETURN</span><br><span class="line">[0:0] -A KUBE-MARK-DROP -j MARK --set-xmark 0x8000/0x8000</span><br><span class="line">[0:0] -A KUBE-MARK-MASQ -j MARK --set-xmark 0x4000/0x4000</span><br><span class="line">[450:29065] -A KUBE-POSTROUTING -m mark ! --mark 0x4000/0x4000 -j RETURN</span><br><span class="line">[0:0] -A KUBE-POSTROUTING -j MARK --set-xmark 0x4000/0x0</span><br><span class="line">[0:0] -A KUBE-POSTROUTING -m comment --comment &quot;kubernetes service traffic requiring SNAT&quot; -j MASQUERADE --random-fully</span><br><span class="line">[0:0] -A KUBE-SEP-VD5CM36UTN4SSMVL -s 10.0.20.5/32 -m comment --comment &quot;default/kubernetes:https&quot; -j KUBE-MARK-MASQ</span><br><span class="line">[0:0] -A KUBE-SEP-VD5CM36UTN4SSMVL -p tcp -m comment --comment &quot;default/kubernetes:https&quot; -m tcp -j DNAT --to-destination 10.0.20.5:6443</span><br><span class="line">[0:0] -A KUBE-SERVICES -d 10.43.0.1/32 -p tcp -m comment --comment &quot;default/kubernetes:https cluster IP&quot; -m tcp --dport 443 -j KUBE-SVC-NPX46M4PTMTKRN6Y</span><br><span class="line">[596:24001] -A KUBE-SERVICES -m comment --comment &quot;kubernetes service nodeports; NOTE: this must be the last rule in this chain&quot; -m addrtype --dst-type LOCAL -j KUBE-NODEPORTS</span><br><span class="line">[0:0] -A KUBE-SVC-NPX46M4PTMTKRN6Y ! -s 10.42.0.0/16 -d 10.43.0.1/32 -p tcp -m comment --comment &quot;default/kubernetes:https cluster IP&quot; -m tcp --dport 443 -j KUBE-MARK-MASQ</span><br><span class="line">[0:0] -A KUBE-SVC-NPX46M4PTMTKRN6Y -m comment --comment &quot;default/kubernetes:https&quot; -j KUBE-SEP-VD5CM36UTN4SSMVL</span><br><span class="line">COMMIT</span><br><span class="line"><span class="meta">#</span><span class="bash"> Completed on Mon Jul 18 11:32:54 2022</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> Generated by iptables-save v1.8.4 on Mon Jul 18 11:32:54 2022</span></span><br><span class="line">*filter</span><br><span class="line">:INPUT ACCEPT [12408:3022585]</span><br><span class="line">:FORWARD DROP [0:0]</span><br><span class="line">:OUTPUT ACCEPT [12420:3225157]</span><br><span class="line">:DOCKER - [0:0]</span><br><span class="line">:DOCKER-ISOLATION-STAGE-1 - [0:0]</span><br><span class="line">:DOCKER-ISOLATION-STAGE-2 - [0:0]</span><br><span class="line">:DOCKER-USER - [0:0]</span><br><span class="line">:KUBE-EXTERNAL-SERVICES - [0:0]</span><br><span class="line">:KUBE-FIREWALL - [0:0]</span><br><span class="line">:KUBE-FORWARD - [0:0]</span><br><span class="line">:KUBE-KUBELET-CANARY - [0:0]</span><br><span class="line">:KUBE-NODEPORTS - [0:0]</span><br><span class="line">:KUBE-PROXY-CANARY - [0:0]</span><br><span class="line">:KUBE-SERVICES - [0:0]</span><br><span class="line">[8703356:2282095737] -A INPUT -m comment --comment &quot;kubernetes health check service ports&quot; -j KUBE-NODEPORTS</span><br><span class="line">[477049:20536811] -A INPUT -m conntrack --ctstate NEW -m comment --comment &quot;kubernetes externally-visible service portals&quot; -j KUBE-EXTERNAL-SERVICES</span><br><span class="line">[8705941:2283153404] -A INPUT -j KUBE-FIREWALL</span><br><span class="line">[0:0] -A FORWARD -m comment --comment &quot;kubernetes forwarding rules&quot; -j KUBE-FORWARD</span><br><span class="line">[0:0] -A FORWARD -m conntrack --ctstate NEW -m comment --comment &quot;kubernetes service portals&quot; -j KUBE-SERVICES</span><br><span class="line">[0:0] -A FORWARD -m conntrack --ctstate NEW -m comment --comment &quot;kubernetes externally-visible service portals&quot; -j KUBE-EXTERNAL-SERVICES</span><br><span class="line">[0:0] -A FORWARD -j DOCKER-USER</span><br><span class="line">[0:0] -A FORWARD -j DOCKER-ISOLATION-STAGE-1</span><br><span class="line">[0:0] -A FORWARD -o docker0 -m conntrack --ctstate RELATED,ESTABLISHED -j ACCEPT</span><br><span class="line">[0:0] -A FORWARD -o docker0 -j DOCKER</span><br><span class="line">[0:0] -A FORWARD -i docker0 ! -o docker0 -j ACCEPT</span><br><span class="line">[0:0] -A FORWARD -i docker0 -o docker0 -j ACCEPT</span><br><span class="line">[348158:22886200] -A OUTPUT -m conntrack --ctstate NEW -m comment --comment &quot;kubernetes service portals&quot; -j KUBE-SERVICES</span><br><span class="line">[8646279:2223824877] -A OUTPUT -j KUBE-FIREWALL</span><br><span class="line">[0:0] -A DOCKER-ISOLATION-STAGE-1 -i docker0 ! -o docker0 -j DOCKER-ISOLATION-STAGE-2</span><br><span class="line">[0:0] -A DOCKER-ISOLATION-STAGE-1 -j RETURN</span><br><span class="line">[0:0] -A DOCKER-ISOLATION-STAGE-2 -o docker0 -j DROP</span><br><span class="line">[0:0] -A DOCKER-ISOLATION-STAGE-2 -j RETURN</span><br><span class="line">[0:0] -A DOCKER-USER -j RETURN</span><br><span class="line">[0:0] -A KUBE-FIREWALL -m comment --comment &quot;kubernetes firewall for dropping marked packets&quot; -m mark --mark 0x8000/0x8000 -j DROP</span><br><span class="line">[0:0] -A KUBE-FIREWALL ! -s 127.0.0.0/8 -d 127.0.0.0/8 -m comment --comment &quot;block incoming localnet connections&quot; -m conntrack ! --ctstate RELATED,ESTABLISHED,DNAT -j DROP</span><br><span class="line">[0:0] -A KUBE-FORWARD -m conntrack --ctstate INVALID -j DROP</span><br><span class="line">[0:0] -A KUBE-FORWARD -m comment --comment &quot;kubernetes forwarding rules&quot; -m mark --mark 0x4000/0x4000 -j ACCEPT</span><br><span class="line">[0:0] -A KUBE-FORWARD -m comment --comment &quot;kubernetes forwarding conntrack rule&quot; -m conntrack --ctstate RELATED,ESTABLISHED -j ACCEPT</span><br><span class="line">[0:0] -A KUBE-SERVICES -d 10.43.0.10/32 -p tcp -m comment --comment &quot;kube-system/kube-dns:dns-tcp has no endpoints&quot; -m tcp --dport 53 -j REJECT --reject-with icmp-port-unreachable</span><br><span class="line">[0:0] -A KUBE-SERVICES -d 10.43.0.10/32 -p tcp -m comment --comment &quot;kube-system/kube-dns:metrics has no endpoints&quot; -m tcp --dport 9153 -j REJECT --reject-with icmp-port-unreachable</span><br><span class="line">[0:0] -A KUBE-SERVICES -d 10.43.0.10/32 -p udp -m comment --comment &quot;kube-system/kube-dns:dns has no endpoints&quot; -m udp --dport 53 -j REJECT --reject-with icmp-port-unreachable</span><br><span class="line">[0:0] -A KUBE-SERVICES -d 10.43.40.11/32 -p tcp -m comment --comment &quot;kube-system/metrics-server:https has no endpoints&quot; -m tcp --dport 443 -j REJECT --reject-with icmp-port-unreachable</span><br><span class="line">COMMIT</span><br><span class="line"><span class="meta">#</span><span class="bash"> Completed on Mon Jul 18 11:32:54 2022</span></span><br></pre></td></tr></table></figure>

<p>解读几个关键语法</p>
<ul>
<li><p><code>*raw</code></p>
<p>声明往下到COMMIT之间的行，都是在raw表中</p>
</li>
<li><p><code>:PREROUTING ACCEPT [8488585:2225268588]</code></p>
<p>这是一个累计状态，表示 PREROUTING这个chain已经接受了 8488585 个数据包，共计2225268588个字节的数据。</p>
</li>
<li><p><code>[402612:15051273] -A PREROUTING -m comment --comment &quot;kubernetes service portals&quot; -j KUBE-SERVICES</code></p>
<p>这是一条规则，前面是匹配这条规则的累计状态<code>[包数:字节数]</code>。</p>
<p>这条规则说明：经过PREROUTING阶段的的所有数据包，都加上注解，然后跳转到KUBE-SERVICES chain上遍历</p>
</li>
</ul>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>iptables关键点</p>
<ul>
<li>TCP/IP协议栈</li>
<li>数据包在内核中的处理流程</li>
<li>iptables语法</li>
</ul>
]]></content>
      <categories>
        <category>运维</category>
      </categories>
      <tags>
        <tag>iptables</tag>
      </tags>
  </entry>
  <entry>
    <title>《超越感觉》——没有预期的那样好</title>
    <url>/2021/09/11/%E3%80%8A%E8%B6%85%E8%B6%8A%E6%84%9F%E8%A7%89%E3%80%8B%E2%80%94%E2%80%94%E6%B2%A1%E6%9C%89%E9%A2%84%E6%9C%9F%E7%9A%84%E9%82%A3%E6%A0%B7%E5%A5%BD--chao-yue-gan-jue--mei-you-yu-qi-de-na-yang-hao/</url>
    <content><![CDATA[<blockquote>
<p>阅读时间：6.5小时<br>阅读粒度：较粗</p>
</blockquote>
<h2 id="背景篇"><a href="#背景篇" class="headerlink" title="背景篇"></a>背景篇</h2><p>全书的思路很清晰，也能看出作者想要表达什么。</p>
<p>大家认识自我我们每个人，都受到特定的时间和空间的限制，拥有不同的文化背景，从小被灌输特定的道德观念，因此我们看待问题的角度一定是不一样的；我们的想法、思绪，受外界影响，大众媒体的发展，导致我们花在手机、电视上的时间比花在学习上的时间多好几倍，而这些媒介只是受商业或政治驱使的工具，具有很强的“洗脑”作用，无形中影响着我们看问题的角度；就算我们是一个爱学习的好孩子，我们的认知也会收到当前时代局限性的影响：人类从古至今的发展，几乎一直是进步的，每个时代都认为自己拥有超高水平的认知。但历史一次次证明，以前看起来无懈可击的理论，随着更多发现和研究，看起来变得颇为可笑，日心说如此，甚至经典力学也不能完全适用所有情况。这是第一章所阐述的内容，是全书最有意义的一章。</p>
<p>要拥有批判性思维，首先应该有上述觉悟，我们有局限性，我们的时代有局限性。应当始终坚持一个观点：“我知道我有局限性并且容易出错。而且，毫无疑问，我将永远不可能找到自己想知道的所有答案。但是我可以观察得更准确一点，权衡问题更全面一点，作出决定时更加仔细一点，如果我这么做了，我就会更加接近真理”。</p>
<p>这里引出一个方法问题，如何才算批判性思维呢？从事理性研究工作的人应该比较有体会。</p>
<ul>
<li>对于任何信息、观点，都不能直接相信</li>
<li>需要针对它提出问题 → 搜集资料、证据 → 分析论证 → 得出结论</li>
</ul>
<p>这一过程，也是我们日常工作的一部分。有人说，WebSocket是服务端推送最好的方式，针对这一观点，我们可以提出几个疑问</p>
<ul>
<li>这个观点本身是真的吗？</li>
<li>服务端推送是什么？</li>
<li>服务端推送还有哪些技术实现方案？</li>
<li>有最好的方式吗？“最好”岂不是银弹？这个世界上有银弹吗？</li>
</ul>
<p>然后，通过搜集整理，我们会发现除了WebSocket外，还有long-polling、SSE、HTTP2都与服务端推送相关，只是说WebSocket的功能更加全面，但它也有缺点，如不能使用现有的HTTP基础设施，这个角度讲，长轮询和SSE反而更好。还有使用场景，如果仅仅想要一个简单的服务端推送，几个技术都能满足，此时就要从实现的简单程度上考虑了。</p>
<p>这里又引出一个问题，那就是持有批判性思维，必然要求我们对大量资料和数据进行分析，如此大量的输入，要求我们有较为丰富的知识储备：丰富的知识，是又一个重点。</p>
<p>至于本篇后面几章，只是对前两章的扩展，论证说明几个点，过于啰嗦，直接略过。</p>
<ul>
<li>自我认知是有局限性的</li>
<li>任何资料都可能出错，包括感知、记忆、信息、权威，我们要做的，是判断它的确信度</li>
<li>得出观点要有充分的依据</li>
<li>为了面子坚持自己错误的观点是愚蠢的，理智地改变自己的观点并不会被人嘲笑</li>
<li>自我要求：要从受限的环境中通过一次次理性的批判分析赢得“个性”</li>
</ul>
<h2 id="易犯的错误"><a href="#易犯的错误" class="headerlink" title="易犯的错误"></a>易犯的错误</h2><p>本篇列举多达十几种错误。从根源看的话，无非两类：自我认知问题和方式方法问题</p>
<ul>
<li>自我认知问题：以自我为中心，不听从他人意见，容易受情绪影响；或者是受外界影响，无法坚持自己，容易盲从；多多少少有一些观点偏向性，导致发现的证据和做出的结论带有偏见。</li>
<li>方式方法问题：搜集资料不够多，不能做出正确的判断；缺乏耐心，急于下结论，导致得到一个草率的结论，甚至错误的结论。</li>
</ul>
<p>要解决这些问题，觉得应该做到几点</p>
<ul>
<li>扩展知识面</li>
<li>保持谦逊的态度，保持求知的态度</li>
<li>保持自信，却不盲目自信：这前提是观点经过自己反复论证</li>
<li>保持耐心</li>
</ul>
<h2 id="策略"><a href="#策略" class="headerlink" title="策略"></a>策略</h2><p>如果说前面讨论的是理论基础，这里说的就是方法了，但这几章我直接跳过了，因为除了提纲，它所传达的细节内容对我不会有任何帮助。</p>
<p>那我们来大致说一下方法论。</p>
<ul>
<li>认识自己：批判性思考，一般来说是思考自己在生活中遇到的问题。但自己才是所有问题的首要，很多人愤怒、堕落，正是因为没有从批判的角度看清自己。</li>
<li>善于观察：不只是善于观察生活，还要善于观察方方面面，以我为例，行业、技术，都算。</li>
<li>选择议题：即批判性思考的目标。首先要从各方面拆分问题，再根据这些方面搜集资料。</li>
<li>资料搜集：搜集的资料，来自各种途径、有各种类型，要针对途径、类型再次以批判性眼光进行论证。</li>
<li>下结论：什么时候能下结论？当你认为事情已经有明确证据证明的时候。</li>
<li>说服他人：我为什么要说服他人？</li>
</ul>
<p>看，这也只是对第一篇批判性思考执行方法的具体扩展，所以呢，不读也罢。</p>
<p>而且，批判性思维这种东西，重在指导，具体怎么做，还是看个人。</p>
<h2 id="总体怎么讲"><a href="#总体怎么讲" class="headerlink" title="总体怎么讲"></a>总体怎么讲</h2><p>总体来说是本好书，但读完之后有种啥也没看的感觉，原因是干扰项太多。至少有两个干扰项——不够本土化的例子、过于啰嗦的表述方式。</p>
<p>仔细回想，我能记得的关键点就只有几个</p>
<ul>
<li>怀疑一切，包括自己：证据有可能是假的；自己是有局限性的</li>
<li>凡事经过论证：只有充分的证据表明一件事情是那样的，它才是那样的，别人说的，一概不信</li>
<li>问-找-结：从各方面充分提问，找论据做支撑，得出结论</li>
</ul>
<p>这本书适合谁？</p>
<p>至少不适合我，或者不完全适合我。一来，对于我认为是问题的问题，已经采取了书中所说的方法进行论证解析，因此没有带来太多东西；二来，表达过于学术化，可能因为它叫”批判性思考指南“吧，所以提出的任何一个观点，都会有一堆素材作为证据。而这些论据往往带有美国独有的历史、政治、民族特性，我完全无感，对阅读体验来说是负面的。与此相对，《认知觉醒》中的例子十分符合中国国情，队理解起到了正面作用。</p>
<p>适合谁呢🤔。可能适合学生，每一章后有应用题，而且作者也有提及”学期“这种字眼，想必就是为学生专门设计。我这种只想从中获取观点和方法的人，粗略看一遍即可；而想要细致培养批判性思维方式的学生、学者，可以按照书的节奏试一试。</p>
<h2 id="本书对我的影响"><a href="#本书对我的影响" class="headerlink" title="本书对我的影响"></a>本书对我的影响</h2><ul>
<li>认识到自己有局限性，别人也有局限性，所以不应该对别人有莫名的高期望值。别人，是你文章的读者，你的同事，也是你的聊天对象。</li>
<li>局限于专业会导致看问题视角过窄，因此保持对学习的激情，保持对问题的好奇，多多探索，才是批判性探索的应对之道。</li>
<li>批判所有，问题本身、提出问题的人、为解决问题而找出的资料，批判是递归的。</li>
<li>保持耐心：“我知道我有局限性并且容易出错。而且，毫无疑问，我将永远不可能找到自己想知道的所有答案。但是我可以观察得更准确一点，权衡问题更全面一点，作出决定时更加仔细一点，如果我这么做了，我就会更加接近真理”。</li>
</ul>
]]></content>
      <categories>
        <category>随笔</category>
        <category>读书笔记</category>
      </categories>
      <tags>
        <tag>超越感觉</tag>
      </tags>
  </entry>
  <entry>
    <title>区分随笔和正文</title>
    <url>/2020/08/15/%E5%8C%BA%E5%88%86%E9%9A%8F%E7%AC%94%E5%92%8C%E6%AD%A3%E6%96%87-qu-fen-sui-bi-he-zheng-wen/</url>
    <content><![CDATA[<h2 id="破掉的FLAG"><a href="#破掉的FLAG" class="headerlink" title="破掉的FLAG"></a>破掉的FLAG</h2><p>2019年8月11日，发布博文《我有点想要写博客了》，总结了之前一段时间的个人状态，并立下从那以后每月至少两篇博文的FLAG。如今一年过去了，不出所料，FLAG倒了。这一年间按计划应该又至少24篇新发布的文章，实际数量——20篇。且其中质量较好的不到10篇。考虑到立FLAG只有几个月里写的挺积极，则近几个月如果不是公司的一月一篇的硬性博客任务，恐怕会是触目惊心的0篇文章。</p>
<span id="more"></span>

<h2 id="冷启动"><a href="#冷启动" class="headerlink" title="冷启动"></a>冷启动</h2><h3 id="时间会消磨提笔的勇气"><a href="#时间会消磨提笔的勇气" class="headerlink" title="时间会消磨提笔的勇气"></a>时间会消磨提笔的勇气</h3><p>一件事，如果长时间不做，想再开始，难度会成倍上涨。这里说的难度来自各方面：心理的、生理的；自身因素、外界因素。这种现象在生活中大量存在：如果长时间不与人交流，突然和别人说话时会显得咬字不清或语无伦次；长时间不从事某项运动，想要再次开始并达到之前的运动水准需要较长时间；大脑长时间处于放空状态，反应会变慢。这种现象，我愿称之为<strong>冷启动</strong>。俗话说可以是刀久了不用会生锈。</p>
<p>就写博客而言，冷启动的阻力主要来自于思维和身体的惰性、文笔的生疏等方面，更重要的是会消磨掉你想要分享东西给别人的热情和勇气。</p>
<p>写代码也一样，作为一个程序员，如果长时间不写代码，对常用工具的生疏感、对自身的焦虑都会加深不自信，形成恶性循环。</p>
<h3 id="冷启动优化-预热"><a href="#冷启动优化-预热" class="headerlink" title="冷启动优化 - 预热"></a>冷启动优化 - 预热</h3><p>技术上讲，冷启动常用的优化方式是预热。即在刀生锈之前再磨一磨。曾遇到某云服务厂商的函数计算服务长时间不调用会因冷启动时间过长而导致响应超时，解决方式就是预热，因此对此音箱深刻。</p>
<p>写博客的预热方式，就是——常写。</p>
<h2 id="随笔和正文"><a href="#随笔和正文" class="headerlink" title="随笔和正文"></a>随笔和正文</h2><h3 id="预热的成本和价值"><a href="#预热的成本和价值" class="headerlink" title="预热的成本和价值"></a>预热的成本和价值</h3><p>预热的成本不可太高，过高的成本会占用过多资源，相对地，正式任务的资源会减少；且对现实意义来说，预热这一操作必须具有一定的价值，不能为了预热而预热。比如用于保持状态（预热）的博客必须具有价值，不能太水。</p>
<h3 id="随笔和正文-1"><a href="#随笔和正文-1" class="headerlink" title="随笔和正文"></a>随笔和正文</h3><p>目前为止，我们确认了两个指导方针</p>
<ul>
<li>博客要常写，否则会手生</li>
<li>常写的博客成本不能太高，必须与价值均衡</li>
</ul>
<p>这为随笔出现在我的博客列表中提供了正当性。按照过去一年的经验，要想完成一篇知识涵盖相对完整、有稍许深度的博文，往往需要好几个工作日的下班时间来搜集资料，再花一整天时间进行资料整理、知识点提炼和总结，最后再花半天时间进行文本校对、版式重排等。可以说相当耗时。</p>
<p>比如《可能是最全的Kotlin协程讲解》这篇文章零零总总耗费了一周的业余时间查阅整理资料，一整个周六的时间提炼和编写；《PostgreSQL - 一文看懂explain》花费了一周时间看完了整本书，再花费了两天时间整理和编写。</p>
<p>如上列举的两篇文章，我们称之为正文，成本非常高，当然不能作为常写的目标，毕竟我还需要学习和工作。于是我需要随笔的加入。</p>
<p>我这样定义随笔：日常学习中的某些知识点提取出来的，有一定分享价值的短篇文章。不会过于随便，又不会过于耗时。非常适合用来预热。</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>写了一个小时，总结就是，<strong>我要些随笔了</strong>。</p>
]]></content>
  </entry>
  <entry>
    <title>单元测试 - 理论</title>
    <url>/2022/01/22/%E5%8D%95%E5%85%83%E6%B5%8B%E8%AF%95%E7%90%86%E8%AE%BA/</url>
    <content><![CDATA[<blockquote>
<p>很多人是不写单元测试的，无非因为性价比太低。但我始终以为，真实原因是打开方式不正确，如果花功夫系统研究一下，或许会不一样。</p>
<p>这不就来了，现希望相对系统第了解单元测试的理论、常用工具、实施方法。伴随会产生系列文章。初预备三部分：</p>
<ul>
<li>理论：介绍单元测试需要关注的内容，从设计上如何考虑</li>
<li>工具：介绍Spring Test、JUnit、Assert、Mock技术，相关库的使用</li>
<li>实践：基于以上两个部分的学习，重构当前的一个项目，记录过程中考虑的点。并最终给出结论。</li>
</ul>
<p>此篇为首！</p>
</blockquote>
<span id="more"></span>

<p>与单元测试相关的书籍，大约有这么三本，评分都不戳。</p>
<ul>
<li>《单元测试的艺术》</li>
<li>《有效的单元测试》</li>
<li>《单元测试之道》</li>
</ul>
<p>本文主要内容来自于《单元测试之道》，需要注意的是，它是2005年出版的书籍，谨慎接受其知识点。</p>
<h2 id="几个概念"><a href="#几个概念" class="headerlink" title="几个概念"></a>几个概念</h2><p>无论文章或书籍，时常提及几个概念，注意区分。</p>
<ul>
<li><p>SDLC：Software Development Lifecycle</p>
<p>软件开发生命周期</p>
</li>
<li><p>TDD：Test Driven Development</p>
<p>测试驱动开发，以测试用例为主，编码以通过用例为主要目的。通过不断地 测试-重构 ，最终完成编码</p>
<p><img src="https://gdz.oss-cn-shenzhen.aliyuncs.com/local/image-20220122114903059.png" alt="image-20220122114903059"></p>
</li>
<li><p>BDD：Bebavioural Driven Development</p>
<p>行为驱动开发，TDD衍生出来的一种<strong>测试case开发方式</strong>。测试基于被测系统的行为，即所谓的Given-When-Then（假设 - 当 -然后），举例</p>
<ul>
<li>假设用户输入了有效凭证</li>
<li>当用户点击登录按钮</li>
<li>提示登录成功信息</li>
</ul>
<p>BDD使得开发者更加关注用户的行为。</p>
<img src="https://gdz.oss-cn-shenzhen.aliyuncs.com/local/image-20220122115159520.png" alt="image-20220122115159520" style="zoom:80%;" />

<blockquote>
<p>AssertJ提供BDD方式的断言API</p>
</blockquote>
</li>
<li><p>ATDD：Acceptance Test-Driven Development</p>
<p>验收测试驱动开发。从用户的角度编写。主要侧重于验证系统的功能行为。它用于验证 - 代码是否按照预期工作了。重点在验收，行为人是QA或用户</p>
</li>
</ul>
<p>TDD、BDD、ATDD都可归属于测试驱动开发，三者主要对比关系如下</p>
<table>
<thead>
<tr>
<th align="left"><strong>Parameters</strong></th>
<th align="left"><strong>TDD</strong></th>
<th align="left"><strong>BDD</strong></th>
<th align="left"><strong>ATDD</strong></th>
</tr>
</thead>
<tbody><tr>
<td align="left"><strong>参与方</strong></td>
<td align="left">开发者</td>
<td align="left">开发者, 用户, QA</td>
<td align="left">开发者, 用户, QA</td>
</tr>
<tr>
<td align="left"><strong>使用语言</strong></td>
<td align="left">编程语言，如Java、Kotlin</td>
<td align="left">自然语言。或者是DSL</td>
<td align="left">自然语言。或者是DSL</td>
</tr>
<tr>
<td align="left"><strong>关注点</strong></td>
<td align="left">单元测试</td>
<td align="left">理解需求</td>
<td align="left">验收测试</td>
</tr>
<tr>
<td align="left"><strong>工具(过时)</strong></td>
<td align="left">JDave, <a href="https://www.browserstack.com/guide/learn-about-cucumber-testing-tool">Cucumber</a>, JBehave, Spec Flow, BeanSpec, Gherkin Concordian, FitNesse</td>
<td align="left">Gherkin, Dave, Cucumber, JBehave, Spec Flow, BeanSpec, Concordian</td>
<td align="left"><a href="https://www.browserstack.com/guide/testng-framework-with-selenium-automation">TestNG</a>, FitNesse, EasyB, Spectacular, Concordian, Thucydides</td>
</tr>
</tbody></table>
<blockquote>
<p>资料参考：<a href="https://www.browserstack.com/guide/tdd-vs-bdd-vs-atdd">https://www.browserstack.com/guide/tdd-vs-bdd-vs-atdd</a></p>
</blockquote>
<h2 id="测试什么"><a href="#测试什么" class="headerlink" title="测试什么"></a>测试什么</h2><p>提到单元测试，你肯定会想到测试边缘case，但其实不止于此。详细来说，所有需要考虑的点可以用RIGHT-BICEP表示</p>
<h3 id="RIGHT"><a href="#RIGHT" class="headerlink" title="RIGHT"></a>RIGHT</h3><p>结果是否正确？</p>
<p>首先考虑所有的正常case，保证基本功能正常。对于这类case，如果有大量测试数据，可以考虑使用数据文件存储，测试代码读取的方式。</p>
<h3 id="B-order"><a href="#B-order" class="headerlink" title="B[order]"></a>B[order]</h3><p>所有边界条件都正确吗？</p>
<p>有一个方式有助于思考所有的边界条件</p>
<ul>
<li>Conformance - 一致性，值是否和预期一致</li>
<li>Ordering - 顺序性，值是否和预期一样有序</li>
<li>Range - 区间性，值是否位于最小值和最大值之间</li>
<li>Reference - 依赖性，代码是否引入了一些不在代码控制范围内的资源</li>
<li>Existence - 存在性，值是否存在，null、0、””、空集合等</li>
<li>Cardinatity - 基数性，是否恰好有足够的数量</li>
<li>Time - 时间性，所有事情的发生是否是有序的、时间是否正好</li>
</ul>
<h3 id="I-nverse"><a href="#I-nverse" class="headerlink" title="I[nverse]"></a>I[nverse]</h3><p>反向关联如何？</p>
<p>运用方法的反向逻辑关系来验证它们。比如插入数据库，可以用查询数据库进行验证。</p>
<h3 id="C-ross"><a href="#C-ross" class="headerlink" title="C[ross]"></a>C[ross]</h3><p>能用其它手段交叉检查结果吗？</p>
<p>计算一个量可以有多种算法，当我们实现一种算法时。可以在单元测试中用另一种看起来比较笨但正确率比较高的算法来对比验证。这就叫交叉检查。</p>
<h3 id="E-rror"><a href="#E-rror" class="headerlink" title="E[rror]"></a>E[rror]</h3><p>是否可以强制错误条件发生？</p>
<p>模拟现实情况中的错误，当然不可能去拔网线，但是我们可以Mock，一些典型的错误如</p>
<ul>
<li>内存耗光</li>
<li>磁盘用满</li>
<li>时钟出问题</li>
<li>网络不可用或者有问题</li>
<li>系统过载</li>
</ul>
<h3 id="P-erformance"><a href="#P-erformance" class="headerlink" title="P[erformance]"></a>P[erformance]</h3><p>性能是否满足要求？</p>
<p>测试指定方法的性能，但是需要注意的是这类单元测试不能经常做，因为比较耗时，要与其它单元测试分开。</p>
<blockquote>
<p>下文，我们具体来看看各细分点</p>
</blockquote>
<h2 id="边界条件"><a href="#边界条件" class="headerlink" title="边界条件"></a>边界条件</h2><h3 id="常见边界"><a href="#常见边界" class="headerlink" title="常见边界"></a>常见边界</h3><ul>
<li>逻辑边界：如角度超过360、人的年龄超过200等</li>
<li>集合：空集合、null、下标越界</li>
</ul>
<h3 id="引用性"><a href="#引用性" class="headerlink" title="引用性"></a>引用性</h3><ul>
<li>前条件：系统必须处于什么状态下才能运行。这和一致性类似</li>
<li>后条件：方法将保证哪些状态发生。方法本身的结果，需要检查。方法产生的副作用，也是需要检查的。</li>
</ul>
<p>比如，对数据库的操作应该就算是副作用，也需要对插入的结果进行验证。</p>
<h3 id="基数性"><a href="#基数性" class="headerlink" title="基数性"></a>基数性</h3><ul>
<li>基数指的是计数，是否有恰好的数量</li>
<li>关注0-1-n，其中n可能会随着数量的变化而变化</li>
<li>这个n意味着两方面<ul>
<li>写代码时，需要考虑n变化的情况，不能写死</li>
<li>测试时，需要验证n的变化情况是否在代码中有考虑到</li>
</ul>
</li>
</ul>
<h3 id="时间性"><a href="#时间性" class="headerlink" title="时间性"></a>时间性</h3><ul>
<li><p>相对时间，即时间上的顺序</p>
<ul>
<li><p>比如两个方法的调用需要有顺序，如果调用顺序相反，则需要有错误</p>
<p>比如connect() 和 read()</p>
</li>
</ul>
</li>
<li><p>绝对时间，即time，钟表上的时间</p>
<ul>
<li><p>时区是否对代码有所影响。遵循不同的时间规则，对时间的计算不一样。比如GMT、夏令时等</p>
<p>一般来说，遇到时区问题时，底层库很可能会出现问题。因此在单元测试中有必要进行测试</p>
</li>
<li><p>超时时间是否生效</p>
</li>
</ul>
</li>
<li><p>并发问题</p>
<ul>
<li>即多线程测试</li>
</ul>
</li>
</ul>
<h2 id="使用Mock"><a href="#使用Mock" class="headerlink" title="使用Mock"></a>使用Mock</h2><p><strong>单元测试的目的是一次只验证一个方法。</strong>如果方法耦合了其它因素，比如数据库、网络请求等，此时我们在验证方法之前去准备这些外部环境，不仅浪费时间，还可能因为外部环境发生变化而导致单元测试在没有修改的情况下出现失败。此时需要使用Mock进行数据模拟。</p>
<p>一般来说，真实对象具有如下不方便的特点，Mock可以完全解决这些问题</p>
<ul>
<li>具有不确定的行为</li>
<li>很难被创建</li>
<li>某些行为很难被触发</li>
<li>可能有用户界面</li>
</ul>
<blockquote>
<p>日常使用的大部分东西，如数据库、网络，都有专门的Mock库，不要费劲去自己手动Mock。</p>
</blockquote>
<h2 id="何为好的单元测试"><a href="#何为好的单元测试" class="headerlink" title="何为好的单元测试"></a>何为好的单元测试</h2><p>单元测试虽好，但如果使用不当，则会浪费大量时间。有一个衡量单元测试好坏的标准：A-TRIP</p>
<ul>
<li>Automatic - 自动化<ul>
<li>测试调用自动化</li>
<li>测试结果检查自动化</li>
</ul>
</li>
<li>Thorough - 彻底<ul>
<li>单元测试覆盖要完全</li>
</ul>
</li>
<li>Repeatable - 可重复<ul>
<li>每个测试独立于其它测试；独立于周围的环境</li>
<li>需要能够以任意顺序可重复地执行</li>
</ul>
</li>
<li>Independent - 独立<ul>
<li>每个测试都要有很强的针对性</li>
<li>确保一次只测试了一样东西</li>
<li>一个测试函数可以仅测试一个复杂函数的一小部分功能；该函数的测试由多个这种小的测试函数共同组成</li>
<li>JUnit的@Before和@After就是针对这个问题设置的。每个test函数都会执行一次@Before和@After指定的函数</li>
<li>你绝对不能假设JUnit的单元测试函数之间的顺序</li>
</ul>
</li>
<li>Professional - 专业<ul>
<li>不要对无关紧要的bug进行测试</li>
<li>测试的代码和正常的代码一样，都可以面向对象、遵循解耦合原则等</li>
</ul>
</li>
</ul>
<h2 id="面向测试的设计"><a href="#面向测试的设计" class="headerlink" title="面向测试的设计"></a>面向测试的设计</h2><p>如TDD所说，从一开始就针对测试进行设计，具体来说：</p>
<ul>
<li>通过令代码更加容易测试来改善代码的设计。甚至可能为了使代码变得容易测试而对代码进行重构</li>
<li>关注点分离。将能够测试的点和不能测试的点分离，使得该方法可测试</li>
<li>如果测试代码看起来非常丑陋，这可能就是一个不好的征兆，代码需要重新设计，直到写出易于测试的代码</li>
</ul>
<p>书中给出了一个例子，一个GUI组件，将逻辑和GUI显示糅合在了一起，使得无法进行单元测试。解决方案是拆分出逻辑部分，对它进行单元测试。</p>
<h2 id="一些陷阱"><a href="#一些陷阱" class="headerlink" title="一些陷阱"></a>一些陷阱</h2><p>一些陷阱，还挺典型的</p>
<ul>
<li><p>不写单元测试</p>
<p>没有单元测试的代码，bug一定会在某个时刻爆发</p>
</li>
<li><p>用冒烟测试替代单元测试</p>
<p>这里并不是指整个系统的冒烟测试，而是很多人写单元测试的一种方式：将包含多个流程的函数用一个单元测试搞定，忽略中间逻辑的测试，这种测试的目的是：流程是否能够跑通</p>
<p>这种单元测试无非在给自己营造一种虚无的安全感而已 - <strong>你以为你测试过了，实际上并没有</strong></p>
</li>
<li><p>只在本机跑单元测试</p>
<p>有可能在CI机或别人的机器上跑不了，要求在所有机器上都能跑起来</p>
</li>
<li><p>浮点数相等问题</p>
<p>断言浮点数相等时，要考虑精度问题</p>
</li>
<li><p>每次执行长耗时单元测试</p>
<p>部分单元测试耗时太长，不能每次提交CI都执行，需要将其提取出来，低频测试</p>
</li>
<li><p>代码修改导致单元测试失败</p>
<p>如果实现代码只修改一小部分，就导致测试代码失败，需要大量修改才能重新正确，说明被测试的代码逻辑之间耦合太深</p>
<p>理论上，修改一部分代码，只需要对这部分测试代码进行修改</p>
</li>
</ul>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>一个好的单元测试，需要考虑的绝不仅仅是边界case，还需要考虑正确性、性能、代码的优雅性。</p>
<p>一个好的单元测试，最终应该是能够提升开发效率，而不是带来无止尽的修改，如果这种情况出现了，考虑重构单元测试🤔。</p>
]]></content>
      <categories>
        <category>测试</category>
      </categories>
      <tags>
        <tag>单元测试</tag>
      </tags>
  </entry>
  <entry>
    <title>域名系统介绍及原理</title>
    <url>/2019/12/01/%E5%9F%9F%E5%90%8D%E7%B3%BB%E7%BB%9F%E4%BB%8B%E7%BB%8D%E5%8F%8A%E5%8E%9F%E7%90%86-%E5%9F%9F%E5%90%8D%E7%B3%BB%E7%BB%9F%E4%BB%8B%E7%BB%8D%E5%8F%8A%E5%8E%9F%E7%90%86/</url>
    <content><![CDATA[<p>DNS，全称Domain Namespace System，即域名系统。是互联网一项核心服务，将域名映射为IP地址（或其他类型记录），使得用户能够通过域名方便地访问特定的网站，而不必记住复杂而晦涩的IP地址。<br>如此重要功能，各大云服务商一般都有提供域名申请和域名解析服务。域名申请服务提供获得全网唯一域名的方式，如zouguodong.top、baidu.com等；域名解析服务则能够提供域名到指定服务的映射，最常见的就是映射到IP。</p>
<span id="more"></span>

<h1 id="域名"><a href="#域名" class="headerlink" title="域名"></a>域名</h1><h2 id="域名的组成"><a href="#域名的组成" class="headerlink" title="域名的组成"></a>域名的组成</h2><p>域名具有全网唯一性。而由于互联网用户数量众多，想要拥有自己域名的个人或企业数不胜数，因此域名采用状结构命名法。任何连接在因特网上的主机或路由器，都有一个唯一的层次结构的名字，即域名(domain name)。这里，“域”(domain)是名字空间中一个可被管理的划分。从语法上讲，每一个域名都是有标号(label)序列组成，而各标号之间用点(小数点)隔开。域名可以划分为各个子域，子域还可以继续划分为子域的子域，这样就形成了顶级域、主域名、子域名等。图示如下</p>
<p><img src="https://gdz.oss-cn-shenzhen.aliyuncs.com/hexo/%E5%9F%9F%E5%90%8D%E8%A7%A3%E6%9E%90DNS/image-20191201165045751.png" alt="image-20191201165045751"></p>
<p>各级域名举例如下</p>
<ul>
<li>顶级域名（一级域名）：.com</li>
<li>主域名（二级域名）：google.com</li>
<li>子域名（三级域名）：api.google.com</li>
</ul>
<blockquote>
<p>一个完整的域名，本应该由子域名+主域名+顶级域名+根域名组成，如：api.google.com.，早先的域名解析系统就是这样，如果不输入最后一个点，是无法正确解析的。这当然是很傻的做法，因此在如今的DNS服务器已经能够自动补全根域的点了，现在反而是输入了最后的点会无法解析。</p>
</blockquote>
<p>我们通常是购买主域名，一个主域名下理论上可以创建无限多个子域名，例如内网穿透服务提供商NATAPP自身拥有一个主域名如nat100.top，但是可以提供用户购买子域名。</p>
<p><img src="https://gdz.oss-cn-shenzhen.aliyuncs.com/hexo/%E5%9F%9F%E5%90%8D%E8%A7%A3%E6%9E%90DNS/image-20191201154232500.png" alt="image-20191201154232500"></p>
<h2 id="域名注册"><a href="#域名注册" class="headerlink" title="域名注册"></a>域名注册</h2><p>一个比较好的类比是买房子，购买域名相当于买一块地皮，创建子域名好比划分这块地，而服务搭建可类比建房子。</p>
<p>域名注册的价格比较便宜，但由于其唯一性，你想要的域名在你之前很可能已经被人注册了，此时就要委托购买，价格就天差地别了，数万到数百万不等，上亿也有可能，据称VacationRentals.com收购价为3500万美元，国内最贵360.com收购价则为1700万美元。也正是如此高昂的价格，使得域名抢注称为一个热点。</p>
<p>抛开热门域名，对于普通用户，想要注册一个冷门域名，价格还是比较亲和的，几十块就能搞定一年，没错，域名是有使用期限限制的，注册时可选年限，比如以我的名字命名的域名价格一年和十年比较如下。</p>
<p><img src="https://gdz.oss-cn-shenzhen.aliyuncs.com/hexo/%E5%9F%9F%E5%90%8D%E8%A7%A3%E6%9E%90DNS/image-20191201155650946.png" alt="image-20191201155650946"></p>
<p><img src="https://gdz.oss-cn-shenzhen.aliyuncs.com/hexo/%E5%9F%9F%E5%90%8D%E8%A7%A3%E6%9E%90DNS/image-20191201155715623.png" alt="image-20191201155715623"></p>
<h2 id="域名备案"><a href="#域名备案" class="headerlink" title="域名备案"></a>域名备案</h2><p>根据 《互联网信息服务管理办法》 以及 《非经营性互联网信息服务备案管理办法》 ，国家对非经营性互联网信息服务实行备案制度，对经营性互联网信息服务实行许可制度。未取得许可或者未履行备案手续的，不得从事互联网信息服务。即所有对中国大陆提供服务的网站都必须先进行ICP备案，才可开通服务。</p>
<p>若未备案，域名服务商将会拒绝解析，并提示你去备案啦。</p>
<h1 id="域名解析"><a href="#域名解析" class="headerlink" title="域名解析"></a>域名解析</h1><p>上面介绍了域名相关知识，但域名最终还是要解析到具体的服务上才有价值。如下说明域名解析如何运作</p>
<h2 id="域名服务器"><a href="#域名服务器" class="headerlink" title="域名服务器"></a>域名服务器</h2><p>域名呈树状结构，解析方式也是如此，针对不同层级上的域名，有不同的DNS服务器</p>
<ul>
<li><p>本地域名服务器：DNS Resolver或Local DNS。响应来自客户端的请求，并最终跟踪直到获取到解析结果的DNS服务器，是客户端直接访问的服务。如本机自动分配的DNS、运营商ISP分配的DNS、谷歌/114公共DNS等。例如我们手动设置电脑网络为手动配置时的DNS服务器，即为本地域名服务器的地址，可以手动设置114.114.114.114等公共DNS服务器地址。也可以选择自动DHCP的方式，自动分配DNS服务器地址。理解这点很重要，因为这是我们直接访问的DNS服务器，而下面三种则是我们不会直接访问的服务器。</p>
<p><img src="https://gdz.oss-cn-shenzhen.aliyuncs.com/hexo/%E5%9F%9F%E5%90%8D%E8%A7%A3%E6%9E%90DNS/image-20191201161114768.png" alt="image-20191201161114768"></p>
</li>
<li><p>根DNS服务器：Root nameserver。本地域名服务器在本地找不到解析结果时，会首先向它查询，它会返回顶级域名服务器的地址</p>
</li>
<li><p>顶级域名服务器：Tld nameserver。负责管理该顶级域名下的二级域名，返回二级域名所在的权威域名服务器地址</p>
</li>
<li><p>权威域名服务器：authoritative nameserver。负责维护该区域内的域名和IP地址的之间的对应关系，能够返回最终的解析结果。阿里云DNS解析服务、amazon的Route 53 name都属于该类服务器。</p>
</li>
</ul>
<h2 id="解析过程"><a href="#解析过程" class="headerlink" title="解析过程"></a>解析过程</h2><p>用户使用域名访问某个资源的完整过程如下图</p>
<p><img src="https://gdz.oss-cn-shenzhen.aliyuncs.com/hexo/%E5%9F%9F%E5%90%8D%E8%A7%A3%E6%9E%90DNS/image-20191201162003135.png" alt="image-20191201162003135"></p>
<ol>
<li>用户在浏览器中输入域名，回车</li>
<li>请求来到本地域名服务器</li>
<li>本地域名服务器首先向根服务器请求得到顶级域名服务器地址</li>
<li>本地域名服务器根据上一步地址向顶级域名该服务器请求得到权威域名服务器地址</li>
<li>本地域名服务器根据上一步地址向权威域名服务器请求得到最终解析的结果，这是IP地址</li>
<li>本地域名服务器将IP返回给浏览器</li>
<li>浏览器根据IP访问到目标服务</li>
<li>得到访问结果</li>
</ol>
<h2 id="解析结果-DNS记录类型"><a href="#解析结果-DNS记录类型" class="headerlink" title="解析结果 - DNS记录类型"></a>解析结果 - DNS记录类型</h2><p>上面的举例解析结果是IP地址，但这只是众多类型中的一种，RFC规范允许总共几十种记录类型，这里介绍几种常使用的</p>
<ul>
<li>A：IP4地址</li>
<li>AAAA：IP6地址</li>
<li>CNAME：一个主机名字的别名（域名），域名服务器会再次尝试解析该别名</li>
<li>PTR：指标记录，引导一个规范名称。类似CNAME，不同的是DNS不会尝试解析该名称，而是直接返回。</li>
<li>NS：返回一个域名服务器记录</li>
<li>MX：邮件记录，引导域名到该域名的邮件传输代理列表</li>
<li>SRV：服务定位器，即返回提供特定服务的服务器</li>
<li>TXT：返回文字记录</li>
<li>CAA：权威认证授权，DNS认证机构授权，限制主机可接受的CA</li>
</ul>
<h1 id="其它术语解释"><a href="#其它术语解释" class="headerlink" title="其它术语解释"></a>其它术语解释</h1><ul>
<li><p>TTL</p>
<p>Time To Live，即域名解析结果在本地域名服务器中保留的时间。超时会重新执行一遍完整的解析流程</p>
</li>
<li><p>ICANN</p>
<p><strong>I</strong>nternet <strong>C</strong>orporation for <strong>A</strong>ssigned <strong>N</strong>ames and <strong>N</strong>umbers，网际网络名称与数字地址分配机构，位于美国加利福尼亚的非盈利社团，创建于1998年9月18日，存在目的是专门管理域名和IP地址的分配等网络相关任务。需要说明的是该机构受到美国政府及法律的管理。</p>
</li>
<li><p>WHOIS</p>
<p>域名资料库查询。可以通过该资料库找到一个域名的注册信息。对于大多数根域名服务器，基本的WHOIS库由ICANN管理，而WHOIS的具体细节则由该域的授权机构管理。如中国互联网信息中心（China Internet Network Information Center）负责.cn的WHOIS资料维护。</p>
</li>
</ul>
<h1 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h1><ol>
<li><a href="https://aws.amazon.com/tw/route53/what-is-dns/">Amazon Route 53服务说明手册</a></li>
<li><a href="https://help.aliyun.com/document_detail/102237.html">阿里云云解析DNS服务说明手册</a></li>
<li><a href="https://www.jianshu.com/p/1f3d930a8756">互联网史上最贵的域名排名榜（简书）</a></li>
<li><a href="https://zh.wikipedia.org/wiki/DNS%E8%AE%B0%E5%BD%95%E7%B1%BB%E5%9E%8B%E5%88%97%E8%A1%A8">DNS记录类型列表（中文维基百科）</a></li>
</ol>
]]></content>
      <categories>
        <category>网络基础</category>
      </categories>
      <tags>
        <tag>DNS</tag>
      </tags>
  </entry>
  <entry>
    <title>单元测试 - 工具</title>
    <url>/2022/03/05/%E5%8D%95%E5%85%83%E6%B5%8B%E8%AF%95-%E5%B7%A5%E5%85%B7/</url>
    <content><![CDATA[<p>工欲善其事，必先利其器。写单元测试，需要三类工具</p>
<ul>
<li>测试平台：JUnit、TestNG</li>
<li>Mock框架：Mockito、MockK</li>
<li>断言框架：AssertJ、Assertk</li>
</ul>
<p>当开发语言为kotlin时，推荐JUnit5 + MockK + Assertk的组合。</p>
<span id="more"></span>

<h1 id="JUnit"><a href="#JUnit" class="headerlink" title="JUnit"></a>JUnit</h1><p>测试框架承载单元测试运行的环境，基础技术。一般会提到JUnit和TestNG，Spring默认集成了JUnit5，后者由于没有具体使用过，不大好作评论，但是网上文章搜了一圈，相比于JUnit5，TestNG并没有看出什么优势，具有差不多的功能，但是需要写xml。处于好奇看了下两者的发布时间，JUnit5诞生的日期、更新的频繁程度都较高，所以倾向使用JUnit5，至于JUnit4，现在已经过时了。</p>
<table>
<thead>
<tr>
<th>框架</th>
<th>首版发布日期</th>
<th>首个正式版发布日期</th>
<th>最近一个正式版发布日期</th>
<th>更新频率</th>
</tr>
</thead>
<tbody><tr>
<td>JUnit4</td>
<td>2014-7-29</td>
<td>2014-7-29</td>
<td>2021-2-14</td>
<td>一年左右</td>
</tr>
<tr>
<td>JUnit5</td>
<td>alpha版2016-2-1</td>
<td>2017-10-03</td>
<td>2021-11-29</td>
<td>一两个月一次</td>
</tr>
<tr>
<td>TestNG</td>
<td>2010往前</td>
<td>2010往前</td>
<td>2022-1-3</td>
<td>一年左右</td>
</tr>
</tbody></table>
<h2 id="概览"><a href="#概览" class="headerlink" title="概览"></a>概览</h2><p>注意区分它有4、5两个版本，后者为最新版，也是极力推广的版本，功能丰富了不少。组成如下</p>
<p>JUnit 5 = JUnit Platform + JUnit Jupiter + JUnit Vintage</p>
<p>JUnit Platform：在JVM中启动测试的基础；同时提供开发测试引擎的API</p>
<p>JUnit Jupiter：是写单元测试的编程模型、扩展模型的结合；提供跑基于juipter测试的测试引擎</p>
<p>JUnit Vintage：提供在当前平台跑JUnit3和JUnit4的测试引擎</p>
<blockquote>
<p>JUnit5最低支持JDK8</p>
</blockquote>
<blockquote>
<p>有关JUnit的全部功能，参考<a href="https://junit.org/junit5/docs/current/user-guide/">官方手册</a>，建议从头到尾看一遍，了解一下有哪些型号的锤子。</p>
</blockquote>
<h2 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h2><p>掌握三个基本概念</p>
<ul>
<li><p>测试类</p>
<p>如下三种类可以被称作静态类，并且它们必须至少包含一个测试方法</p>
<ul>
<li>顶级类</li>
<li>静态内部类</li>
<li>被@Nested注解的非静态内部类</li>
</ul>
</li>
<li><p>测试方法</p>
<p>被@Test,@RepeatedTest, @ParameterizedTest, @TestFactory, or @TestTemplate注解的实例方法</p>
</li>
<li><p>生命周期方法</p>
<p>被@BeforeAll,@AfterAll, @BeforeEach, or @AfterEach注解的方法</p>
</li>
</ul>
<p>注意事项</p>
<ul>
<li>除@TestFactory注解的方法外，测试方法不能有返回值</li>
<li>测试类、测试方法不必是public的，但也不能是private的</li>
<li>对于Java来说，JUnit建议省略掉类和方法的public关键字</li>
</ul>
<h2 id="注解和功能解释"><a href="#注解和功能解释" class="headerlink" title="注解和功能解释"></a>注解和功能解释</h2><p>JUnit有21个以上的注解，我们挑选其中最常用的看</p>
<table>
<thead>
<tr>
<th>注解</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>@Test</td>
<td>标记一个测试方法</td>
</tr>
<tr>
<td>@ParameterizedTest</td>
<td>参数化测试，与数据源注解协同使用</td>
</tr>
<tr>
<td>@RepeatedTest</td>
<td>重复执行的方法，即一个方法被执行多次</td>
</tr>
<tr>
<td>@DisplayName</td>
<td>显示在测试报告中的名称<br />注：部分注解有name属性，也可以指定</td>
</tr>
<tr>
<td>@Nested</td>
<td>表明被注解的类是非静态的嵌套类；主要用来分组</td>
</tr>
<tr>
<td>@Tag</td>
<td>标签，用于过滤<br />和TestNG中的组概念类似<br />和JUnit4中的分类概念类似</td>
</tr>
<tr>
<td>@BeforeAll<br />@AfterAll<br />@BeforeEach<br />@AfterEach</td>
<td>生命周期方法</td>
</tr>
<tr>
<td>@Timeout</td>
<td>方法执行的超时时间，超时则报错</td>
</tr>
<tr>
<td>@ExtendWith</td>
<td>声明式扩展</td>
</tr>
<tr>
<td>@RegisterExtension</td>
<td>编程式扩展</td>
</tr>
</tbody></table>
<h2 id="一个例子"><a href="#一个例子" class="headerlink" title="一个例子"></a>一个例子</h2><p>使用Kotlin编写的两个工具测试方法</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 将类S的同名属性填充到D中</span></span><br><span class="line"><span class="comment"> * 要求源对象的属性必须有getter方法，且，目标对象的属性必须有setter方法，否则复制不会成功</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="type">&lt;S, D&gt;</span> D.<span class="title">fillWith</span><span class="params">(source: <span class="type">S</span>)</span></span>: D = apply &#123;</span><br><span class="line">    BeanUtils.copyProperties(source, <span class="keyword">this</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 从一个链接中解析出oss的object key，如果它不是oss的链接，解析结果为null</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">fun</span> String.<span class="title">parseOssObjectKey</span><span class="params">()</span></span>: String? &#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">this</span>.startsWith(<span class="string">&quot;http&quot;</span>, <span class="literal">true</span>)) &#123;</span><br><span class="line">        <span class="keyword">return</span> URL(<span class="keyword">this</span>).path.trim(<span class="string">&#x27;/&#x27;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">null</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>对应的单元测试如下</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="meta">@DisplayName(<span class="meta-string">&quot;全局扩展方法测试&quot;</span>)</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ExtensionMethodTest</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">companion</span> <span class="keyword">object</span> &#123;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@BeforeAll</span></span><br><span class="line">        <span class="meta">@JvmStatic</span></span><br><span class="line">        <span class="function"><span class="keyword">fun</span> <span class="title">beforeAll</span><span class="params">()</span></span> &#123;</span><br><span class="line">            println(<span class="string">&quot;全局开始&quot;</span>)</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@AfterAll</span></span><br><span class="line">        <span class="meta">@JvmStatic</span></span><br><span class="line">        <span class="function"><span class="keyword">fun</span> <span class="title">afterAll</span><span class="params">()</span></span> &#123;</span><br><span class="line">            println(<span class="string">&quot;全局结束&quot;</span>)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@BeforeEach</span></span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">beforeEach</span><span class="params">(info: <span class="type">TestInfo</span>)</span></span> &#123;</span><br><span class="line">        println(<span class="string">&quot;<span class="subst">$&#123;info.displayName&#125;</span>开始&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@AfterEach</span></span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">afterEach</span><span class="params">(info: <span class="type">TestInfo</span>)</span></span> &#123;</span><br><span class="line">        println(<span class="string">&quot;<span class="subst">$&#123;info.displayName&#125;</span>结束&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Nested</span></span><br><span class="line">    <span class="meta">@DisplayName(<span class="meta-string">&quot;D.fillWith(S)&quot;</span>)</span></span><br><span class="line">    <span class="keyword">inner</span> <span class="class"><span class="keyword">class</span> <span class="title">FillWith</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Test</span></span><br><span class="line">        <span class="function"><span class="keyword">fun</span> `fail case`<span class="params">()</span></span> &#123;</span><br><span class="line">            <span class="keyword">val</span> source = NonInheritanceValClass(</span><br><span class="line">                field1 = <span class="string">&quot;1&quot;</span>,</span><br><span class="line">                field2 = <span class="number">1</span>,</span><br><span class="line">                field3 = <span class="literal">false</span>,</span><br><span class="line">                fieldA = listOf&lt;String&gt;()</span><br><span class="line">            )</span><br><span class="line">            <span class="keyword">val</span> destination = NonInheritanceValClass()</span><br><span class="line"></span><br><span class="line">            destination.fillWith(source)</span><br><span class="line"></span><br><span class="line">            assertAll &#123;</span><br><span class="line">                assertThat(destination.field1).isNull()</span><br><span class="line">                assertThat(destination.field2).isNull()</span><br><span class="line">                assertThat(destination.field3).isNull()</span><br><span class="line">                assertThat(destination.fieldA).isNull()</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Nested</span></span><br><span class="line">    <span class="meta">@DisplayName(<span class="meta-string">&quot;String.parseOssObjectKey()&quot;</span>)</span></span><br><span class="line">    <span class="keyword">inner</span> <span class="class"><span class="keyword">class</span> <span class="title">ParseOssObjectKey</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@ParameterizedTest(name = ParameterizedTest.ARGUMENTS_WITH_NAMES_PLACEHOLDER)</span></span><br><span class="line">        <span class="meta">@CsvSource(</span></span><br><span class="line"><span class="meta">            value = [</span></span><br><span class="line"><span class="meta">                <span class="meta-string">&quot;https://mylogs-oss.wemore.com/image/hello.jpg, image/hello.jpg&quot;</span>,</span></span><br><span class="line"><span class="meta">                <span class="meta-string">&quot;https://mylogs-oss.moumoux.com/image/hello.jpg, image/hello.jpg&quot;</span>,</span></span><br><span class="line"><span class="meta">                <span class="meta-string">&quot;http://mylogs-oss.moumoux.com/image/hello.jpg, image/hello.jpg&quot;</span></span></span><br><span class="line"><span class="meta">            ], nullValues = [<span class="meta-string">&quot;null&quot;</span>]</span></span><br><span class="line"><span class="meta">        )</span></span><br><span class="line">        <span class="function"><span class="keyword">fun</span> `just test`<span class="params">(input: <span class="type">String</span>, expectedOutput: <span class="type">String</span>?)</span></span> &#123;</span><br><span class="line">            <span class="keyword">val</span> result = input.parseOssObjectKey()</span><br><span class="line">            assertThat(result).isEqualTo(expectedOutput)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>运行整个测试类，能够得到如下输出</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">全局开始</span><br><span class="line">fail case()开始</span><br><span class="line">fail case()结束</span><br><span class="line">input=https://mylogs-oss.wemore.com/image/hello.jpg, expectedOutput=image/hello.jpg开始</span><br><span class="line">input=https://mylogs-oss.wemore.com/image/hello.jpg, expectedOutput=image/hello.jpg结束</span><br><span class="line">input=https://mylogs-oss.moumoux.com/image/hello.jpg, expectedOutput=image/hello.jpg开始</span><br><span class="line">input=https://mylogs-oss.moumoux.com/image/hello.jpg, expectedOutput=image/hello.jpg结束</span><br><span class="line">input=http://mylogs-oss.moumoux.com/image/hello.jpg, expectedOutput=image/hello.jpg开始</span><br><span class="line">input=http://mylogs-oss.moumoux.com/image/hello.jpg, expectedOutput=image/hello.jpg结束</span><br><span class="line">全局结束</span><br><span class="line">全局扩展方法测试 &gt; D.fillWith(S) &gt; fail case() PASSED</span><br><span class="line">全局扩展方法测试 &gt; String.parseOssObjectKey() &gt; input=https://mylogs-oss.wemore.com/image/hello.jpg, expectedOutput=image/hello.jpg PASSED</span><br><span class="line">全局扩展方法测试 &gt; String.parseOssObjectKey() &gt; input=https://mylogs-oss.moumoux.com/image/hello.jpg, expectedOutput=image/hello.jpg PASSED</span><br><span class="line">全局扩展方法测试 &gt; String.parseOssObjectKey() &gt; input=http://mylogs-oss.moumoux.com/image/hello.jpg, expectedOutput=image/hello.jpg PASSED</span><br></pre></td></tr></table></figure>

<p>上面的例子可以总结出几个问题，我们一个一个看</p>
<ol>
<li>如何启动那个测试类？可能在IEAD中有启动按钮，但是如果只是给了一个类文件，我们要如何启动呢？在CI构建时要如何启动呢？</li>
<li>为什么要用嵌套类？</li>
<li>@BeforeAll的使用看起来很不方便？</li>
<li>测试case的生命周期是怎样的？</li>
<li>参数化测试，还支持别的设置参数的方式吗？</li>
</ol>
<h2 id="启动"><a href="#启动" class="headerlink" title="启动"></a>启动</h2><p>三种启动方式</p>
<ul>
<li><p>Console Launcher</p>
<p>提供一个可执行文件 junit-platform-console-standalone-1.8.2.jar ，用如下命令执行测试</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">java -jar junit-platform-console-standalone-1.8.2.jar &lt;额外选项&gt;</span><br></pre></td></tr></table></figure>

<p>这种场景还没用过</p>
</li>
<li><p>IDEA插件 —— 开发最常用</p>
<p>到IDEA的插件市场搜索junit，安装插件就能直接测试（可以看到，junit插件是软件绑定的，默认已经安装了，甚至没有卸载选项）</p>
<img src="https://gdz.oss-cn-shenzhen.aliyuncs.com/local/image-20220226175402518.png" alt="image-20220226175402518" style="zoom:80%;" />

<p>此时写的测试类和方法上就会有运行按钮</p>
<img src="https://gdz.oss-cn-shenzhen.aliyuncs.com/local/image-20220226175613488.png" alt="image-20220226175613488" style="zoom:80%;" /></li>
<li><p>gradle插件 —— CI最常用</p>
<p>使用gradle构建时需要添加junit插件。同样，gradle已经将JUnit添加到test任务的默认支持工具中，同样支持的还有JUnit4、TestNG。详情参考<a href="https://docs.gradle.org/current/userguide/java_testing.html">gradle的测试文档</a>，可配置的参数比较多，一个较为简单的配置如下</p>
<figure class="highlight groovy"><table><tr><td class="code"><pre><span class="line">test &#123;</span><br><span class="line">    <span class="comment">// 使用JUnit5进行测试</span></span><br><span class="line">    useJUnitPlatform()</span><br><span class="line">    <span class="comment">// 测试线程数：2</span></span><br><span class="line">    maxParallelForks(<span class="number">2</span>)</span><br><span class="line">    <span class="comment">// 日志配置</span></span><br><span class="line">    testLogging &#123;</span><br><span class="line">        <span class="comment">// level=LIFECYCLE的配置项</span></span><br><span class="line">        events <span class="string">&quot;passed&quot;</span>, <span class="string">&quot;skipped&quot;</span>, <span class="string">&quot;failed&quot;</span></span><br><span class="line">        exceptionFormat <span class="string">&quot;full&quot;</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<h2 id="测试生命周期"><a href="#测试生命周期" class="headerlink" title="测试生命周期"></a>测试生命周期</h2><p>一个测试类启动后，生命周期从上到下为（以上面的例子为例）</p>
<ul>
<li>测试类ExtensionMethodTest加载，执行被@BeforeAll注解的静态方法</li>
<li>测试类创建：ExtensionMethodTest、嵌套类FillWith</li>
<li>执行@BeforeEach注解的方法</li>
<li>执行@Test或@ParameterizedTest注解的方法</li>
<li>执行@AfterEach注解的方法</li>
<li>测试类被丢弃</li>
<li>执行另一个测试方法时，从第二步开始再执行</li>
<li>执行被@AfterAll注解的静态方法</li>
</ul>
<p>所以重点是</p>
<ul>
<li>执行每个测试方法，都会重新创建测试类实例。而不是多个测试方法共用一个实例</li>
<li>基于上面的原因，@BeforeAll、@AfterAll注解的方法只能在类加载期间执行，即只能注解到静态方法上。这也解释了为什么非静态嵌套类中无法使用@BeforeAll，因为它无法定义静态方法呀</li>
</ul>
<blockquote>
<p>理解单元测试：单元测试的基本要求之一是测试case之间相互不影响，测试方法可能使用了测试类中定义的变量，为了保证不受其它使用该变量的测试方法的影响，最好的方式就是为该方法专门创建一个测试类实例。这就是JUnit的默认行为，一定要理解。</p>
<p>也十分推荐这么做，这才是真的单元测试。</p>
<p>对于那些多个测试方法确实需要共享一个测试类实例的情况，JUnit也提供支持。使用时要慎重，此时@BeforeAll的行为也会改变。</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="meta">@TestInstance(Lifecycle.PER_CLASS)</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ExtensionMethodTest</span> </span>&#123;</span><br></pre></td></tr></table></figure>
</blockquote>
<h2 id="嵌套类"><a href="#嵌套类" class="headerlink" title="嵌套类"></a>嵌套类</h2><p>JUnit提供嵌套类的支持，是为了提供给用户更好的测试之间组关系的支持。</p>
<p>上例中，对每个待测方法，都有多个case需要执行，为了将二者分为两组，我为每个待测方法建立了一个嵌套对象，测试case作为嵌套对象的方法，这样在嵌套类上添加公共的说明，得到的测试报告也更加层次化。</p>
<p><img src="https://gdz.oss-cn-shenzhen.aliyuncs.com/local/image-20220226182218073.png" alt="image-20220226182218073"></p>
<p>可以想见，如果没有这样的支持，我需要在每个方法的显示名中加上说明，多么麻烦。</p>
<h2 id="参数化测试"><a href="#参数化测试" class="headerlink" title="参数化测试"></a>参数化测试</h2><p>利器之二，最典型的应用场景就是针对各种不同输入的测试，参考上例<code>ExtensionMethodTest.ParseOssObjectKey.just test()</code>，特点</p>
<ul>
<li><p>使用注解@ParameterizedTest，可以通过name指定测试名称。name指定的字符串中有几个可以使用的占位符</p>
<table>
<thead>
<tr>
<th align="left">Placeholder</th>
<th align="left">Description</th>
</tr>
</thead>
<tbody><tr>
<td align="left"><code>&#123;displayName&#125;</code></td>
<td align="left">方法的名称</td>
</tr>
<tr>
<td align="left"><code>&#123;index&#125;</code></td>
<td align="left">当前调用的参数在参数列表中的索引</td>
</tr>
<tr>
<td align="left"><code>&#123;arguments&#125;</code></td>
<td align="left">完整的测试方法参数值，逗号分隔</td>
</tr>
<tr>
<td align="left"><code>&#123;argumentsWithNames&#125;</code></td>
<td align="left">完整的测试方法的参数名和参数值，格式 key1=value1,key2=value2…</td>
</tr>
<tr>
<td align="left"><code>&#123;0&#125;</code>, <code>&#123;1&#125;</code>, …</td>
<td align="left">具体的参数</td>
</tr>
</tbody></table>
</li>
<li><p>有定义的现成名称可以使用，如：<code>ParameterizedTest#DISPLAY_NAME_PLACEHOLDER</code></p>
</li>
<li><p>必须和数据源注解一起使用，支持的注解源（可以叠加使用）</p>
<ul>
<li><p>@ValueSource：最常用，单个值的列表</p>
</li>
<li><p>@NullAndEmptySource、@NullSource。。。：最常用，null或空串</p>
</li>
<li><p>@EnumSource</p>
</li>
<li><p>@MethodSource：数据来源于一个方法</p>
<p>一个例子如下，重点是方法要是静态的（除非LifeCycle.PER_CLASS）；返回Arguments的集合类型</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 定义</span></span><br><span class="line">  <span class="meta">@JvmStatic</span></span><br><span class="line">  <span class="function"><span class="keyword">fun</span> <span class="title">provideLegalResource</span><span class="params">()</span></span>: List&lt;Arguments&gt; &#123;</span><br><span class="line">      <span class="keyword">return</span> PathMatchingResourcePatternResolver().getResources(LEGAL_RESOURCE_PATTERN).map &#123; resource -&gt;</span><br><span class="line">          resource.file.name to publicObjectMapper.readTree(resource.file)</span><br><span class="line">      &#125;.map &#123; (fileName, mockResources) -&gt;</span><br><span class="line">          mockResources.map &#123; mockResource -&gt;</span><br><span class="line">              <span class="keyword">val</span> resourceType = fileName.removeSuffix(RESOURCE_FILE_SUFFIX)</span><br><span class="line">              <span class="keyword">val</span> comment = (mockResource <span class="keyword">as</span> ObjectNode).remove(COMMENT_KEY).asText()</span><br><span class="line">              <span class="keyword">val</span> content = <span class="string">&quot;&quot;&quot;&#123;&quot;resources&quot;: [<span class="subst">$&#123;mockResource.toJsonString()&#125;</span>]&#125;&quot;&quot;&quot;</span></span><br><span class="line">              <span class="comment">// 上面都忽略，这才是关键</span></span><br><span class="line">              Arguments.of(resourceType, comment, content)</span><br><span class="line">          &#125;</span><br><span class="line">      &#125;.flatten()</span><br><span class="line">  &#125;</span><br><span class="line">    </span><br><span class="line"><span class="comment">// 使用</span></span><br><span class="line">  <span class="meta">@ParameterizedTest(name = <span class="meta-string">&quot;&#123;displayName&#125; &#123;argumentsWithNames&#125;&quot;</span>)</span></span><br><span class="line">  <span class="meta">@MethodSource(<span class="meta-string">&quot;xxx.ResourceProvider#provideLegalResource&quot;</span>)</span></span><br><span class="line">  <span class="function"><span class="keyword">fun</span> `200 <span class="keyword">when</span> legal resource`<span class="params">(type: <span class="type">String</span>, comment: <span class="type">String</span>, content: <span class="type">String</span>)</span></span> &#123;</span><br></pre></td></tr></table></figure></li>
<li><p>@CsvSource：以CSV的方式提供多个值</p>
</li>
<li><p>@CsvFileSource</p>
</li>
<li><p>@ArgumentsSource：数据源于一个ArgumentsProvider，这个其实是最通用的方法，上面的所有注解都是用ArgumentsProvider实现的，比如下面这个</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@ArgumentsSource(NullArgumentsProvider.class)</span></span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> NullSource &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
</ul>
<h2 id="构造器和方法的注入"><a href="#构造器和方法的注入" class="headerlink" title="构造器和方法的注入"></a>构造器和方法的注入</h2><p>注意上面的beforeEach()方法的参数TestInfo，之所以方法执行时能够获得这个参数，是因为JUnit执行了注入操作。</p>
<p>JUnit支持向测试类的构造器和所有成员方法执行注入操作，对应的API是<code>ParameterResolver</code>。默认实现有三个，有需要可以自己增加</p>
<ul>
<li><code>TestInfoParameterResolver</code></li>
<li><code>RepetitionInfoParameterResolver</code></li>
<li><code>TestReporterParameterResolver</code></li>
</ul>
<h2 id="测试的继承"><a href="#测试的继承" class="headerlink" title="测试的继承"></a>测试的继承</h2><p>如果有多个类都有相同的测试前置操作、测试case，可以将这些内容抽取成为一个接口。JUnit的注解效果是可以继承的，这是个利器。合理使用。</p>
<p>举例：controller层的单元测试中，接口鉴权是公共的case，就很适合抽出来，每个接口都实现它。</p>
<blockquote>
<p>更多内容请参考JUnit用户手册，值得探究的内容</p>
<ul>
<li><p>测试顺序</p>
<p>测试方法之间默认没有顺序，但可通过添加@Order的方式声明顺序</p>
</li>
<li><p>并行执行</p>
<p>JUnit默认使用一个线程执行所有测试，我们可以指定多个以提升测试执行速度，不过要注意并发问题</p>
</li>
<li><p>条件测试</p>
<p>测试case在条件满足的情况下才执行</p>
</li>
<li><p>测试模板和动态测试</p>
<p>当需要动态生成测试方法时，不妨考虑考虑它们</p>
</li>
</ul>
</blockquote>
<h1 id="Mockk"><a href="#Mockk" class="headerlink" title="Mockk"></a>Mockk</h1><p>单元测试不像集成测试，”单元“二字是关键，一次只测试单个逻辑。其它级联的方法调用，都可以通过mock解决。与之对应的两个概念</p>
<ul>
<li>mock：完全伪造目标，目标可以是对象、静态方法、kotlin的object等</li>
<li>spy：在现有的目标上进行mock</li>
</ul>
<p>如果用Kotlin，mockk一定是个很好的尝试。相对于Mockito，MockK功能全面，支持DSL，书写流畅简单。下面通过一些场景介绍。</p>
<h2 id="基本使用方法"><a href="#基本使用方法" class="headerlink" title="基本使用方法"></a>基本使用方法</h2><p>MockK的完整使用方法包括</p>
<ul>
<li>声明mock对象</li>
<li>mock对象的行为</li>
<li>执行被测方法</li>
<li>验证结果、行为、过程参数</li>
</ul>
<p>如果使用JUnit5，MockK提供MockkExtension，同MockitoExtension，Mockito中对应的@Mock、@Spy、@InjectMocks分别变成@MockK、@SpyK、@InjectMockKs。一个典型的例子</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="meta">@ExtendWith(MockKExtension::class)</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MediaServiceTest</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 声明mock对象</span></span><br><span class="line">  <span class="meta">@MockK</span></span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">lateinit</span> <span class="keyword">var</span> miscService: MiscService</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 声明spy对象，同时声明spy的具体对象：mockMediaProperties</span></span><br><span class="line">  <span class="meta">@SpyK</span></span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">var</span> mediaProperties: MediaProperties = mockMediaProperties</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 声明被测对象，mediaService会被创建，并使用miscService和mediaProperties注入其构造方法</span></span><br><span class="line">  <span class="meta">@InjectMockKs</span></span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">lateinit</span> <span class="keyword">var</span> mediaService: MediaService</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Test</span></span><br><span class="line">  <span class="function"><span class="keyword">fun</span> `test`<span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">val</span> mockUser = MOCK_USER_ID</span><br><span class="line">    <span class="keyword">val</span> mockDir = <span class="string">&quot;mockDir&quot;</span></span><br><span class="line">    <span class="comment">// 临时声明的mock对象，GetOssDirMetaResp类的对象</span></span><br><span class="line">    <span class="keyword">val</span> mockOssDirMetaResp = mockk&lt;GetOssDirMetaResp&gt;()</span><br><span class="line">    <span class="keyword">val</span> mockDirMeta = mockk&lt;GetOssDirMetaResp.DirMeta&gt;()</span><br><span class="line">    <span class="comment">// 临时创建spy对象，基于被测对象mediaService创建，目标是mock被测对象的行为</span></span><br><span class="line">    <span class="keyword">val</span> spyMediaService = spyk(mediaService)</span><br><span class="line">    <span class="comment">// mock行为</span></span><br><span class="line">    every &#123; spyMediaService.parseDir(any()) &#125; returns mockDir</span><br><span class="line">    every &#123; spyMediaService.mediaStub.getOssDirMeta(any()) &#125; returns mockOssDirMetaResp</span><br><span class="line">    every &#123; mockOssDirMetaResp.dirMetaList &#125; returns listOf(mockDirMeta)</span><br><span class="line">    every &#123; mockDirMeta.totalSize &#125; returns <span class="number">0</span></span><br><span class="line">		<span class="comment">// 调用被测方法</span></span><br><span class="line">    spyMediaService.getOccupiedSpaceOfUser(mockUser)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">val</span> slot = slot&lt;GetOssDirMetaReq&gt;()</span><br><span class="line">    <span class="comment">// 捕获spyMediaService.mediaStub.getOssDirMeta()的参数</span></span><br><span class="line">    verify &#123; spyMediaService.mediaStub.getOssDirMeta(capture(slot)) &#125;</span><br><span class="line">    <span class="comment">// 验证捕获到的参数</span></span><br><span class="line">    assertThat(slot.captured.app).isEqualTo(mediaProperties.appId)</span><br><span class="line">    assertThat(slot.captured.getDir(<span class="number">0</span>)).isEqualTo(mockDir)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>解释</p>
<ul>
<li><p>miscService需要凭空mock，mediaProperties需要在提供的对象基础上mock</p>
</li>
<li><p>mediaService的创建依赖于miscService和mediaProperties</p>
</li>
<li><p>除了MockKExtension，也可以直接使用<code>MockKAnnotations.init(this::class)</code>来使其生效</p>
</li>
<li><p>本例测试的是某个参数，使用slot()方法抓取该参数</p>
</li>
</ul>
<h2 id="默认行为"><a href="#默认行为" class="headerlink" title="默认行为"></a>默认行为</h2><p>Mockito中，如果不对mock对象的行为做预设，行为默认返回对应返回类型的空值。MockK略有不同，不提供默认行为的mock，但可手动选择开启。</p>
<ul>
<li>@RelaxedMockK : 备注接的对象带有默认值</li>
<li>@MockK(relaxed = true)：同上</li>
<li>mockk&lt;MyObject&gt;(relaxed = true)：手动mock出来的MyObject对象行为带有默认值</li>
</ul>
<h2 id="mock单例对象"><a href="#mock单例对象" class="headerlink" title="mock单例对象"></a>mock单例对象</h2><figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">object</span> RequestContext &#123;</span><br><span class="line">	<span class="keyword">val</span> currentUser: <span class="built_in">Int</span> = <span class="number">12</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">test</span><span class="params">()</span></span> &#123;</span><br><span class="line">  mockkObject(RequestContext)</span><br><span class="line">  every &#123; RequestContext.currentUser &#125; returns <span class="number">1</span></span><br><span class="line">  println(RequestContext.currentUser) <span class="comment">// 输出1</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>值得一提的是，mock枚举对象也是通过mockkObject完成，毕竟，每个枚举项就是一个单例。</p>
</blockquote>
<h2 id="mock静态方法"><a href="#mock静态方法" class="headerlink" title="mock静态方法"></a>mock静态方法</h2><figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">object</span> RequestContext &#123;</span><br><span class="line">  <span class="meta">@JvmStatic</span></span><br><span class="line">  <span class="function"><span class="keyword">fun</span> <span class="title">getUserId</span><span class="params">()</span></span> = userIdTL.<span class="keyword">get</span>()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">test</span><span class="params">()</span></span> &#123;</span><br><span class="line">  mockkStatic(RequestContext::getUserId)</span><br><span class="line">  every &#123; RequestContext.getUserId() &#125; returns <span class="number">1</span></span><br><span class="line">  println(RequestContext.getUserId()) <span class="comment">// 输出1</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="mock构造方法"><a href="#mock构造方法" class="headerlink" title="mock构造方法"></a>mock构造方法</h2><p>比如下面这个，MembershipLevelStrategySelector创建，然后调用select()方法，我想要mock select()方法的行为，就要mockMembershipLevelStrategySelector的构造方法</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">doRedeem</span><span class="params">(currentUser: <span class="type">Int</span>, currentAward: <span class="type">InvitationAwardModel</span>)</span></span> &#123;</span><br><span class="line">  ... ...</span><br><span class="line">  MembershipLevelStrategySelector(existSubscription, addPrivilegedBo).select().handle()</span><br><span class="line">  ... ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>于是mock这样写</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line">mockkConstructor(MembershipLevelStrategySelector::<span class="class"><span class="keyword">class</span>)</span></span><br><span class="line">every &#123; anyConstructed&lt;MembershipLevelStrategySelector&gt;().select() &#125; returns mockk&lt;AddPrivilegedStrategy&gt;(relaxed = <span class="literal">true</span>)</span><br></pre></td></tr></table></figure>

<h2 id="与SpringBoot集成"><a href="#与SpringBoot集成" class="headerlink" title="与SpringBoot集成"></a>与SpringBoot集成</h2><p>有<a href="https://github.com/Ninja-Squad/springmockk">springmock</a>项目为MockK集成到SpringBoot中提供支持，主要是支持@MockKBean注解啦。</p>
<h2 id="其它"><a href="#其它" class="headerlink" title="其它"></a>其它</h2><p>还有功能如下，不再详述，详情参考<a href="https://mockk.io/">官方手册</a></p>
<ul>
<li>mock链式调用，即一次性mock<code>a.method1().method2()</code>，而不需要单独mock</li>
<li>带有层次结构的mock</li>
<li>带有顺序的verify</li>
<li>verify某个方法未被调用（很有用）</li>
<li>自定义answer等</li>
</ul>
<h1 id="AssertK"><a href="#AssertK" class="headerlink" title="AssertK"></a>AssertK</h1><p>与AssertJ对应的，是AssertK。下面展示简单用法，具体参考<a href="https://github.com/willowtreeapps/assertk">官方手册</a></p>
<h2 id="常规"><a href="#常规" class="headerlink" title="常规"></a>常规</h2><figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line">assertThat(person.name).isEqualTo(<span class="string">&quot;Hello&quot;</span>)</span><br><span class="line">assertThat(person.age, <span class="string">&quot;age&quot;</span>).isGreaterThan(<span class="number">20</span>) <span class="comment">// age是报错时的显示名</span></span><br><span class="line">assertThat(nullString).isNotNull().hasLength(<span class="number">4</span>) <span class="comment">// 可空判断和字符串判断</span></span><br><span class="line">assertThat(string).all &#123;</span><br><span class="line">    startsWith(<span class="string">&quot;L&quot;</span>)</span><br><span class="line">    hasLength(<span class="number">3</span>)</span><br><span class="line">&#125; <span class="comment">// 多个同时判断</span></span><br><span class="line">assertAll &#123;</span><br><span class="line">    assertThat(<span class="literal">false</span>).isTrue()</span><br><span class="line">    assertThat(<span class="literal">true</span>).isFalse()</span><br><span class="line">&#125; <span class="comment">// 更通用的多个同时判断</span></span><br></pre></td></tr></table></figure>

<h2 id="错误判断"><a href="#错误判断" class="headerlink" title="错误判断"></a>错误判断</h2><figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line">assertThat &#123; <span class="keyword">throw</span> Exception(<span class="string">&quot;error&quot;</span>) &#125;.isFailure().hasMessage(<span class="string">&quot;wrong&quot;</span>)</span><br><span class="line">assertThat &#123; <span class="keyword">throw</span> Exception(<span class="string">&quot;error&quot;</span>) &#125;.isFailure().matchPreticate &#123;</span><br><span class="line">  <span class="comment">// 自己的判断</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>个人认为断言库的两个关键点是使用的简单性和报错信息的展示，AssertK做的都还不错。</p>
<p>如果觉得不够用，也有自定义断言可选。</p>
</blockquote>
<h1 id="Spring-Boot-Test"><a href="#Spring-Boot-Test" class="headerlink" title="Spring Boot Test"></a>Spring Boot Test</h1><p>SpringBoot的test模块，默认包含的测试工具JUnit5、Mockito、AssertJ。相对于此，额外的功能是提供Spring上下文。</p>
<h2 id="SpringBootTest"><a href="#SpringBootTest" class="headerlink" title="@SpringBootTest"></a>@SpringBootTest</h2><p>在测试类上添加此注解是最为简单的方式。它做了如下几件事</p>
<ul>
<li><p>通过SpringApplication创建ApplicationContext</p>
</li>
<li><p>默认情况下它不会启动server。但是可以通过webEnvironment指定环境，默认为MOCK</p>
<ul>
<li><p>MOCK：创建一个web类型的ApplicationContext、一个web类型的Environment。SpringBoot内嵌的Server不会启动。如果类路径中没有web相关的类可提供。则回滚创建一个非web的ApplicationContext。</p>
<p>可以结合@AutoConfigureMockMvc和@AutoConfigWebTestClient使用。前者提供一个服务mock，后者提供一个客户端mock终端</p>
</li>
<li><p>RANDOM_PORT：创建WebApplicationContext，创建真实的Server，内嵌Server被启动，端口随机</p>
</li>
<li><p>DEFINED_PORT：同上，只不过端口跟随配置文件</p>
</li>
<li><p>NONE：创建普通的ApplicationContext</p>
</li>
</ul>
</li>
<li><p>当Spring MVC、Spring Webflux任何一个被检测到，就创建对应的web环境。如果都存在，则创建MVC环境。此时想要使用webflux，只能@SpringBootTest(properties = “spring.main.web-application-type=reactive”)</p>
</li>
</ul>
<p>可见，@SpringBootTest非常重，会扫描并加载所有Bean。但实际我们往往只会测试一部分内容，对此Spring提供了部分装载的功能，相当于@SpringBootTest的子集。它基于Spring的自动配置机制，现有支持可在<a href="https://docs.spring.io/spring-boot/docs/current/reference/html/features.html#features.testing.spring-boot-applications.autoconfigured-tests">这里查看</a>。</p>
<p>依据实际使用的经验，Spring提供的测试机制并不友好，往往过于复杂，所以能不用就不用。相反，它更适合集成测试时使用，而不是单元测试。</p>
<h2 id="MockBean和-SpyBean"><a href="#MockBean和-SpyBean" class="headerlink" title="@MockBean和@SpyBean"></a>@MockBean和@SpyBean</h2><p>被此二者注解的属性，会使用Mockito生成一个mock对象，然后注入到容器中，其他地方可以自由注入。以@MockBean为例，它有如下特性</p>
<ul>
<li><p>使用@SpringBootTest时，该功能默认开启。其它情况使用时，需要手动开启。添加两个监听器</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="meta">@ContextConfiguration(classes = MyConfig.class)</span></span><br><span class="line"><span class="meta">@TestExecutionListeners(&#123; MockitoTestExecutionListener.class, ResetMocksTestExecutionListener.class &#125;)</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyTests</span> </span></span><br></pre></td></tr></table></figure></li>
<li><p>它定义的是Mockito的Mock</p>
</li>
<li><p>每个test方法结束后，被Mock的Bean会被reset</p>
</li>
<li><p>例子如下：Reverser使用真实对象；RemoteService使用Mock出来的Bean(覆盖原对象中的Bean)</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="meta">@SpringBootTest</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyTests</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Autowired</span></span><br><span class="line">  <span class="keyword">private</span> Reverser reverser;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@MockBean</span></span><br><span class="line">  <span class="keyword">private</span> RemoteService remoteService;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Test</span></span><br><span class="line">  void exampleTest() &#123;</span><br><span class="line">    given(<span class="keyword">this</span>.remoteService.getValue()).willReturn(<span class="string">&quot;spring&quot;</span>);</span><br><span class="line">    String reverse = <span class="keyword">this</span>.reverser.getReverseValue(); <span class="comment">// Calls injected RemoteService</span></span><br><span class="line">    assertThat(reverse).isEqualTo(<span class="string">&quot;gnirps&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<blockquote>
<p>前文说过，使用MockK后，换成@MockKBean，由springmock库提供支持</p>
</blockquote>
<h2 id="MockMvc"><a href="#MockMvc" class="headerlink" title="MockMvc"></a>MockMvc</h2><p>MockMvc是个好东西，与之相对的，是端到端测试（即服务启动，然后使用客户端手动访问）。使用它能够很好滴对Spring MVC构建的端点进行测试，同时支持Kotlin DSL，一个简单的例子</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="meta">@ControllerTest(SyncController::class)</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SyncControllerTest</span> </span>&#123;</span><br><span class="line">  <span class="meta">@Autowired</span></span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">lateinit</span> <span class="keyword">var</span> mockMvc: MockMvc</span><br><span class="line"></span><br><span class="line">  <span class="meta">@MockkBean</span></span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">lateinit</span> <span class="keyword">var</span> resourceService: ResourceService</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Test</span></span><br><span class="line">  <span class="function"><span class="keyword">fun</span> `test`<span class="params">()</span></span> &#123;</span><br><span class="line">    mockMvc.post(<span class="string">&quot;/v2/resources/push&quot;</span>) &#123;</span><br><span class="line">      contentType = MediaType.APPLICATION_JSON</span><br><span class="line">      content = PushReqV2Dto().apply &#123; resources = <span class="literal">null</span> &#125;.toJsonString()</span><br><span class="line">    &#125;.andExpect &#123;</span><br><span class="line">      status &#123;</span><br><span class="line">        isBadRequest()</span><br><span class="line">      &#125;</span><br><span class="line">      header &#123;</span><br><span class="line">        exists(<span class="string">&quot;TOKEN&quot;</span>)</span><br><span class="line">      &#125;</span><br><span class="line">      content &#123;</span><br><span class="line">        contentType(MediaType.APPLICATION_JSON)</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>DSL的使用也相当简单，整体而言包括两个</p>
<ul>
<li>填充请求参数<ul>
<li>请求方式：get、post，或者中性的perform</li>
<li>请求路径</li>
<li>请求参数：头部、参数、body</li>
</ul>
</li>
<li>填充预期内容<ul>
<li>状态码</li>
<li>响应结果：头部、body等</li>
</ul>
</li>
</ul>
<p>通过代码提示，也能知道，有三种类型的API调用</p>
<ul>
<li>andReturn()：返回执行结果，以MvcResult封装</li>
<li>andExpect{}：DSL，填充一些断言</li>
<li>andDo{}：DSL，这里可以做一些中性的实行，比如打印出响应结果。</li>
</ul>
<p><img src="https://gdz.oss-cn-shenzhen.aliyuncs.com/local/image-20220305125110742.png" alt="image-20220305125110742"></p>
<blockquote>
<p>这是Spring构建的Web应用的测试利器</p>
<p>但正如<a href="https://docs.spring.io/spring-framework/docs/5.3.16/reference/html/testing.html#spring-mvc-test-framework">Spring手册</a>所分类的那样，其实这玩意儿被分类在集成测试的</p>
<img src="https://gdz.oss-cn-shenzhen.aliyuncs.com/local/image-20220305125736965.png" alt="image-20220305125736965" style="zoom:80%;" />
</blockquote>
<h1 id="一点想法"><a href="#一点想法" class="headerlink" title="一点想法"></a>一点想法</h1><p>想法1：眼高手低。收集资料时想着有好多东西可以写；写的时候又发现如果要把那些都写完，衍生出来的知识太多了，根本无暇顾及。于是拖延，但一想不行，要继续写呀，于是一减再减，成了现在看到的这个样子，不甚满意。但总好过没有。</p>
<p>想法2：写这类学习的文章，还是要趁新鲜。一些内容，刚看到时会有惊艳的感觉，觉得值得一写。习惯之后又觉得理所当然，有什么好写的。殊不知，数月后，对那些认为理所当然的内容，我又恢复成萌新的状态。又要从头开始学习，到时连个回顾的纲要都没有。或许从另一面证明了：写这玩意儿，叫做沉淀🤔</p>
<h1 id="参考文档"><a href="#参考文档" class="headerlink" title="参考文档"></a>参考文档</h1><ul>
<li><p><a href="https://zhuanlan.zhihu.com/p/101905583">TestNG 与 Junit 对比，测试框架如何选择？</a></p>
</li>
<li><p><a href="https://junit.org/junit5/docs/current/user-guide/">JUnit用户手册</a></p>
</li>
<li><p><a href="https://mockk.io/">MockK用户手册</a></p>
</li>
<li><p><a href="https://github.com/Ninja-Squad/springmockk">springmockk主页</a></p>
</li>
<li><p><a href="https://github.com/willowtreeapps/assertk">AssertK主页</a></p>
</li>
<li><p><a href="https://docs.spring.io/spring-boot/docs/current/reference/html/features.html">Spring Boot Test</a></p>
</li>
<li><p><a href="https://docs.spring.io/spring-framework/docs/5.3.16/reference/html/testing.html#unit-testing">Spring Test</a></p>
</li>
</ul>
]]></content>
      <categories>
        <category>测试</category>
      </categories>
      <tags>
        <tag>Junit5</tag>
        <tag>MockK</tag>
        <tag>AssertK</tag>
      </tags>
  </entry>
  <entry>
    <title>基于frp构建内网穿透</title>
    <url>/2020/02/23/%E5%9F%BA%E4%BA%8Efrp%E6%9E%84%E5%BB%BA%E5%86%85%E7%BD%91%E7%A9%BF%E9%80%8F-%E5%9F%BA%E4%BA%8Efrp%E6%9E%84%E5%BB%BA%E5%86%85%E7%BD%91%E7%A9%BF%E9%80%8F/</url>
    <content><![CDATA[<h1 id="开篇废话"><a href="#开篇废话" class="headerlink" title="开篇废话"></a>开篇废话</h1><p>第一次接触到内网穿透这一概念大概是20017年左右，手中有一树莓派，想到如何能够在公司访问运行在家里的树莓派呢？百度之，基本就是下面这种情况——广告劝退，我一个小小的需求，要什么花里胡哨的东西，当时不了了之。后来了解到NATAPP，使用方便，价格也不贵，关键是配置简单，还支持自定义二级域名（当然是要钱的啦），这样使用了很长一段时间。但后来发现自己的使用场景是希望长期处于内网穿透，偶尔用一下，频率相当低。即使使用NATAPP这样低至9元/月的服务都嫌贵。</p>
<span id="more"></span>

<p><img src="https://gdz.oss-cn-shenzhen.aliyuncs.com/hexo/%E5%9F%BA%E4%BA%8Efrp%E6%9E%84%E5%BB%BA%E5%86%85%E7%BD%91%E7%A9%BF%E9%80%8F/image-20200223182842911.png" alt="image-20200223182842911"></p>
<p>无疑，开源软件是拯救我的唯一方式。gayhub是个好地方。<a href="https://github.com/snail007/goproxy">goproxy（8k star）</a>和<a href="https://github.com/fatedier/frp">frp（33k star）</a>映入眼帘。大致查看了使用教程，无论从简易程度，还是受欢迎程度，我都倾向于选择frp。它通过命令行配置。别跟我整那些花里胡哨的dashboard，简单易用才是硬道理，我不需要复杂的功能。</p>
<h1 id="frp简介"><a href="#frp简介" class="headerlink" title="frp简介"></a>frp简介</h1><p>frp使用go语言编写，工作原理是反向代理，下面的官方的架构图。</p>
<p><img src="https://gdz.oss-cn-shenzhen.aliyuncs.com/hexo/%E5%9F%BA%E4%BA%8Efrp%E6%9E%84%E5%BB%BA%E5%86%85%E7%BD%91%E7%A9%BF%E9%80%8F/image-20200223184119014.png" alt="image-20200223184119014"></p>
<p>需要说明的是，该项目目前处于开发状态，未经充分测试和验证，因此不推荐用于生产环境。</p>
<p>关于使用frp的前置条件，是你需要有一台VPS，我手里有一台阿里云服务器，正好。</p>
<h1 id="需求说明"><a href="#需求说明" class="headerlink" title="需求说明"></a>需求说明</h1><p>自己目前有两个需求</p>
<ul>
<li>可通过公网IP ssh到树莓派进行操作</li>
<li>可通过域名访问运行在树莓派上的web服务，端口7000。暂时只要http</li>
</ul>
<p>下面针对这两个需求进行配置</p>
<h1 id="服务端"><a href="#服务端" class="headerlink" title="服务端"></a>服务端</h1><h2 id="frp配置"><a href="#frp配置" class="headerlink" title="frp配置"></a>frp配置</h2><p>到项目的<a href="https://github.com/fatedier/frp/releases">release页</a>下载符合自己服务器版本的压缩包。</p>
<p><img src="https://gdz.oss-cn-shenzhen.aliyuncs.com/hexo/%E5%9F%BA%E4%BA%8Efrp%E6%9E%84%E5%BB%BA%E5%86%85%E7%BD%91%E7%A9%BF%E9%80%8F/image-20200223184719862.png" alt="image-20200223184719862"></p>
<p>我的VPS是ubuntu 64位，因此下载<a href="https://github.com/fatedier/frp/releases/download/v0.31.2/frp_0.31.2_linux_amd64.tar.gz">frp_0.31.2_linux_amd64.tar.gz</a>。 依照如下步骤</p>
<ul>
<li><p>解压</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">tar -zxvf frp_0.31.2_linux_amd64.tar.gz</span><br></pre></td></tr></table></figure></li>
<li><p>修改ini配置文件</p>
<p>修改目录下的服务器配置文件frps.ini，注意别改到客户端配置文件frpc.ini。</p>
<p>这里指定了frp的tcp服务监听7000端口，http服务监听7001端口。</p>
<figure class="highlight ini"><table><tr><td class="code"><pre><span class="line"><span class="comment"># frps.ini</span></span><br><span class="line"><span class="section">[common]</span></span><br><span class="line"><span class="attr">bind_port</span> = <span class="number">7000</span></span><br><span class="line"><span class="attr">vhost_http_port</span> = <span class="number">7001</span></span><br></pre></td></tr></table></figure></li>
<li><p>启动</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">./frps -c ./frps.ini</span><br></pre></td></tr></table></figure>

<p>看到如下输出，代表成功了。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">2020/02/23 19:09:37 [I] [service.go:152] frps tcp listen on 0.0.0.0:7000                    </span><br><span class="line">2020/02/23 19:09:37 [I] [service.go:194] http service listen on 0.0.0.0:7001               </span><br><span class="line">2020/02/23 19:09:37 [I] [root.go:205] start frps success </span><br></pre></td></tr></table></figure></li>
</ul>
<h2 id="nginx配置"><a href="#nginx配置" class="headerlink" title="nginx配置"></a>nginx配置</h2><p>第二点需求可以通过nginx实现，直接在80端口上监听，将对应域名转发到该域名下7001端口。</p>
<figure class="highlight nginx"><table><tr><td class="code"><pre><span class="line"><span class="section">server</span> &#123;</span><br><span class="line">    <span class="attribute">listen</span> <span class="number">80</span>;</span><br><span class="line">    <span class="attribute">server_name</span> awtrix.pi.zouguodong.top;</span><br><span class="line">    </span><br><span class="line">    <span class="attribute">location</span> / &#123;</span><br><span class="line">        <span class="attribute">proxy_pass</span> http://awtrix.pi.zouguodong.top:7001/;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="客户端"><a href="#客户端" class="headerlink" title="客户端"></a>客户端</h1><p>frp将客户端和服务端文件放在一个包中，你可以观察到上面解压出来的包中包含了frpc——即客户端命令和配置文件。因此，如果客户端环境也是linux 64位，可以直接使用刚才下载的那个包。</p>
<p>但我的客户端是树莓派，因此需要下载<strong>arm 32位版</strong>，即<a href="https://github.com/fatedier/frp/releases/download/v0.31.2/frp_0.31.2_linux_arm.tar.gz">frp_0.31.2_linux_arm.tar.gz</a>，注意不要下载64位，树莓派3使用了64位CPU，但操作系统依然是32位。</p>
<p>执行如下步骤</p>
<ul>
<li><p>解压</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">tar -zxvf frp_0.31.2_linux_arm.tar.gz</span><br></pre></td></tr></table></figure></li>
<li><p>修改配置文件</p>
<p>修改frpc.ini</p>
<figure class="highlight ini"><table><tr><td class="code"><pre><span class="line"><span class="comment"># frpc.ini</span></span><br><span class="line"><span class="comment"># 这里填写服务端的IP和端口号</span></span><br><span class="line"><span class="section">[common]</span></span><br><span class="line"><span class="attr">server_addr</span> = x.x.x.x</span><br><span class="line"><span class="attr">server_port</span> = <span class="number">7000</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 将服务端的6000端口转发到本地的22端口</span></span><br><span class="line"><span class="section">[ssh]</span></span><br><span class="line"><span class="attr">type</span> = tcp</span><br><span class="line"><span class="attr">local_ip</span> = <span class="number">127.0</span>.<span class="number">0.1</span></span><br><span class="line"><span class="attr">local_port</span> = <span class="number">22</span></span><br><span class="line"><span class="attr">remote_port</span> = <span class="number">6000</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 将服务端的指定域名的请求转发到本地7000端口</span></span><br><span class="line"><span class="section">[web]</span></span><br><span class="line"><span class="attr">type</span> = http</span><br><span class="line"><span class="attr">local_port</span> = <span class="number">7000</span></span><br><span class="line"><span class="attr">custom_domains</span> = &lt;你的域名&gt;</span><br></pre></td></tr></table></figure></li>
<li><p>启动</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">./frpc -c ./frpc.ini</span><br></pre></td></tr></table></figure>

<p>启动输出如下</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">2020/02/23 19:19:34 [I] [service.go:250] [ae46f3632a860bba] login to server success, get run id [ae46f3632a860bba], server udp port [0]</span><br><span class="line">2020/02/23 19:19:34 [I] [proxy_manager.go:144] [ae46f3632a860bba] proxy added: [web ssh]</span><br><span class="line">2020/02/23 19:19:34 [I] [control.go:164] [ae46f3632a860bba] [web] start proxy success</span><br><span class="line">2020/02/23 19:19:34 [I] [control.go:164] [ae46f3632a860bba] [ssh] start proxy success</span><br></pre></td></tr></table></figure>

<p>同时观察服务端输出，增加了如下输出</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">2020/02/23 19:19:34 [I] [service.go:392] [ae46f3632a860bba] client login info: ip [113.110.200.14:46946] version [0.31.2] hostname [] os [linux] arch [arm]                                                                                                                                            </span><br><span class="line">2020/02/23 19:19:34 [I] [http.go:92] [ae46f3632a860bba] [web] http proxy listen <span class="keyword">for</span> host [xxx.xxx.xxx] location [] group []</span><br><span class="line">2020/02/23 19:19:34 [I] [control.go:445] [ae46f3632a860bba] new proxy [web] success</span><br><span class="line">2020/02/23 19:19:34 [I] [tcp.go:63] [ae46f3632a860bba] [ssh] tcp proxy listen port [6000]</span><br><span class="line">2020/02/23 19:19:34 [I] [control.go:445] [ae46f3632a860bba] new proxy [ssh] success</span><br></pre></td></tr></table></figure>

<p>至此，通过ssh命令登录VPS的6000端口，即可远程访问到树莓派；通过指定的域名，即可访问到树莓派中暴露于7000端口的web服务。</p>
</li>
</ul>
<h1 id="验证"><a href="#验证" class="headerlink" title="验证"></a>验证</h1><ul>
<li><p>测试需求一</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 尝试远程ssh登录</span></span><br><span class="line">ssh -oPort=6000 pi@&lt;VPS公网IP&gt;</span><br></pre></td></tr></table></figure>

<p>ssh登录成功</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">floyd@floyd-ThinkPad-T490:~$ ssh -oPort=6000 pi@xxx.xxx.xxx.xxx</span><br><span class="line">The authenticity of host <span class="string">&#x27;[blog]:6000 ([xxx.xxx.xxx.xxx]:6000)&#x27;</span> can<span class="string">&#x27;t be established.</span></span><br><span class="line"><span class="string">ECDSA key fingerprint is SHA256:o4+aSfAmCMmE5l/UAj+8/XJ8YyWDYrMzlbVelu0ggAA.</span></span><br><span class="line"><span class="string">Are you sure you want to continue connecting (yes/no)? </span></span><br></pre></td></tr></table></figure></li>
<li><p>测试需求二</p>
<p>浏览器访问指定域名，成功访问到树莓派中运行的服务——AWTRIX控制台</p>
<p><img src="https://gdz.oss-cn-shenzhen.aliyuncs.com/hexo/%E5%9F%BA%E4%BA%8Efrp%E6%9E%84%E5%BB%BA%E5%86%85%E7%BD%91%E7%A9%BF%E9%80%8F/image-20200223200953292.png" alt="image-20200223200953292"></p>
</li>
</ul>
<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>通过frp，完美实现了上述两个需求，关键是免费。当然，该软件还有更加强大的功能，如有需要，尽管去折腾。</p>
<p>在配置过程中也有遇到坑和觉得可以改善的地方，如下</p>
<ul>
<li><p>VPS安全组问题。阿里云的访问白名单默认没有开启6000\7000\7001三个端口的访问，需要手动添加，否则无法访问</p>
<p><img src="https://gdz.oss-cn-shenzhen.aliyuncs.com/hexo/%E5%9F%BA%E4%BA%8Efrp%E6%9E%84%E5%BB%BA%E5%86%85%E7%BD%91%E7%A9%BF%E9%80%8F/image-20200223201440732.png" alt="image-20200223201440732"></p>
</li>
<li><p>服务端可客户端的启动脚本，可以加入开机自启动。为了方便，服务端使用了supervisor进行管理。客户端则直接添加到/etc/rc.local</p>
<ul>
<li><p>服务端</p>
<p>supervisor配置文件</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[program:frp]</span><br><span class="line">directory = /root/frp/frp_0.31.2_linux_amd64</span><br><span class="line"><span class="built_in">command</span> = /root/frp/frp_0.31.2_linux_amd64/frps -c /root/frp/frp_0.31.2_linux_amd64/frps.ini</span><br><span class="line">autostart = <span class="literal">true</span></span><br><span class="line">startsecs = 10</span><br><span class="line">autorestart = <span class="literal">true</span></span><br><span class="line">startretries = 3</span><br><span class="line">user = root</span><br><span class="line">redirect_stderr = <span class="literal">true</span></span><br><span class="line">stdout_logfile_maxbytes = 50MB</span><br><span class="line">stdout_logfile_backups = 20</span><br><span class="line">stdout_logfile = /var/<span class="built_in">log</span>/frp/frp.log</span><br></pre></td></tr></table></figure>

<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 更新supervisor</span></span><br><span class="line">supervisorctl update</span><br></pre></td></tr></table></figure></li>
<li><p>客户端</p>
<p>在/etc/systemd/system下创建frp.service文件，内容如下</p>
<figure class="highlight ini"><table><tr><td class="code"><pre><span class="line"><span class="section">[Unit]</span></span><br><span class="line"><span class="attr">Description</span>=FRP Client</span><br><span class="line"><span class="attr">After</span>=network.target</span><br><span class="line"></span><br><span class="line"><span class="section">[Service]</span></span><br><span class="line"><span class="attr">Type</span>=simple</span><br><span class="line"><span class="attr">WorkingDirectory</span>=/home/pi/frp/frp_0.<span class="number">31.2</span>_linux_arm</span><br><span class="line"><span class="attr">ExecStart</span>=/home/pi/frp/frp_0.<span class="number">31.2</span>_linux_arm/frpc -c /home/pi/frp/frp_0.<span class="number">31.2</span>_linux_arm/frpc.ini</span><br><span class="line"></span><br><span class="line"><span class="section">[Install]</span></span><br><span class="line"><span class="attr">WantedBy</span>=multi-user.target</span><br></pre></td></tr></table></figure>

<p>执行命令如下</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 自启动开启</span></span><br><span class="line">sudo systemctl <span class="built_in">enable</span> frp.service</span><br><span class="line"><span class="comment"># 启动服务</span></span><br><span class="line">sudo systemctl start frp.service</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
</ul>
<h1 id="参考文档"><a href="#参考文档" class="headerlink" title="参考文档"></a>参考文档</h1><ol>
<li><a href="https://github.com/fatedier/frp/blob/master/README.md">frp手册</a></li>
</ol>
]]></content>
      <categories>
        <category>工具</category>
      </categories>
      <tags>
        <tag>frp</tag>
      </tags>
  </entry>
  <entry>
    <title>使用JSON Schema验证API响应</title>
    <url>/2020/10/03/%E4%BD%BF%E7%94%A8JSON%20Schema%E9%AA%8C%E8%AF%81API%E5%93%8D%E5%BA%94-shi-yong-jsonschema-yan-zheng-api-xiang-ying/</url>
    <content><![CDATA[<h2 id="API的响应需要约束"><a href="#API的响应需要约束" class="headerlink" title="API的响应需要约束"></a>API的响应需要约束</h2><p>目前我们开发Web API的方式是通过定义Open API描述文件来定义请求约束。约束能够保证所有请求参数按照正确的格式和必要性传输，从而规范化输入。这保护了服务端内部的安全——输入约束不变的情况下，输入的值总是合法可期的。</p>
<p>尽管Open API也提供了对Response Body的定义，允许用户描述响应的消息格式，但由于其不具有强制性——语法上可以不写，写了也不与实际返回内容有深入结合，因此无法验证真实API的响应是否符合预期，这也是从一开始不愿写响应体的原因。</p>
<p>而关于验证API响应的重要性，是不言而喻的，截止目前，至少有两个时刻让我有了“如果能够在单元测试就验证响应体格式就好了”的想法。</p>
<p>其一：今年上半年的一次down time，彼时是上线真米视频，其video id要做到可控（手动编写，数位字符串），而原逻辑使用了阿里云生成的video id——32位字符串。使用的方案是将手动生成的video id替换了阿里云video id，结果由于测试上的不周全导致所有视频的video id都被替换，对于那些没有分配手动id的音视频，其video id自然变成了null。而该问题因为机缘巧合对视频无影响，仅对音频产生影响。导致较长时间才发现。回首该问题，出在video id字段的格式上，如果有对响应体做约束——要求video id必须有值，且长度为32位，则该问题能够在单元测试就发现。</p>
<span id="more"></span>

<p>其二：呼啦亲子项目已进行了多次迭代，大致如下</p>
<ul>
<li>初版</li>
<li>增加了呼啦圈，其内容与文章接近，封面图需要记录宽高和媒体类型；为了保持格式一致，原本文章的封面格式也改为如此</li>
<li>首页文章的封面的显示增加多图效果，其它页面保持原有格式不变，且多图效果要求类随机——即要对封面字段格式化输出</li>
<li>创作者中心用于编辑上面多图的选项，因此获取的封面字段要原样输出</li>
<li>每一次升级都要兼容之前的版本</li>
</ul>
<p>光看文章这一项的元数据，就有下面四种格式</p>
<p>首页文章格式（其中coverSrc用于兼容最初版本、cover用于兼容次初版本API、covers+style是最新版的API需要的字段）</p>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line"><span class="string">&quot;meta&quot;</span>: &#123;</span><br><span class="line">    <span class="attr">&quot;title&quot;</span>: <span class="string">&quot;各国孩子吃什么零食之法国篇&quot;</span>,</span><br><span class="line">    <span class="attr">&quot;covers&quot;</span>: [</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="attr">&quot;url&quot;</span>: <span class="string">&quot;https://qinzi.static.hulaplanet.com/ttp/editor/94d53aa2e67acaf5bdac445eb1ed2144.jpg?x-oss-process=image/auto-orient,1/interlace,1/resize,m_lfit,w_828/quality,q_90/format,jpg&quot;</span>,</span><br><span class="line">            <span class="attr">&quot;width&quot;</span>: <span class="number">800</span>,</span><br><span class="line">            <span class="attr">&quot;height&quot;</span>: <span class="number">600</span>,</span><br><span class="line">            <span class="attr">&quot;mediaType&quot;</span>: <span class="string">&quot;image&quot;</span></span><br><span class="line">        &#125;</span><br><span class="line">    ],</span><br><span class="line">    <span class="attr">&quot;coverSrc&quot;</span>: <span class="string">&quot;https://qinzi.static.hulaplanet.com/ttp/editor/94d53aa2e67acaf5bdac445eb1ed2144.jpg&quot;</span>,</span><br><span class="line">    <span class="attr">&quot;cover&quot;</span>: &#123;</span><br><span class="line">        <span class="attr">&quot;url&quot;</span>: <span class="string">&quot;https://qinzi.static.hulaplanet.com/ttp/editor/94d53aa2e67acaf5bdac445eb1ed2144.jpg?x-oss-process=image/auto-orient,1/interlace,1/resize,m_lfit,w_828/quality,q_90/format,jpg&quot;</span>,</span><br><span class="line">        <span class="attr">&quot;width&quot;</span>: <span class="number">800</span>,</span><br><span class="line">        <span class="attr">&quot;height&quot;</span>: <span class="number">600</span>,</span><br><span class="line">        <span class="attr">&quot;mediaType&quot;</span>: <span class="string">&quot;image&quot;</span></span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="attr">&quot;style&quot;</span>: <span class="string">&quot;singleMinImage&quot;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>普通文章列表页格式（多图显示仅对首页生效，普通列表页保持次初版本格式）</p>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line"><span class="string">&quot;meta&quot;</span>: &#123;</span><br><span class="line">    <span class="attr">&quot;title&quot;</span>: <span class="string">&quot;各国孩子吃什么零食之法国篇&quot;</span>,</span><br><span class="line">    <span class="attr">&quot;coverSrc&quot;</span>: <span class="string">&quot;https://qinzi.static.hulaplanet.com/ttp/editor/94d53aa2e67acaf5bdac445eb1ed2144.jpg&quot;</span>,</span><br><span class="line">    <span class="attr">&quot;cover&quot;</span>: &#123;</span><br><span class="line">        <span class="attr">&quot;url&quot;</span>: <span class="string">&quot;https://qinzi.static.hulaplanet.com/ttp/editor/94d53aa2e67acaf5bdac445eb1ed2144.jpg?x-oss-process=image/auto-orient,1/interlace,1/resize,m_lfit,w_828/quality,q_90/format,jpg&quot;</span>,</span><br><span class="line">        <span class="attr">&quot;width&quot;</span>: <span class="number">800</span>,</span><br><span class="line">        <span class="attr">&quot;height&quot;</span>: <span class="number">600</span>,</span><br><span class="line">        <span class="attr">&quot;mediaType&quot;</span>: <span class="string">&quot;image&quot;</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>文章详情页格式（多出来了jsVersion和cssVersion）</p>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line"><span class="string">&quot;meta&quot;</span>: &#123;</span><br><span class="line">    <span class="attr">&quot;title&quot;</span>: <span class="string">&quot;各国孩子吃什么零食之法国篇&quot;</span>,</span><br><span class="line">    <span class="attr">&quot;coverSrc&quot;</span>: <span class="string">&quot;https://qinzi.static.hulaplanet.com/ttp/editor/94d53aa2e67acaf5bdac445eb1ed2144.jpg&quot;</span>,</span><br><span class="line">    <span class="attr">&quot;cover&quot;</span>: &#123;</span><br><span class="line">        <span class="attr">&quot;url&quot;</span>: <span class="string">&quot;https://qinzi.static.hulaplanet.com/ttp/editor/94d53aa2e67acaf5bdac445eb1ed2144.jpg?x-oss-process=image/auto-orient,1/interlace,1/resize,m_lfit,w_828/quality,q_90/format,jpg&quot;</span>,</span><br><span class="line">        <span class="attr">&quot;width&quot;</span>: <span class="number">800</span>,</span><br><span class="line">        <span class="attr">&quot;height&quot;</span>: <span class="number">600</span>,</span><br><span class="line">        <span class="attr">&quot;mediaType&quot;</span>: <span class="string">&quot;image&quot;</span></span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="attr">&quot;jsVersion&quot;</span>: <span class="string">&quot;awbegiwaubegwug&quot;</span>,</span><br><span class="line">    <span class="attr">&quot;cssVersion&quot;</span>: <span class="string">&quot;weignwoegowibhg&quot;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>创作者中心文章格式（多出来了jsVersion, cssVersion, coverDisplayCount(用于用户选择该文章显示几张图)）</p>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line"><span class="string">&quot;meta&quot;</span>: &#123;</span><br><span class="line">    <span class="attr">&quot;title&quot;</span>: <span class="string">&quot;各国孩子吃什么零食之法国篇&quot;</span>,</span><br><span class="line">    <span class="attr">&quot;covers&quot;</span>: [</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="attr">&quot;url&quot;</span>: <span class="string">&quot;https://qinzi.static.hulaplanet.com/ttp/editor/94d53aa2e67acaf5bdac445eb1ed2144.jpg?x-oss-process=image/auto-orient,1/interlace,1/resize,m_lfit,w_828/quality,q_90/format,jpg&quot;</span>,</span><br><span class="line">            <span class="attr">&quot;width&quot;</span>: <span class="number">800</span>,</span><br><span class="line">            <span class="attr">&quot;height&quot;</span>: <span class="number">600</span>,</span><br><span class="line">            <span class="attr">&quot;mediaType&quot;</span>: <span class="string">&quot;image&quot;</span></span><br><span class="line">        &#125;</span><br><span class="line">    ],,</span><br><span class="line">    <span class="attr">&quot;jsVersion&quot;</span>: <span class="string">&quot;awbegiwaubegwug&quot;</span>,</span><br><span class="line">    <span class="attr">&quot;cssVersion&quot;</span>: <span class="string">&quot;weignwoegowibhg&quot;</span>,</span><br><span class="line">    <span class="attr">&quot;coverDisplayCount&quot;</span>: <span class="number">1</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>一个文章的mata就有四种格式，再加上呼啦圈的meta格式，如果需要同时对他们进行修改，一定会令人相当头大。此时如果能够在单元测试约束meta的格式，要求哪些字段是必须的，不需要哪些字段，则可大大减轻心智负担，对API质量也是一个保证。</p>
<h2 id="可能的约束方法"><a href="#可能的约束方法" class="headerlink" title="可能的约束方法"></a>可能的约束方法</h2><p>那么有什么好的方法来做这件事呢？一般我们有几种方法</p>
<p><strong>编程测试</strong></p>
<p>最原始也是最直接的方法，直接编程验证每个字段的格式。这种方式砖量太大，如果要对拥有数十个字段的响应，针对每个字段验证类型、长度、多余字段等。如果多几个这样的接口，会头晕的。</p>
<p>有针对此做一些优化的，即使用一些json validator进行验证，但这些工具的局限性太大，不能完全满足需求。</p>
<p>使用编程测试最终的归宿很可能会变成只测试几个重要的字段的格式，但<strong>往往出问题的都是没有关注的字段，而重视的字段一般没那么容易出问题</strong>。</p>
<p><strong>使用JSON Schema</strong></p>
<p>铺垫那么多，就是想说JSON Schema。一个真正满足需求的东西。JSON Schema是一个规范，用于全方位描述json的格式，包括一个json中必须包含哪些字段、只能包含哪些字段、字段的类型、是否可为空、字段最大最小值、字段的长度等。如同我们使用Open API描述文件来描述我们接口的输入参数；使用JSON Schema描述API响应消息体并在单元测试进行验证。这样把控API输入和输出，在安全性上会有比较大的提升。</p>
<h2 id="Json-Schema"><a href="#Json-Schema" class="headerlink" title="Json Schema"></a>Json Schema</h2><p>JSON Schema官网<a href="https://json-schema.org/%EF%BC%8C%E7%9B%AE%E5%89%8D%E6%9C%80%E6%96%B0%E7%89%88%E6%98%AF2019-09">https://json-schema.org/，目前最新版是2019-09</a>.</p>
<p>按照官网的话说，JSON Schema是一个用于描述和验证JSON文档的规范。</p>
<p>使用JSON Schema时最大的问题是会把描述文件写得太大，尤其是使用JSON Schema生成工具(<a href="https://jsonschema.net/home)%E6%97%B6%E3%80%82%E5%88%9A%E5%BC%80%E5%A7%8B%E5%B0%86/feeds%E6%8E%A5%E5%8F%A3%E7%9A%84%E5%93%8D%E5%BA%94%E8%87%AA%E5%8A%A8%E7%94%9F%E6%88%90%E4%BA%86%E6%95%B0%E7%99%BE%E8%A1%8C%E6%8F%8F%E8%BF%B0%E6%96%87%E4%BB%B6%EF%BC%8C%E8%BF%99%E6%97%A0%E7%96%91%E6%98%AF%E4%B8%8D%E5%8F%AF%E6%8E%A5%E5%8F%97%E7%9A%84%E3%80%82">https://jsonschema.net/home)时。刚开始将/feeds接口的响应自动生成了数百行描述文件，这无疑是不可接受的。</a></p>
<p>解决此问题的最好办法，以目前我的认知来看，是全部手写+定义复用的方式——仅增加自己需要的特性，再将公共结构抽取出来，在合适的地方使用$ref引用。具体可参考<a href="https://json-schema.org/understanding-json-schema/structuring.html">如何定义一个复杂的schema</a>（该文章对应的书籍<a href="https://json-schema.org/understanding-json-schema/index.html">Understanding Json Schema</a>也是学习JSON Schema的不错的资料）。</p>
<p>同时，官网也列出了<a href="https://json-schema.org/implementations.html">各语言下验证JSON Schema的库</a>，在Java下，我推荐<a href="https://github.com/networknt/json-schema-validator">这个</a></p>
<h2 id="使用JSON-Schema"><a href="#使用JSON-Schema" class="headerlink" title="使用JSON Schema"></a>使用JSON Schema</h2><p>我们举例如何使用JSON SChema验证/feeds接口文章类型的数据</p>
<h3 id="定义Schema"><a href="#定义Schema" class="headerlink" title="定义Schema"></a>定义Schema</h3><h4 id="公共属性"><a href="#公共属性" class="headerlink" title="公共属性"></a>公共属性</h4><figure class="highlight json"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="attr">&quot;$schema&quot;</span>: <span class="string">&quot;http://json-schema.org/draft-07/schema#&quot;</span>,</span><br><span class="line">  <span class="attr">&quot;definitions&quot;</span>: &#123;</span><br><span class="line">    <span class="attr">&quot;nullableString&quot;</span>: &#123;</span><br><span class="line">      <span class="attr">&quot;oneOf&quot;</span>: [</span><br><span class="line">        &#123;</span><br><span class="line">          <span class="attr">&quot;type&quot;</span>: <span class="string">&quot;string&quot;</span></span><br><span class="line">        &#125;,</span><br><span class="line">        &#123;</span><br><span class="line">          <span class="attr">&quot;type&quot;</span>: <span class="string">&quot;null&quot;</span></span><br><span class="line">        &#125;</span><br><span class="line">      ]</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="attr">&quot;encodedId&quot;</span>: &#123;</span><br><span class="line">      <span class="attr">&quot;type&quot;</span>: <span class="string">&quot;string&quot;</span>,</span><br><span class="line">      <span class="attr">&quot;minLength&quot;</span>: <span class="number">20</span></span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="attr">&quot;mediaType&quot;</span>: &#123;</span><br><span class="line">      <span class="attr">&quot;enum&quot;</span>: [</span><br><span class="line">        <span class="string">&quot;image&quot;</span>,</span><br><span class="line">        <span class="string">&quot;video&quot;</span></span><br><span class="line">      ]</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="attr">&quot;stateEnum&quot;</span>: &#123;</span><br><span class="line">      <span class="attr">&quot;enum&quot;</span>: [</span><br><span class="line">        <span class="string">&quot;normal&quot;</span>,</span><br><span class="line">        <span class="string">&quot;draft&quot;</span></span><br><span class="line">      ]</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="attr">&quot;postFeedStyle&quot;</span>: &#123;</span><br><span class="line">      <span class="attr">&quot;enum&quot;</span>: [</span><br><span class="line">        <span class="string">&quot;textOnly&quot;</span>,</span><br><span class="line">        <span class="string">&quot;singleMinImage&quot;</span>,</span><br><span class="line">        <span class="string">&quot;singleMaxImage&quot;</span>,</span><br><span class="line">        <span class="string">&quot;twoImages&quot;</span>,</span><br><span class="line">        <span class="string">&quot;threeImages&quot;</span></span><br><span class="line">      ]</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="作者"><a href="#作者" class="headerlink" title="作者"></a>作者</h4><figure class="highlight json"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="attr">&quot;$schema&quot;</span>: <span class="string">&quot;http://json-schema.org/draft-07/schema#&quot;</span>,</span><br><span class="line">  <span class="attr">&quot;type&quot;</span>: <span class="string">&quot;object&quot;</span>,</span><br><span class="line">  <span class="attr">&quot;properties&quot;</span>: &#123;</span><br><span class="line">    <span class="attr">&quot;id&quot;</span>: &#123;</span><br><span class="line">      <span class="attr">&quot;$ref&quot;</span>: <span class="string">&quot;../../public-definitions.json#/definitions/encodedId&quot;</span></span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="attr">&quot;nickname&quot;</span>: &#123;</span><br><span class="line">      <span class="attr">&quot;$ref&quot;</span>: <span class="string">&quot;../../public-definitions.json#/definitions/nullableString&quot;</span></span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="attr">&quot;avatar&quot;</span>: &#123;</span><br><span class="line">      <span class="attr">&quot;$ref&quot;</span>: <span class="string">&quot;../../public-definitions.json#/definitions/nullableString&quot;</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="attr">&quot;required&quot;</span>: [</span><br><span class="line">    <span class="string">&quot;id&quot;</span>,</span><br><span class="line">    <span class="string">&quot;nickname&quot;</span>,</span><br><span class="line">    <span class="string">&quot;avatar&quot;</span></span><br><span class="line">  ],</span><br><span class="line">  <span class="attr">&quot;additionalProperties&quot;</span>: <span class="literal">false</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="媒体类型"><a href="#媒体类型" class="headerlink" title="媒体类型"></a>媒体类型</h4><figure class="highlight json"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="attr">&quot;$schema&quot;</span>: <span class="string">&quot;http://json-schema.org/draft-07/schema#&quot;</span>,</span><br><span class="line">  <span class="attr">&quot;type&quot;</span>: <span class="string">&quot;object&quot;</span>,</span><br><span class="line">  <span class="attr">&quot;properties&quot;</span>: &#123;</span><br><span class="line">    <span class="attr">&quot;url&quot;</span>: &#123;</span><br><span class="line">      <span class="attr">&quot;$ref&quot;</span>: <span class="string">&quot;../../public-definitions.json#/definitions/nullableString&quot;</span></span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="attr">&quot;width&quot;</span>: &#123;</span><br><span class="line">      <span class="attr">&quot;type&quot;</span>: <span class="string">&quot;integer&quot;</span></span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="attr">&quot;height&quot;</span>: &#123;</span><br><span class="line">      <span class="attr">&quot;type&quot;</span>: <span class="string">&quot;integer&quot;</span></span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="attr">&quot;mediaType&quot;</span>: &#123;</span><br><span class="line">      <span class="attr">&quot;$ref&quot;</span>: <span class="string">&quot;../../public-definitions.json#/definitions/mediaType&quot;</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="attr">&quot;required&quot;</span>: [</span><br><span class="line">    <span class="string">&quot;url&quot;</span>,</span><br><span class="line">    <span class="string">&quot;width&quot;</span>,</span><br><span class="line">    <span class="string">&quot;height&quot;</span>,</span><br><span class="line">    <span class="string">&quot;mediaType&quot;</span></span><br><span class="line">  ],</span><br><span class="line">  <span class="attr">&quot;additionalProperties&quot;</span>: <span class="literal">false</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="标签类型"><a href="#标签类型" class="headerlink" title="标签类型"></a>标签类型</h4><figure class="highlight json"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="attr">&quot;$schema&quot;</span>: <span class="string">&quot;http://json-schema.org/draft-07/schema#&quot;</span>,</span><br><span class="line">  <span class="attr">&quot;type&quot;</span>: <span class="string">&quot;object&quot;</span>,</span><br><span class="line">  <span class="attr">&quot;properties&quot;</span>: &#123;</span><br><span class="line">    <span class="attr">&quot;id&quot;</span>: &#123;</span><br><span class="line">      <span class="attr">&quot;$ref&quot;</span>: <span class="string">&quot;../../public-definitions.json#/definitions/encodedId&quot;</span></span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="attr">&quot;name&quot;</span>: &#123;</span><br><span class="line">      <span class="attr">&quot;type&quot;</span>: <span class="string">&quot;string&quot;</span></span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="attr">&quot;hotted&quot;</span>: &#123;</span><br><span class="line">      <span class="attr">&quot;type&quot;</span>: <span class="string">&quot;boolean&quot;</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="attr">&quot;required&quot;</span>: [</span><br><span class="line">    <span class="string">&quot;id&quot;</span>,</span><br><span class="line">    <span class="string">&quot;name&quot;</span>,</span><br><span class="line">    <span class="string">&quot;hotted&quot;</span></span><br><span class="line">  ],</span><br><span class="line">  <span class="attr">&quot;additionalProperties&quot;</span>: <span class="literal">false</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="元数据"><a href="#元数据" class="headerlink" title="元数据"></a>元数据</h4><figure class="highlight json"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="attr">&quot;$schema&quot;</span>: <span class="string">&quot;http://json-schema.org/draft-07/schema#&quot;</span>,</span><br><span class="line">  <span class="attr">&quot;type&quot;</span>: <span class="string">&quot;object&quot;</span>,</span><br><span class="line">  <span class="attr">&quot;properties&quot;</span>: &#123;</span><br><span class="line">    <span class="attr">&quot;title&quot;</span>: &#123;</span><br><span class="line">      <span class="attr">&quot;type&quot;</span>: <span class="string">&quot;string&quot;</span></span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="attr">&quot;coverSrc&quot;</span>: &#123;</span><br><span class="line">      <span class="attr">&quot;type&quot;</span>: <span class="string">&quot;string&quot;</span>,</span><br><span class="line">      <span class="attr">&quot;description&quot;</span>: <span class="string">&quot;为了兼容最初的API而留存的字段&quot;</span></span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="attr">&quot;cover&quot;</span>: &#123;</span><br><span class="line">      <span class="attr">&quot;$ref&quot;</span>: <span class="string">&quot;../../base/media.json&quot;</span>,</span><br><span class="line">      <span class="attr">&quot;description&quot;</span>: <span class="string">&quot;为了兼容V2.0前期而存在的字段&quot;</span></span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="attr">&quot;covers&quot;</span>: &#123;</span><br><span class="line">      <span class="attr">&quot;type&quot;</span>: <span class="string">&quot;array&quot;</span>,</span><br><span class="line">      <span class="attr">&quot;description&quot;</span>: <span class="string">&quot;目前线上版本在用的字段&quot;</span>,</span><br><span class="line">      <span class="attr">&quot;items&quot;</span>: [</span><br><span class="line">        &#123;</span><br><span class="line">          <span class="attr">&quot;$ref&quot;</span>: <span class="string">&quot;../../base/media.json&quot;</span></span><br><span class="line">        &#125;</span><br><span class="line">      ]</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="attr">&quot;style&quot;</span>: &#123;</span><br><span class="line">      <span class="attr">&quot;$ref&quot;</span>: <span class="string">&quot;../../../public-definitions.json#/definitions/postFeedStyle&quot;</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="attr">&quot;required&quot;</span>: [</span><br><span class="line">    <span class="string">&quot;title&quot;</span>,</span><br><span class="line">    <span class="string">&quot;cover&quot;</span>,</span><br><span class="line">    <span class="string">&quot;covers&quot;</span>,</span><br><span class="line">    <span class="string">&quot;coverSrc&quot;</span>,</span><br><span class="line">    <span class="string">&quot;style&quot;</span></span><br><span class="line">  ],</span><br><span class="line">  <span class="attr">&quot;additionalProperties&quot;</span>: <span class="literal">false</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="汇总成-feeds接口返回的数据"><a href="#汇总成-feeds接口返回的数据" class="headerlink" title="汇总成/feeds接口返回的数据"></a>汇总成/feeds接口返回的数据</h4><figure class="highlight json"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="attr">&quot;$schema&quot;</span>: <span class="string">&quot;http://json-schema.org/draft-07/schema#&quot;</span>,</span><br><span class="line">  <span class="attr">&quot;type&quot;</span>: <span class="string">&quot;object&quot;</span>,</span><br><span class="line">  <span class="attr">&quot;definitions&quot;</span>: &#123;</span><br><span class="line">    <span class="attr">&quot;item&quot;</span>: &#123;</span><br><span class="line">      <span class="attr">&quot;allOf&quot;</span>: [</span><br><span class="line">        &#123;</span><br><span class="line">          <span class="attr">&quot;$ref&quot;</span>: <span class="string">&quot;base/public-properties.json&quot;</span></span><br><span class="line">        &#125;,</span><br><span class="line">        &#123;</span><br><span class="line">          <span class="attr">&quot;properties&quot;</span>: &#123;</span><br><span class="line">            <span class="attr">&quot;meta&quot;</span>: &#123;</span><br><span class="line">              <span class="attr">&quot;$ref&quot;</span>: <span class="string">&quot;base/meta-feed.json&quot;</span></span><br><span class="line">            &#125;,</span><br><span class="line">            <span class="attr">&quot;author&quot;</span>: &#123;</span><br><span class="line">              <span class="attr">&quot;$ref&quot;</span>: <span class="string">&quot;../base/author.json&quot;</span></span><br><span class="line">            &#125;</span><br><span class="line">          &#125;,</span><br><span class="line">          <span class="attr">&quot;required&quot;</span>: [</span><br><span class="line">            <span class="string">&quot;meta&quot;</span>,</span><br><span class="line">            <span class="string">&quot;author&quot;</span></span><br><span class="line">          ]</span><br><span class="line">        &#125;</span><br><span class="line">      ]</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="attr">&quot;properties&quot;</span>: &#123;</span><br><span class="line">    <span class="attr">&quot;list&quot;</span>: &#123;</span><br><span class="line">      <span class="attr">&quot;type&quot;</span>: <span class="string">&quot;array&quot;</span>,</span><br><span class="line">      <span class="attr">&quot;items&quot;</span>: [</span><br><span class="line">        &#123;</span><br><span class="line">          <span class="attr">&quot;$ref&quot;</span>: <span class="string">&quot;#/definitions/item&quot;</span></span><br><span class="line">        &#125;</span><br><span class="line">      ]</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="attr">&quot;required&quot;</span>: [</span><br><span class="line">    <span class="string">&quot;list&quot;</span></span><br><span class="line">  ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>可以看到，最终定义的文章schema也没有很长，而前面的公共属性、作者等提取出来的结构由于会被众多其它定义使用，因此总体长度是可以接受的。</p>
<h3 id="使用schema验证响应体"><a href="#使用schema验证响应体" class="headerlink" title="使用schema验证响应体"></a>使用schema验证响应体</h3><p>我们使用json-schema-validator库加载定义好的schema来验证接口响应。</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">suspend</span> <span class="function"><span class="keyword">fun</span> WebClient.<span class="title">validateAPIResponseSchema</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">  path: <span class="type">String</span>, params: <span class="type">Map</span>&lt;<span class="type">String</span>, String&gt; = mapOf()</span></span>, schemaPath: String</span><br><span class="line">) &#123;</span><br><span class="line">  <span class="keyword">val</span> request = <span class="keyword">this</span></span><br><span class="line">    .<span class="keyword">get</span>(path)</span><br><span class="line">    .host(serverHost)</span><br><span class="line">    .port(serverPort)</span><br><span class="line">    .putHeader(<span class="string">&quot;token&quot;</span>, testToken)</span><br><span class="line"></span><br><span class="line">  params.forEach &#123; (k, v) -&gt; request.addQueryParam(k, v) &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">val</span> response = request.<span class="keyword">expect</span>(ResponsePredicate.JSON)</span><br><span class="line">    .<span class="keyword">expect</span>(ResponsePredicate.SC_OK)</span><br><span class="line">    .sendAwait().bodyAsJsonObject()</span><br><span class="line"></span><br><span class="line">  <span class="keyword">val</span> schemaURI = File(schemaPath).toURI()</span><br><span class="line">  <span class="keyword">val</span> schema = JsonSchemaFactory.getInstance(SpecVersion.VersionFlag.V7).getSchema(schemaURI)</span><br><span class="line">  <span class="keyword">val</span> node = withContext(Dispatchers.IO) &#123; ObjectMapper().readTree(response.encode()) &#125;</span><br><span class="line">  schema.assertLegal(node)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Test</span></span><br><span class="line">  <span class="function"><span class="keyword">fun</span> <span class="title">testGetPostFeeds</span><span class="params">(vertx: <span class="type">Vertx</span>, tc: <span class="type">VertxTestContext</span>)</span></span> &#123;</span><br><span class="line">    launch5e(tc) &#123;</span><br><span class="line">      webClient.validateAPIResponseSchema(</span><br><span class="line">        path = <span class="string">&quot;/feeds&quot;</span>,</span><br><span class="line">        params = mapOf(<span class="string">&quot;content_type&quot;</span> to <span class="string">&quot;post&quot;</span>, <span class="string">&quot;limit&quot;</span> to <span class="string">&quot;20&quot;</span>),</span><br><span class="line">        schemaPath = <span class="string">&quot;src/main/resources/jsonschema/content/post/profile-feed.json&quot;</span></span><br><span class="line">      )</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>

<p>运行测试函数testGetPostFeeds，如果验证失败，可得到具体错误原因，方便排查。</p>
<p>至此，使用JSON Schema进行API响应的验证就完成了。只要描述文件不动，就能及时发现响应格式上的错误，保证了接口的正确性。</p>
<h2 id="Open-API与Json-Schema"><a href="#Open-API与Json-Schema" class="headerlink" title="Open API与Json Schema"></a>Open API与Json Schema</h2><p>不止一次前端或客户端的同志直接或间接要求我们写Response格式描述，但由于写起来耗时且该描述与实际响应没有强耦合关系，改动很可能不及时，带来很多问题。如果能够将上面定义的JSON Schema描述文件应用到Open API描述文件中，岂不美哉。</p>
<p>然而现实是残酷的，Swagger确实<a href="https://swagger.io/docs/specification/data-models/keywords/">支持JSON Schema</a>，但支持的是个子集，因此无法直接使用上面定义的描述文件。美梦落空。。。淡淡的忧桑。</p>
]]></content>
      <categories>
        <category>后端</category>
        <category>协议</category>
      </categories>
      <tags>
        <tag>JsonSchema</tag>
      </tags>
  </entry>
  <entry>
    <title>将html转换为格式化文本</title>
    <url>/2021/07/07/%E5%B0%86html%E8%BD%AC%E6%8D%A2%E4%B8%BA%E6%A0%BC%E5%BC%8F%E5%8C%96%E6%96%87%E6%9C%AC-jiang-html-zhuan-huan-wei-ge-shi-hua-wen-ben/</url>
    <content><![CDATA[<h2 id="需求"><a href="#需求" class="headerlink" title="需求"></a>需求</h2><p>html渲染是一个相对常见的需求，在web前端做起来比较容易。Java中很多组价也支持直接填入html原始数据进行格式化渲染。但有时我们需要将html转换为格式化文本，举例来说，满足如下条件</p>
<ul>
<li>反转html实体，如&amp;</li>
<li>去除所有标签</li>
<li>除换行之外的所有格式全都去除</li>
</ul>
<span id="more"></span>

<h2 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h2><p>目前市面上并没有一步实现该需求的方案，最为接近可行的方案是Jsoup:<a href="https://github.com/jhy/jsoup">https://github.com/jhy/jsoup</a>；它能够将html文本转换为dom树，并能提取其中文本和元素。</p>
<p>我们的实现逻辑如下：</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="string">private</span> <span class="string">fun</span> <span class="string">Document.format():</span> <span class="string">String</span> &#123;</span><br><span class="line">    <span class="string">return</span> <span class="string">StringBuffer().apply</span> &#123; <span class="string">this@format.body().format(this)</span> &#125;<span class="string">.toString()</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="string">private</span> <span class="string">fun</span> <span class="string">Element.format(sb:</span> <span class="string">StringBuffer)</span> &#123;</span><br><span class="line">    <span class="string">if</span> <span class="string">(this.childNodeSize()</span> <span class="string">==</span> <span class="number">0</span><span class="string">)</span> <span class="string">return</span></span><br><span class="line">    <span class="string">this.childNodes().forEach</span> &#123;</span><br><span class="line">        <span class="string">when</span> <span class="string">(it)</span> &#123;</span><br><span class="line">            <span class="string">is</span> <span class="string">TextNode</span> <span class="string">-&gt;</span> &#123;</span><br><span class="line">                <span class="string">sb.append(it.wholeText.trim())</span></span><br><span class="line">            &#125;</span><br><span class="line">            <span class="string">is</span> <span class="string">Element</span> <span class="string">-&gt;</span> <span class="string">when</span> <span class="string">(it.tagName())</span> &#123;</span><br><span class="line">                <span class="string">&quot;div&quot;</span>, <span class="string">&quot;p&quot;</span>, <span class="string">&quot;ul&quot;</span> <span class="string">-&gt;</span> &#123;</span><br><span class="line">                    <span class="string">it.format(sb)</span></span><br><span class="line">                &#125;</span><br><span class="line">                <span class="string">&quot;li&quot;</span> <span class="string">-&gt;</span> &#123;</span><br><span class="line">                    <span class="string">sb.append(&quot;-</span> <span class="string">&quot;)</span></span><br><span class="line"><span class="string">                    it.format(sb)</span></span><br><span class="line"><span class="string">                &#125;</span></span><br><span class="line"><span class="string">                &quot;</span><span class="string">span&quot;</span>, <span class="string">&quot;pre&quot;</span> <span class="string">-&gt;</span> &#123;</span><br><span class="line">                    <span class="string">it.format(sb)</span></span><br><span class="line">                    <span class="string">sb.append(&quot;</span> <span class="string">&quot;)</span></span><br><span class="line"><span class="string">                &#125;</span></span><br><span class="line"><span class="string">                &quot;</span><span class="string">br&quot;</span> <span class="string">-&gt;</span> <span class="string">Unit</span></span><br><span class="line">                <span class="string">&quot;a&quot;</span> <span class="string">-&gt;</span> &#123;</span><br><span class="line">                    <span class="string">sb.append(&quot;&lt;$</span>&#123;<span class="string">it.attr(&quot;href&quot;)</span>&#125;<span class="string">&gt;&quot;)</span></span><br><span class="line">                    <span class="string">it.format(sb)</span></span><br><span class="line">                &#125;</span><br><span class="line">                <span class="string">else</span> <span class="string">-&gt;</span> <span class="string">println(it)</span></span><br><span class="line">            &#125;</span><br><span class="line">            <span class="string">is</span> <span class="string">Comment</span> <span class="string">-&gt;</span> <span class="string">Unit</span></span><br><span class="line">            <span class="string">else</span> <span class="string">-&gt;</span> <span class="string">println(it)</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="string">//</span> <span class="string">如果下一个标签是这些，则需要换行</span></span><br><span class="line">        <span class="string">if</span> <span class="string">(it.nextSibling()</span> <span class="string">is</span> <span class="string">Element</span> <span class="string">&amp;&amp;</span></span><br><span class="line">            <span class="string">(it.nextSibling()</span> <span class="string">as</span> <span class="string">Element).tagName()</span> <span class="string">in</span> <span class="string">listOf(&quot;div&quot;</span>, <span class="string">&quot;p&quot;</span>, <span class="string">&quot;ul&quot;</span>, <span class="string">&quot;li&quot;</span>, <span class="string">&quot;a&quot;</span>, <span class="string">&quot;br&quot;</span><span class="string">)</span></span><br><span class="line">        <span class="string">)</span></span><br><span class="line">            <span class="string">sb.append(&quot;\n&quot;)</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="string">fun</span> <span class="string">main()</span> &#123;</span><br><span class="line">    <span class="string">val</span> <span class="string">html</span> <span class="string">=</span> <span class="string">&quot;&quot;</span><span class="string">&quot;</span></span><br><span class="line"><span class="string">        这是你的html温拌</span></span><br><span class="line"><span class="string">    &quot;</span><span class="string">&quot;&quot;</span><span class="string">.trimIndent()</span></span><br><span class="line">    <span class="string">println(Jsoup.parse(html).body())</span></span><br><span class="line">    <span class="string">println(Jsoup.parse(html).format())</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>我们输入如下内容</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="string">&lt;div&gt;</span></span><br><span class="line"> <span class="number">18</span><span class="string">/47/284</span></span><br><span class="line"><span class="string">&lt;/div&gt;</span></span><br><span class="line"><span class="string">&lt;div&gt;</span></span><br><span class="line"> <span class="string">&lt;br&gt;</span></span><br><span class="line"><span class="string">&lt;/div&gt;</span></span><br><span class="line"><span class="string">&lt;div&gt;</span></span><br><span class="line"> <span class="string">&lt;br&gt;</span></span><br><span class="line"><span class="string">&lt;/div&gt;</span></span><br><span class="line"><span class="string">&lt;div&gt;</span></span><br><span class="line"> <span class="string">北京&amp;nbsp;</span></span><br><span class="line"><span class="string">&lt;/div&gt;</span></span><br><span class="line"><span class="string">&lt;div&gt;</span></span><br><span class="line"> <span class="string">李诞</span></span><br><span class="line"><span class="string">&lt;/div&gt;</span></span><br><span class="line"><span class="string">&lt;div&gt;</span></span><br><span class="line"> <span class="string">李丹</span></span><br><span class="line"> <span class="string">&lt;br&gt;</span></span><br><span class="line"><span class="string">&lt;/div&gt;</span></span><br><span class="line"><span class="string">&lt;div&gt;</span></span><br><span class="line"> <span class="string">&lt;p&gt;&lt;br&gt;&lt;/p&gt;</span></span><br><span class="line"> <span class="string">&lt;p&gt;成都&lt;/p&gt;</span></span><br><span class="line"> <span class="string">&lt;p&gt;尺子&lt;/p&gt;</span></span><br><span class="line"> <span class="string">&lt;p&gt;&lt;br&gt;&lt;/p&gt;</span></span><br><span class="line"> <span class="string">&lt;p&gt;上海&amp;nbsp;&lt;/p&gt;</span></span><br><span class="line"> <span class="string">&lt;p&gt;池子&lt;/p&gt;</span></span><br><span class="line"> <span class="string">&lt;p&gt;格桑酒店&lt;/p&gt;</span></span><br><span class="line"> <span class="string">&lt;p&gt;&lt;br&gt;&lt;/p&gt;</span></span><br><span class="line"> <span class="string">&lt;p&gt;杭州&amp;nbsp;&lt;/p&gt;</span></span><br><span class="line"> <span class="string">&lt;p&gt;&lt;br&gt;&lt;/p&gt;</span></span><br><span class="line"> <span class="string">&lt;div&gt;</span></span><br><span class="line">  <span class="string">&lt;p&gt;深圳&lt;/p&gt;</span></span><br><span class="line">  <span class="string">&lt;p&gt;建国&lt;/p&gt;</span></span><br><span class="line">  <span class="string">&lt;p&gt;&lt;br&gt;&lt;/p&gt;</span></span><br><span class="line">  <span class="string">&lt;p&gt;西安&lt;/p&gt;</span></span><br><span class="line">  <span class="string">&lt;p&gt;李雪琴&lt;/p&gt;</span></span><br><span class="line">  <span class="string">&lt;p&gt;&lt;br&gt;&lt;/p&gt;</span></span><br><span class="line">  <span class="string">&lt;p&gt;武汉&lt;/p&gt;</span></span><br><span class="line">  <span class="string">&lt;p&gt;王建国&lt;/p&gt;</span> </span><br><span class="line">  <span class="string">&lt;p&gt;&lt;br&gt;&lt;span&gt;&lt;/span&gt;&lt;/p&gt;</span></span><br><span class="line"> <span class="string">&lt;/div&gt;</span></span><br><span class="line"><span class="string">&lt;/div&gt;</span></span><br></pre></td></tr></table></figure>

<p>得到的输出，完全满足需求</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="number">18</span><span class="string">/47/284</span></span><br><span class="line"></span><br><span class="line"><span class="string">北京</span></span><br><span class="line"><span class="string">李诞</span></span><br><span class="line"><span class="string">李丹</span></span><br><span class="line"></span><br><span class="line"><span class="string">成都</span></span><br><span class="line"><span class="string">尺子</span></span><br><span class="line"></span><br><span class="line"><span class="string">上海</span></span><br><span class="line"><span class="string">池子</span></span><br><span class="line"><span class="string">格桑酒店</span></span><br><span class="line"></span><br><span class="line"><span class="string">杭州</span></span><br><span class="line"></span><br><span class="line"><span class="string">深圳</span></span><br><span class="line"><span class="string">建国</span></span><br></pre></td></tr></table></figure>

<h3 id="说明"><a href="#说明" class="headerlink" title="说明"></a>说明</h3><p>这里说明编写中的注意事项</p>
<ul>
<li><p>dom结构</p>
<p>  明白dom结构很重要，最开始我就搞错了文本本身也是一个节点</p>
  <figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 评论 --&gt;</span></span><br><span class="line">文本1</span><br><span class="line"><span class="tag">&lt;<span class="name">div</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span>&gt;</span></span><br><span class="line">    文本1</span><br><span class="line">  <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">p</span>&gt;</span></span><br><span class="line">  文本2</span><br><span class="line"><span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>  节点结构如下</p>
  <figure class="highlight html"><table><tr><td class="code"><pre><span class="line">Comment</span><br><span class="line">TextNode</span><br><span class="line">Element(div)</span><br><span class="line">  - Element(div)</span><br><span class="line">    - TextNode</span><br><span class="line">Element(p)</span><br><span class="line">  - TextNode</span><br></pre></td></tr></table></figure></li>
<li><p>换行符的处理</p>
<p>  不能直接在块标签后增加换行符，因为块标签会嵌套，从早造成多余的换行</p>
<p>  取而代之的，应该看下一个兄弟元素是否是块标签或换行标签</p>
  <figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span>&gt;</span></span><br><span class="line">    文本1</span><br><span class="line">  <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">p</span>&gt;</span></span><br><span class="line">  文本2</span><br><span class="line"><span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>  如上文本肯定想要得到如下结果</p>
  <figure class="highlight html"><table><tr><td class="code"><pre><span class="line">文本1</span><br><span class="line">文本2</span><br></pre></td></tr></table></figure>

<p>  如果按块标签换行，则会得到如下结果，显然是不正确的。</p>
  <figure class="highlight html"><table><tr><td class="code"><pre><span class="line">文本1</span><br><span class="line"></span><br><span class="line">文本2</span><br></pre></td></tr></table></figure>

<p>  “下一个相邻元素”，jsoup中有提供nextSibling()方法进行获取</p>
</li>
<li><p>超链接的处理</p>
<p>  超链接提供getAttr()获取href属性。</p>
</li>
<li><p>评论标签的处理</p>
<p>  评论标签有专门的节点类型——Comment，可以直接识别以忽略。</p>
</li>
</ul>
]]></content>
      <categories>
        <category>工具</category>
      </categories>
      <tags>
        <tag>日志</tag>
      </tags>
  </entry>
  <entry>
    <title>工具快手记 - JMH</title>
    <url>/2021/10/20/%E5%B7%A5%E5%85%B7%E5%BF%AB%E6%89%8B%E8%AE%B0%20-%20JMH-%E5%B7%A5%E5%85%B7%E5%BF%AB%E6%89%8B%E8%AE%B0-jmh/</url>
    <content><![CDATA[<p>站在巨人的肩膀上，JMH是一个工具，不打算深入研究它，只求能够正确使用，网上关于它的使用方法讲的还挺全面的，就直接看他们吧。</p>
<p>这篇文章包含基本使用方法、注意事项、IEAD插件、JMH可视化工具的介绍等：<a href="https://cloud.tencent.com/developer/article/1644001?from=article.detail.1378150">性能调优必备利器之 JMH</a></p>
<p>这篇文章包含较为深层次的解释：<a href="https://cloud.tencent.com/developer/article/1350814?from=article.detail.1378150">JAVA拾遗 — JMH与8个代码陷阱</a></p>
<p>当然最重要的还有官方例程：<a href="https://github.com/lexburner/JMH-samples">JMH给的38个例子</a></p>
<p>作为补充，我添加了所有注解的说明，还有自己使用中遇到的问题</p>
<span id="more"></span>

<h2 id="注解解释"><a href="#注解解释" class="headerlink" title="注解解释"></a>注解解释</h2><ul>
<li><p>Benchmark：被该注解标记的方法将会编译生成benchmark代码，并添加到Benchmarklist中。</p>
<p>被它标记的方法有几个限制，如果要打破限制，只能再写一个方法，然后再Benchmark方法中调用他们</p>
<ul>
<li>必须是public的</li>
<li>方法参数只能是 State、Control、Blackhole三种</li>
</ul>
</li>
<li><p>BenchmarkMode：模式多选一</p>
<ul>
<li>测试吞吐量</li>
<li>测试每次调用的平均时间</li>
<li>基于采样时间，在规定的采样时间内，测试完成的情况</li>
<li>每个方法只执行一次，然后看执行时间</li>
</ul>
</li>
<li><p>CompilerControl：编译器控制</p>
<ul>
<li>为方法添加端点</li>
<li>打印方法的信息</li>
<li>排除某个具体的方法</li>
<li>强制内联</li>
<li>强制不要内联</li>
<li>只编译当前注释的方法，其它的忽略</li>
</ul>
</li>
<li><p>Fork：fork的次数，即fork多少个进程来执行方法，放在类上时，对每个方法都有效。</p>
<p>即，一个方法需要被多少个进程执行，结果取平均</p>
</li>
<li><p>Group：分组，一个组的方法共享一批线程</p>
<ul>
<li>一个组内有一个或多个线程</li>
<li>被Group注解注释的多个方法共享一批线程</li>
<li>默认情况下，针对一个Benchmark方法，只会由单个线程执行，除非用GroupThreads进行指定</li>
</ul>
</li>
<li><p>GroupThreads：决定有多少个线程参与执行当前的方法</p>
</li>
<li><p>Measurement：设置做测试时的行为，和Warmup类似，只不过后者是用来热身，前者是用来正式测量的</p>
<p>能设置的参数如下，</p>
<ul>
<li>iterations：设置测试的迭代数量</li>
<li>time：一个迭代执行多长时间</li>
<li>timeUnit：时间单位</li>
<li>batchSize：每次操作执行方法多少次</li>
</ul>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Measurement(iterations = 1, time = 2, timeUnit = TimeUnit.SECONDS, batchSize = 3)</span></span><br></pre></td></tr></table></figure>

<p>这样的配置标识，执行1个迭代，每个迭代时长2秒，每次操作执行3次调用</p>
</li>
<li><p>OperationsPerInvocation：调用前执行的operation次数，我也不懂啥意思</p>
</li>
<li><p>OutputTimeUnit：测量结果输出的时间单位</p>
</li>
<li><p>Param：参数，可以设置参数，在被测试方法中使用，以查看不同参数时的效果</p>
</li>
<li><p>Setup：设置生命周期方法</p>
<ul>
<li>每次迭代前调用一次</li>
<li>每次调用前调用一次</li>
<li>测试完成调用一次</li>
</ul>
<p>可以理解为JUnit的@Before</p>
</li>
<li><p>TearDown：等同于Setuo(Level.Trial)</p>
</li>
<li><p>State：定义了实例的共享范围</p>
<ul>
<li>全局共享</li>
<li>组内共享</li>
<li>每个线程都会创建一个新的实例</li>
</ul>
</li>
<li><p>Threads：指定固定的线程数来跑测试</p>
</li>
<li><p>Timeout：整个测试的超时时间</p>
</li>
<li><p>Warmup：类似Measurement，唯一的区别是，这是用来预热的</p>
</li>
</ul>
<h2 id="工作机制"><a href="#工作机制" class="headerlink" title="工作机制"></a>工作机制</h2><p>JMH由两部分组成</p>
<ul>
<li>代码生成器，根据注解配置，生成我们待测试方法的测试代码</li>
<li>库：底层API支持，我们所使用的注解和生成的代码均依赖于它</li>
</ul>
<p>因此在引入依赖时，一要依赖库，而要以注解处理器的形式引入，对kotlin，注释注解处理器是kapt</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line">dependencies &#123;</span><br><span class="line">  implementation(<span class="string">&quot;org.openjdk.jmh:jmh-core:1.28&quot;</span>)</span><br><span class="line">  annotationProcessor(<span class="string">&quot;org.openjdk.jmh:jmh-generator-annprocess:1.28&quot;</span>)</span><br><span class="line">  kapt(<span class="string">&quot;org.openjdk.jmh:jmh-generator-annprocess:1.28&quot;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="遇到的问题"><a href="#遇到的问题" class="headerlink" title="遇到的问题"></a>遇到的问题</h2><ul>
<li><p>ERROR: Unable to find the resource: /META-INF/BenchmarkList</p>
<p>Benchmarklist是在代码生成阶段生成的，没有说明没有进行生成。这是因为我没有正确配置<code>jmh-generator-annprocess</code>，当成普通依赖了，实际上应该如上所述，是注解生成器。</p>
</li>
</ul>
]]></content>
      <categories>
        <category>工具</category>
      </categories>
      <tags>
        <tag>JMH</tag>
      </tags>
  </entry>
  <entry>
    <title>如何应对无意义感</title>
    <url>/2021/07/01/%E5%A6%82%E4%BD%95%E5%BA%94%E5%AF%B9%E6%97%A0%E6%84%8F%E4%B9%89%E6%84%9F-ru-he-ying-dui-wu-yi-yi-gan/</url>
    <content><![CDATA[<blockquote>
<p>读《西西弗神话》有感</p>
</blockquote>
<h2 id="思考人生意义的必要性"><a href="#思考人生意义的必要性" class="headerlink" title="思考人生意义的必要性"></a>思考人生意义的必要性</h2><p>意义，亦可作价值、作用。是我们一直在找寻的东西。</p>
<p>上学的意义，读书的意义，工作的意义，以及终极问题——活着的意义、人生的意义。</p>
<p>人是需要驱动力的，而驱动力的很大一部分，来自于对自身当前境况及前途的希望和预期。当不停地对自己进行灵魂拷问，往往会发现你的生活，你的存在并无多大意义，又或者是生活的意义太过遥远，遥远导致短期的心灵空虚。希望变得若隐若现，驱动力时有时无。轻则彷徨度日，重则丧失生活的信心，走向极端。</p>
<p>因此，学习如何和无意义感相处，是一项重要的课题。是每个人总会遇到的问题，迟早而已。</p>
<span id="more"></span>

<h2 id="意识到荒诞"><a href="#意识到荒诞" class="headerlink" title="意识到荒诞"></a>意识到荒诞</h2><p>常玩笑似地说，希望和理想，是这个世界上最毒的毒药，但其实我是讲真。一个充满理想主义的人，要么是极度幸福的，要么是悲惨的。</p>
<p>理想是预期，生活是现实，当现实情况与预期发展偏差越来越大时，会给人一种荒诞感，继而是挫败，接着是失望，然后是消极躺平。</p>
<p>大多数人都能觉察到的荒诞：刚出校园满怀理想，要在多少年内达成某某成就，但日子一天天过去，发现自己陷入了 起床-上班-吃饭-午休-上班-吃饭-下班-公交地铁-出租屋-睡觉 的死循环，原本的理想变得越来越遥远。你被封印了，封印在出租屋-公司的两点一线，封印在一座城市。开始思考：我这样无限死循环的生活到底有什么意义。开始恐惧，因为你看到了几十年时光隧道另一头的自己，这种对未来的已知性，让人不寒而栗。</p>
<p>当然，大多数人并不会感到恐惧，更多的仅仅是感到无聊。然后就会寻找消磨时间的事情——刷刷刷，让大脑陷入无意识状态，求得一种爽感，度日。私认为，这更让人担心。</p>
<h2 id="人间值不值得？"><a href="#人间值不值得？" class="headerlink" title="人间值不值得？"></a>人间值不值得？</h2><p>我们常在思考：活着的意义是什么，又常常为找不到答案而苦恼和沮丧。但其实大可不必这样，因为这本身就是一个非常复杂的命题。</p>
<p>并不能简单地下结论说人生是有意义，人间不值得之类的话。没有银弹，这句话同样适用于此。</p>
<p>加缪说：”回答人生中还不值得活，等于回答哲学的根本问题“。对一个没有多少阅读经验、没多少人生阅历、啥都缺的年轻人来说，这个问题没有答案并不可耻，甚至很正常。</p>
<p>但对这个问题的思考，不应该停止——尽管大多数时候得到的答案都是一致的。</p>
<h2 id="如何应对"><a href="#如何应对" class="headerlink" title="如何应对"></a>如何应对</h2><p>应对无意义，加缪提出了三种方法</p>
<ul>
<li><p>物理自杀</p>
<p>  顾名思义，就是自杀。自杀确实是一个问题，曾问过周边的人，相当一部分都曾有过自杀的想法。但自杀只是在逃避问题，并没有解决问题，不可取。</p>
</li>
<li><p>哲学自杀</p>
<p>  宗教信仰。不为自己而活，为上帝而活，或者万事皆有上帝参与或保佑。作为一个虔诚的信徒，不必再思考活着的意义，谨遵上帝指引即可。</p>
<p>  但这简直就是在作弊！直接越过自身生命的无意义。因无法回答而拒绝回答，也是一种逃避问题的方式，个人认为不可取。</p>
</li>
<li><p>直接面对</p>
<p>  正面硬刚，是最勇敢的出路，也是永恒的出路。</p>
<p>  我们先有生活的习惯，后有思想的习惯。当我们日复一日跑近死亡，肉体始终行进着，不可折返。先有肉体行进，后有思想。活着、活得精彩是作为人的责任。责任，不可推卸，不可逃避。一说逃避可耻但有用，于我，光可耻这一点就无法接受。</p>
<p>  思考生活的意义没有任何问题，甚至可以说是作为人的责任。但不该因为该问题的消极答案而打乱生活的节奏和轨迹。成年人应当用于承担起生活的责任。</p>
</li>
</ul>
<h2 id="西西弗斯"><a href="#西西弗斯" class="headerlink" title="西西弗斯"></a>西西弗斯</h2><p>你一定见过下面这张图，他叫西西弗斯（西西弗是法语的音译，在希腊语中，应该译作西西弗斯）</p>
<p><img src="https://5b0988e595225.cdn.sohucs.com/images/20180511/fd19c3efac2b490fa26279602bf36c4b.jpeg"></p>
<p>西西弗斯，是希腊神话中，被惩罚的人，他的惩罚方式是，将一块巨石从山底推到山顶，但是每次快到山顶时，巨石又会滑落到山底，如此循环往复，永无止境。（这块巨石的设定就是到山顶就会滑落到山底，没有平台，没有停靠点，别想了。。。）</p>
<p>西西弗神话是一个法国谚语，借喻永久无望又无用的人生状况。人的本质就是复读机，循环往复，day by day, year after year 。</p>
<p>在大多数的图片中，巨石下的西西弗都是一个浑身肌肉，充满能量的形象。没错，对西西弗斯的神话，不同人有不同的解读。可能认为他的命运极其悲惨，重复此无尽又无用的动作，西西弗斯定是悲伤的。但站在西西弗的角度上，如果就此悲伤沉沦，那就是巨石的胜利，是惩罚它的诸神的胜利。要同命运抗争到底。</p>
<p>西西弗斯告诉我们，还有更高的忠实，它可以否定神灵，举起巨石。他最终也发现，一切安好。从此，这个没有主人的宇宙在他看来，既不贫瘠、也非无望。那块石头的每一颗微粒，那座夜色笼罩的山上的每一片矿石，本身都是一个世界。迈向高处的挣扎足够填充一个人的心灵。人们应当想象西西弗斯是快乐的。</p>
<h3 id="吴刚伐桂"><a href="#吴刚伐桂" class="headerlink" title="吴刚伐桂"></a>吴刚伐桂</h3><p>中国古代神话也有类似的人物——吴刚。</p>
<p>传说吴刚的妻子与炎帝之孙伯陵私通，吴刚一怒之下杀了伯陵，因而惹怒太阳神炎帝，被发配到月亮砍伐不死之树。但月桂树随砍即合，吴刚每砍一斧，斧子砍下的枝叶就会长回树上，经过了这么久，吴刚仍然没能砍倒月桂树。</p>
<blockquote>
<p>神话总是喜欢这种死循环，西西弗斯的巨石和高山；吴刚的斧头与桂树；普罗米修斯的恶鹰与肝脏。。。。。。复读机无疑。</p>
</blockquote>
<h2 id="两句诗"><a href="#两句诗" class="headerlink" title="两句诗"></a>两句诗</h2><ul>
<li>吾魂兮无求乎永生</li>
<li>竭尽兮人事之所能</li>
</ul>
<h2 id="PS"><a href="#PS" class="headerlink" title="PS"></a>PS</h2><p>自杀、人生的意义，是哲学讨论的两个终极课题，哲学对我而言，目前还是艰深晦涩的。</p>
<p>本文零散表达，缺乏有力论据，仅作为个人小感想。</p>
<p>且上述观点也仅仅是存在主义的一种表达。</p>
<p>但同时，我们聊过技术、团队建设、人力资源，甚至聊过中医，本着国家不禁止，我们就能聊的原则，人生的意义这一话题自此也算是有开端了。耶！</p>
]]></content>
      <categories>
        <category>生活</category>
      </categories>
      <tags>
        <tag>人生</tag>
      </tags>
  </entry>
  <entry>
    <title>将项目发布到Maven中央库</title>
    <url>/2020/02/29/%E5%B0%86%E9%A1%B9%E7%9B%AE%E5%8F%91%E5%B8%83%E5%88%B0Maven%E4%B8%AD%E5%A4%AE%E5%BA%93-%E5%B0%86%E9%A1%B9%E7%9B%AE%E5%8F%91%E5%B8%83%E5%88%B0maven%E4%B8%AD%E5%A4%AE%E5%BA%93/</url>
    <content><![CDATA[<p>之前的文章介绍了如何编写一个Maven插件。那插件的使用上呢？在本地，我们可以安装到本地仓库，使用没问题；在SIT环境中，我们可以安装到公司内部的私有仓库中。但如果公司的Maven包尚未形成规模，不需要搭建私有仓库，且私有仓库需要有专人进行维护，如果只有少量包，可能过一段时间都忘了还有这么个东西。等到出问题了找半天，又是一个麻烦事。</p>
<p>上传到Maven中央库也许是一个非常好的选择，任何人在任何地方都可以使用该包，爽歪歪。</p>
<span id="more"></span>

<p>为了方便，使用OSSRH的发布方案。</p>
<h1 id="步骤介绍"><a href="#步骤介绍" class="headerlink" title="步骤介绍"></a>步骤介绍</h1><p>整个步骤大致有如下三步</p>
<ul>
<li>使用JIRA申请创建一个新的Repository，用于在OSSRH申请空间。</li>
<li>向项目的pom.xml中增加必要的内容</li>
<li>部署</li>
</ul>
<p>其中第一步需要人工审核，时间耗费比较久，按照个人经验来说半天可以搞定。</p>
<blockquote>
<p>说明：如下步骤是<a href="https://central.sonatype.org/pages/ossrh-guide.html">OSSRH Guide</a>的实践。</p>
</blockquote>
<h1 id="仓库及空间申请"><a href="#仓库及空间申请" class="headerlink" title="仓库及空间申请"></a>仓库及空间申请</h1><h2 id="创建JIRA账号"><a href="#创建JIRA账号" class="headerlink" title="创建JIRA账号"></a>创建JIRA账号</h2><p>登录<a href="https://issues.sonatype.org/login.jsp">Snatype JIRA</a></p>
<p><img src="https://gdz.oss-cn-shenzhen.aliyuncs.com/hexo/%E5%A6%82%E4%BD%95%E5%B0%86%E6%8F%92%E4%BB%B6%E5%8F%91%E5%B8%83%E5%88%B0Maven%E4%B8%AD%E5%A4%AE%E5%BA%93/image-20200229174034285.png" alt="image-20200229174034285"></p>
<p>收到邮件代表创建成功。</p>
<h2 id="新建工单"><a href="#新建工单" class="headerlink" title="新建工单"></a>新建工单</h2><p>还是登录<a href="https://issues.sonatype.org/secure/CreateIssue.jspa?issuetype=21&pid=10134">Snatype JIRA</a></p>
<p>依次填入概要、Group Id、Project URL（项目URL，可填github项目主页）、SCM url（项目版本控制链接）</p>
<p><img src="https://gdz.oss-cn-shenzhen.aliyuncs.com/hexo/%E5%A6%82%E4%BD%95%E5%B0%86%E6%8F%92%E4%BB%B6%E5%8F%91%E5%B8%83%E5%88%B0Maven%E4%B8%AD%E5%A4%AE%E5%BA%93/image-20200229174512183.png" alt="image-20200229174512183"></p>
<p>工单创建成功后需要等待邮件确认，反复几个来回后才能正常发布。下图是截止申请成功的所有交流。可以看到会有如下几个步骤</p>
<ul>
<li>创建工单</li>
<li>在自己的github主页下创建一个它要求的repository以完成验证</li>
<li>验证完成，允许用户发布组件到仓库</li>
<li>申请的Group Id激活，用户发布的组件能够被同步到中央仓库（但要花两个小时）</li>
</ul>
<p><img src="https://gdz.oss-cn-shenzhen.aliyuncs.com/hexo/%E5%A6%82%E4%BD%95%E5%B0%86%E6%8F%92%E4%BB%B6%E5%8F%91%E5%B8%83%E5%88%B0Maven%E4%B8%AD%E5%A4%AE%E5%BA%93/image-20200229175945672.png" alt="image-20200229175945672"></p>
<h1 id="GPG签名准备"><a href="#GPG签名准备" class="headerlink" title="GPG签名准备"></a>GPG签名准备</h1><p>组件发布之前，需要进行GPG签名，发布到服务器后，服务器会使用公钥对组件进行校验。关于GPG的介绍和详细解读，大家可以参考<a href="https://wiki.archlinux.org/index.php/GnuPG_(%E7%AE%80%E4%BD%93%E4%B8%AD%E6%96%87)#%E7%9B%AE%E5%BD%95%E4%BD%8D%E7%BD%AE">这篇文章</a>。这里涉及到几个点</p>
<ul>
<li><p>安装gnupg工具</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 安装</span></span><br><span class="line">$ sudo apt install gnupg</span><br><span class="line"><span class="comment"># 安装成功与否的验证</span></span><br><span class="line">$ gpg --version</span><br><span class="line">gpg (GnuPG) 2.2.4</span><br><span class="line">libgcrypt 1.8.1</span><br><span class="line">Copyright (C) 2017 Free Software Foundation, Inc.</span><br><span class="line">License GPLv3+: GNU GPL version 3 or later &lt;https://gnu.org/licenses/gpl.html&gt;</span><br><span class="line">This is free software: you are free to change and redistribute it.</span><br><span class="line">There is NO WARRANTY, to the extent permitted by law.</span><br><span class="line"></span><br><span class="line">Home: /home/floyd/.gnupg</span><br><span class="line">支持的算法：</span><br><span class="line">公钥： RSA, ELG, DSA, ECDH, ECDSA, EDDSA</span><br><span class="line">密文： IDEA, 3DES, CAST5, BLOWFISH, AES, AES192, AES256, TWOFISH,</span><br><span class="line">    CAMELLIA128, CAMELLIA192, CAMELLIA256</span><br><span class="line">散列： SHA1, RIPEMD160, SHA256, SHA384, SHA512, SHA224</span><br><span class="line">压缩： 不压缩, ZIP, ZLIB, BZIP2</span><br></pre></td></tr></table></figure></li>
<li><p>生成密钥对</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 执行如下命令，提示填入真实姓名和邮箱，并设置密码</span></span><br><span class="line">$ gpg --gen-key</span><br><span class="line"><span class="comment"># 查看刚才生成的密钥</span></span><br><span class="line">$ gpg --list-key</span><br><span class="line">/home/floyd/.gnupg/pubring.kbx</span><br><span class="line">------------------------------</span><br><span class="line">pub   rsa3072 2020-02-29 [SC] [有效至：2022-02-28]</span><br><span class="line">      EB3877C670A794E0238E66E1D4420641AADB285E</span><br><span class="line">uid           [ 绝对 ] Zou Guodong &lt;zou894475@gmail.com&gt;</span><br><span class="line">sub   rsa3072 2020-02-29 [E] [有效至：2022-02-28]</span><br></pre></td></tr></table></figure>

<p>上面生成的秘钥，其中EB3877C670A794E0238E66E1D4420641AADB285E是用户ID，记住，下一步会使用</p>
</li>
<li><p>发送公钥到 key server</p>
<p>这一步非常重要，否则OSSRH会因为无法验证发布的组件而导致发布失败。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">gpg --send-key EB3877C670A794E0238E66E1D4420641AADB285E</span><br></pre></td></tr></table></figure>

<p>如果发送成功，你可能会收到opengpg发送的邮件</p>
<p><img src="https://gdz.oss-cn-shenzhen.aliyuncs.com/hexo/%E5%A6%82%E4%BD%95%E5%B0%86%E6%8F%92%E4%BB%B6%E5%8F%91%E5%B8%83%E5%88%B0Maven%E4%B8%AD%E5%A4%AE%E5%BA%93/image-20200229181853303.png" alt="image-20200229181853303"></p>
<p>但这一步很可能会遇到问题，这在后面的问题集中有介绍</p>
</li>
<li><p>在pom.xml中配置插件（在POM修改中有对应说明）</p>
</li>
<li><p>在setting.xml中配置要使用的gpg工具 （在setting.xml修改中有对应说明）</p>
</li>
</ul>
<h1 id="pom-xml修改"><a href="#pom-xml修改" class="headerlink" title="pom.xml修改"></a>pom.xml修改</h1><h2 id="添加POM必备项"><a href="#添加POM必备项" class="headerlink" title="添加POM必备项"></a>添加POM必备项</h2><ul>
<li><p>项目基础信息</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.example.applications<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>example-application<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">version</span>&gt;</span>1.4.7<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">name</span>&gt;</span>$&#123;project.groupId&#125;:$&#123;project.artifactId&#125;<span class="tag">&lt;/<span class="name">name</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">description</span>&gt;</span>A application used as an example on how to set up pushing   its components to the Central Repository.<span class="tag">&lt;/<span class="name">description</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">url</span>&gt;</span>http://www.example.com/example-application<span class="tag">&lt;/<span class="name">url</span>&gt;</span></span><br></pre></td></tr></table></figure></li>
<li><p>证书</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">licenses</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">license</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">name</span>&gt;</span>The Apache License, Version 2.0<span class="tag">&lt;/<span class="name">name</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">url</span>&gt;</span>http://www.apache.org/licenses/LICENSE-2.0.txt<span class="tag">&lt;/<span class="name">url</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">license</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">licenses</span>&gt;</span></span><br></pre></td></tr></table></figure></li>
<li><p>开发者信息</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">developers</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">developer</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">name</span>&gt;</span>Manfred Moser<span class="tag">&lt;/<span class="name">name</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">email</span>&gt;</span>manfred@sonatype.com<span class="tag">&lt;/<span class="name">email</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">organization</span>&gt;</span>Sonatype<span class="tag">&lt;/<span class="name">organization</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">organizationUrl</span>&gt;</span>http://www.sonatype.com<span class="tag">&lt;/<span class="name">organizationUrl</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">developer</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">developers</span>&gt;</span></span><br></pre></td></tr></table></figure></li>
<li><p>SCM信息</p>
<p>即版本控制信息</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">scm</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">connection</span>&gt;</span>scm:git:git://github.com/simpligility/ossrh-demo.git<span class="tag">&lt;/<span class="name">connection</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">developerConnection</span>&gt;</span>scm:git:ssh://github.com:simpligility/ossrh-demo.git<span class="tag">&lt;/<span class="name">developerConnection</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">url</span>&gt;</span>http://github.com/simpligility/ossrh-demo/tree/master<span class="tag">&lt;/<span class="name">url</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">scm</span>&gt;</span></span><br></pre></td></tr></table></figure></li>
</ul>
<h2 id="添加发布相关插件"><a href="#添加发布相关插件" class="headerlink" title="添加发布相关插件"></a>添加发布相关插件</h2><ul>
<li><p>Javadoc 和 源码打包插件</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">plugin</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.apache.maven.plugins<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>maven-source-plugin<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.2.1<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">executions</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">execution</span>&gt;</span></span><br><span class="line">          <span class="tag">&lt;<span class="name">id</span>&gt;</span>attach-sources<span class="tag">&lt;/<span class="name">id</span>&gt;</span></span><br><span class="line">          <span class="tag">&lt;<span class="name">goals</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">goal</span>&gt;</span>jar-no-fork<span class="tag">&lt;/<span class="name">goal</span>&gt;</span></span><br><span class="line">          <span class="tag">&lt;/<span class="name">goals</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">execution</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;/<span class="name">executions</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">plugin</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">plugin</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.apache.maven.plugins<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>maven-javadoc-plugin<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.9.1<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">executions</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">execution</span>&gt;</span></span><br><span class="line">          <span class="tag">&lt;<span class="name">id</span>&gt;</span>attach-javadocs<span class="tag">&lt;/<span class="name">id</span>&gt;</span></span><br><span class="line">          <span class="tag">&lt;<span class="name">goals</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">goal</span>&gt;</span>jar<span class="tag">&lt;/<span class="name">goal</span>&gt;</span></span><br><span class="line">          <span class="tag">&lt;/<span class="name">goals</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">execution</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;/<span class="name">executions</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">plugin</span>&gt;</span></span><br></pre></td></tr></table></figure></li>
<li><p>GPG签名插件</p>
<p>在发布到中央库前，需要对所有生成文件签名。可以手动执行，但使用插件会方便很多</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">plugin</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.apache.maven.plugins<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>maven-gpg-plugin<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.5<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">executions</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">execution</span>&gt;</span></span><br><span class="line">          <span class="tag">&lt;<span class="name">id</span>&gt;</span>sign-artifacts<span class="tag">&lt;/<span class="name">id</span>&gt;</span></span><br><span class="line">          <span class="tag">&lt;<span class="name">phase</span>&gt;</span>verify<span class="tag">&lt;/<span class="name">phase</span>&gt;</span></span><br><span class="line">          <span class="tag">&lt;<span class="name">goals</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">goal</span>&gt;</span>sign<span class="tag">&lt;/<span class="name">goal</span>&gt;</span></span><br><span class="line">          <span class="tag">&lt;/<span class="name">goals</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">execution</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;/<span class="name">executions</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">plugin</span>&gt;</span></span><br></pre></td></tr></table></figure></li>
<li><p>Nexu暂存插件</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">plugin</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.sonatype.plugins<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>nexus-staging-maven-plugin<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.6.7<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">extensions</span>&gt;</span>true<span class="tag">&lt;/<span class="name">extensions</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">configuration</span>&gt;</span></span><br><span class="line">     <span class="tag">&lt;<span class="name">serverId</span>&gt;</span>ossrh<span class="tag">&lt;/<span class="name">serverId</span>&gt;</span></span><br><span class="line">     <span class="tag">&lt;<span class="name">nexusUrl</span>&gt;</span>https://oss.sonatype.org/<span class="tag">&lt;/<span class="name">nexusUrl</span>&gt;</span></span><br><span class="line">     <span class="tag">&lt;<span class="name">autoReleaseAfterClose</span>&gt;</span>true<span class="tag">&lt;/<span class="name">autoReleaseAfterClose</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">configuration</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">plugin</span>&gt;</span></span><br></pre></td></tr></table></figure></li>
</ul>
<h1 id="Setting-xml修改"><a href="#Setting-xml修改" class="headerlink" title="Setting.xml修改"></a>Setting.xml修改</h1><h2 id="JIRA账号"><a href="#JIRA账号" class="headerlink" title="JIRA账号"></a>JIRA账号</h2><p>设置准备阶段设置的账号密码，以便mvn能够连接到服务器</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">settings</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">servers</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">server</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">id</span>&gt;</span>ossrh<span class="tag">&lt;/<span class="name">id</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">username</span>&gt;</span>your-jira-id<span class="tag">&lt;/<span class="name">username</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">password</span>&gt;</span>your-jira-pwd<span class="tag">&lt;/<span class="name">password</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">server</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">servers</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">settings</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h2 id="GPG"><a href="#GPG" class="headerlink" title="GPG"></a>GPG</h2><p>添加如下配置，指定加密工具</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">settings</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">profiles</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">profile</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">id</span>&gt;</span>ossrh<span class="tag">&lt;/<span class="name">id</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">activation</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">activeByDefault</span>&gt;</span>true<span class="tag">&lt;/<span class="name">activeByDefault</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;/<span class="name">activation</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">properties</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">gpg.executable</span>&gt;</span>gpg<span class="tag">&lt;/<span class="name">gpg.executable</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">gpg.passphrase</span>&gt;</span>the_pass_phrase<span class="tag">&lt;/<span class="name">gpg.passphrase</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;/<span class="name">properties</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">profile</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">profiles</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">settings</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h1 id="我的配置"><a href="#我的配置" class="headerlink" title="我的配置"></a>我的配置</h1><p>作为参考，给出我的配置，看<a href="https://github.com/zou8944/json-loader-maven-plugin/blob/master/pom.xml">这里</a></p>
<h1 id="发布"><a href="#发布" class="headerlink" title="发布"></a>发布</h1><p>上述内容准备好后，可以执行如下命令进行发布。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">mvn clean deploy</span><br></pre></td></tr></table></figure>

<p>需要注意的是，如果我们发布的版本是release版本，即版本号不以-SNAPSHOT结尾，且刚才配置的Nexus暂存插件的<code>autoReleaseAfterClose</code>设置为true时，执行上述命令后，OSSRH会自动发送到中央库。</p>
<p>至此，发布完成。更多步骤请参考<a href="https://central.sonatype.org/pages/apache-maven.html">官方文档</a>。官方文档中提供了完整的发布开发版、release版的方式，可供参考。</p>
<h2 id="效果"><a href="#效果" class="headerlink" title="效果"></a>效果</h2><p>执行成功，等待大约两个小时，你就能在<a href="https://search.maven.org/">中央库</a>查询到自己的组件了。例如搜索我刚才发布的组件。</p>
<p><img src="https://gdz.oss-cn-shenzhen.aliyuncs.com/hexo/%E5%A6%82%E4%BD%95%E5%B0%86%E6%8F%92%E4%BB%B6%E5%8F%91%E5%B8%83%E5%88%B0Maven%E4%B8%AD%E5%A4%AE%E5%BA%93/image-20200229190119427.png" alt="image-20200229190119427"></p>
<p>点击进入，可以查看详情，<a href="https://search.maven.org/artifact/com.github.zou8944/json-loader-maven-plugin/1.0.0/maven-plugin">这里</a></p>
<p><img src="https://gdz.oss-cn-shenzhen.aliyuncs.com/hexo/%E5%A6%82%E4%BD%95%E5%B0%86%E6%8F%92%E4%BB%B6%E5%8F%91%E5%B8%83%E5%88%B0Maven%E4%B8%AD%E5%A4%AE%E5%BA%93/image-20200229190243615.png" alt="image-20200229190243615"></p>
<p>而作为一个插件，可以通过如下方式使用它</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">plugin</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.github.zou8944<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>json-loader-maven-plugin<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.0.0<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">executions</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">execution</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">phase</span>&gt;</span>initialize<span class="tag">&lt;/<span class="name">phase</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">goals</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">goal</span>&gt;</span>read-project-json-to-properties<span class="tag">&lt;/<span class="name">goal</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;/<span class="name">goals</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">configuration</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">files</span>&gt;</span></span><br><span class="line">          <span class="tag">&lt;<span class="name">file</span>&gt;</span>hello.json<span class="tag">&lt;/<span class="name">file</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">files</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;/<span class="name">configuration</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">execution</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">executions</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">plugin</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h1 id="踩过的坑"><a href="#踩过的坑" class="headerlink" title="踩过的坑"></a>踩过的坑</h1><ul>
<li><p>在snatype上无法找到对应的profile</p>
<p><img src="https://gdz.oss-cn-shenzhen.aliyuncs.com/hexo/%E5%A6%82%E4%BD%95%E5%B0%86%E6%8F%92%E4%BB%B6%E5%8F%91%E5%B8%83%E5%88%B0Maven%E4%B8%AD%E5%A4%AE%E5%BA%93/image-20200229131357158.png" alt="image-20200229131357158"></p>
<p>该问题是由于pom的GroupId和第一步申请JIRA账号时指定的GroupId不一致导致，修改本地使得一致即可</p>
</li>
<li><p>组件上传成功，但服务端签名校验失败</p>
<p><img src="https://gdz.oss-cn-shenzhen.aliyuncs.com/hexo/%E5%A6%82%E4%BD%95%E5%B0%86%E6%8F%92%E4%BB%B6%E5%8F%91%E5%B8%83%E5%88%B0Maven%E4%B8%AD%E5%A4%AE%E5%BA%93/image-20200229133647975.png" alt="image-20200229133647975"></p>
<p>该问题在于没有上传本地生成的密钥对。执行<code>gpg --send-key &lt;ID&gt;</code>生成即可。上传后，收到opengpg发来的邮件才能确认上传成功。</p>
</li>
<li><p>pgp上传秘钥失败</p>
<p>前后报过两个错，分别是上传失败和服务器拒绝连接。网上找了很多解决方案对我都无效。最终使用如下终极方法</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 删除整个.gnupg目录</span></span><br><span class="line">sudo rm -r ~./gnupg</span><br><span class="line"><span class="comment"># 重新生成秘钥，不能加sudo</span></span><br><span class="line">gpg --gen-key</span><br><span class="line"><span class="comment"># 执行如下命令，这是解决服务器拒绝连接的关键</span></span><br><span class="line">pkill dirmngr</span><br><span class="line"><span class="comment"># 再次发送</span></span><br><span class="line">gpg --send-key &lt;ID&gt;</span><br></pre></td></tr></table></figure></li>
</ul>
<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>本文主要以实践为主，介绍了如果将本地项目发布到Maven中央库。尽管没有什么原创的内容，但价值在于踩坑。</p>
<h1 id="参考文档"><a href="#参考文档" class="headerlink" title="参考文档"></a>参考文档</h1><ol>
<li><p><a href="https://maven.apache.org/repository/guide-central-repository-upload.html">Guide to uploading artifacts to the Central Repository</a></p>
</li>
<li><p><a href="https://www.youtube.com/watch?v=bxP9IuJbcDQ">How to Publish a Java Library to Maven Central</a></p>
</li>
<li><p><a href="https://central.sonatype.org/pages/ossrh-guide.html">OSSRH Guide</a></p>
</li>
<li><p><a href="https://jackgruber.github.io/2019-06-07-gnupg-cannot-connect-to-keyserver/">gnupg can not connet to key server</a></p>
</li>
<li><p><a href="https://unix.stackexchange.com/questions/318385/no-such-file-or-directory-when-generating-a-gpg-key">pgp can not find secret key</a></p>
</li>
</ol>
]]></content>
      <categories>
        <category>工具</category>
      </categories>
      <tags>
        <tag>Maven</tag>
      </tags>
  </entry>
  <entry>
    <title>序列化探索之一 - Java</title>
    <url>/2021/10/06/%E5%BA%8F%E5%88%97%E5%8C%96%E6%8E%A2%E7%B4%A2%E4%B9%8B%E4%B8%80%20-%20Java-xu-lie-hua-tan-suo-zhi-yi--java/</url>
    <content><![CDATA[<p>序列化和反序列化，渗透在日常开发的方方面面。</p>
<p>所谓的序列化，就是将数据转换为能够在网络上传输、在数据库中存储、在文件中持久化的格式，这类格式很多，可以是字节流（如Java自带的序列化机制）、可以是JSON（系统之间传输用的较多）、可以是Protocol Buffers（压缩率高，GRPC有用）。反序列化，即序列化的反过程。</p>
<p>序列化这件事，不同的语言、库，提供了不同的使用方法，哪怕是对同一种序列化格式的支持也有差别。因此，深入了解常用的序列化技术，很有必要。不要再去记使用方法了，我们来看原理吧。</p>
<span id="more"></span>

<h2 id="序列化探索思路"><a href="#序列化探索思路" class="headerlink" title="序列化探索思路"></a>序列化探索思路</h2><p>从序列化格式看，市面上有很多种，我选取最常用的两种：JSON和ProtoBuf。对JSON，协议本身比较简单，主要关注不同库的使用方式和原理、功能和性能差异，重点放在使用最为广泛的Jackson和最快bug也最多的FastJson上；对ProtoBuf，协议本身就具有一定的特点，因此重点放在协议的研究上。</p>
<p>从语言层面看，每种语言一般都会提供序列化的方式，作为对该语言了解的一部分，它提供的序列化也需要研究。这方面的重点我放在Java和Kotlin上。</p>
<p>综上，我们将会分为四个部分学习探索</p>
<ul>
<li>Java的序列化支持</li>
<li>Kotlin的序列化支持</li>
<li>JSON序列化专题探究</li>
<li>ProtoBuf序列化专题探究</li>
</ul>
<p>本文，就是Java。</p>
<h2 id="Java序列化的使用方法"><a href="#Java序列化的使用方法" class="headerlink" title="Java序列化的使用方法"></a>Java序列化的使用方法</h2><p>作为一个Java码农，一定会记得Java序列化的使用方式：目标类实现Serializable接口，给出serialVersionUID常量。然后该类的对象就能够被序列化了。这没错，但不完整，Java序列化能做的，远比这个多。</p>
<p>具体来讲，实现序列化，Java提供了两个接口：Serializable和Externalizable，实现前者的类的序列化逻辑由Java提供，自己能够稍微干涉；实现后者的类的序列化逻辑则完全由该类自己提供。</p>
<h3 id="Serializable"><a href="#Serializable" class="headerlink" title="Serializable"></a>Serializable</h3><p>Java中，一个能够被序列化的类，必须满足如下条件</p>
<ul>
<li>实现Serializable接口</li>
<li>指定需要序列化的字段值，两种方法<ul>
<li>排除法：默认所有字段都会被序列化，如果某个字段不需要，使用transient关键字排除</li>
<li>显式声明法：声明serialPersistentFields变量，声明需要被序列化的字段</li>
</ul>
</li>
</ul>
<p>也就是说，下面两种序列化的声明方式，是一样的</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 排除法</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Video</span> <span class="keyword">implements</span> <span class="title">Serializable</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> String id;</span><br><span class="line">    <span class="keyword">private</span> String title;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">transient</span> String description;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 显式声明法</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Video</span> <span class="keyword">implements</span> <span class="title">Serializable</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> String id;</span><br><span class="line">    <span class="keyword">private</span> String title;</span><br><span class="line">    <span class="keyword">private</span> String description;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> ObjectStreamField[] serialPersistentFields = &#123;</span><br><span class="line">        <span class="keyword">new</span> ObjectStreamField(<span class="string">&quot;id&quot;</span>, String.class),</span><br><span class="line">        <span class="keyword">new</span> ObjectStreamField(<span class="string">&quot;title&quot;</span>, String.class),</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>One Tip：Kotlin中使用Java序列化时，是没有transient关键字的，此时使用@Transient注解替代</p>
</blockquote>
<p>此外，它还能增加一些方法以更加个性化地控制序列化和反序列化</p>
<ul>
<li>writeObject()：控制写</li>
<li>readObject()：控制读</li>
<li>writeReplace()：指定一个替换对象写进流</li>
<li>readResolve()：指定一个从流读出来的对象的替换对象</li>
</ul>
<p>需要注意的是，上述两个write方法互斥，两个read方法互斥，如果同时存在，则只有后面的会生效。writeReplace和readResolve互斥，如果同时存在，只会writeReplace生效。下面演示readResolve()，同时通过注释的方式将其它三个方法签名给出，以供参考。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Data</span></span><br><span class="line"><span class="meta">@AllArgsConstructor</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Video</span> <span class="keyword">implements</span> <span class="title">Serializable</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> String id;</span><br><span class="line">    <span class="keyword">private</span> String title;</span><br><span class="line">    <span class="keyword">private</span> String description;</span><br><span class="line"></span><br><span class="line"><span class="comment">//    private void writeObject(ObjectOutputStream stream) throws IOException &#123;</span></span><br><span class="line"><span class="comment">//        System.out.println(&quot;执行writeObject&quot;);</span></span><br><span class="line"><span class="comment">//        stream.writeLong(0xfffffff);</span></span><br><span class="line"><span class="comment">//    &#125;</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">//    private void readObject(ObjectInputStream stream) throws IOException, ClassNotFoundException &#123;</span></span><br><span class="line"><span class="comment">//        System.out.println(&quot;执行readObject&quot;);</span></span><br><span class="line"><span class="comment">//    &#125;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//    private Object writeReplace() throws ObjectStreamException &#123;</span></span><br><span class="line"><span class="comment">//        System.out.println(&quot;执行writeReplace&quot;);</span></span><br><span class="line"><span class="comment">//        return &quot;替换成了一个String&quot;;</span></span><br><span class="line"><span class="comment">//    &#125;</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">readResolve</span><span class="params">()</span> <span class="keyword">throws</span> ObjectStreamException </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;执行readResolve&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> Video(<span class="string">&quot;ID&quot;</span>, <span class="string">&quot;标题&quot;</span>, <span class="string">&quot;描述&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Main</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException, ClassNotFoundException </span>&#123;</span><br><span class="line">        ByteArrayOutputStream bos = <span class="keyword">new</span> ByteArrayOutputStream();</span><br><span class="line">        ObjectOutputStream oos = <span class="keyword">new</span> ObjectOutputStream(bos);</span><br><span class="line"></span><br><span class="line">        Video oldVideo = <span class="keyword">new</span> Video(<span class="string">&quot;旧ID&quot;</span>, <span class="string">&quot;旧标题&quot;</span>, <span class="string">&quot;旧描述&quot;</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;序列化前：&quot;</span> + oldVideo);</span><br><span class="line"></span><br><span class="line">        oos.writeObject(oldVideo);</span><br><span class="line">        System.out.println(<span class="string">&quot;序列化后：&quot;</span> + bos);</span><br><span class="line"></span><br><span class="line">        ByteArrayInputStream bis = <span class="keyword">new</span> ByteArrayInputStream(bos.toByteArray());</span><br><span class="line">        ObjectInputStream ois = <span class="keyword">new</span> ObjectInputStream(bis);</span><br><span class="line">        Video newVideo = (Video) ois.readObject();</span><br><span class="line">        System.out.println(<span class="string">&quot;反序列化后：&quot;</span> + newVideo);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>运行main方法，能够输出如下。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">序列化前：Video(id=旧ID, title=旧标题, description=旧描述)</span><br><span class="line">序列化后：��sr<span class="comment">#com.gitee.floyd.serialization.Video����.@LdescriptiontLjava/lang/String;Lidq~Ltitleq~xpt	旧描述t旧IDt	旧标题</span></span><br><span class="line">执行readResolve</span><br><span class="line">反序列化后：Video(id=ID, title=标题, description=描述)</span><br></pre></td></tr></table></figure>

<p>从输出我们看出几点</p>
<ul>
<li>序列化后的字节流其实有一定规律，将其转换为字符串后还有一定可读性。其规律遵循Java序列化流语法规范，稍后讨论。</li>
<li>执行了readResolve，并且其返回值替换了我们原先的对象。</li>
</ul>
<blockquote>
<p>为了更直观地观察序列化后的内容，我们可以通过<a href="https://bined.exbin.org/intellij-plugin/">IDEA二进制插件</a>查看，对上面的内容，我们能够得到如下。脱离IDEA的单独软件，也可以使用<a href="https://hexed.it/">HexEdit</a>（亲测好用）</p>
<p><img src="https://gdz.oss-cn-shenzhen.aliyuncs.com/local/image-20211006160453425.png" alt="image-20211006160453425"></p>
</blockquote>
<h3 id="Externalizable"><a href="#Externalizable" class="headerlink" title="Externalizable"></a>Externalizable</h3><p>首先要理解这个接口，所谓“外部”序列化，重点在理解这个“外部”，它不是代码的外部，而是Java自身序列化逻辑的外部，相当于一方和二方的差别。具体来说，对Serializable的支持，Java提供完整的序列化规范，用户可以完全撒手不管；而Externalizable，Java除了将类ID写入，整个序列化和反序列化逻辑是完全由用户控制。</p>
<p>选用时，如果自定义序列化程度非常高，可以使用Externalizable，如果依旧需要Java的序列化逻辑，使用Serializable，具体方式可参考<a href="https://www.baeldung.com/java-externalizable">这篇文章</a>。</p>
<p>同样，对于支持外部序列化的类，必须满足如下条件</p>
<ul>
<li>实现Externalizable接口</li>
<li>实现接口的writeExternal和readExternal方法</li>
</ul>
<p>也可以实现下面两个方法，其作用和前文所述完全一样</p>
<ul>
<li>writeReplace：指定一个替换对象写进流</li>
<li>readResolve：指定一个从流读出来的对象的替换对象</li>
</ul>
<h3 id="serialVersionUID"><a href="#serialVersionUID" class="headerlink" title="serialVersionUID"></a>serialVersionUID</h3><p>提出问题：</p>
<ul>
<li><p>serialVersionID有什么用？如果没有行不行？</p>
</li>
<li><p>不同的类具有相同的serialVersionID，会有什么影响？</p>
</li>
<li><p>同一个类的serialVersionID不同时，会有什么影响？</p>
</li>
<li><p>同一个类演变多次，实际不兼容，却还有一个serialVersionID时，会有什么影响？</p>
</li>
</ul>
<p>serialVersionUID用于做序列化的版本控制：在反序列化时，反序列化器会检测输入流中的serialVersionUID和目标类的serialVersionUID是否一致，如果一致则继续反序列化流程，否则抛出异常。但这个行为，是果不是因。具体怎么说，参考下文的“版本控制”。这里我们先看它的生成方式。</p>
<p>上面的例子，我们并没有提供serialVersionUID常量。事实上，如果不提供，Java会按照默认算法提供一个。计算方式如下</p>
<ol>
<li>使用DataOutputStream构建一个字节流，其输入组成由<ul>
<li>类名</li>
<li>类修饰符标记</li>
<li>类的接口的名字排序后组成的字符串</li>
<li>类中所有的字段，除static和transient的：字段名、修饰符标记、描述符</li>
<li>类的初始化器：方法名(&lt;cinit&gt;)、修饰符标记(java.lang.reflect.Modifier.STATIC)、描述符(()v)</li>
<li>类的所有非私有构造方法：方法名(&lt;init&gt;)、修饰符标记、描述符</li>
<li>类的所有非私有方法：方法名、修饰符标记、描述符</li>
</ul>
</li>
<li>对上述字节流进行SHA-1摘要计算，生成5个32bit值</li>
<li>取摘要计算的最高两个32位构成serialVersionUID</li>
</ol>
<p>虽然这个生成逻辑看起来比较周到，但它有可能随着编译器的变化而变化，对同一个类，不同的编译器可能生成不同的serialVersionUID，因此，最好的方式还是我们自己指定serialVersionUID。</p>
<blockquote>
<p>One Tip：IDEA中创建类时，没有生成serialVersionUID的固定快捷键可用，可安装GenerateSerialVersionUID插件，在generate菜单中增加一个自动生成serialVersionUID的功能。看了一下<a href="https://github.com/jbellassai/idea-GenerateSerialVersionUID/blob/master/src/org/intellij/plugins/serial/siyeh_ig/fixes/SerialVersionUIDBuilder.java">它生成serialVersionUID的逻辑</a>，也是根据类的完整特征生成的，包括了类名、描述符、方法签名等。</p>
</blockquote>
<h3 id="注意事项"><a href="#注意事项" class="headerlink" title="注意事项"></a>注意事项</h3><ol>
<li>对一个类序列化，会递归序列化器所有属性，这就要求与其关联的所有属性的类都可被序列化</li>
<li>枚举的序列化与常规对象不同，只会序列化其name，读取时读取name，然后调用该枚举类型的valueof方法获取原枚举</li>
<li>不建议对内部类进行序列化，因为<ul>
<li>内部类引用外部类，会连同外部类一起序列化</li>
<li>不同的java编译器实现针对内部类的实现有所差别，这些差别可能导致序列化后不兼容，还可能导致serialVersionUID冲突</li>
<li>内部类是没有无参构造函数的（它有一个默认参数，就是外部类的引用），不能实现Externalizable</li>
</ul>
</li>
</ol>
<h2 id="Java序列化原理"><a href="#Java序列化原理" class="headerlink" title="Java序列化原理"></a>Java序列化原理</h2><p>了解Java序列化，回答两个问题即可：一是怎么用？二是序列化的结果是个啥？第一个问题上面已经回答了，这里回答第二个问题。</p>
<p>Java序列化结果是具有一定格式的二进制流，即协议。ObjectOutputStream和ObjectInputStream就是该协议的实现。</p>
<h3 id="序列化流协议"><a href="#序列化流协议" class="headerlink" title="序列化流协议"></a>序列化流协议</h3><p>一手资料在<a href="https://docs.oracle.com/javase/7/docs/platform/serialization/spec/protocol.html">这里</a>，仔细看的话，还挺复杂的，这里简单总结留个印象就好。</p>
<p>序列化后的流组成：</p>
<ul>
<li>魔数</li>
<li>序列化协议版本号</li>
<li>内容正文<ul>
<li>序列化的对象，包含很多种类，包括实例对象、类对象、数组、空引用、对已经在流中的序列化对应的应用<ul>
<li>起始标记，可查看ObjectStreamConstants</li>
<li>类名</li>
<li>serialVersionUID</li>
<li>类描述</li>
<li>所有字段</li>
<li>注解</li>
<li>父类描述等</li>
<li>结束标记</li>
</ul>
</li>
<li>块数据<ul>
<li>起始标记</li>
<li>真实数据</li>
<li>结束标记</li>
</ul>
</li>
</ul>
</li>
</ul>
<p>当然实际组成要复杂得多，具体查看原文档的6.4节</p>
<p><strong>为原始文档做的说明</strong></p>
<ul>
<li>New Class指的是用户自定义的类，New Object同理</li>
<li>block data，原生类型值会以块模式写入，这叫做block data，是ObjectStreamConstants.PROTOCOL_VERSION_2之后引入的。</li>
<li>所有需要用到的常量，都定义在ObjectStreamConstants中</li>
</ul>
<h3 id="序列化结果解读"><a href="#序列化结果解读" class="headerlink" title="序列化结果解读"></a>序列化结果解读</h3><p>我们将上面例子的serialVersionID转成0XFFFFFFFFFFFFFFFFL，以便区分，然后来大致解读序列化结果（为什么不详细解读？尝试过，花费太多时间，都绕晕了，最后放弃，一个字——没必要）。</p>
<p><img src="https://gdz.oss-cn-shenzhen.aliyuncs.com/local/image-20211006175542457.png" alt="image-20211006175542457"></p>
<p>来个表格</p>
<table>
<thead>
<tr>
<th>二进制值</th>
<th>含义</th>
</tr>
</thead>
<tbody><tr>
<td>AC ED</td>
<td>魔数，ObjectStreamConstants.STREAM_MAGIC</td>
</tr>
<tr>
<td>00 05</td>
<td>版本号，ObjectStreamConstants.STREAM_VERSION</td>
</tr>
<tr>
<td>73</td>
<td>新对象</td>
</tr>
<tr>
<td>72</td>
<td>新的类型描述符</td>
</tr>
<tr>
<td>00</td>
<td>classDescFlags</td>
</tr>
<tr>
<td>23 63 6F 6D 2E 67 69 74 65 65 2E 66 6C 6F 79 64 2E 73 65 72 69 61 6C 69 7A 61 74 69 6F 6E 2E 56 69 64 65 6F</td>
<td>类名：#com.gitee.floyd.serialization.Video</td>
</tr>
<tr>
<td>FF FF FF FF FF FF FF FF</td>
<td>serialVersionID</td>
</tr>
<tr>
<td>02 00 03 4C</td>
<td>newHandle</td>
</tr>
<tr>
<td>00</td>
<td>classDescFlags</td>
</tr>
<tr>
<td>0B</td>
<td>count</td>
</tr>
<tr>
<td>64 65 73 63 72 69 70 74 69 6F 6E</td>
<td>description</td>
</tr>
<tr>
<td>4C 6A 61 76 61 2F 6C 61 6E 67 2F 53 74 72 69 6E 67</td>
<td>Ljava/lang/String</td>
</tr>
<tr>
<td>。。。。。。</td>
<td>后面反正就是一堆，有兴趣自己对着规范一个一个找</td>
</tr>
</tbody></table>
<h2 id="其它"><a href="#其它" class="headerlink" title="其它"></a>其它</h2><h3 id="版本控制"><a href="#版本控制" class="headerlink" title="版本控制"></a>版本控制</h3><p>序列化流的版本控制是什么：控制的是新旧版本的类序列化的结果，让对方进行反序列化时，应该做出什么样的反应。</p>
<p>这里的主要问题是：类的演进，如何算兼容，如何算不兼容呢？</p>
<p><strong>兼容的标准</strong></p>
<ul>
<li>旧版本的类序列化后，能够被新版本的类正常反序列化，并且反序列化的结果在数据完整性上不会造成破坏</li>
<li>反之亦然</li>
</ul>
<p><strong>不兼容的演进</strong></p>
<ul>
<li>删除字段：旧版本的类在反序列化时会因为缺少对应字段的值，被设置为默认值，默认值可能对业务产生负面影响</li>
<li>非静态字段改为静态字段、给已有字段添加transient关键字：等效于删除</li>
<li>在层次结构中上下移动类：流中的数据会以错误的形式出现</li>
<li>修改字段类型：反序列化时将无法正确进行类型转换</li>
<li>更改writeObject和readObject，使其发生了重大变化：将导致反序列化失败</li>
<li>将Serializable改为Externalizable或者删除Serializable：将直接导致不可序列化</li>
<li>从非枚举改为枚举：枚举的序列化方式是不一样的</li>
</ul>
<p><strong>兼容的演进</strong></p>
<ul>
<li>增加字段：对原始类不会产生影响，在新的类中应该设定对新增字段默认值的处理</li>
<li>增加类：增加的类也能够被检测出来，新增的类将被初始化为零值</li>
<li>删除类：删除类是能够检测出来的</li>
<li>添加writeObject/readObject：新添加逻辑</li>
<li>其它。。。</li>
</ul>
<p>可以看到，这里说的兼容演进是非常主观的，是说可以在新类中做添加兼容逻辑，如果逻辑添加错误，还是可能发生不兼容的情况。上面的不兼容演进，是没有机会添加兼容逻辑了，所以才叫”不兼容“。</p>
<p><strong>serialVersionID扮演的作用</strong></p>
<p>如果我们认为新类和原始类是能够兼容的，那么他们就应该具有相同的serialVersionID；反之，如果认为不兼容，他们就应该具有不同的serialVersionID。</p>
<p>声明和维护serialVersionID是必要的</p>
<ul>
<li>serialVersionID是Java提供的强制不兼容机制，必须要有，如果我们不声明，它也会自动生成，而自动生成的可能不稳定，有隐患。</li>
<li>如果实际演进不兼容，却具有相同的serialVersionID，而当不兼容的修改项运行时并不会报错，却影响到业务逻辑（如删除字段）时，是非常危险的，及时修改serialVersionID，相当于将兼容性问题显式暴露出来。</li>
</ul>
<p><strong>现在来回答那四个问题</strong></p>
<ul>
<li><p>serialVersionID有什么用？如果没有行不行？</p>
<p>上面回答过了，忽略</p>
</li>
<li><p>不同的类具有相同的serialVersionID，会有什么影响？</p>
<p>不会有什么一项，serialVersionID只在类内部起作用，类之间互不干扰。</p>
</li>
<li><p>同一个类的serialVersionID不同时，会有什么影响？</p>
<p>反序列化时会报错</p>
</li>
<li><p>同一个类演变多次，实际不兼容，却还有一个serialVersionID时，会有什么影响？</p>
<p>可能反序列化时候会报错，也可能不报错，从而产生bug</p>
</li>
</ul>
<h3 id="安全考量"><a href="#安全考量" class="headerlink" title="安全考量"></a>安全考量</h3><p>有时会涉及到敏感信息的序列化和反序列化，可以通过以下方式进行数据保护：</p>
<ul>
<li><p>可以通过transient忽略敏感字段</p>
</li>
<li><p>如果一个类敏感，它就不应该能够被序列化。IDEA还提供了这方面的警告，当在一个安全上下文中使用序列化时报警</p>
<p><img src="https://gdz.oss-cn-shenzhen.aliyuncs.com/local/image-20211006184408647.png" alt="image-20211006184408647"></p>
</li>
<li><p>如果实在要序列化，则应该在writeObject()时控制它，在readObject()时候验证它</p>
</li>
</ul>
<blockquote>
<p>PS：敏感数据，压根儿就不应该被序列化</p>
</blockquote>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>Java自带的序列化，现在其实很少使用，学习它，一方面是作为Java程序员的职责，一方面也是消散心中的执念。</p>
<p>总体来看，我们要关注几个方面</p>
<ul>
<li>Java序列化的使用方式，不只是Serializable那么简单</li>
<li>serialVersionID的正确理解</li>
<li>序列化流协议，可以了解一下，我们要知道一个对象被序列化后长什么样子</li>
</ul>
<p>同时也可以看出它的缺点</p>
<ul>
<li>不能跨平台，自己定义的二进制协议，其它语言不能使用，除非人家实现这个协议，不过别人也没必要去实现这个协议吧</li>
<li>实现中大量使用反射，效率可能会比较低</li>
</ul>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ul>
<li><p><a href="https://docs.oracle.com/javase/7/docs/platform/serialization/spec/serialTOC.html">Java序列化规范</a></p>
</li>
<li><p>ObjectOutputStream、ObjectInputStream源码</p>
</li>
<li><p>一些网络文档</p>
</li>
</ul>
]]></content>
      <categories>
        <category>后端</category>
      </categories>
      <tags>
        <tag>序列化</tag>
      </tags>
  </entry>
  <entry>
    <title>序列化探索之五 - Gson</title>
    <url>/2021/10/16/%E5%BA%8F%E5%88%97%E5%8C%96%E6%8E%A2%E7%B4%A2%E4%B9%8B%E4%BA%94%20-%20Gson-xu-lie-hua-tan-suo-zhi-wu--gson/</url>
    <content><![CDATA[<p>Gson是一个相对简单的库，没有那么多功能，从设计上也并不想让别人去扩展它，它只想安安静静地做一个Json序列化库，简单而实用。</p>
<span id="more"></span>

<h2 id="简单说"><a href="#简单说" class="headerlink" title="简单说"></a>简单说</h2><p>Gson提供两种方式创建Gson实例</p>
<ul>
<li><code>new Gson()</code>：快速创建，默认配置，快速使用</li>
<li><code>new GsonBuilder().setxxxxx().create()</code>：完整方式创建，支持一些自定义化的配置</li>
</ul>
<p>Gson突出一个简单，API如此，功能更是如此，大致列一下其支持的功能</p>
<ul>
<li>基于field的序列化与反序列化：基本特性</li>
<li>支持自定义属性名：@SerializedName</li>
<li>支持反序列化时指定泛型信息：TypeToken</li>
<li>支持排除某个字段：transient关键字排除单个字段、按照可见性修饰符排除、@Expose主动选择</li>
<li>支持自定义序列化和反序列化逻辑：JsonSerializer、JsonDeserializer，或者它们的集合体：TypeAdapter</li>
</ul>
<h2 id="基础能力"><a href="#基础能力" class="headerlink" title="基础能力"></a>基础能力</h2><p>什么注释也不用加，啥也不用干，直接就能使用</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Resource1</span>&lt;<span class="type">T</span>&gt; </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> id: <span class="built_in">Int</span> = -<span class="number">1</span></span><br><span class="line">    <span class="keyword">var</span> type: ResourceType? = <span class="literal">null</span></span><br><span class="line"></span><br><span class="line">    <span class="meta">@Transient</span></span><br><span class="line">    <span class="keyword">var</span> secret: String = <span class="string">&quot;&quot;</span></span><br><span class="line"></span><br><span class="line">    <span class="meta">@SerializedName(<span class="meta-string">&quot;我是实际数据&quot;</span>)</span></span><br><span class="line">    <span class="keyword">var</span> <span class="keyword">data</span>: T? = <span class="literal">null</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">toString</span><span class="params">()</span></span>: String &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;Resource1(id=<span class="variable">$id</span>, type=<span class="variable">$type</span>, secret=&#x27;<span class="variable">$secret</span>&#x27;, data=<span class="variable">$data</span>)&quot;</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">val</span> gson = Gson()</span><br><span class="line">    <span class="keyword">val</span> resource = Resource1&lt;JsonObject&gt;().apply &#123;</span><br><span class="line">        <span class="keyword">this</span>.id = <span class="number">1</span></span><br><span class="line">        <span class="keyword">this</span>.type = <span class="literal">null</span></span><br><span class="line">        <span class="keyword">this</span>.secret = <span class="string">&quot;我是密码&quot;</span></span><br><span class="line">        <span class="keyword">this</span>.<span class="keyword">data</span> = JsonObject().apply &#123;</span><br><span class="line">            addProperty(<span class="string">&quot;key&quot;</span>, <span class="string">&quot;value&quot;</span>)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">val</span> jsonString = gson.toJson(resource)</span><br><span class="line">    println(jsonString)</span><br><span class="line">    println(gson.fromJson&lt;Resource1&lt;JsonObject&gt;&gt;(jsonString, <span class="keyword">object</span> : TypeToken&lt;Resource1&lt;JsonObject&gt;&gt;() &#123;&#125;.type))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>要点</p>
<ul>
<li>序列化用<code>gson.toJson(xxx)</code>，反序列化用<code>gson.fromJson(jsonString, 类型信息)</code></li>
<li>忽略字段可以用transient关键字</li>
<li>自定义字段名用@SerializedName注解，实际上这是Gson能够个性化配置的唯四之一</li>
<li>对于泛型擦除的情况，在反序列化时通过TypeToken指定：<code>object : TypeToken&lt;Resource1&lt;JsonObject&gt;&gt;() &#123;&#125;.type</code>。这一点和Jackson和Fastjson的TypeReference类似</li>
</ul>
<h2 id="排除字段"><a href="#排除字段" class="headerlink" title="排除字段"></a>排除字段</h2><figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Resource4</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Expose</span></span><br><span class="line">    <span class="keyword">var</span> id: <span class="built_in">Int</span> = -<span class="number">1</span></span><br><span class="line">    <span class="keyword">var</span> type: ResourceType? = <span class="literal">null</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">val</span> gson = GsonBuilder().excludeFieldsWithoutExposeAnnotation().create()</span><br><span class="line">    println(gson.toJson(Resource4().apply &#123; id = <span class="number">10</span>; type = ResourceType.CHARACTER &#125;))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li><code>GsonBuilder().excludeFieldsWithoutExposeAnnotation()</code>设置只暴露@Expose的数据</li>
<li>@Expose标记字段</li>
</ul>
<h2 id="自定义实例创建器"><a href="#自定义实例创建器" class="headerlink" title="自定义实例创建器"></a>自定义实例创建器</h2><p>Gson反序列化时创建对象的逻辑</p>
<ul>
<li>首先寻找是否存在目标类的无参构造函数，有则用它创建实例</li>
<li>其次寻找是否存在用户自定义的实例创建器</li>
<li>然后如果目标类是原生类型，则直接查找对应类型的构造器并创建实例</li>
<li>都没有，则用sun.misc.Unsafe创建实例</li>
</ul>
<p>一般不推荐使用Unsafe创建实例，要么提供无参构造方法，要么提供实例创建器，这里有一个后者的例子</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Resource3</span></span>(<span class="keyword">var</span> id: <span class="built_in">Int</span>, <span class="keyword">var</span> type: ResourceType?) &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">init</span> &#123;</span><br><span class="line">        println(<span class="string">&quot;有参构造函数被执行了&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">toString</span><span class="params">()</span></span>: String &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;Resource3(id=<span class="variable">$id</span>, type=<span class="variable">$type</span>)&quot;</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Resource3Creator</span> : <span class="type">InstanceCreator</span>&lt;<span class="type">Resource3</span>&gt; </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">createInstance</span><span class="params">(type: <span class="type">Type</span>)</span></span>: Resource3 &#123;</span><br><span class="line">        <span class="keyword">return</span> Resource3(-<span class="number">1</span>, <span class="literal">null</span>)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">val</span> gson = GsonBuilder().registerTypeAdapter(Resource3::<span class="keyword">class</span>.java, Resource3Creator()).create()</span><br><span class="line">    <span class="keyword">val</span> resource = Resource3(<span class="number">1</span>, <span class="literal">null</span>)</span><br><span class="line">    println(<span class="string">&quot;序列化&quot;</span>)</span><br><span class="line">    <span class="keyword">val</span> jsonString = gson.toJson(resource)</span><br><span class="line">    println(jsonString)</span><br><span class="line">    println(<span class="string">&quot;反序列化&quot;</span>)</span><br><span class="line">    println(gson.fromJson(jsonString, Resource3::<span class="keyword">class</span>.java))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>输出</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">有参构造函数被执行了</span><br><span class="line">序列化</span><br><span class="line">&#123;<span class="string">&quot;id&quot;</span>:1&#125;</span><br><span class="line">反序列化</span><br><span class="line">有参构造函数被执行了</span><br><span class="line">Resource3(id=1, <span class="built_in">type</span>=null)</span><br></pre></td></tr></table></figure>

<blockquote>
<p>PS：Gson默认忽略掉内部类，因为它没有无参构造函数</p>
</blockquote>
<h2 id="自定义序列化器"><a href="#自定义序列化器" class="headerlink" title="自定义序列化器"></a>自定义序列化器</h2><p>老规矩，自定义LocalDateTime的序列化和反序列化逻辑，为此Gson提供了三种类型可供定义，要么定义序列化器、要么反序列化器，要么同时有。</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Resource5</span> </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> id: <span class="built_in">Int</span> = -<span class="number">1</span></span><br><span class="line">    <span class="keyword">var</span> type: ResourceType = ResourceType.CHARACTER</span><br><span class="line"></span><br><span class="line">    <span class="meta">@JsonAdapter(Resource5TypeAdapter::class)</span></span><br><span class="line">    <span class="keyword">var</span> updatedTime: LocalDateTime? = <span class="literal">null</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">toString</span><span class="params">()</span></span>: String &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;Resource5(id=<span class="variable">$id</span>, type=<span class="variable">$type</span>, updatedTime=<span class="variable">$updatedTime</span>)&quot;</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Resource5TypeAdapter</span> : <span class="type">TypeAdapter</span>&lt;<span class="type">LocalDateTime</span>&gt;</span>() &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">write</span><span class="params">(<span class="keyword">out</span>: <span class="type">JsonWriter</span>, value: <span class="type">LocalDateTime</span>?)</span></span> &#123;</span><br><span class="line">        println(<span class="string">&quot;执行了写方法&quot;</span>)</span><br><span class="line">        <span class="keyword">if</span> (value == <span class="literal">null</span>) <span class="keyword">out</span>.nullValue()</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">out</span>.value(value.toInstant(ZoneOffset.UTC).toEpochMilli())</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">read</span><span class="params">(`<span class="keyword">in</span>`: <span class="type">JsonReader</span>)</span></span>: LocalDateTime &#123;</span><br><span class="line">        println(<span class="string">&quot;执行了读方法&quot;</span>)</span><br><span class="line">        <span class="keyword">return</span> LocalDateTime.ofInstant(Instant.ofEpochMilli(`<span class="keyword">in</span>`.nextLong()), ZoneOffset.UTC)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">val</span> resource = Resource5().apply &#123;</span><br><span class="line">        <span class="keyword">this</span>.id = <span class="number">1</span></span><br><span class="line">        <span class="keyword">this</span>.updatedTime = LocalDateTime.now()</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">val</span> gson = Gson()</span><br><span class="line">    <span class="keyword">val</span> jsonString = gson.toJson(resource)</span><br><span class="line">    println(jsonString)</span><br><span class="line">    println(gson.fromJson(jsonString, Resource5::<span class="keyword">class</span>.java))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>可通过@JsonAdapter局部指定</li>
<li>也可通过<code>GsonBuilder().registerTypeAdapter</code>全局注册</li>
</ul>
<h2 id="多态"><a href="#多态" class="headerlink" title="多态"></a>多态</h2><p>Gson原生不支持多态，但可通过一些其它方式实现，以下是官方推荐的方式（尽管很傻）</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">val</span> gson = Gson()</span><br><span class="line">    <span class="keyword">val</span> list = listOf(</span><br><span class="line">        <span class="number">1</span>,</span><br><span class="line">        <span class="string">&quot;&quot;</span>,</span><br><span class="line">        mapOf(</span><br><span class="line">            <span class="string">&quot;key&quot;</span> to <span class="string">&quot;value&quot;</span></span><br><span class="line">        )</span><br><span class="line">    )</span><br><span class="line">    <span class="keyword">val</span> jsonString = gson.toJson(list)</span><br><span class="line">    println(jsonString)</span><br><span class="line">    gson.fromJson(jsonString, JsonArray::<span class="keyword">class</span>.java).mapIndexed &#123; index, jsonElement -&gt;</span><br><span class="line">        <span class="keyword">when</span> (index) &#123;</span><br><span class="line">            <span class="number">0</span> -&gt; gson.fromJson(jsonElement, <span class="built_in">Int</span>::<span class="keyword">class</span>.java)</span><br><span class="line">            <span class="number">1</span> -&gt; gson.fromJson(jsonElement, String::<span class="keyword">class</span>.java)</span><br><span class="line">            <span class="number">2</span> -&gt; gson.fromJson(jsonElement, <span class="keyword">object</span> : TypeToken&lt;Map&lt;String, String&gt;&gt;() &#123;&#125;.type)</span><br><span class="line">            <span class="keyword">else</span> -&gt; <span class="keyword">throw</span> Exception()</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;.toList().also &#123; println(it) &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>如果一个集合中有多重类型，反序列化时，先得到JsonArray，再针对具体元素应用具体类型</li>
<li>这就不咋科学，还有一种方式是RuntimeTypeAdapterFactory，这非官方推荐的方式，所以要用多态还是别用Gson了</li>
</ul>
<h2 id="树模型"><a href="#树模型" class="headerlink" title="树模型"></a>树模型</h2><p>Gson的树模型还是简单的，只有JsonArray、JsonObject以及JsonElement三个类，但是API不大友好，限制的比较死</p>
<ul>
<li>添加一般属性就要调用addProperty方法，且只支持String、Boolean、Number、Character四种类型</li>
<li>添加对象或数组属性就得用add方法</li>
<li>不支持fluent API</li>
</ul>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">val</span> resource = JsonObject().apply &#123;</span><br><span class="line">        addProperty(<span class="string">&quot;id&quot;</span>, <span class="number">1</span>)</span><br><span class="line">        addProperty(<span class="string">&quot;type&quot;</span>, ResourceType.CHARACTER.name)</span><br><span class="line">        addProperty(<span class="string">&quot;usn&quot;</span>, <span class="literal">null</span> <span class="keyword">as</span> String?)</span><br><span class="line">        add(<span class="string">&quot;data&quot;</span>, JsonArray().apply &#123;</span><br><span class="line">            add(<span class="literal">false</span>)</span><br><span class="line">            add(<span class="number">123</span>)</span><br><span class="line">        &#125;)</span><br><span class="line">    &#125;</span><br><span class="line">    println(GsonBuilder().setPrettyPrinting().create().toJson(resource))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="支持设置啥能力"><a href="#支持设置啥能力" class="headerlink" title="支持设置啥能力"></a>支持设置啥能力</h2><p>穷举一下GsonBuilder，有啥能力，可以看到，其实没啥能力。</p>
<p><img src="https://gdz.oss-cn-shenzhen.aliyuncs.com/local/image-20211016115638338.png" alt="image-20211016115638338"></p>
<ul>
<li>设置序列化和反序列化的排除策略</li>
<li>设置各种类型适配器，用于控制类型序列化和反序列化时的行为</li>
<li>关闭内部类的序列化</li>
<li>Html格式转义</li>
<li>序列化名称控制</li>
<li>输出格式化</li>
<li>版本控制（@Since和@Until注解可设置POJO的版本，有点类似@JsonView的功能，但感觉非常鸡肋）</li>
<li>设置日期格式</li>
<li>设置字段名命名策略</li>
</ul>
<h2 id="基本原理"><a href="#基本原理" class="headerlink" title="基本原理"></a>基本原理</h2><p>加上Gson，前前后后看了五个序列化库，除了Java，原理结构上都大同小异，只是在序列化和反序列化的具体算法上有所差别，扣得比较细节，尤其是Fastjson用了很多奇技淫巧，硬是把速度提了上去。</p>
<ul>
<li>对于序列化，首先得到序列化器，再用序列化器将实际对象写入流</li>
<li>对反序列化，首先得到反序列化器，再得到目标类的实例，再用反序列化器从流中读取内容塞入目标实例</li>
</ul>
<p>至于Gson，它比较与众不同的点在于</p>
<ul>
<li>序列化时，直接使用了StringWriter做写操作，而不是自己维护输出流和缓冲区</li>
<li>Json格式的实际写入在com.google.gson.stream.JsonWriter，内部套StringWriter<ul>
<li>写入状态控制与Jackson采用树状结构不同，它采用了栈（一个一维数组，数组的大小即当前层次结构的深度，数组的值即当前所处结构的类型）的方式维护，参见com.google.gson.stream.JsonWriter#stack</li>
</ul>
</li>
<li>对未自定义序列化器的类型来说，使用com.google.gson.internal.bind.ReflectiveTypeAdapterFactory.Adapter达成<ul>
<li>对于序列化，它直接使用了反射获取符合要求的字段，然后写入writer</li>
<li>对于反序列化，它使用前文”自定义实例创建器”所说的方式创建对象，然后通过反射写入目标对象</li>
</ul>
</li>
</ul>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>通篇看起来，Gson定位清晰，目标明确，文档和代码规范，用起来也比较轻松。只是功能简单，原理也简单，直接使用StringWriter和反射，就是一个功能性的Json库，看不大出有什么性能优化，因此可以推测，Gson的性能不会太出色。</p>
]]></content>
      <categories>
        <category>后端</category>
      </categories>
      <tags>
        <tag>序列化</tag>
      </tags>
  </entry>
  <entry>
    <title>单元测试 - 最佳实践</title>
    <url>/2022/03/06/%E5%8D%95%E5%85%83%E6%B5%8B%E8%AF%95-%E6%9C%80%E4%BD%B3%E5%AE%9E%E8%B7%B5/</url>
    <content><![CDATA[<blockquote>
<p>是不是最佳不知道，反正它是个实践！</p>
</blockquote>
<span id="more"></span>

<h1 id="预备"><a href="#预备" class="headerlink" title="预备"></a>预备</h1><h2 id="测试目标"><a href="#测试目标" class="headerlink" title="测试目标"></a>测试目标</h2><p>每记后端是没有单元测试的，此次对其进行添加单元测试的重构。</p>
<h2 id="技术选型及项目配置"><a href="#技术选型及项目配置" class="headerlink" title="技术选型及项目配置"></a>技术选型及项目配置</h2><p>主要技术如下</p>
<ul>
<li>测试平台：JUnit5</li>
<li>mock库：MockK</li>
<li>断言库：AssertK</li>
<li>测试覆盖率：Jacoco</li>
<li>数据层测试：embedded-database-spring-test、flyway-spring-test、mybatis-plus-spring-boot-test</li>
</ul>
<p>gradle配置如下</p>
<figure class="highlight groovy"><table><tr><td class="code"><pre><span class="line">plugins &#123;</span><br><span class="line">  id <span class="string">&#x27;jacoco&#x27;</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">dependencies &#123;</span><br><span class="line">  <span class="comment">// 测试：mockk替代mockito,assertk替代assertj;embedded-database</span></span><br><span class="line">  testImplementation(<span class="string">&#x27;org.springframework.boot:spring-boot-starter-test&#x27;</span>) &#123;</span><br><span class="line">    exclude <span class="attr">module:</span> <span class="string">&#x27;mockito-core&#x27;</span></span><br><span class="line">    exclude <span class="attr">module:</span> <span class="string">&#x27;assertj-core&#x27;</span></span><br><span class="line">  &#125;</span><br><span class="line">  testImplementation(<span class="string">&quot;com.ninja-squad:springmockk:3.1.0&quot;</span>)</span><br><span class="line">  testImplementation(<span class="string">&#x27;com.willowtreeapps.assertk:assertk-jvm:0.25&#x27;</span>)</span><br><span class="line">  testImplementation(<span class="string">&#x27;io.zonky.test:embedded-database-spring-test:2.1.1&#x27;</span>)</span><br><span class="line">  testImplementation(<span class="string">&#x27;com.baomidou:mybatis-plus-boot-starter-test:3.5.1&#x27;</span>)</span><br><span class="line">  testImplementation(<span class="string">&#x27;org.flywaydb.flyway-test-extensions:flyway-spring-test:7.0.0&#x27;</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// https://docs.gradle.org/current/dsl/org.gradle.api.tasks.testing.Test.html</span></span><br><span class="line"><span class="comment">// 测试报告位置: build/reports/test</span></span><br><span class="line">test &#123;</span><br><span class="line">  <span class="comment">// 使用JUnit5进行测试</span></span><br><span class="line">  useJUnitPlatform()</span><br><span class="line">  <span class="comment">// 测试线程数：2</span></span><br><span class="line">  maxParallelForks(<span class="number">2</span>)</span><br><span class="line">  <span class="comment">// 日志配置</span></span><br><span class="line">  testLogging &#123;</span><br><span class="line">    <span class="comment">// level=LIFECYCLE的配置项</span></span><br><span class="line">    events <span class="string">&quot;passed&quot;</span>, <span class="string">&quot;skipped&quot;</span>, <span class="string">&quot;failed&quot;</span></span><br><span class="line">    exceptionFormat <span class="string">&quot;full&quot;</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 生成覆盖率测试报告: ./gradlew test jacocoTestReport</span></span><br><span class="line"><span class="comment">// 测试报告位置: build/jacocoReport</span></span><br><span class="line">jacocoTestReport &#123;</span><br><span class="line">  reports &#123;</span><br><span class="line">    xml.enabled = <span class="literal">false</span></span><br><span class="line">    csv.enabled = <span class="literal">false</span></span><br><span class="line">    html.enabled = <span class="literal">true</span></span><br><span class="line">    html.destination = file(<span class="string">&quot;$&#123;buildDir&#125;/jacocoReport&quot;</span>)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>日志：src/test/resources下添加logback-test.xml文件，这里我们仅在控制台打印WARN级别的应用日志</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">configuration</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">appender</span> <span class="attr">name</span>=<span class="string">&quot;CONSOLE&quot;</span> <span class="attr">class</span>=<span class="string">&quot;ch.qos.logback.core.ConsoleAppender&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">encoder</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">pattern</span>&gt;</span>%d&#123;HH:mm:ss.SSS&#125; [%thread] %-5level %logger - %msg %X&#123;THREAD_ID&#125; %n<span class="tag">&lt;/<span class="name">pattern</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">encoder</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">appender</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">root</span> <span class="attr">level</span>=<span class="string">&quot;WARN&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">appender-ref</span> <span class="attr">ref</span>=<span class="string">&quot;CONSOLE&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">root</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">configuration</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>IDEA：安装JUnit插件（如果是IDEA专业版，默认已安装）。</p>
<h2 id="测试思路-MVC如何测试"><a href="#测试思路-MVC如何测试" class="headerlink" title="测试思路 - MVC如何测试"></a>测试思路 - MVC如何测试</h2><p>被测项目是采用Spring Web MVC构建的Restful服务，那么MVC应该如何测试呢？</p>
<p>如果我们将每一层的职责区分得比较好，则每层负责的内容和测试思路如下</p>
<ul>
<li>Controller：路由转发、参数验证<ul>
<li>重点在参数验证的测试，对Service的调用应该被Mock掉</li>
<li>使用MockMvc</li>
<li>使用@WebMvcTest加载单个Controller类，提升启动速度</li>
</ul>
</li>
<li>Service：业务逻辑的处理<ul>
<li>常规测试，单元测试的主要工作集中在这里</li>
<li>不使用Spring Test的任何注解，可以提升启动速度</li>
</ul>
</li>
<li>Repository：数据库访问<ul>
<li>使用嵌入式数据库提供真实等价的数据库环境</li>
<li>使用@MybatisPlusTest只加载数据库相关的Bean，提升启动速度</li>
</ul>
</li>
</ul>
<blockquote>
<p>你写的是单元测试还是集成测试？</p>
<p>使用Spring Boot Test，我们写出来的往往是集成测试。即一个测试中其实包含了Controller、Service、Repository。但真的单元测试，一个测试应该只包含一个方法的一种case。</p>
<p>集成测试的好处是写起来方便快捷，缺点是覆盖不全面，且一旦一个调用链路的任何环节修改，相关的case都必须修改。</p>
</blockquote>
<p>接下来看具体的实施情况。</p>
<h1 id="Controller测试"><a href="#Controller测试" class="headerlink" title="Controller测试"></a>Controller测试</h1><h2 id="测什么"><a href="#测什么" class="headerlink" title="测什么"></a>测什么</h2><ul>
<li>测试接口路由是否正确</li>
<li>测试参数验证是否符合预期</li>
</ul>
<h2 id="一个需求"><a href="#一个需求" class="headerlink" title="一个需求"></a>一个需求</h2><p>一个典型待测试的接口如下</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">UserController</span></span>(</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">val</span> userService: UserService,</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">val</span> subscriptionService: SubscriptionService</span><br><span class="line">) &#123;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Authenticate</span></span><br><span class="line">  <span class="meta">@PatchMapping(<span class="meta-string">&quot;/users/&#123;id&#125;&quot;</span>)</span></span><br><span class="line">  <span class="function"><span class="keyword">fun</span> <span class="title">updateUserInfo</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">    <span class="meta">@PathVariable</span> id: <span class="type">Int</span>,</span></span></span><br><span class="line"><span class="params"><span class="function">    <span class="meta">@RequestBody</span> request: <span class="type">UserUpdateReq</span>,</span></span></span><br><span class="line"><span class="params"><span class="function">  )</span></span>: R&lt;User&gt; &#123;</span><br><span class="line">    <span class="keyword">val</span> initiator = RequestContext.getUserId()!!</span><br><span class="line">    <span class="keyword">return</span> R.succeed(userService.updateUserInfo(id, initiator, request))</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li><p>@Authenticate表示该接口需要鉴权，具体鉴权逻辑如下</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">AuthInterceptor</span></span>(</span><br><span class="line">  <span class="meta">@Autowired</span> <span class="keyword">val</span> objectMapper: ObjectMapper</span><br><span class="line">) : HandlerInterceptor &#123;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">preHandle</span><span class="params">(request: <span class="type">HttpServletRequest</span>, response: <span class="type">HttpServletResponse</span>, handler: <span class="type">Any</span>)</span></span>: <span class="built_in">Boolean</span> &#123;</span><br><span class="line">    <span class="comment">// 从头部取X-5E-USER字段值，解析成User对象</span></span><br><span class="line">    <span class="keyword">val</span> user = request.getHeader(<span class="string">&quot;X-5E-USER&quot;</span>)?.let &#123; objectMapper.readValue(it, User::<span class="keyword">class</span>.java) &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 判断方法是否被@Authenticate注解，如果被注解了且user为空，则报401错误</span></span><br><span class="line">    <span class="keyword">val</span> authorize = (handler <span class="keyword">as</span> HandlerMethod).beanType.getDeclaredAnnotation(Authenticate::<span class="keyword">class</span>.java)</span><br><span class="line">    ?: handler.getMethodAnnotation(Authenticate::<span class="keyword">class</span>.java)</span><br><span class="line">    <span class="keyword">if</span> (authorize != <span class="literal">null</span> &amp;&amp; user == <span class="literal">null</span>) &#123;</span><br><span class="line">      <span class="keyword">throw</span> ResponseException(ResErrCode.NEED_AUTHORIZE)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>UserUpdateReq需要被验证</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="meta">@ApiModel(<span class="meta-string">&quot;更新用户信息&quot;</span>)</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">UserUpdateReq</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@ApiModelProperty(<span class="meta-string">&quot;用户名&quot;</span>)</span></span><br><span class="line">  <span class="meta">@NotBlank</span></span><br><span class="line">  <span class="keyword">var</span> name: String? = <span class="literal">null</span></span><br><span class="line"></span><br><span class="line">  <span class="meta">@ApiModelProperty(<span class="meta-string">&quot;头像&quot;</span>)</span></span><br><span class="line">  <span class="meta">@NotBlank</span></span><br><span class="line">  <span class="keyword">var</span> avatar: String? = <span class="literal">null</span></span><br><span class="line"></span><br><span class="line">  <span class="meta">@ApiModelProperty(<span class="meta-string">&quot;用户描述&quot;</span>)</span></span><br><span class="line">  <span class="meta">@NotBlank</span></span><br><span class="line">  <span class="keyword">var</span> description: String? = <span class="literal">null</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<h2 id="测试类的构建"><a href="#测试类的构建" class="headerlink" title="测试类的构建"></a>测试类的构建</h2><p>测试类的构建，主要考虑以下几个因素</p>
<ul>
<li><p>只加载Web配置和待测Controller，其它Bean都不要，我们基于@WebMvcTest构建自己的注解</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Inherited</span></span><br><span class="line"><span class="meta">@Documented</span></span><br><span class="line"><span class="meta">@Target(ElementType.TYPE)</span></span><br><span class="line"><span class="meta">@Retention(RetentionPolicy.RUNTIME)</span></span><br><span class="line"><span class="meta">@WebMvcTest</span></span><br><span class="line"><span class="comment">// WebMvcConfig是本业务中自定义的Web配置</span></span><br><span class="line"><span class="meta">@Import(WebMvcConfig.class)</span></span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> ControllerTest &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@AliasFor(annotation = WebMvcTest.class)</span></span><br><span class="line">    String[] properties() <span class="keyword">default</span> &#123;&#125;;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@AliasFor(annotation = WebMvcTest.class)</span></span><br><span class="line">    Class&lt;?&gt;[] value() <span class="keyword">default</span> &#123;&#125;;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@AliasFor(annotation = WebMvcTest.class)</span></span><br><span class="line">    Class&lt;?&gt;[] controllers() <span class="keyword">default</span> &#123;&#125;;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@AliasFor(annotation = WebMvcTest.class)</span></span><br><span class="line">    <span class="function"><span class="keyword">boolean</span> <span class="title">useDefaultFilters</span><span class="params">()</span> <span class="keyword">default</span> <span class="keyword">true</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@AliasFor(annotation = WebMvcTest.class)</span></span><br><span class="line">    Filter[] includeFilters() <span class="keyword">default</span> &#123;&#125;;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@AliasFor(annotation = WebMvcTest.class)</span></span><br><span class="line">    Filter[] excludeFilters() <span class="keyword">default</span> &#123;&#125;;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@AliasFor(annotation = WebMvcTest.class)</span></span><br><span class="line">    Class&lt;?&gt;[] excludeAutoConfiguration() <span class="keyword">default</span> &#123;&#125;;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>一个Controller一个测试类，但每个接口都有好几个case，因此需要分组。用内部类+@Nested实现，不过这样的话，一个内部类对应一个接口，可以定义一个接口，管理公共属性</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">IRequestMapping</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * 指定本次测试的路径</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="keyword">val</span> path: String</span><br><span class="line"></span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * 针对该路径的mock。这样，子类只需要调用mockRequest即可请求，而不需要每个case重新构建填写path、method等重复参数</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="function"><span class="keyword">fun</span> <span class="title">mockRequest</span><span class="params">(block: <span class="type">MockHttpServletRequestDsl</span>.() -&gt; <span class="type">Unit</span> = &#123;&#125;)</span></span>: ResultActionsDsl</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">fun</span> <span class="title">mockRequestWithToken</span><span class="params">(block: <span class="type">MockHttpServletRequestDsl</span>.() -&gt; <span class="type">Unit</span> = &#123;&#125;)</span></span>: ResultActionsDsl &#123;</span><br><span class="line">    <span class="keyword">return</span> mockRequest &#123;</span><br><span class="line">      header(mockAuthHeader.first, mockAuthHeader.second)</span><br><span class="line">      block(<span class="keyword">this</span>)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">fun</span> <span class="title">mockRequestWithEmptyContent</span><span class="params">(block: <span class="type">MockHttpServletRequestDsl</span>.() -&gt; <span class="type">Unit</span> = &#123;&#125;)</span></span>: ResultActionsDsl &#123;</span><br><span class="line">    <span class="keyword">return</span> mockRequest &#123;</span><br><span class="line">      content = <span class="string">&quot;&#123;&#125;&quot;</span></span><br><span class="line">      block(<span class="keyword">this</span>)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>实际上，所有的接口都有两个共同的需求，我们将其写成父类</p>
<ul>
<li><p>都需要测试鉴权</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">AuthenticateTest</span> : <span class="type">IRequestMapping &#123;</span></span></span><br><span class="line">  <span class="meta">@Test</span></span><br><span class="line">  <span class="function"><span class="keyword">fun</span> `401 <span class="keyword">when</span> missing token`<span class="params">()</span></span> &#123;</span><br><span class="line">    mockRequestWithEmptyContent().andExpect &#123;</span><br><span class="line">      status &#123;</span><br><span class="line">        isUnauthorized()</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>都需要验证响应结构</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">ResponseFormatTest</span> : <span class="type">IRequestMapping &#123;</span></span></span><br><span class="line">  <span class="meta">@Test</span></span><br><span class="line">  <span class="function"><span class="keyword">fun</span> `response format validate`<span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">val</span> mockResult = mockRequestWithEmptyContent().andReturn()</span><br><span class="line">    assertThat(mockResult.response.contentType).isEqualTo(MediaType.APPLICATION_JSON.toString())</span><br><span class="line">    <span class="keyword">val</span> resNode = publicObjectMapper.readTree(mockResult.response.contentAsString)</span><br><span class="line">    assertThat(publicObjectMapper.convertValue(resNode, R::<span class="keyword">class</span>.java)).isInstanceOf(R::<span class="class"><span class="keyword">class</span>)</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
</ul>
<p>这样，就构建得到如下测试类</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="meta">@DisplayName(<span class="meta-string">&quot;用户参数验证&quot;</span>)</span></span><br><span class="line"><span class="meta">@ControllerTest(UserController::class)</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">UserControllerTest</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Autowired</span></span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">lateinit</span> <span class="keyword">var</span> mockMvc: MockMvc</span><br><span class="line"></span><br><span class="line">  <span class="meta">@MockkBean</span></span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">lateinit</span> <span class="keyword">var</span> subscriptionService: SubscriptionService</span><br><span class="line"></span><br><span class="line">  <span class="meta">@MockkBean(relaxed = true)</span></span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">lateinit</span> <span class="keyword">var</span> userService: UserService</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 同时需要验证鉴权和响应格式</span></span><br><span class="line">  <span class="meta">@Nested</span></span><br><span class="line">  <span class="meta">@DisplayName(<span class="meta-string">&quot;更新用户信息&quot;</span>)</span></span><br><span class="line">  <span class="keyword">inner</span> <span class="class"><span class="keyword">class</span> <span class="title">UpdateUserInfo</span> : <span class="type">AuthenticateTest</span>, <span class="type">ResponseFormatTest &#123;</span></span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 指定接口路径</span></span><br><span class="line">    <span class="keyword">override</span> <span class="keyword">val</span> path: String = <span class="string">&quot;/users/1&quot;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 指定接口的method和contentType等公共属性</span></span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">mockRequest</span><span class="params">(block: <span class="type">MockHttpServletRequestDsl</span>.() -&gt; <span class="type">Unit</span>)</span></span>: ResultActionsDsl &#123;</span><br><span class="line">      <span class="keyword">return</span> mockMvc.patch(path) &#123;</span><br><span class="line">        contentType = MediaType.APPLICATION_JSON</span><br><span class="line">        block(<span class="keyword">this</span>)</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 异常case的测试</span></span><br><span class="line">    <span class="meta">@ParameterizedTest(name = <span class="meta-string">&quot;&#123;displayName&#125; &#123;argumentsWithNames&#125;&quot;</span>)</span></span><br><span class="line">    <span class="meta">@CsvSource(</span></span><br><span class="line"><span class="meta">      value = [</span></span><br><span class="line"><span class="meta">        <span class="meta-string">&quot;&#x27;&#x27;, &#x27;&#x27;, null&quot;</span>,</span></span><br><span class="line"><span class="meta">        <span class="meta-string">&quot;&#x27; &#x27;, null, 非空&quot;</span></span></span><br><span class="line"><span class="meta">      ],</span></span><br><span class="line"><span class="meta">      nullValues = [<span class="meta-string">&quot;null&quot;</span>]</span></span><br><span class="line"><span class="meta">    )</span></span><br><span class="line">    <span class="function"><span class="keyword">fun</span> `400 <span class="keyword">when</span> illegal input`<span class="params">(name: <span class="type">String</span>?, avatar: <span class="type">String</span>?, description: <span class="type">String</span>?)</span></span> &#123;</span><br><span class="line">      mockRequestWithToken &#123;</span><br><span class="line">        <span class="keyword">val</span> mockBody = UserUpdateReq().apply &#123;</span><br><span class="line">          <span class="keyword">this</span>.name = name</span><br><span class="line">          <span class="keyword">this</span>.avatar = avatar</span><br><span class="line">          <span class="keyword">this</span>.description = description</span><br><span class="line">        &#125;</span><br><span class="line">        content = mockBody.toJsonString()</span><br><span class="line">      &#125;.andExpect &#123;</span><br><span class="line">        status &#123; isBadRequest() &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 正常case的测试</span></span><br><span class="line">    <span class="meta">@ParameterizedTest(name = <span class="meta-string">&quot;&#123;displayName&#125; &#123;argumentsWithNames&#125;&quot;</span>)</span></span><br><span class="line">    <span class="meta">@CsvSource(</span></span><br><span class="line"><span class="meta">      value = [</span></span><br><span class="line"><span class="meta">        <span class="meta-string">&quot;null, null, null&quot;</span>,</span></span><br><span class="line"><span class="meta">        <span class="meta-string">&quot;null, null, 非空&quot;</span></span></span><br><span class="line"><span class="meta">      ],</span></span><br><span class="line"><span class="meta">      nullValues = [<span class="meta-string">&quot;null&quot;</span>]</span></span><br><span class="line"><span class="meta">    )</span></span><br><span class="line">    <span class="function"><span class="keyword">fun</span> `200 <span class="keyword">when</span> legal input`<span class="params">(name: <span class="type">String</span>?, avatar: <span class="type">String</span>?, description: <span class="type">String</span>?)</span></span> &#123;</span><br><span class="line">      mockRequestWithToken &#123;</span><br><span class="line">        <span class="keyword">val</span> mockBody = UserUpdateReq().apply &#123;</span><br><span class="line">          <span class="keyword">this</span>.name = name</span><br><span class="line">          <span class="keyword">this</span>.avatar = avatar</span><br><span class="line">          <span class="keyword">this</span>.description = description</span><br><span class="line">        &#125;</span><br><span class="line">        content = mockBody.toJsonString()</span><br><span class="line">      &#125;.andExpect &#123;</span><br><span class="line">        status &#123; isOk() &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="关于Json格式的测试"><a href="#关于Json格式的测试" class="headerlink" title="关于Json格式的测试"></a>关于Json格式的测试</h2><p>当前项目一个比较特殊的需求：资源保存接口，资源的结构如下，每次保存时需要验证资源的结构是否符合预期。</p>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="attr">&quot;resourceId&quot;</span>: <span class="string">&quot;1233&quot;</span>,</span><br><span class="line">  <span class="attr">&quot;resourceType&quot;</span>: <span class="string">&quot;record&quot;</span>,</span><br><span class="line">  <span class="attr">&quot;data&quot;</span>: &#123;</span><br><span class="line">    <span class="attr">&quot;...&quot;</span>: <span class="string">&quot;...&quot;</span>,</span><br><span class="line">    <span class="attr">&quot;...&quot;</span>: <span class="string">&quot;...&quot;</span>,</span><br><span class="line">    <span class="attr">&quot;...&quot;</span>: <span class="string">&quot;...&quot;</span>,</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>其中的data结构不固定，多达五六种。服务端将data的验证逻辑写成了json schema，以自定义validator的形式加入Spring中。现在要对这些验证逻辑进行单元测试。</p>
<p>这其中的测试难点及解决方法如下</p>
<ul>
<li><p>测试数据量大</p>
<p>将测试数据写在文件中，通过文件读取各条测试数据，再以参数化形式传入测试case。需要用到JUnit的@ParameterizedTest + @MethodSource达成</p>
</li>
<li><p>测试case多</p>
<p>我们提取了最常见的case，对它们进行数据构建</p>
<ul>
<li><p>预期成功的case</p>
<ul>
<li>拥有最少合法元素</li>
<li>拥有最多合法元素</li>
<li>可空元素都为null</li>
</ul>
<p>以tag为例，可以看到除了数据之外我们还添加了针对该数据的说明：_comment_字段，这在测试结果中会打印出来</p>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line">[</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="attr">&quot;_comment_&quot;</span>: <span class="string">&quot;拥有最少合法元素&quot;</span>,</span><br><span class="line">    <span class="attr">&quot;resourceId&quot;</span>: <span class="string">&quot;12345678901234567890123456789012&quot;</span>,</span><br><span class="line">    <span class="attr">&quot;resourceType&quot;</span>: <span class="string">&quot;tag&quot;</span>,</span><br><span class="line">    <span class="attr">&quot;usn&quot;</span>: <span class="number">1</span>,</span><br><span class="line">    <span class="attr">&quot;data&quot;</span>: &#123;</span><br><span class="line">      <span class="attr">&quot;id&quot;</span>: <span class="string">&quot;12345678901234567890123456789012&quot;</span>,</span><br><span class="line">      <span class="attr">&quot;title&quot;</span>: <span class="string">&quot;5qCH562+5qCH6aKY&quot;</span>,</span><br><span class="line">      <span class="attr">&quot;created_time&quot;</span>: <span class="number">1</span>,</span><br><span class="line">      <span class="attr">&quot;updated_time&quot;</span>: <span class="number">1</span>,</span><br><span class="line">      <span class="attr">&quot;version&quot;</span>: <span class="number">3</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="attr">&quot;_comment_&quot;</span>: <span class="string">&quot;拥有最多合法元素&quot;</span>,</span><br><span class="line">    <span class="attr">&quot;resourceId&quot;</span>: <span class="string">&quot;12345678901234567890123456789012&quot;</span>,</span><br><span class="line">    <span class="attr">&quot;resourceType&quot;</span>: <span class="string">&quot;tag&quot;</span>,</span><br><span class="line">    <span class="attr">&quot;usn&quot;</span>: <span class="number">1</span>,</span><br><span class="line">    <span class="attr">&quot;data&quot;</span>: &#123;</span><br><span class="line">      <span class="attr">&quot;id&quot;</span>: <span class="string">&quot;12345678901234567890123456789012&quot;</span>,</span><br><span class="line">      <span class="attr">&quot;title&quot;</span>: <span class="string">&quot;5qCH562+5qCH6aKY&quot;</span>,</span><br><span class="line">      <span class="attr">&quot;description&quot;</span>: <span class="string">&quot;5o+P6L+w&quot;</span>,</span><br><span class="line">      <span class="attr">&quot;created_time&quot;</span>: <span class="number">1</span>,</span><br><span class="line">      <span class="attr">&quot;updated_time&quot;</span>: <span class="number">1</span>,</span><br><span class="line">      <span class="attr">&quot;deleted_time&quot;</span>: <span class="number">1</span>,</span><br><span class="line">      <span class="attr">&quot;version&quot;</span>: <span class="number">3</span>,</span><br><span class="line">      <span class="attr">&quot;usn&quot;</span>: <span class="number">1</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="attr">&quot;_comment_&quot;</span>: <span class="string">&quot;可空元素都为null&quot;</span>,</span><br><span class="line">    <span class="attr">&quot;resourceId&quot;</span>: <span class="string">&quot;12345678901234567890123456789012&quot;</span>,</span><br><span class="line">    <span class="attr">&quot;resourceType&quot;</span>: <span class="string">&quot;tag&quot;</span>,</span><br><span class="line">    <span class="attr">&quot;usn&quot;</span>: <span class="literal">null</span>,</span><br><span class="line">    <span class="attr">&quot;data&quot;</span>: &#123;</span><br><span class="line">      <span class="attr">&quot;id&quot;</span>: <span class="string">&quot;12345678901234567890123456789012&quot;</span>,</span><br><span class="line">      <span class="attr">&quot;title&quot;</span>: <span class="string">&quot;5qCH562+5qCH6aKY&quot;</span>,</span><br><span class="line">      <span class="attr">&quot;description&quot;</span>: <span class="literal">null</span>,</span><br><span class="line">      <span class="attr">&quot;created_time&quot;</span>: <span class="number">1</span>,</span><br><span class="line">      <span class="attr">&quot;updated_time&quot;</span>: <span class="number">1</span>,</span><br><span class="line">      <span class="attr">&quot;deleted_time&quot;</span>: <span class="literal">null</span>,</span><br><span class="line">      <span class="attr">&quot;version&quot;</span>: <span class="number">3</span>,</span><br><span class="line">      <span class="attr">&quot;usn&quot;</span>: <span class="literal">null</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">]</span><br></pre></td></tr></table></figure></li>
<li><p>预期失败的case</p>
<ul>
<li>必须字段未出现</li>
<li>不可空元素设置为null</li>
<li>数据类型问题：故意将每个元素的数据类型写错</li>
<li>数据格式问题：故意将每个元素的数据格式写错</li>
<li>出现未定义的字段</li>
</ul>
<p>同样以tag为例，不同的是这次还多了_errorKeywords_字段，指出了该case的错误信息必须包含的关键字</p>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line">[</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="attr">&quot;_comment_&quot;</span>: <span class="string">&quot;必须字段未出现&quot;</span>,</span><br><span class="line">    <span class="attr">&quot;_errorKeywords_&quot;</span>: [</span><br><span class="line">      <span class="string">&quot;id&quot;</span>,</span><br><span class="line">      <span class="string">&quot;title&quot;</span>,</span><br><span class="line">      <span class="string">&quot;created_time&quot;</span>,</span><br><span class="line">      <span class="string">&quot;updated_time&quot;</span>,</span><br><span class="line">      <span class="string">&quot;version&quot;</span></span><br><span class="line">    ],</span><br><span class="line">    <span class="attr">&quot;resourceId&quot;</span>: <span class="string">&quot;12345678901234567890123456789012&quot;</span>,</span><br><span class="line">    <span class="attr">&quot;resourceType&quot;</span>: <span class="string">&quot;tag&quot;</span>,</span><br><span class="line">    <span class="attr">&quot;usn&quot;</span>: <span class="number">1</span>,</span><br><span class="line">    <span class="attr">&quot;data&quot;</span>: &#123;&#125;</span><br><span class="line">  &#125;,</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="attr">&quot;_comment_&quot;</span>: <span class="string">&quot;字段可空问题: id, title, created_time, updated_time, version&quot;</span>,</span><br><span class="line">    <span class="attr">&quot;_errorKeywords_&quot;</span>: [</span><br><span class="line">      <span class="string">&quot;id&quot;</span>,</span><br><span class="line">      <span class="string">&quot;title&quot;</span>,</span><br><span class="line">      <span class="string">&quot;created_time&quot;</span>,</span><br><span class="line">      <span class="string">&quot;updated_time&quot;</span>,</span><br><span class="line">      <span class="string">&quot;version&quot;</span></span><br><span class="line">    ],</span><br><span class="line">    <span class="attr">&quot;resourceId&quot;</span>: <span class="string">&quot;12345678901234567890123456789012&quot;</span>,</span><br><span class="line">    <span class="attr">&quot;resourceType&quot;</span>: <span class="string">&quot;tag&quot;</span>,</span><br><span class="line">    <span class="attr">&quot;usn&quot;</span>: <span class="number">1</span>,</span><br><span class="line">    <span class="attr">&quot;data&quot;</span>: &#123;</span><br><span class="line">      <span class="attr">&quot;id&quot;</span>: <span class="literal">null</span>,</span><br><span class="line">      <span class="attr">&quot;title&quot;</span>: <span class="literal">null</span>,</span><br><span class="line">      <span class="attr">&quot;description&quot;</span>: <span class="string">&quot;5o+P6L+w&quot;</span>,</span><br><span class="line">      <span class="attr">&quot;created_time&quot;</span>: <span class="literal">null</span>,</span><br><span class="line">      <span class="attr">&quot;updated_time&quot;</span>: <span class="literal">null</span>,</span><br><span class="line">      <span class="attr">&quot;deleted_time&quot;</span>: <span class="number">1</span>,</span><br><span class="line">      <span class="attr">&quot;version&quot;</span>: <span class="literal">null</span>,</span><br><span class="line">      <span class="attr">&quot;usn&quot;</span>: <span class="number">1</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="attr">&quot;_comment_&quot;</span>: <span class="string">&quot;数据类型问题: id、title、description为string;其它为数字&quot;</span>,</span><br><span class="line">    <span class="attr">&quot;_errorKeywords_&quot;</span>: [</span><br><span class="line">      <span class="string">&quot;id&quot;</span>,</span><br><span class="line">      <span class="string">&quot;title&quot;</span>,</span><br><span class="line">      <span class="string">&quot;description&quot;</span>,</span><br><span class="line">      <span class="string">&quot;created_time&quot;</span>,</span><br><span class="line">      <span class="string">&quot;updated_time&quot;</span>,</span><br><span class="line">      <span class="string">&quot;deleted_time&quot;</span>,</span><br><span class="line">      <span class="string">&quot;version&quot;</span>,</span><br><span class="line">      <span class="string">&quot;usn&quot;</span></span><br><span class="line">    ],</span><br><span class="line">    <span class="attr">&quot;resourceId&quot;</span>: <span class="string">&quot;12345678901234567890123456789012&quot;</span>,</span><br><span class="line">    <span class="attr">&quot;resourceType&quot;</span>: <span class="string">&quot;tag&quot;</span>,</span><br><span class="line">    <span class="attr">&quot;usn&quot;</span>: <span class="number">1</span>,</span><br><span class="line">    <span class="attr">&quot;data&quot;</span>: &#123;</span><br><span class="line">      <span class="attr">&quot;id&quot;</span>: <span class="number">1</span>,</span><br><span class="line">      <span class="attr">&quot;title&quot;</span>: <span class="number">1</span>,</span><br><span class="line">      <span class="attr">&quot;description&quot;</span>: <span class="number">1</span>,</span><br><span class="line">      <span class="attr">&quot;created_time&quot;</span>: <span class="string">&quot;1&quot;</span>,</span><br><span class="line">      <span class="attr">&quot;updated_time&quot;</span>: <span class="string">&quot;1&quot;</span>,</span><br><span class="line">      <span class="attr">&quot;deleted_time&quot;</span>: <span class="string">&quot;1&quot;</span>,</span><br><span class="line">      <span class="attr">&quot;version&quot;</span>: <span class="string">&quot;3&quot;</span>,</span><br><span class="line">      <span class="attr">&quot;usn&quot;</span>: <span class="string">&quot;1&quot;</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="attr">&quot;_comment_&quot;</span>: <span class="string">&quot;数据格式问题: id为32位;title、description为base64;version固定为3&quot;</span>,</span><br><span class="line">    <span class="attr">&quot;_errorKeywords_&quot;</span>: [</span><br><span class="line">      <span class="string">&quot;id&quot;</span>,</span><br><span class="line">      <span class="string">&quot;title&quot;</span>,</span><br><span class="line">      <span class="string">&quot;description&quot;</span>,</span><br><span class="line">      <span class="string">&quot;version&quot;</span></span><br><span class="line">    ],</span><br><span class="line">    <span class="attr">&quot;resourceId&quot;</span>: <span class="string">&quot;12345678901234567890123456789012&quot;</span>,</span><br><span class="line">    <span class="attr">&quot;resourceType&quot;</span>: <span class="string">&quot;tag&quot;</span>,</span><br><span class="line">    <span class="attr">&quot;usn&quot;</span>: <span class="number">1</span>,</span><br><span class="line">    <span class="attr">&quot;data&quot;</span>: &#123;</span><br><span class="line">      <span class="attr">&quot;id&quot;</span>: <span class="string">&quot;123456789012345678901234567890&quot;</span>,</span><br><span class="line">      <span class="attr">&quot;title&quot;</span>: <span class="string">&quot;明文标题&quot;</span>,</span><br><span class="line">      <span class="attr">&quot;description&quot;</span>: <span class="string">&quot;明文描述&quot;</span>,</span><br><span class="line">      <span class="attr">&quot;created_time&quot;</span>: <span class="number">1</span>,</span><br><span class="line">      <span class="attr">&quot;updated_time&quot;</span>: <span class="number">1</span>,</span><br><span class="line">      <span class="attr">&quot;deleted_time&quot;</span>: <span class="number">1</span>,</span><br><span class="line">      <span class="attr">&quot;version&quot;</span>: <span class="number">2</span>,</span><br><span class="line">      <span class="attr">&quot;usn&quot;</span>: <span class="number">1</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="attr">&quot;_comment_&quot;</span>: <span class="string">&quot;出现未定义字段: undefinedField&quot;</span>,</span><br><span class="line">    <span class="attr">&quot;_errorKeywords_&quot;</span>: [</span><br><span class="line">      <span class="string">&quot;undefinedField&quot;</span></span><br><span class="line">    ],</span><br><span class="line">    <span class="attr">&quot;resourceId&quot;</span>: <span class="string">&quot;12345678901234567890123456789012&quot;</span>,</span><br><span class="line">    <span class="attr">&quot;resourceType&quot;</span>: <span class="string">&quot;tag&quot;</span>,</span><br><span class="line">    <span class="attr">&quot;usn&quot;</span>: <span class="number">1</span>,</span><br><span class="line">    <span class="attr">&quot;data&quot;</span>: &#123;</span><br><span class="line">      <span class="attr">&quot;id&quot;</span>: <span class="string">&quot;12345678901234567890123456789012&quot;</span>,</span><br><span class="line">      <span class="attr">&quot;title&quot;</span>: <span class="string">&quot;5qCH562+5qCH6aKY&quot;</span>,</span><br><span class="line">      <span class="attr">&quot;description&quot;</span>: <span class="string">&quot;5o+P6L+w&quot;</span>,</span><br><span class="line">      <span class="attr">&quot;created_time&quot;</span>: <span class="number">1</span>,</span><br><span class="line">      <span class="attr">&quot;updated_time&quot;</span>: <span class="number">1</span>,</span><br><span class="line">      <span class="attr">&quot;deleted_time&quot;</span>: <span class="number">1</span>,</span><br><span class="line">      <span class="attr">&quot;version&quot;</span>: <span class="number">3</span>,</span><br><span class="line">      <span class="attr">&quot;usn&quot;</span>: <span class="number">1</span>,</span><br><span class="line">      <span class="attr">&quot;undefinedField&quot;</span>: <span class="string">&quot;&quot;</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">]</span><br></pre></td></tr></table></figure></li>
</ul>
<p>目前为止所有数据有这么多：</p>
<p><img src="https://gdz.oss-cn-shenzhen.aliyuncs.com/local/image-20220305174323051.png" alt="image-20220305174323051"></p>
</li>
</ul>
<p>至于测试方法，我们这样写</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="meta">@ParameterizedTest(name = <span class="meta-string">&quot;&#123;displayName&#125; &#123;argumentsWithNames&#125;&quot;</span>)</span></span><br><span class="line"><span class="meta">@MethodSource(<span class="meta-string">&quot;com.project5e.app.mylog.controller.mock.ResourceProvider#provideLegalResource&quot;</span>)</span></span><br><span class="line"><span class="function"><span class="keyword">fun</span> `200 <span class="keyword">when</span> legal resource`<span class="params">(type: <span class="type">String</span>, comment: <span class="type">String</span>, content: <span class="type">String</span>)</span></span> &#123;</span><br><span class="line">  every &#123; resourceService.saveV2(any()) &#125; returns listOf()</span><br><span class="line">  mockRequestWithToken &#123;</span><br><span class="line">    <span class="keyword">this</span>.content = content</span><br><span class="line">  &#125;.andExpect &#123;</span><br><span class="line">    status &#123; isOk() &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@ParameterizedTest(name = <span class="meta-string">&quot;&#123;displayName&#125; &#123;argumentsWithNames&#125;&quot;</span>)</span></span><br><span class="line"><span class="meta">@MethodSource(<span class="meta-string">&quot;com.project5e.app.mylog.controller.mock.ResourceProvider#provideIllegalResource&quot;</span>)</span></span><br><span class="line"><span class="function"><span class="keyword">fun</span> `400 <span class="keyword">when</span> illegal resource`<span class="params">(type: <span class="type">String</span>, comment: <span class="type">String</span>, errorKeyWords: <span class="type">List</span>&lt;<span class="type">String</span>&gt;, content: <span class="type">String</span>)</span></span> &#123;</span><br><span class="line">  <span class="keyword">val</span> mvcResult = mockRequestWithToken &#123;</span><br><span class="line">    <span class="keyword">this</span>.content = content</span><br><span class="line">  &#125;.andExpect &#123;</span><br><span class="line">    status &#123; isBadRequest() &#125;</span><br><span class="line">  &#125;.andReturn()</span><br><span class="line"></span><br><span class="line">  errorKeyWords.forEach &#123; errorKeyWord -&gt;</span><br><span class="line">                         assertThat(mvcResult.response.contentAsString).contains(errorKeyWord)</span><br><span class="line">                        &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>测试数据读取方法如下</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">object</span> ResourceProvider &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">const</span> <span class="keyword">val</span> RESOURCE_FILE_SUFFIX = <span class="string">&quot;json&quot;</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">const</span> <span class="keyword">val</span> LEGAL_RESOURCE_PATTERN = <span class="string">&quot;classpath:mock-resource/legal/*.<span class="variable">$RESOURCE_FILE_SUFFIX</span>&quot;</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">const</span> <span class="keyword">val</span> ILLEGAL_RESOURCE_PATTERN = <span class="string">&quot;classpath:mock-resource/illegal/*.<span class="variable">$RESOURCE_FILE_SUFFIX</span>&quot;</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">const</span> <span class="keyword">val</span> COMMENT_KEY = <span class="string">&quot;_comment_&quot;</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">const</span> <span class="keyword">val</span> ERROR_KEYWORDS_KEY = <span class="string">&quot;_errorKeywords_&quot;</span></span><br><span class="line"></span><br><span class="line">    <span class="meta">@JvmStatic</span></span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">provideLegalResource</span><span class="params">()</span></span>: List&lt;Arguments&gt; &#123;</span><br><span class="line">        <span class="keyword">return</span> PathMatchingResourcePatternResolver().getResources(LEGAL_RESOURCE_PATTERN).map &#123; resource -&gt;</span><br><span class="line">            resource.file.name to publicObjectMapper.readTree(resource.file)</span><br><span class="line">        &#125;.map &#123; (fileName, mockResources) -&gt;</span><br><span class="line">            mockResources.map &#123; mockResource -&gt;</span><br><span class="line">                <span class="keyword">val</span> resourceType = fileName.removeSuffix(RESOURCE_FILE_SUFFIX)</span><br><span class="line">                <span class="keyword">val</span> comment = (mockResource <span class="keyword">as</span> ObjectNode).remove(COMMENT_KEY).asText()</span><br><span class="line">                <span class="keyword">val</span> content = <span class="string">&quot;&quot;&quot;&#123;&quot;resources&quot;: [<span class="subst">$&#123;mockResource.toJsonString()&#125;</span>]&#125;&quot;&quot;&quot;</span></span><br><span class="line">                Arguments.of(resourceType, comment, content)</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;.flatten()</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@JvmStatic</span></span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">provideIllegalResource</span><span class="params">()</span></span>: List&lt;Arguments&gt; &#123;</span><br><span class="line">        <span class="keyword">return</span> PathMatchingResourcePatternResolver().getResources(ILLEGAL_RESOURCE_PATTERN).map &#123; resource -&gt;</span><br><span class="line">            resource.file.name to publicObjectMapper.readTree(resource.file)</span><br><span class="line">        &#125;.map &#123; (fileName, mockResources) -&gt;</span><br><span class="line">            mockResources.map &#123; it <span class="keyword">as</span> ObjectNode &#125;.map &#123; mockResource -&gt;</span><br><span class="line">                <span class="keyword">val</span> resourceType = fileName.removeSuffix(RESOURCE_FILE_SUFFIX)</span><br><span class="line">                <span class="keyword">val</span> comment = mockResource.remove(COMMENT_KEY).asText()</span><br><span class="line">                <span class="keyword">val</span> errorKeywords = mockResource.remove(ERROR_KEYWORDS_KEY).map &#123; it.asText() &#125;</span><br><span class="line">                <span class="keyword">val</span> content = <span class="string">&quot;&quot;&quot;&#123;&quot;resources&quot;: [<span class="subst">$&#123;mockResource.toJsonString()&#125;</span>]&#125;&quot;&quot;&quot;</span></span><br><span class="line">                Arguments.of(resourceType, comment, errorKeywords, content)</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;.flatten()</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如果运行测试，能够得到如下输出</p>
<p><img src="https://gdz.oss-cn-shenzhen.aliyuncs.com/local/image-20220305174813410.png" alt="image-20220305174813410"></p>
<h2 id="可以改进的地方"><a href="#可以改进的地方" class="headerlink" title="可以改进的地方"></a>可以改进的地方</h2><ul>
<li>controller层测试还可以再抽象：不需要写代码，通过excel或db录入访问路径、预期输入、预期输出，直接生成测试代码生成，更为方便</li>
<li>controller层测试或许可以和集成测试合并。但也不尽然，集成测试不一定要在controller这一次层做，以service为入口或许更加方便</li>
</ul>
<h1 id="Service测试"><a href="#Service测试" class="headerlink" title="Service测试"></a>Service测试</h1><h2 id="测什么-1"><a href="#测什么-1" class="headerlink" title="测什么"></a>测什么</h2><ul>
<li>测试业务逻辑</li>
</ul>
<h2 id="一个需求-1"><a href="#一个需求-1" class="headerlink" title="一个需求"></a>一个需求</h2><figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">UserService</span></span>(<span class="meta">@Autowired</span> <span class="keyword">private</span> <span class="keyword">val</span> userDao: UserDao) &#123;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Value(<span class="meta-string">&quot;\$&#123;user.appid&#125;&quot;</span>)</span></span><br><span class="line">  <span class="keyword">lateinit</span> <span class="keyword">var</span> appId: String</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Value(<span class="meta-string">&quot;\$&#123;user.fresh.avatar&#125;&quot;</span>)</span></span><br><span class="line">  <span class="keyword">lateinit</span> <span class="keyword">var</span> freshUserAvatar: String</span><br><span class="line"></span><br><span class="line">  <span class="meta">@GrpcClient(<span class="meta-string">&quot;user-service&quot;</span>)</span></span><br><span class="line">  <span class="keyword">lateinit</span> <span class="keyword">var</span> userStub: UserServiceGrpc.UserServiceBlockingStub</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">fun</span> <span class="title">updateUserInfo</span><span class="params">(id: <span class="type">Int</span>, initiator: <span class="type">Int</span>, request: <span class="type">UserUpdateReq</span>)</span></span>: User &#123;</span><br><span class="line">    <span class="keyword">if</span> (id != initiator) &#123;</span><br><span class="line">      <span class="keyword">throw</span> ResponseException(ResErrCode.ILLEGAL_REQUEST, <span class="string">&quot;不可修改他人信息&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (!request.isAllFieldNull()) &#123;</span><br><span class="line">      userDao.updateUserInfo(id, request)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> getUserInfo(id)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="构建测试类"><a href="#构建测试类" class="headerlink" title="构建测试类"></a>构建测试类</h2><p>在Controller测试时，我们采用了@Nested+内部类的方式对接口进行了分组。但是在Service中，往往有很多个方法，每个方法的case也会非常多，如果还采用和Controller一样的方式，测试类会爆炸。因此我们采用类继承的方式进行分组。</p>
<p>父类如下：定义了mock对象和测试对象，以及测试对象中的共享mock属性</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="meta">@ExtendWith(MockKExtension::class)</span></span><br><span class="line"><span class="keyword">open</span> <span class="class"><span class="keyword">class</span> <span class="title">UserServiceTest</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@RelaxedMockK</span></span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">lateinit</span> <span class="keyword">var</span> userDao: UserDao</span><br><span class="line"></span><br><span class="line">    <span class="meta">@InjectMockKs</span></span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">lateinit</span> <span class="keyword">var</span> userService: UserService</span><br><span class="line"></span><br><span class="line">    <span class="meta">@BeforeEach</span></span><br><span class="line">    <span class="meta">@Order(Int.MIN_VALUE)</span></span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">setUp</span><span class="params">()</span></span> &#123;</span><br><span class="line">        userService.appId = MOCK_APP_ID</span><br><span class="line">        userService.freshUserAvatar = MOCK_FRESH_USER_AVATAR</span><br><span class="line">        userService.userStub = mockk(relaxed = <span class="literal">true</span>)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>针对需求中的方法的测试类如下，只需要写测试方法即可</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="meta">@DisplayName(<span class="meta-string">&quot;UserService测试 &gt; 更新用户信息&quot;</span>)</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">UpdateUserInfoTest</span> : <span class="type">UserServiceTest</span></span>() &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">fun</span> `reject <span class="keyword">when</span> update others info`<span class="params">()</span></span> &#123;</span><br><span class="line">        <span class="keyword">val</span> mockUserId = MOCK_USER_ID</span><br><span class="line">        <span class="keyword">val</span> mockInitiatorId = MOCK_USER_ID + <span class="number">1</span></span><br><span class="line">        <span class="keyword">val</span> mockRequest = UserUpdateReq()</span><br><span class="line"></span><br><span class="line">        assertThat &#123; userService.updateUserInfo(mockUserId, mockInitiatorId, mockRequest) &#125;.isFailure()</span><br><span class="line">            .isInstanceOf(ResponseException::<span class="class"><span class="keyword">class</span>)</span></span><br><span class="line">            .matchesPredicate &#123; it.errorCode == ResErrCode.ILLEGAL_REQUEST &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">fun</span> `success <span class="keyword">when</span> empty request`<span class="params">()</span></span> &#123;</span><br><span class="line">        <span class="keyword">val</span> spyUserService = spyk(userService)</span><br><span class="line">        every &#123; spyUserService.getUserInfo(any()) &#125; returns User()</span><br><span class="line"></span><br><span class="line">        spyUserService.updateUserInfo(MOCK_USER_ID, MOCK_USER_ID, UserUpdateReq())</span><br><span class="line"></span><br><span class="line">        verify &#123; userDao wasNot called &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">fun</span> `success <span class="keyword">when</span> non-empty request`<span class="params">()</span></span> &#123;</span><br><span class="line">        <span class="keyword">val</span> mockUserId = MOCK_USER_ID</span><br><span class="line">        <span class="keyword">val</span> mockInitiatorId = MOCK_USER_ID</span><br><span class="line">        <span class="keyword">val</span> mockRequest = UserUpdateReq().apply &#123;</span><br><span class="line">            <span class="keyword">this</span>.name = <span class="string">&quot;假名，只让它非空&quot;</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">val</span> spyUserService = spyk(userService)</span><br><span class="line">        <span class="keyword">val</span> mockUpdateResult = User()</span><br><span class="line"></span><br><span class="line">        every &#123; spyUserService.getUserInfo(any()) &#125; returns mockUpdateResult</span><br><span class="line"></span><br><span class="line">        <span class="keyword">val</span> updateResult = spyUserService.updateUserInfo(mockUserId, mockInitiatorId, mockRequest)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">val</span> idSlot = slot&lt;<span class="built_in">Int</span>&gt;()</span><br><span class="line">        <span class="keyword">val</span> requestSlot = slot&lt;UserUpdateReq&gt;()</span><br><span class="line">        verify &#123; userDao.updateUserInfo(capture(idSlot), capture(requestSlot)) &#125;</span><br><span class="line">        assertThat(idSlot.captured).isEqualTo(mockUserId)</span><br><span class="line">        assertThat(requestSlot.captured).isEqualTo(mockRequest)</span><br><span class="line">        assertThat(updateResult).isEqualTo(mockUpdateResult)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>如何脱离Spring </p>
<p>当Service依赖Bean的注入使用构造器注入时，对Service层的单元测试就能脱离Spring：因为MockK在构建测试对象时，是通过构造器注入的。否则就得一个个手动mock</p>
</blockquote>
<h2 id="让代码更易于测试"><a href="#让代码更易于测试" class="headerlink" title="让代码更易于测试"></a>让代码更易于测试</h2><p>最易于测试的代码当然是纯函数式，一个确定的输入就能对应一个确定的输出。但理想与现实是有差别的，日常业务中过分追求函数式可能会使得代码晦涩难懂。尽量函数式+mock才是正解。但是副作用和函数内部的级联调用过多，又会造成mock灾难。所以还是一个权衡的过程。</p>
<p>按照个人经验总结一下就是</p>
<ul>
<li>函数式+适当mock</li>
<li>功能拆解：复杂方法拆分成若干小的方法，分别测试，这样弹性更高</li>
</ul>
<p>一个例子：如下是重构之前的一个方法（获取用户邀请信息），如此之大，很显然是无法测试的</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">getInvitationInfo</span><span class="params">()</span></span>: InvitationInfoResponseDto &#123;</span><br><span class="line">      <span class="keyword">val</span> currentUser = RequestContext.currentUser</span><br><span class="line">      <span class="comment">// 从库中获取邀请码，没有就生成一个插入库中</span></span><br><span class="line">      <span class="keyword">var</span> userModel = userDao.getById(currentUser)</span><br><span class="line">      <span class="keyword">if</span> (userModel.invitationCode.isNullOrEmpty()) &#123;</span><br><span class="line">          userModel.invitationCode = userDao.generateInvitationCode().toUpperCase()</span><br><span class="line">          userModel.invitedCount = <span class="number">0</span></span><br><span class="line">          <span class="comment">// 尝试更新，如果提示冲突，说明发生了并发问题，以库中已有为准。不过这能发生的前提是数据表针对invitation_code做了unique限制</span></span><br><span class="line">          runCatching &#123; userModel.updateById() &#125;.exceptionOrNull()</span><br><span class="line">              ?.takeIf &#123; it.message?.contains(<span class="string">&quot;duplicate&quot;</span>) == <span class="literal">true</span> &#125;</span><br><span class="line">              ?.run &#123; userModel = userDao.getById(currentUser) &#125;</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="comment">// 查出一串记录，作为后面的计算依据</span></span><br><span class="line">      <span class="keyword">val</span> invitedHistory = invitationHistoryDao.getByInvitee(currentUser)</span><br><span class="line">      <span class="keyword">val</span> redeemHistory = invitationRedeemHistoryDao.listByRedeemer(currentUser)</span><br><span class="line">      <span class="keyword">val</span> subscriptionModel = subscriptionService.ktQuery().eq(SubscriptionModel::userId, currentUser).one()</span><br><span class="line"></span><br><span class="line">      <span class="comment">// 奖品构建：基本信息固定，只需填充兑换状态、是否可用（置灰状态）</span></span><br><span class="line">      <span class="keyword">val</span> awards = awardModels.map &#123; InvitationInfoResponseDto.Award().fillWith(it) &#125;.onEach &#123; award -&gt;</span><br><span class="line">          award.redeemed = redeemHistory.any &#123; it.awardId == award.id &#125;</span><br><span class="line">          <span class="comment">// 常规case：邀请数够且未被兑换，则高亮。否则置灰</span></span><br><span class="line">          award.enable = (userModel.invitedCount!! &gt;= award.triggerCount!!) &amp;&amp; !award.redeemed!!</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">val</span> standardAward = awards.single &#123; it.membershipLevel == MembershipLevel.STANDARD &#125;</span><br><span class="line">      <span class="keyword">val</span> premiumAward = awards.single &#123; it.membershipLevel == MembershipLevel.PREMIUM &#125;</span><br><span class="line">      <span class="comment">// 特殊case1：只要高级有效(要么购买要么兑换)，普通奖励就置灰</span></span><br><span class="line">      <span class="keyword">if</span> (subscriptionModel?.membershipLevel == MembershipLevel.PREMIUM) &#123;</span><br><span class="line">          standardAward.enable = <span class="literal">false</span></span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="comment">// 构建完整的邀请信息</span></span><br><span class="line">      <span class="keyword">return</span> InvitationInfoResponseDto().apply &#123;</span><br><span class="line">          <span class="keyword">this</span>.invitationCode = userModel.invitationCode</span><br><span class="line">          <span class="keyword">this</span>.invitedCount = userModel.invitedCount</span><br><span class="line">          <span class="keyword">this</span>.hasBeenInvited = invitedHistory != <span class="literal">null</span></span><br><span class="line">          <span class="keyword">this</span>.awards = awards</span><br><span class="line">      &#125;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>

<p>如下是重构之后的代码，按功能拆分，不但更易测，可读性也增强了不少。之前的代码不一点点看你一定不知道它在干啥</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">getInvitationInfo</span><span class="params">()</span></span>: InvitationInfoResponseDto &#123;</span><br><span class="line">      <span class="keyword">val</span> currentUser = RequestContext.currentUser</span><br><span class="line">      <span class="keyword">val</span> (invitationCode, invitedCount) = getInvitationCodeAndInvitedCount(currentUser)</span><br><span class="line">      <span class="keyword">val</span> hasBeenInvited = hasBeenInvited(invitationHistoryDao.getByInvitee(currentUser))</span><br><span class="line">      <span class="keyword">val</span> awards = awardModels.map &#123; InvitationInfoResponseDto.Award().fillWith(it) &#125;</span><br><span class="line">      fillAwardRedeemed(awards, invitationRedeemHistoryDao.listByRedeemer(currentUser))</span><br><span class="line">      fillAwardEnable(awards, currentUser, invitedCount, subscriptionDao.getByUserId(currentUser))</span><br><span class="line"></span><br><span class="line">      <span class="keyword">return</span> InvitationInfoResponseDto().apply &#123;</span><br><span class="line">          <span class="keyword">this</span>.invitationCode = invitationCode</span><br><span class="line">          <span class="keyword">this</span>.invitedCount = invitedCount</span><br><span class="line">          <span class="keyword">this</span>.hasBeenInvited = hasBeenInvited</span><br><span class="line">          <span class="keyword">this</span>.awards = awards</span><br><span class="line">      &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">fun</span> <span class="title">getInvitationCodeAndInvitedCount</span><span class="params">(userId: <span class="type">Int</span>)</span></span>: Pair&lt;String, <span class="built_in">Int</span>&gt; &#123;</span><br><span class="line">      <span class="keyword">var</span> userModel = userDao.getById(userId)!!</span><br><span class="line">      <span class="keyword">if</span> (userModel.invitationCode.isNullOrEmpty()) &#123;</span><br><span class="line">          userModel.invitationCode = generateCode()</span><br><span class="line">          userModel.invitedCount = <span class="number">0</span></span><br><span class="line">          <span class="comment">// 尝试更新，如果提示冲突，说明发生了并发问题，以库中已有为准。前提：invitation_code做了unique限制</span></span><br><span class="line">          <span class="keyword">try</span> &#123;</span><br><span class="line">              userDao.updateById(userModel)</span><br><span class="line">          &#125; <span class="keyword">catch</span> (_: DuplicateKeyException) &#123;</span><br><span class="line">              userModel = userDao.getById(userId)!!</span><br><span class="line">          &#125;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">return</span> userModel.invitationCode!! to userModel.invitedCount!!</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">fun</span> <span class="title">generateCode</span><span class="params">()</span></span>: String &#123;</span><br><span class="line">      <span class="keyword">val</span> tryCount = <span class="number">3</span></span><br><span class="line">      (<span class="number">0.</span>.tryCount).forEach &#123; _ -&gt;</span><br><span class="line">          <span class="keyword">val</span> candidate = UUID.randomUUID().toString().takeLast(<span class="number">6</span>).toUpperCase()</span><br><span class="line">          <span class="keyword">if</span> (userDao.getByInvitationCode(candidate) == <span class="literal">null</span>) &#123;</span><br><span class="line">              <span class="keyword">return</span> candidate</span><br><span class="line">          &#125;</span><br><span class="line">      &#125;</span><br><span class="line">      log.error(<span class="string">&quot;邀请码生成失败，请查找问题&quot;</span>)</span><br><span class="line">      <span class="keyword">throw</span> ResponseException(ResErrCode.COMM_ERROR)</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">fun</span> <span class="title">hasBeenInvited</span><span class="params">(invitationHistoryModel: <span class="type">InvitationHistoryModel</span>?)</span></span>: <span class="built_in">Boolean</span> &#123;</span><br><span class="line">      <span class="keyword">return</span> invitationHistoryModel != <span class="literal">null</span></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">fun</span> <span class="title">fillAwardRedeemed</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">      awards: <span class="type">List</span>&lt;<span class="type">InvitationInfoResponseDto</span>.<span class="type">Award</span>&gt;, redeemHistory: <span class="type">List</span>&lt;<span class="type">InvitationRedeemHistoryModel</span>&gt;</span></span></span><br><span class="line"><span class="params"><span class="function">  )</span></span> = awards.forEach &#123; award -&gt;</span><br><span class="line">      award.redeemed = redeemHistory.any &#123; it.awardId == award.id &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">fun</span> <span class="title">fillAwardEnable</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">      awards: <span class="type">List</span>&lt;<span class="type">InvitationInfoResponseDto</span>.<span class="type">Award</span>&gt;, userId: <span class="type">Int</span>, invitedCount: <span class="type">Int</span>, subscription: <span class="type">SubscriptionModel</span>?</span></span></span><br><span class="line"><span class="params"><span class="function">  )</span></span> &#123;</span><br><span class="line">      awards.forEach &#123; award -&gt;</span><br><span class="line">          award.enable = (invitedCount &gt;= award.triggerCount!!) &amp;&amp; !award.redeemed!!</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">val</span> standardAward = awards.single &#123; it.membershipLevel == MembershipLevel.STANDARD &#125;</span><br><span class="line">      <span class="comment">// 特殊case1：只要高级有效(要么购买要么兑换)，普通奖励就置灰</span></span><br><span class="line">      <span class="keyword">if</span> (subscription?.membershipLevel == MembershipLevel.PREMIUM) &#123;</span><br><span class="line">          standardAward.enable = <span class="literal">false</span></span><br><span class="line">      &#125;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>一个经验：在重构一个大方法时，预想拆分成多个子方法，每个方法写成完全无副作用、无级联方法调用，这样做的结果是子方法包含很多高阶方法，可读性相较于前，差了不少。</p>
</blockquote>
<h2 id="不要过分纠结BDD风格"><a href="#不要过分纠结BDD风格" class="headerlink" title="不要过分纠结BDD风格"></a>不要过分纠结BDD风格</h2><p>BDD风格即所谓的 given - when - then 结构（mock数据 - 执行被测方法 - 断言判断），AssertJ提供BDD风格的断言。但given阶段由Mock库决定，then阶段由断言库决定。这两个库通常还不是一个，所以API很可能组合不出预想的效果。还不如老老实实用every{}进行mock，assertThat()进行断言，约定俗成，言简意赅，大家都懂。</p>
<h1 id="Repository测试"><a href="#Repository测试" class="headerlink" title="Repository测试"></a>Repository测试</h1><p>对该层的测试难点及解决方法如下</p>
<ul>
<li><p>数据库环境难以搭建</p>
<p>对于MySQL，还有嵌入式数据库H2可供选择。但对于PostgreSQL，有一个更好的选择：<a href="https://github.com/zonkyio/embedded-postgres">embedded-postres</a>，测试期间启动数据库，支持PG11版本以上，支持run in docker。这是真实的环境，应该说是绝佳选择了。</p>
</li>
<li><p>MyBatis Plus写的如何测试</p>
<p>MyBatsi Plus有提供<a href="https://baomidou.com/pages/b7dae0/">测试支持</a>，仅加载数据库相关内容。</p>
</li>
</ul>
<p>如下自定义的注解，包含了所有测试必须的内容</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Inherited</span></span><br><span class="line"><span class="meta">@Documented</span></span><br><span class="line"><span class="meta">@Target(ElementType.TYPE)</span></span><br><span class="line"><span class="meta">@Retention(RetentionPolicy.RUNTIME)</span></span><br><span class="line"><span class="comment">// mybatis plus的测试支持</span></span><br><span class="line"><span class="meta">@MybatisPlusTest</span></span><br><span class="line"><span class="comment">// 关闭测试完成后的事务回滚（@MybatisPlusTest默认开启，但我们是单元测试单独的环境，测试完成后会被销毁，因此不需要）</span></span><br><span class="line"><span class="meta">@Transactional(propagation = Propagation.NOT_SUPPORTED)</span></span><br><span class="line"><span class="comment">// 导入自定义的针对MyBatis的配置，主要是Mapper扫描位置</span></span><br><span class="line"><span class="meta">@Import(MyBatisConfig.class)</span></span><br><span class="line"><span class="comment">// 扫描dao、model等内容</span></span><br><span class="line"><span class="meta">@ComponentScan(&quot;com.project5e.app.mylog.repo&quot;)</span></span><br><span class="line"><span class="comment">// PG的嵌入式数据库开启</span></span><br><span class="line"><span class="meta">@AutoConfigureEmbeddedDatabase(type = AutoConfigureEmbeddedDatabase.DatabaseType.POSTGRES, refresh = AutoConfigureEmbeddedDatabase.RefreshMode.AFTER_EACH_TEST_METHOD)</span></span><br><span class="line"><span class="comment">// 嵌入式数据库的初始化走Flyway</span></span><br><span class="line"><span class="meta">@FlywayTest</span></span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> RepositoryTest &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="测什么-2"><a href="#测什么-2" class="headerlink" title="测什么"></a>测什么</h2><ul>
<li>测试表完整性</li>
<li>测试SQL正确性</li>
</ul>
<h2 id="关于Flyway"><a href="#关于Flyway" class="headerlink" title="关于Flyway"></a>关于Flyway</h2><p>flyway的使用，自行查阅手册，在这里的作用是：embedded-postres在启动本地数据库后，将使用flyway对数据库初始化。所以，src/db/migration下的sql必须组成一个完整的数据表环境。</p>
<p><img src="https://gdz.oss-cn-shenzhen.aliyuncs.com/local/image-20220305185526827.png" alt="image-20220305185526827"></p>
<h2 id="表完整性测试"><a href="#表完整性测试" class="headerlink" title="表完整性测试"></a>表完整性测试</h2><p>包括如下内容</p>
<ul>
<li>不可空字段检查</li>
<li>可空或具有默认值的字段检查</li>
<li>唯一索引检查</li>
</ul>
<p>由于每个表都需要进行完整性测试，因此我们写成一个抽象类。子类需要提供预期不允许为空的字段列表、具有默认值字段和默认值映射、唯一索引和用于测试它们的数据。</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">RepositoryIntegrityTest</span>&lt;<span class="type">M : BaseMapper&lt;T</span>&gt;, <span class="type">T&gt; &#123;</span></span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 非空且无默认值的字段</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">abstract</span> <span class="keyword">val</span> nonNullableWithoutDefaultValueFields: List&lt;KMutableProperty&lt;*&gt;&gt;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 可空或有默认值的字段</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">abstract</span> <span class="keyword">val</span> nullableOrDefaultFields: Map&lt;KMutableProperty&lt;*&gt;, Any?&gt;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 唯一索引列表和测试它们的数据（当存在多个唯一索引时，测试数据不好造，还是交给实现类比较好）</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">abstract</span> <span class="keyword">val</span> uniqueIndexesWithTestData: Map&lt;List&lt;KMutableProperty&lt;*&gt;&gt;, List&lt;T&gt;&gt;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">abstract</span> <span class="function"><span class="keyword">fun</span> <span class="title">getDao</span><span class="params">()</span></span>: ServiceImpl&lt;M, T&gt;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 提供一个所有字段都不为空的基础model，用于测试</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">abstract</span> <span class="function"><span class="keyword">fun</span> <span class="title">createModelWithAllFieldNotNull</span><span class="params">()</span></span>: T</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">fun</span> `validate <span class="keyword">when</span> field <span class="title">absent</span> <span class="params">(without default value)</span></span>`() &#123;</span><br><span class="line">        assertAll &#123;</span><br><span class="line">            nonNullableWithoutDefaultValueFields.forEach &#123; prop -&gt;</span><br><span class="line">                <span class="comment">// 待测字段填充null</span></span><br><span class="line">                <span class="keyword">val</span> mockModel = createModelWithAllFieldNotNull().apply &#123; prop.setter.call(<span class="keyword">this</span>, <span class="literal">null</span>) &#125;</span><br><span class="line">                <span class="comment">// 填充null的字段都有应该报错</span></span><br><span class="line">                <span class="keyword">val</span> result = Result.runCatching &#123; getDao().save(mockModel) &#125;</span><br><span class="line">                assertThat(result, prop.name).isFailure().matchesPredicate &#123;</span><br><span class="line">                    <span class="keyword">val</span> nameInDb = StringUtils.camelToUnderline(prop.name)</span><br><span class="line">                    it.message!!.contains(<span class="string">&quot;&quot;&quot;null value in column &quot;<span class="variable">$nameInDb</span>&quot; violates not-null constraint&quot;&quot;&quot;</span>)</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">fun</span> `validate <span class="keyword">when</span> field <span class="title">absent</span> <span class="params">(with default value)</span></span>`() &#123;</span><br><span class="line">        <span class="comment">// 清空数据库</span></span><br><span class="line">        clearTable()</span><br><span class="line">        <span class="comment">// 字段填充null</span></span><br><span class="line">        <span class="keyword">val</span> mockModel = createModelWithAllFieldNotNull().apply &#123;</span><br><span class="line">            nullableOrDefaultFields.forEach &#123; (prop, _) -&gt;</span><br><span class="line">                prop.setter.call(<span class="keyword">this</span>, <span class="literal">null</span>)</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 保存然后查出</span></span><br><span class="line">        getDao().save(mockModel)</span><br><span class="line">        <span class="keyword">val</span> insertedModel = getDao().list().first()</span><br><span class="line">        <span class="comment">// 所有设置为null的字段查询结果都应该与预期的一致</span></span><br><span class="line">        assertAll &#123;</span><br><span class="line">            nullableOrDefaultFields.forEach &#123; (prop, expectedValue) -&gt;</span><br><span class="line">                <span class="keyword">if</span> (expectedValue != <span class="literal">null</span> &amp;&amp; expectedValue::<span class="class"><span class="keyword">class</span> == <span class="title">Any</span>:<span class="type">:class) &#123;</span></span></span><br><span class="line">                    assertThat(prop.getter.call(insertedModel), prop.name).isNotNull()</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    assertThat(prop.getter.call(insertedModel), prop.name).isEqualTo(expectedValue)</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">fun</span> `validate unique constraint`<span class="params">()</span></span> &#123;</span><br><span class="line">        clearTable()</span><br><span class="line">        <span class="comment">// 构建两个拥有一样字段值的对象</span></span><br><span class="line">        assertAll &#123;</span><br><span class="line">            uniqueIndexesWithTestData.forEach &#123; (index, testModels) -&gt;</span><br><span class="line">                <span class="keyword">val</span> result = Result.runCatching &#123; getDao().saveBatch(testModels) &#125;</span><br><span class="line">                assertThat(result, index.toString()).isFailure().isInstanceOf(DuplicateKeyException::<span class="class"><span class="keyword">class</span>)</span></span><br><span class="line">                    .matchesPredicate &#123;</span><br><span class="line">                        it.message!!.contains(<span class="string">&quot;already exists&quot;</span>)</span><br><span class="line">                    &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">clearTable</span><span class="params">()</span></span> &#123;</span><br><span class="line">        getDao().ktUpdate().remove()</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>以表senior_user为例，实现它如下</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="meta">@RepositoryTest</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SeniorTest</span> : <span class="type">RepositoryIntegrityTest</span>&lt;<span class="type">SeniorUserMapper, SeniorUserModel</span>&gt;</span>() &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">lateinit</span> <span class="keyword">var</span> seniorUserDao: SeniorUserDao</span><br><span class="line"></span><br><span class="line">    <span class="keyword">override</span> <span class="keyword">val</span> nonNullableWithoutDefaultValueFields: List&lt;KMutableProperty&lt;*&gt;&gt; = listOf(</span><br><span class="line">        SeniorUserModel::id</span><br><span class="line">    )</span><br><span class="line"></span><br><span class="line">    <span class="keyword">override</span> <span class="keyword">val</span> nullableOrDefaultFields: Map&lt;KMutableProperty&lt;*&gt;, Any?&gt; = mapOf(</span><br><span class="line">        SeniorUserModel::createdTime to Any(),</span><br><span class="line">        SeniorUserModel::updatedTime to Any(),</span><br><span class="line">        SeniorUserModel::redeemed to <span class="literal">false</span></span><br><span class="line">    )</span><br><span class="line"></span><br><span class="line">    <span class="keyword">override</span> <span class="keyword">val</span> uniqueIndexesWithTestData: Map&lt;List&lt;KMutableProperty&lt;*&gt;&gt;, List&lt;SeniorUserModel&gt;&gt; = mapOf(</span><br><span class="line">        listOf(SeniorUserModel::id) to listOf(createModelWithAllFieldNotNull(), createModelWithAllFieldNotNull())</span><br><span class="line">    )</span><br><span class="line"></span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">getDao</span><span class="params">()</span></span>: ServiceImpl&lt;SeniorUserMapper, SeniorUserModel&gt; &#123;</span><br><span class="line">        <span class="keyword">return</span> seniorUserDao</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">createModelWithAllFieldNotNull</span><span class="params">()</span></span>: SeniorUserModel &#123;</span><br><span class="line">        <span class="keyword">return</span> SeniorUserModel().apply &#123;</span><br><span class="line">            <span class="keyword">this</span>.id = MOCK_USER_ID.toLong()</span><br><span class="line">            <span class="keyword">this</span>.createdTime = OffsetDateTime.now()</span><br><span class="line">            <span class="keyword">this</span>.updatedTime = OffsetDateTime.now()</span><br><span class="line">            <span class="keyword">this</span>.redeemed = <span class="literal">false</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="SQL正确性测试"><a href="#SQL正确性测试" class="headerlink" title="SQL正确性测试"></a>SQL正确性测试</h2><p>通常的做法是：构建mock数据，插入数据库 -&gt; 调用被测SQL -&gt; 判断结果</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">fun</span> `test update user info partially`<span class="params">()</span></span> &#123;</span><br><span class="line">  <span class="comment">// 清空表</span></span><br><span class="line">  clearTable()</span><br><span class="line">  <span class="comment">// 构建测试数据</span></span><br><span class="line">  <span class="keyword">val</span> oldModel = createModelWithAllFieldNotNull()</span><br><span class="line">  userDao.save(oldModel)</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 调用被测SQL方法</span></span><br><span class="line">  <span class="keyword">val</span> mockUserId = MOCK_USER_ID</span><br><span class="line">  <span class="keyword">val</span> mockUserName = MOCK_USER_NAME + <span class="string">&quot;gt&quot;</span></span><br><span class="line">  <span class="keyword">val</span> mockRequest = UserUpdateReq().apply &#123;</span><br><span class="line">    <span class="keyword">this</span>.name = mockUserName</span><br><span class="line">  &#125;</span><br><span class="line">  userDao.updateUserInfo(mockUserId, mockRequest)</span><br><span class="line">  <span class="comment">// 取出数据</span></span><br><span class="line">  <span class="keyword">val</span> newModel = userDao.getById(mockUserId)</span><br><span class="line">	<span class="comment">// 判断结果</span></span><br><span class="line">  assertThat(newModel.id).isEqualTo(mockUserId)</span><br><span class="line">  assertThat(newModel.name).isEqualTo(mockRequest.name)</span><br><span class="line">  assertThat(newModel.avatar).isEqualTo(oldModel.avatar)</span><br><span class="line">  assertThat(newModel.description).isEqualTo(oldModel.description)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>被测SQL如下（当然它也不一定是个SQL，也可能是基于底层库构建的对数据库的操作，比如这里）</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">updateUserInfo</span><span class="params">(id: <span class="type">Int</span>, request: <span class="type">UserUpdateReq</span>)</span></span>: <span class="built_in">Boolean</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> UserModel(</span><br><span class="line">    id = id,</span><br><span class="line">    name = request.name,</span><br><span class="line">    avatar = request.avatar,</span><br><span class="line">    description = request.description,</span><br><span class="line">  ).run &#123; updateById() &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="MyBatis-Plus的SQL写在哪里"><a href="#MyBatis-Plus的SQL写在哪里" class="headerlink" title="MyBatis Plus的SQL写在哪里"></a>MyBatis Plus的SQL写在哪里</h2><p>MyBatis Plus提供了类<code>public class ServiceImpl&lt;M extends BaseMapper&lt;T&gt;, T&gt; implements IService&lt;T&gt;</code>，提供三个能力</p>
<ul>
<li>快捷方法，如save、list、getById等</li>
<li>提供写SQL的DSL能力</li>
<li>提供baseMapper，对mapper直接调用</li>
</ul>
<p>如此方便，以至于很多业务将Service类继承了它，省去了定义DAO的麻烦。个人认为，这样做在能力1和能力3的使用上都没有问题，但利用DSL构建SQL的能力对Service层造成了入侵，至少它不是容易测试的代码：</p>
<ul>
<li>如果构建的SQL DSL和业务代码混在一起，则根本无法测试</li>
<li>如果将其提成一个单独的方法，那为什么不专门定义一个DAO来负责呢？能力1和能力3调用的方便性没有变差，能力2也得到了的有效管控</li>
</ul>
<p>所以我的看法是：应该将ServiceImpl锁定在DAO里，不要侵入到业务代码。</p>
<h2 id="测试锁"><a href="#测试锁" class="headerlink" title="测试锁"></a>测试锁</h2><p>如下SQL如何测试，测试重点在于FOR UPDATE</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">lockUser</span><span class="params">(userId: <span class="type">Int</span>)</span></span> &#123;</span><br><span class="line">  ktQuery()</span><br><span class="line">  .eq(UserModel::id, userId)</span><br><span class="line">  .last(<span class="string">&quot;FOR UPDATE&quot;</span>)</span><br><span class="line">  .list()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>分析难点及解决方案</p>
<ul>
<li><p>需要在两个并发的事物中分别调用才能测试</p>
<p>可以利用线程+手动管理事务+延迟</p>
</li>
<li><p>如何验证是否成功</p>
<p>使用<code>SELECT XXXX FOR UPDATE NOWAIT</code>语句，检测到锁冲突时马上报错</p>
</li>
</ul>
<p>于是代码可以如下</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 事务管理器，直接注入即可</span></span><br><span class="line"><span class="meta">@Autowired</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">lateinit</span> <span class="keyword">var</span> tm: DataSourceTransactionManager</span><br><span class="line"></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">fun</span> `test lock user`<span class="params">()</span></span> &#123;</span><br><span class="line">  <span class="comment">// 注意latch的使用</span></span><br><span class="line">  <span class="keyword">val</span> latch = CountDownLatch(<span class="number">2</span>)</span><br><span class="line"></span><br><span class="line">  <span class="keyword">val</span> transaction1 = Runnable &#123;</span><br><span class="line">    <span class="comment">// 注意编程式事务的使用方式</span></span><br><span class="line">    <span class="keyword">val</span> transactionStatus = tm.getTransaction(TransactionDefinition.withDefaults())</span><br><span class="line">    userDao.lockUser(MOCK_USER_ID)</span><br><span class="line">    TimeUnit.SECONDS.sleep(<span class="number">2</span>)</span><br><span class="line">    tm.commit(transactionStatus)</span><br><span class="line">    latch.countDown()</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">val</span> transaction2 = Runnable &#123;</span><br><span class="line">    TimeUnit.SECONDS.sleep(<span class="number">1</span>)</span><br><span class="line">    <span class="keyword">val</span> transactionStatus = tm.getTransaction(TransactionDefinition.withDefaults())</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">      assertThat &#123;</span><br><span class="line">        userDao.ktQuery().eq(UserModel::id, MOCK_USER_ID).last(<span class="string">&quot;FOR UPDATE NOWAIT&quot;</span>).list()</span><br><span class="line">      &#125;.isFailure().isInstanceOf(CannotAcquireLockException::<span class="class"><span class="keyword">class</span>)</span></span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">      tm.commit(transactionStatus)</span><br><span class="line">      latch.countDown()</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  Thread(transaction1).start()</span><br><span class="line">  Thread(transaction2).start()</span><br><span class="line">  latch.await()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="问题记录"><a href="#问题记录" class="headerlink" title="问题记录"></a>问题记录</h1><ul>
<li><p>使用@WebMvcTest单独测试Controller时，报错：无法找到xxxMapper</p>
<p>原因：默认情况下，@WebMvcTest会将SpringBootApplication注解的那个启动类当做配置主类，而之前将@MapperScan写在了上面。</p>
<p>解决：将@MapperScan转移到单独的配置文件中。同时也提醒：配置不要乱放</p>
</li>
<li><p>logback-test.xml中指定的日志等级不生效</p>
<p>原因：如果在src/main/resources/application.properties中指定了logging.root.level，在配置文件中的等级就不会生效</p>
<p>解决：移除logging.root.level</p>
<p>要彻底解决，可以参考<a href="https://www.notion.so/TDD-e8c9e51b1c28483c890a9a3ddc12338d#1fea41c4163f4fc7a64c75aa756b7f4c">这篇文章</a></p>
</li>
<li><p>配置问题：Controller测试过程中发现一些针对Web的配置未生效</p>
<p>原因：配置类未被@WebMvcTest加载</p>
<p>解决：手动导入自定义的Web配置</p>
</li>
<li><p>Kotlin兼容性问题：@NotBlank对写在构造方法中的Kotlin属性不生效</p>
<p>原因：验证库和Kotlin的兼容性问题</p>
<p>解决：使用@field:NotBlank或者将属性从构造方法移到类体</p>
</li>
<li><p>MockK无法调用、mock私有方法</p>
<p>解决：MockK提供这样的功能，但使用起来不是很方便。所以这个问题尚未有较好的解决方式</p>
</li>
</ul>
<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>我花了两周去了解单元测试常用技术，细读JUnit用户手册，浏览了Spring Boot Test手册（但是忘记看Spring Test手册，是说用的时候觉得哪里不对，😓），去了解了如何正确地写单元测试。又花了两周对每记后端项目进行TDD重构，先后尝试了Mockito、AssertJ和MockK、AssertK，发现用Kotlin时，MockK比Mockito香得不是一点点（Mockito写得像Java，mock静态方法时还得打补丁，对Kotlin DSL的补丁看起来并不特别好；MockK就不一样了，功能全面，使用优雅）。</p>
<p>在补单元测试时，还修复了一些之前没注意也没测出来的bug，所谓矫枉过正，现在的我觉得没有单元测试的代码，是非常不可靠的。</p>
<p>本周开发新功能时，同步添加单元测试。两点感受颇深</p>
<ul>
<li>写起来确实放心不少。写测试的过程中，已经细细品过很多边缘case了。也省去了本地启动服务一遍遍手动测试的麻烦。</li>
<li>是真的挺花费时间。扪心自问，如果进度要求再急一点，这单元测试可能写不下去，还得后面补。所以，要给自己预留充足的时间。</li>
</ul>
<p>回看刚写的这些单测，还是有很多问题的</p>
<ul>
<li>case数量多，当前有将近300个case（算上条件测试）。根据80%的bug出在20%代码中的定律，可以依靠经验识别容易出问题的地方，集中测试，其它地方，相对可以放松警惕。这样能够节省写单测时间</li>
<li>测试速度慢，CI机上跑完所有case需要2:30左右。速度有待优化</li>
<li>测试代码质量有待加强</li>
</ul>
<p>而就整个测试工作来说，要做的也还有很多</p>
<ul>
<li>集成测试：目前没有集成测试，所以各层的协作还是靠手动测试</li>
<li>CI+接口测试自动化：当前CI负责从构建、单元测试、发布应用的过程；还可以更加自动化：发布使用金丝雀，检测应用发布完成后对所有接口进行冒烟测试，测试通过再替换实际应用，否则就只发布金丝雀，从而最大程度降低发布风险。</li>
<li>推广单元测试：单测值得推广吗？肯定是值得的。但说实话，让我去写table应用的单元测试，我也会心生抗拒，毕竟case太多了。如果克服这些问题，让大家认真写测试，是个课题。</li>
</ul>
]]></content>
      <categories>
        <category>测试</category>
      </categories>
      <tags>
        <tag>测试</tag>
      </tags>
  </entry>
  <entry>
    <title>序列化探索之六 - Protobuf</title>
    <url>/2021/10/18/%E5%BA%8F%E5%88%97%E5%8C%96%E6%8E%A2%E7%B4%A2%E4%B9%8B%E5%85%AD%20-%20Protobuf-xu-lie-hua-tan-suo-zhi-liu--protobuf/</url>
    <content><![CDATA[<h1 id="序列化探索之Protobuf"><a href="#序列化探索之Protobuf" class="headerlink" title="序列化探索之Protobuf"></a>序列化探索之Protobuf</h1><p>Protobuf是谷歌提出的一种高压缩比的序列化格式，二进制，不可读，语言无关，平台无关。拥有自己的语法规则，压缩编码算法，并提供主流语言的API生成器（即Protobuf编译器），其序列化结果很小，能够有效节省带宽。</p>
<p>掌握Protobuf，需要比较了解三个方面，其中，如果只是单纯滴使用，前两个方面即可。</p>
<ul>
<li>proto语法规则，即proto文件的语法规则</li>
<li>具体语言的API生成及使用规则，即通过proto文件生成对应语言的代码</li>
<li>序列化和反序列化算法</li>
</ul>
<span id="more"></span>

<h2 id="语法"><a href="#语法" class="headerlink" title="语法"></a>语法</h2><p>截止目前，proto有两个版本，proto2和proto3，我们关注proto3。这里展示一个完整的场景，考虑一个获取资源的rpc协议</p>
<figure class="highlight protobuf"><table><tr><td class="code"><pre><span class="line">syntax = <span class="string">&quot;proto3&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;resource.proto&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">package</span> com.gitee.floyd.serialization.protobuf;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 一个类一个文件</span></span><br><span class="line"><span class="keyword">option</span> java_multiple_files = <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">service</span> <span class="title">ResourceService</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">rpc</span> getResource (GetResourceRequest) <span class="keyword">returns</span> (GetResourceResponse)</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">message</span> <span class="title">GetResourceRequest</span> </span>&#123;</span><br><span class="line">  <span class="built_in">int32</span> resourceId = <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">message</span> <span class="title">GetResourceResponse</span> </span>&#123;</span><br><span class="line">  Resource resource = <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>资源定义在这里</p>
<figure class="highlight protobuf"><table><tr><td class="code"><pre><span class="line">syntax = <span class="string">&quot;proto3&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;google/protobuf/any.proto&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">package</span> com.gitee.floyd.serialization.protobuf;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 定义资源类型</span></span><br><span class="line"><span class="class"><span class="keyword">message</span> <span class="title">Resource</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 编号1已经被以前使用了</span></span><br><span class="line">  reserved <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 类型枚举</span></span><br><span class="line">  <span class="class"><span class="keyword">enum</span> <span class="title">Type</span> </span>&#123;</span><br><span class="line">    RECORD = <span class="number">0</span>;</span><br><span class="line">    TAG = <span class="number">1</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 记录的具体内容</span></span><br><span class="line">  <span class="class"><span class="keyword">message</span> <span class="title">RecordData</span> </span>&#123;</span><br><span class="line">    <span class="built_in">string</span> content = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">repeated</span> <span class="built_in">string</span> images = <span class="number">2</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 标签的具体内容</span></span><br><span class="line">  <span class="class"><span class="keyword">message</span> <span class="title">TagData</span> </span>&#123;</span><br><span class="line">    <span class="built_in">string</span> title = <span class="number">1</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 资源ID</span></span><br><span class="line">  <span class="built_in">int32</span> id = <span class="number">2</span>;</span><br><span class="line">  <span class="comment">// 资源类型</span></span><br><span class="line">  Type type = <span class="number">3</span>;</span><br><span class="line">  <span class="comment">// 记录和标签同时只会出现一个</span></span><br><span class="line">  <span class="keyword">oneof</span> data &#123;</span><br><span class="line">    RecordData record = <span class="number">4</span>;</span><br><span class="line">    TagData tag = <span class="number">5</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 还可以塞一些其它的东西</span></span><br><span class="line">  google.protobuf.Any other = <span class="number">6</span>;</span><br><span class="line">  <span class="comment">// 以map的形式塞一些其它的东西</span></span><br><span class="line">  map&lt;<span class="built_in">string</span>, google.protobuf.Any&gt; otherMap = <span class="number">7</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>就上面用到的进行说明，也就七七八八了，其它的可以参考官方文档自己去补。</p>
<h3 id="proto结构"><a href="#proto结构" class="headerlink" title="proto结构"></a>proto结构</h3><ul>
<li>语法版本声明，如果不声明，默认为proto2</li>
<li>导入的proto依赖</li>
<li>包声明</li>
<li>可选参数设置</li>
<li>service声明</li>
<li>消息声明</li>
</ul>
<p>其中，除了消息声明，其它都不是必须的，主要的语法内容，也集中在消息声明</p>
<h3 id="数据类型"><a href="#数据类型" class="headerlink" title="数据类型"></a>数据类型</h3><p>完整的类型声明参考<a href="https://developers.google.com/protocol-buffers/docs/proto3#scalar">官方文档</a>，总结如下</p>
<ul>
<li>int32：占用字节数是变化的；能表示负数，但效率不是很高</li>
<li>uint32：占用字节数是变化的；无符号</li>
<li>sint32：占用字节数是变化的；能表示负数，效率较高</li>
<li>fixed32：定长，当数字真的非常大时，它比uint32更有效率</li>
<li>sfixed32：同上，只不过是有符号的</li>
<li>string：UTF8编码，最长2^32个字节</li>
<li>bytes：最长2^32个字节</li>
</ul>
<h3 id="枚举"><a href="#枚举" class="headerlink" title="枚举"></a>枚举</h3><p>枚举定义参考上面的Resource.Type，要点</p>
<ul>
<li>必须有一个的编号是0，以便设置默认值；且必须是第一个元素，以便于proto2兼容</li>
<li>由于其实际上是使用变长编码，因此编号尽量不好是负数</li>
</ul>
<h3 id="修饰"><a href="#修饰" class="headerlink" title="修饰"></a>修饰</h3><p><strong>repeated</strong></p>
<p>字段只有单数和复数，复数用repeated修饰符，对应的Java中的集合。</p>
<p><strong>oneof</strong></p>
<ul>
<li><p>可使用oneof设置字段多选一，但是使用之前需要使用hasxxx()方法查看是否有值。</p>
</li>
<li><p>oneof里面不能使用repeated</p>
</li>
<li><p>序列化时，如果为多个字段都设置值，只有最后一个设定的值会被保留，其它会被清除，反序列化同理</p>
</li>
<li><p>针对oneof的版本升级问题一般不建议做，会有丢失数据的问题</p>
<p>比如新版本将其中一个元素移出去了，那么新的协议得到的序列化结果用旧的协议来解析，则移出去那个元素有值，oneof本身内部有一个有效值，由于旧版本都在oneof内部，因此会丢失一个对新版本来说有效的值。</p>
</li>
</ul>
<p><strong>map</strong></p>
<ul>
<li>key可以是除了浮点数、bytes和枚举之外的任意值</li>
<li>value可以是除了map之外的任意值</li>
<li>map不能是repeated</li>
<li>map内顺序不被保证</li>
</ul>
<p><strong>Any</strong></p>
<ul>
<li>能够包含任意被序列化为bytes的类型</li>
<li>有专门的方法去包装和拆解它：pack()和unpack()</li>
</ul>
<h3 id="注意事项"><a href="#注意事项" class="headerlink" title="注意事项"></a>注意事项</h3><ul>
<li>一旦一个编号被使用，在之后的升级中，它将不能再被使用，否则会导致反序列化出错</li>
<li>字段编号并非无穷，在1到2^29次方之间；但19000到19999之间的是Protocol Buffers预留的，不能使用</li>
<li>如果不给字段赋值，将会设置为默认值，各种类型默认值如下<ul>
<li>字符串：空串</li>
<li>字节数组：空数组</li>
<li>bool：false</li>
<li>数字：0</li>
<li>枚举：编号是0的那个值</li>
<li>消息字段：取决于具体语言，Kotlin和Java中</li>
</ul>
</li>
<li>proto的导入不可跨层传递，除非用<code>import public</code>，但这在Java中是不支持的</li>
<li>protobuf可以和Json之间直接映射，有兴趣可以去研究一下</li>
</ul>
<h2 id="序列化算法"><a href="#序列化算法" class="headerlink" title="序列化算法"></a>序列化算法</h2><p>Protobuf序列化的目标单位是一条消息（message），其算法，就是一个压缩算法，总体要点有几个</p>
<ul>
<li>以序号替代字段名</li>
<li>对一般的数字类型和布尔采用变长表示法，这样一个int32类型的字段最低只要一个字节即可表示完成</li>
<li>将所有字段类型分为几类，分别有不同的表示方法</li>
<li>对string或自定义的结构化类型，只是多了一个长度标识</li>
</ul>
<h3 id="一个例子"><a href="#一个例子" class="headerlink" title="一个例子"></a>一个例子</h3><p>下面以一个序列化说明</p>
<figure class="highlight protobuf"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">message</span> <span class="title">Resource</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="class"><span class="keyword">message</span> <span class="title">Data</span> </span>&#123;</span><br><span class="line">		<span class="built_in">string</span> content = <span class="number">1</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="built_in">int32</span> id = <span class="number">1</span>;</span><br><span class="line">	<span class="built_in">string</span> type = <span class="number">2</span>;</span><br><span class="line">	Data data = <span class="number">3</span>;</span><br><span class="line">	</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>我们按照如下设置值</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">id = 2</span><br><span class="line"><span class="built_in">type</span> = <span class="string">&quot;R&quot;</span> <span class="comment"># UTF8编码为：</span></span><br><span class="line">data.content = <span class="string">&quot;我&quot;</span> <span class="comment"># UTF8编码为</span></span><br></pre></td></tr></table></figure>

<p>其对应的代码为</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">val</span> resourceBuilder = Resource.newBuilder()</span><br><span class="line">    <span class="keyword">val</span> <span class="keyword">data</span> = resourceBuilder.dataBuilder.setContent(<span class="string">&quot;我&quot;</span>).build()</span><br><span class="line">    <span class="keyword">val</span> resource = Resource.newBuilder()</span><br><span class="line">        .setId(<span class="number">2</span>)</span><br><span class="line">        .setType(<span class="string">&quot;R&quot;</span>)</span><br><span class="line">        .setData(<span class="keyword">data</span>)</span><br><span class="line">        .build()</span><br><span class="line">    <span class="keyword">val</span> buffer = ByteArrayOutputStream()</span><br><span class="line">    resource.writeTo(buffer)</span><br><span class="line">    println(buffer.toByteArray().toHexString())</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>它的序列化结果将是</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">08021201521a050a03e68891</span><br></pre></td></tr></table></figure>

<h3 id="前置知识"><a href="#前置知识" class="headerlink" title="前置知识"></a>前置知识</h3><p>二进制流组成：字段编号&lt;&lt;3 + 编码类型 + 字段值</p>
<p>字段值为复杂类型时，将会递归使用上述编码方式</p>
<p>编码类型如下</p>
<table>
<thead>
<tr>
<th align="left">Type</th>
<th align="left">Meaning</th>
<th align="left">Used For</th>
</tr>
</thead>
<tbody><tr>
<td align="left">0</td>
<td align="left">Varint</td>
<td align="left">int32, int64, uint32, uint64, sint32, sint64, bool, enum</td>
</tr>
<tr>
<td align="left">1</td>
<td align="left">64-bit</td>
<td align="left">fixed64, sfixed64, double</td>
</tr>
<tr>
<td align="left">2</td>
<td align="left">Length-delimited</td>
<td align="left">string, bytes, embedded messages, packed repeated fields</td>
</tr>
<tr>
<td align="left">3</td>
<td align="left">Start group</td>
<td align="left">groups (deprecated)</td>
</tr>
<tr>
<td align="left">4</td>
<td align="left">End group</td>
<td align="left">groups (deprecated)</td>
</tr>
<tr>
<td align="left">5</td>
<td align="left">32-bit</td>
<td align="left">fixed32, sfixed32, float</td>
</tr>
</tbody></table>
<h3 id="例子分析"><a href="#例子分析" class="headerlink" title="例子分析"></a>例子分析</h3><p>现在我们再来看上面的输出：</p>
<p>08 -&gt; 00001 000 ：字段编号为1，类型为0</p>
<p>02 -&gt; 0000 0010 ：字段值为2</p>
<p>12 -&gt; 00010 010 ：字段编号为2，类型为2，即复杂字段，这个类型的下一个字节标识了长度</p>
<p>01 -&gt; 0000 0001 ：字段编号为2的字段值长度为1</p>
<p>52 -&gt; 0101 0010 ：字段编号为2的字段值的UTF8编码，即”R“</p>
<p>1a -&gt; 00011 010 ：字段编号为3，类型为2</p>
<p>05 -&gt; 0000 0101 ：字段编号为3的字段值长度为5，对应我们的嵌套类型Data</p>
<p>​    0a -&gt; 00001 010 ：字段编号为1，类型为2</p>
<p>​    03 -&gt; 0000 0011 ：字段编号为1的字段值长度为3</p>
<p>​    e68891 -&gt; 字段编号为1的字段值的UTF8编码，即”我“</p>
<p>结束</p>
<h3 id="如何做到版本兼容"><a href="#如何做到版本兼容" class="headerlink" title="如何做到版本兼容"></a>如何做到版本兼容</h3><p>由于它是根据字段编号标识字段，反序列化时，遇到不认识的字段编号会直接忽略。因此版本兼容的方式就是，字段编号只增不减，不可与之前的编号复用。复用在protobuf里是绝对不允许的。</p>
<h2 id="API生成规则"><a href="#API生成规则" class="headerlink" title="API生成规则"></a>API生成规则</h2><p>使用protobuf编译器，能够生成对应语言的代码，我们主要看Java和Kotlin，由于Kotlin是在Java生成的基础上生成的，因此一起讲了。</p>
<p>其主要能力，是对proto中定义的消息进行构建，然后提供转换为流的方式；如果加上特定RPC插件，还可以生成Service的代码。</p>
<h3 id="Java文件生成"><a href="#Java文件生成" class="headerlink" title="Java文件生成"></a>Java文件生成</h3><ul>
<li>文件拆分：如果设置了<code>option java_multiple_files = true;</code>，则会按照顶层的Service和Message分别生成多个Java源文件</li>
<li>包名：如果设置了<code>option java_package = &quot;xx.xx.xx.xxx&quot;;</code>，则以它为准；否则以proto文件定义的package为准</li>
<li>字段名：proto中为小写+下划线，Java文件中转换为小驼峰命名</li>
</ul>
<h3 id="关键字段类型"><a href="#关键字段类型" class="headerlink" title="关键字段类型"></a>关键字段类型</h3><ul>
<li>repeated：转换为ProtocolStringList类型，其直接继承了java.util.List</li>
<li>枚举：转换为普通枚举类型，但是会多一个UNRECOGNIZE，表示未知参数</li>
<li>oneof：多选一的字段，每个字段都会生成一个<code>hasXXX()</code>方法，用以判断是否有值；也有提供<code>hasOneof()</code>，判断这几个字段是否有存在一个</li>
<li>map：转换为<code>java.util.Map</code>类型</li>
<li>Any：转换为<code>com.google.protobuf.Any</code>，它提供pack和unpack，用于将其它任意消息类型进行封装和解封</li>
</ul>
<h3 id="消息类型的构建"><a href="#消息类型的构建" class="headerlink" title="消息类型的构建"></a>消息类型的构建</h3><ul>
<li>消息是不可变的，一旦构建不可更改</li>
<li>消息构建采用建造器模式，典型地如<code>Resource.newBuilder().setType(Resource.Type.RECORD).build()</code></li>
<li>嵌套消息，其建造器也是嵌套的，嵌套在父建造器上：<code>Resource.newBuilder().recordBuilder.addImages(&quot;&quot;).build()</code></li>
</ul>
<h3 id="Service"><a href="#Service" class="headerlink" title="Service"></a>Service</h3><p>尽管我们在proto文件中定义了Service，但是脱离具体的RPC实现（比如gRPC），这个Service就没有意义。且一般的RPC实现会作为插件的形式载入（所以你看很多gradle中配置grpc是以插件的形式声明在protobuf块中的），生成两个部分</p>
<ul>
<li>服务抽象类：定义服务端，用户通过它实现自己的服务端逻辑</li>
<li>客户端Stub：定义客户端，用户通过它连接远端服务</li>
</ul>
<p>proto文件中存在<code>option java_generic_services = true;</code>时，会生成一个通用的Service实现。有兴趣可以看一下。</p>
<h3 id="其它"><a href="#其它" class="headerlink" title="其它"></a>其它</h3><ul>
<li>每个消息，还提供了Descriptor，用以描述其proto信息，类似反射，可以获取元信息，如果我们写自己的RPC插件，可以使用</li>
<li>每个消息，都提供<code>getDefaultInstance()</code>，返回一个空对象</li>
</ul>
<h3 id="来个例子（Java）"><a href="#来个例子（Java）" class="headerlink" title="来个例子（Java）"></a>来个例子（Java）</h3><p>这里仅展示将上面定义的Resource消息设置值，并将序列化结果以流的形式输出。</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">val</span> resourceBuilder = Resource.newBuilder()</span><br><span class="line">    <span class="keyword">val</span> record = resourceBuilder.recordBuilder</span><br><span class="line">        .addImages(<span class="string">&quot;https://hello.png&quot;</span>)</span><br><span class="line">        .addAllImages(listOf(<span class="string">&quot;https://key.png&quot;</span>, <span class="string">&quot;https://key2.png&quot;</span>))</span><br><span class="line">        .setContent(<span class="string">&quot;这是记录&quot;</span>)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">val</span> resource1 = resourceBuilder</span><br><span class="line">        .setId(<span class="number">1</span>)</span><br><span class="line">        .setType(Resource.Type.RECORD)</span><br><span class="line">        .setRecord(record)</span><br><span class="line">        .build()</span><br><span class="line"></span><br><span class="line">    <span class="keyword">val</span> resource2 = resourceBuilder</span><br><span class="line">        .setId(<span class="number">2</span>)</span><br><span class="line">        .setType(Resource.Type.RECORD)</span><br><span class="line">        .setOther(Any.pack(resource1))</span><br><span class="line">        .putOtherMap(<span class="string">&quot;key&quot;</span>, Any.pack(resource1))</span><br><span class="line">        .build()</span><br><span class="line"></span><br><span class="line">    ByteArrayOutputStream().run &#123;</span><br><span class="line">        resource2.writeTo(<span class="keyword">this</span>)</span><br><span class="line">        println(<span class="keyword">this</span>.toByteArray().toHexString())</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="来个例子（Kotlin）"><a href="#来个例子（Kotlin）" class="headerlink" title="来个例子（Kotlin）"></a>来个例子（Kotlin）</h3><p>Kotlin生成在Java之上，为我们提供了DSL，上面的代码，用DSL再写一遍，看起来明显好很多。</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">val</span> resource1 = resource &#123;</span><br><span class="line">        <span class="keyword">this</span>.id = <span class="number">1</span></span><br><span class="line">        <span class="keyword">this</span>.type = Resource.Type.RECORD</span><br><span class="line">        <span class="keyword">this</span>.record = ResourceKt.recordData &#123;</span><br><span class="line">            <span class="keyword">this</span>.images.add(<span class="string">&quot;https://hello.png&quot;</span>)</span><br><span class="line">            <span class="keyword">this</span>.images.addAll(listOf(<span class="string">&quot;https://key.png&quot;</span>, <span class="string">&quot;https://key2.png&quot;</span>))</span><br><span class="line">            <span class="keyword">this</span>.content = <span class="string">&quot;这是记录&quot;</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">val</span> resource2 = resource &#123;</span><br><span class="line">        <span class="keyword">this</span>.id = <span class="number">2</span></span><br><span class="line">        <span class="keyword">this</span>.type = Resource.Type.RECORD</span><br><span class="line">        <span class="keyword">this</span>.other = Any.pack(resource1)</span><br><span class="line">        <span class="keyword">this</span>.otherMap.put(<span class="string">&quot;key&quot;</span>, Any.pack(resource1))</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    ByteArrayOutputStream().run &#123;</span><br><span class="line">        resource2.writeTo(<span class="keyword">this</span>)</span><br><span class="line">        println(<span class="keyword">this</span>.toByteArray().toHexString())</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="环境问题"><a href="#环境问题" class="headerlink" title="环境问题"></a>环境问题</h2><p>API生成，可以有两种方式</p>
<ul>
<li>protoc命令行生成API，gradle只引入相关依赖。好处是简单；缺点是一次性，每次修改协议都要生成一次。</li>
<li>直接使用gradle插件，将protoc生成命令嵌入gradle生命周期。好处是一旦配置完成就一劳永逸；坏处是配置麻烦。</li>
</ul>
<p>protobuf简单是简单，但配置起来还是有几个问题的。问题主要在于kotlin代码的生成，gradle插件的配置</p>
<h3 id="关于protoc的安装"><a href="#关于protoc的安装" class="headerlink" title="关于protoc的安装"></a>关于protoc的安装</h3><p>需要在<a href="https://github.com/protocolbuffers/protobuf/releases/tag/v3.18.1">项目发布</a>页下载压缩包进行安装，macos直接选择对应的编译好的二进制包，有先尝试过直接<code>brew install protobuf</code>，结果它不包含protoc-kotlin-gen插件。</p>
<p><img src="https://gdz.oss-cn-shenzhen.aliyuncs.com/local/image-20211018112756901.png" alt="image-20211018112756901"></p>
<h3 id="包的引入"><a href="#包的引入" class="headerlink" title="包的引入"></a>包的引入</h3><p>协议相关包，在<a href="https://search.maven.org/search?q=g:com.google.protobuf">这里</a>才是最完整的，无论java也好，kotlin也好。</p>
<p><img src="https://gdz.oss-cn-shenzhen.aliyuncs.com/local/image-20211018112836558.png" alt="image-20211018112836558"></p>
<h3 id="Kotlin的生成"><a href="#Kotlin的生成" class="headerlink" title="Kotlin的生成"></a>Kotlin的生成</h3><p>kotlin API需要依赖java代码，因此要同时生成java</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ protoc --java_out=xxxxxx --kotlin_out=xxxxxx resource_service.proto</span><br></pre></td></tr></table></figure>

<p>生成的Java代码</p>
<p><img src="https://gdz.oss-cn-shenzhen.aliyuncs.com/local/%E6%88%AA%E5%B1%8F2021-10-18%20%E4%B8%8A%E5%8D%8811.40.08.png" alt="截屏2021-10-18 上午11.40.08"></p>
<p>生成的Kotlin代码</p>
<p><img src="https://gdz.oss-cn-shenzhen.aliyuncs.com/local/%E6%88%AA%E5%B1%8F2021-10-18%20%E4%B8%8A%E5%8D%8811.40.49.png" alt="截屏2021-10-18 上午11.40.49"></p>
<h3 id="Gradle插件"><a href="#Gradle插件" class="headerlink" title="Gradle插件"></a>Gradle插件</h3><p>插件的项目地址：<a href="https://github.com/google/protobuf-gradle-plugin">我是插件的项目地址</a></p>
<p>配置要点</p>
<ul>
<li>添加protobuf插件的依赖</li>
<li>通过sourceSets指定proto文件位置</li>
<li>protobuf.generatedFilesBaseDir指定代码生成位置</li>
<li>protobuf.protoc指定protoc的版本</li>
<li>protobuf.generateProtoTasks定制</li>
</ul>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line">buildscript &#123;</span><br><span class="line">    repositories &#123;</span><br><span class="line">        mavenCentral()</span><br><span class="line">    &#125;</span><br><span class="line">    dependencies &#123;</span><br><span class="line">        classpath(<span class="string">&quot;com.google.protobuf:protobuf-gradle-plugin:0.8.17&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">plugins &#123;</span><br><span class="line">    id(<span class="string">&quot;java&quot;</span>)</span><br><span class="line">    id(<span class="string">&quot;com.google.protobuf&quot;</span>) version <span class="string">&quot;0.8.17&quot;</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">sourceSets &#123;</span><br><span class="line">    main &#123;</span><br><span class="line">        proto &#123;</span><br><span class="line">            srcDir(<span class="string">&quot;src/main/resources/proto&quot;</span>)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">protobuf &#123;</span><br><span class="line">    generatedFilesBaseDir = <span class="string">&quot;<span class="variable">$projectDir</span>/src/generated&quot;</span></span><br><span class="line"></span><br><span class="line">    protoc &#123;</span><br><span class="line">        artifact = <span class="string">&quot;com.google.protobuf:protoc:3.18.1&quot;</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    generateProtoTasks &#123;</span><br><span class="line">        all().forEach &#123; task -&gt;</span><br><span class="line">            task.builtins &#123;</span><br><span class="line">                java &#123; &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>kotlin代码的插件配置方式，暂时还没找到</p>
</blockquote>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>Protobuf优点众多：语法简单；编码算法使得结果非常小巧；编码算法也不难理解；对主流语言提供了API生成支持。但代码生成这种方式增加了构建时间，实际体验并不是很好。</p>
<p>有关更多内容，请需要参考官方文档</p>
<p><a href="https://developers.google.com/protocol-buffers/docs/proto3">语法说明</a></p>
<p><a href="https://developers.google.com/protocol-buffers/docs/encoding">编码方式</a></p>
<p><a href="https://developers.google.com/protocol-buffers/docs/reference/java-generated">Java API生成说明</a></p>
<p><a href="https://developers.google.com/protocol-buffers/docs/reference/kotlin-generated#nested-types">Kotlin API生成说明</a></p>
<p><a href="https://github.com/google/protobuf-gradle-plugin">gradle插件</a></p>
]]></content>
      <categories>
        <category>后端</category>
      </categories>
      <tags>
        <tag>序列化</tag>
      </tags>
  </entry>
  <entry>
    <title>序列化探索之三 - Jackson</title>
    <url>/2021/10/14/%E5%BA%8F%E5%88%97%E5%8C%96%E6%8E%A2%E7%B4%A2%E4%B9%8B%E4%B8%89%20-%20Jackson-xu-lie-hua-tan-suo-zhi-san--jackson/</url>
    <content><![CDATA[<p>写这篇文章时，我一度陷入了纠结与不安，再次体会到了聚焦的重要性。Jackson看似简单，实则功能强大，这两天有些迷失，不知道要看些什么，要写些什么。但路得一步一步走，饭得一口一口吃，纵使它可供探索的点繁如星辰，我也得将焦点拉回，否则就叫失控。至于其它的点，以后再说。因此，本文将聚焦如下几点</p>
<ul>
<li>Jackson的能力</li>
<li>基本原理</li>
<li>module工作原理</li>
</ul>
<span id="more"></span>

<h2 id="基本组成"><a href="#基本组成" class="headerlink" title="基本组成"></a>基本组成</h2><p>Jackson文档怎么看，是一个问题。如果初次接触Jackson，看<a href="https://github.com/FasterXML/jackson">主项目的介绍</a>半个小时，多半还是云里雾里，我认为这是Jackson文档做的很不好的一点，并没有一个Guide，而是需要自己一个一个项目看，而如果你恰巧点到了第三方module，就更不知道它在说什么了。</p>
<p>总的说来，Jackson由三部分组成</p>
<ul>
<li>Jackson-core：提供低层级的流式API，灵活程度高，效率高，但易用性差</li>
<li>Jackson-annotations：提供注解定义，这些注解是与我么打交道最多的</li>
<li>Jackson-databind：在前两个部分的基础上封装了一层，提供序列化和反序列化功能，我们直接使用的API，基本都来自于此。</li>
</ul>
<p>在jackson-databind中，提供了可插入的module机制，允许第三方定义自己的类型转换库，通过ObjectMapper().registerModule的方式注册，常见的有</p>
<ul>
<li>针对java.time包下的时间的类型库</li>
<li>针对kotlin的类型库</li>
<li>好多其它的</li>
</ul>
<p>又，Jackson并非仅仅针对Json，还支持Protobuf、TOML、Yaml等诸多格式，他们是通过自定义jackson-core提供的流式API和Codec实现的。</p>
<p>还有，Jackson中的很多概念都和kotlinx.serialization类似，学习过程中可做类比，加深印象。</p>
<h2 id="能力"><a href="#能力" class="headerlink" title="能力"></a>能力</h2><p>Jackson提供三种方式进行序列化和反序列化</p>
<ul>
<li>低层级的流式API，直接控制基础token的写入（要理解Jackson所谓的token，一个字符、一个起始符，都是token）</li>
<li>ObjectMapper，直接进行POJO和json之间的转换，也可以进行POJO和POJO之间的转换，但原理是一样的。</li>
<li>基于TreeModel，脱离POJO直接构建json结构</li>
</ul>
<h3 id="流式API"><a href="#流式API" class="headerlink" title="流式API"></a>流式API</h3><p>要想快，就用流式API，只需引入jackson-core，这里简单展示</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ResourceWithStream</span> </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> resourceId: String? = <span class="literal">null</span></span><br><span class="line">    <span class="keyword">var</span> resourceType: String? = <span class="literal">null</span></span><br><span class="line">    <span class="keyword">var</span> usn: <span class="built_in">Long</span>? = <span class="literal">null</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">toString</span><span class="params">()</span></span>: String &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;ResourceWithStream(resourceId=<span class="variable">$resourceId</span>, resourceType=<span class="variable">$resourceType</span>, usn=<span class="variable">$usn</span>)&quot;</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="function"><span class="keyword">fun</span> JsonGenerator.<span class="title">encoding</span><span class="params">(resource: <span class="type">ResourceWithStream</span>)</span></span> &#123;</span><br><span class="line">    <span class="keyword">this</span>.writeStartObject()</span><br><span class="line">    <span class="keyword">this</span>.writeStringField(<span class="string">&quot;resourceId&quot;</span>, resource.resourceId)</span><br><span class="line">    <span class="keyword">this</span>.writeStringField(<span class="string">&quot;resourceType&quot;</span>, resource.resourceType)</span><br><span class="line">    resource.usn.let &#123; usn -&gt;</span><br><span class="line">        <span class="keyword">this</span>.writeFieldName(<span class="string">&quot;usn&quot;</span>)</span><br><span class="line">        <span class="keyword">if</span> (usn == <span class="literal">null</span>) <span class="keyword">this</span>.writeNull()</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">this</span>.writeNumber(usn)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">this</span>.writeEndObject()</span><br><span class="line">    <span class="keyword">this</span>.close()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="function"><span class="keyword">fun</span> JsonParser.<span class="title">decoding</span><span class="params">()</span></span>: ResourceWithStream &#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">this</span>.nextToken() != JsonToken.START_OBJECT) <span class="keyword">throw</span> Exception(<span class="string">&quot;没有以对象起头&quot;</span>)</span><br><span class="line">    <span class="keyword">return</span> ResourceWithStream().also &#123;</span><br><span class="line">        <span class="keyword">while</span> (<span class="keyword">this</span>.nextToken() != JsonToken.END_OBJECT) &#123;</span><br><span class="line">            <span class="keyword">when</span> (<span class="keyword">this</span>.currentName) &#123;</span><br><span class="line">                <span class="string">&quot;resourceId&quot;</span> -&gt; it.resourceId = <span class="keyword">this</span>.valueAsString</span><br><span class="line">                <span class="string">&quot;resourceType&quot;</span> -&gt; it.resourceType = <span class="keyword">this</span>.valueAsString</span><br><span class="line">                <span class="string">&quot;usn&quot;</span> -&gt; it.usn = <span class="keyword">this</span>.valueAsLong</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">this</span>.close()</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">val</span> resource = ResourceWithStream().apply &#123;</span><br><span class="line">        <span class="keyword">this</span>.resourceId = <span class="string">&quot;1&quot;</span></span><br><span class="line">        <span class="keyword">this</span>.resourceType = <span class="string">&quot;record&quot;</span></span><br><span class="line">        <span class="keyword">this</span>.usn = <span class="number">123456</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">val</span> bos = ByteArrayOutputStream()</span><br><span class="line">    <span class="keyword">val</span> jsonFactory = JsonFactoryBuilder().build()</span><br><span class="line">    <span class="comment">// 序列化</span></span><br><span class="line">    <span class="keyword">val</span> jsonGenerator = jsonFactory.createGenerator(bos)</span><br><span class="line">    jsonGenerator.encoding(resource)</span><br><span class="line">    println(bos.toString())</span><br><span class="line">    <span class="comment">// 反序列化</span></span><br><span class="line">    <span class="keyword">val</span> jsonParser = jsonFactory.createParser(bos.toByteArray())</span><br><span class="line">    println(jsonParser.decoding())</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>输出</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">&#123;<span class="string">&quot;resourceId&quot;</span>:<span class="string">&quot;1&quot;</span>,<span class="string">&quot;resourceType&quot;</span>:<span class="string">&quot;record&quot;</span>,<span class="string">&quot;usn&quot;</span>:123456&#125;</span><br><span class="line">ResourceWithStream(resourceId=1, resourceType=record, usn=123456)</span><br></pre></td></tr></table></figure>

<h3 id="注解"><a href="#注解" class="headerlink" title="注解"></a>注解</h3><p>Jackson的注解可就多了去了，一个简单而骚气的展示：序列化时将Map类型的数据提取到顶层，反序列化时再将这些数据塞回去。</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Resource2</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">var</span> resourceId: String? = <span class="literal">null</span></span><br><span class="line"></span><br><span class="line">    <span class="meta">@JsonIgnore</span></span><br><span class="line">    <span class="keyword">var</span> <span class="keyword">data</span>: MutableMap&lt;String, Any&gt;? = mutableMapOf()</span><br><span class="line"></span><br><span class="line">    <span class="meta">@JsonAnySetter</span></span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">add</span><span class="params">(key: <span class="type">String</span>, value: <span class="type">String</span>)</span></span> &#123;</span><br><span class="line">        <span class="keyword">data</span>?.put(key, value)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@JsonAnyGetter</span></span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">getOther</span><span class="params">()</span></span>: MutableMap&lt;String, Any&gt;? = <span class="keyword">data</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">toString</span><span class="params">()</span></span>: String &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;Resource2(resourceId=<span class="variable">$resourceId</span>, data=<span class="variable">$data</span>)&quot;</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">val</span> resource = Resource2().apply &#123;</span><br><span class="line">        <span class="keyword">this</span>.resourceId = <span class="string">&quot;资源ID&quot;</span></span><br><span class="line">        <span class="keyword">this</span>.<span class="keyword">data</span> = mutableMapOf(</span><br><span class="line">            <span class="string">&quot;key&quot;</span> to <span class="string">&quot;value&quot;</span>,</span><br><span class="line">            <span class="string">&quot;key2&quot;</span> to <span class="string">&quot;value2&quot;</span>,</span><br><span class="line">            <span class="string">&quot;key3&quot;</span> to <span class="string">&quot;value3&quot;</span></span><br><span class="line">        )</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">val</span> objectMapper = ObjectMapper()</span><br><span class="line">    <span class="keyword">val</span> jsonString = objectMapper</span><br><span class="line">        .writerWithDefaultPrettyPrinter()</span><br><span class="line">        .writeValueAsString(resource)</span><br><span class="line">        .also &#123; println(it) &#125;</span><br><span class="line">    objectMapper.readValue(jsonString, Resource2::<span class="keyword">class</span>.java)</span><br><span class="line">        .also &#123; println(it) &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>考虑到注解多又常用，这里有不能每一个都展示，我们穷举场景</p>
<ul>
<li><p>如果需要自定义POJO某个属性的和序列化结果的对应关系，使用**@JsonProperty、@JsonSetter、@JsonGetter**</p>
</li>
<li><p>如果需要指定序列化后字段之间的顺序，使用**@JsonPropertyOrder**</p>
</li>
<li><p>如果POJO的某个字段需要直接当做json格式输出，使用@Js<strong>onRawValue</strong></p>
</li>
<li><p>如果需要忽略某些字段，使用**@JsonIgnore、@JsonIgnoreProperties、@JsonIgnoreType**</p>
</li>
<li><p>如果需要修改Jackson针对属性、POJO创建器等的检测逻辑，使用**@JsonAutoDetect**配置</p>
<p>典型地就是设置field、getter、setter、creator方法的可见性，指定哪种可见性能够被检测到</p>
</li>
<li><p>如果需要根据属性的值的情况决定是否序列化，可以使用**@JsonInclude**，它甚至可以指定当属性为某个特定的值时才序列化</p>
</li>
<li><p>如果某个类需要将某个属性当做该类型最终序列化结果的值，使用**@JsonValue**，一般用于枚举</p>
</li>
<li><p>如果需要配置jata.util中的日期相关序列化和反序列化转换逻辑，使用**@JsonFormat**</p>
</li>
<li><p>如果同一个POJO，在不同的情况下需要有不同的序列化结果，使用**@JsonView**</p>
</li>
<li><p>如果POJO中存在自定义类型，要想将该类型字段在序列化时提取到顶层，使用**@JsonUnwrapped**</p>
</li>
<li><p>如果POJO中存在map，想要把map的值提到顶层，使用**@JsonAnyGetter**</p>
<p>反之，如果json拥有多个属性，POJO中仅有少量字段，为了将多余的字段直接放在map中，使用**@JsonAnySetter**</p>
</li>
<li><p>如果想要自定义反序列化时调用的POJO构建器，使用**@JsonCreator**</p>
</li>
<li><p>针对枚举类型，如果想要在反序列化时匹配不到的情况下设置一个默认值，使用**@JsonEnumDefaultValue**</p>
</li>
<li><p>如果在反序列化时需要强制干预一个字段的值，可以使用**@JacksonInject**，但要结合ObjectMapper..setInjectableValues使用</p>
</li>
<li><p>如果要使用多态，需要使用**@JsonSubTypes、@JsonTypeId、@JsonTypeInfo、@JsonTypeName**</p>
</li>
<li><p>如果你的POJO之间有相互引用，导致序列化时出现递归，你需要使用**@JsonManagedReference、@JsonBackReference或@JsonIdentityInfo**解递归</p>
</li>
<li><p>如果希望某个POJO序列化后放在一个字段下，使用**@JsonRootName**</p>
</li>
</ul>
<p>他们的使用，可以参考这篇文章，还挺全的：<a href="https://www.baeldung.com/jackson-annotations">就是我</a></p>
<h3 id="TreeModel"><a href="#TreeModel" class="headerlink" title="TreeModel"></a>TreeModel</h3><p>树形结构，是Jackson提供的又一强大功能，它允许我们直接构建Json，类似Kotlin的JsonElement，但是更强大。给一个简单的例子</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">  	<span class="comment">// 两种创建node的方式都一样</span></span><br><span class="line"><span class="comment">//    val node = JsonNodeFactory.instance.objectNode()</span></span><br><span class="line">    <span class="keyword">val</span> objectMapper = ObjectMapper()</span><br><span class="line">    <span class="keyword">val</span> node = objectMapper.createObjectNode()</span><br><span class="line">    node.put(<span class="string">&quot;resourceId&quot;</span>, <span class="string">&quot;这是ID&quot;</span>)</span><br><span class="line">        .put(<span class="string">&quot;resourceType&quot;</span>, <span class="string">&quot;这是Type&quot;</span>)</span><br><span class="line">        .put(</span><br><span class="line">            <span class="string">&quot;data&quot;</span>, objectMapper.createObjectNode().apply &#123;</span><br><span class="line">                put(</span><br><span class="line">                    <span class="string">&quot;images&quot;</span>, objectMapper.createArrayNode().apply &#123;</span><br><span class="line">                        add(<span class="string">&quot;这是第一个链接&quot;</span>)</span><br><span class="line">                        add(<span class="string">&quot;这是第二个链接&quot;</span>)</span><br><span class="line">                    &#125;</span><br><span class="line">                )</span><br><span class="line">            &#125;</span><br><span class="line">        )</span><br><span class="line">    println(node.toPrettyString())</span><br><span class="line">    println(objectMapper.writerWithDefaultPrettyPrinter().writeValueAsString(node))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>输出</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="string">&quot;resourceId&quot;</span> : <span class="string">&quot;这是ID&quot;</span>,</span><br><span class="line">  <span class="string">&quot;resourceType&quot;</span> : <span class="string">&quot;这是Type&quot;</span>,</span><br><span class="line">  <span class="string">&quot;data&quot;</span> : &#123;</span><br><span class="line">    <span class="string">&quot;images&quot;</span> : [ <span class="string">&quot;这是第一个链接&quot;</span>, <span class="string">&quot;这是第二个链接&quot;</span> ]</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">&#123;</span><br><span class="line">  <span class="string">&quot;resourceId&quot;</span> : <span class="string">&quot;这是ID&quot;</span>,</span><br><span class="line">  <span class="string">&quot;resourceType&quot;</span> : <span class="string">&quot;这是Type&quot;</span>,</span><br><span class="line">  <span class="string">&quot;data&quot;</span> : &#123;</span><br><span class="line">    <span class="string">&quot;images&quot;</span> : [ <span class="string">&quot;这是第一个链接&quot;</span>, <span class="string">&quot;这是第二个链接&quot;</span> ]</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="可扩展性"><a href="#可扩展性" class="headerlink" title="可扩展性"></a>可扩展性</h3><p>在MapperFeature、SerializationFeature、DeserializationFeature中，定义了很多开关，可根据需要打开或关闭。具体看三个文档</p>
<ul>
<li><a href="https://github.com/FasterXML/jackson-databind/wiki/Mapper-Features">针对整个ObjectMapper的配置</a></li>
<li><a href="https://github.com/FasterXML/jackson-databind/wiki/Serialization-features">针对序列化的配置</a></li>
<li><a href="https://github.com/FasterXML/jackson-databind/wiki/Deserialization-Features">针对反序列化的配置</a></li>
</ul>
<h2 id="工作原理"><a href="#工作原理" class="headerlink" title="工作原理"></a>工作原理</h2><h3 id="流式API-1"><a href="#流式API-1" class="headerlink" title="流式API"></a>流式API</h3><p> 流式API也支持很多功能，翻开JsonGenerator源码，将近三千行的文件长度有点吓人，但总的来说，它大概也只有功能配置和各种写方法。这其中，我们目前只关心之前用到的内容：</p>
<ul>
<li>一个基本的写方法的实现，即writeXXX</li>
<li>序列化过程中的状态维护，即JsonWriteContext</li>
<li>ObjectMapper的基础，即ObjectCodec</li>
</ul>
<p><strong>最底层的原理</strong></p>
<p>一般来说，通过<code>JsonFactoryBuilder().build().createGenerator(xxx)</code>创建出来的是<code>UTC8JsonGenerator</code>实例，我们来看两个方法的示例</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 写对象开头</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">writeStartObject</span><span class="params">()</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">  _verifyValueWrite(<span class="string">&quot;start an object&quot;</span>);</span><br><span class="line">  _writeContext = _writeContext.createChildObjectContext();</span><br><span class="line">  <span class="keyword">if</span> (_outputTail &gt;= _outputEnd) &#123;</span><br><span class="line">    _flushBuffer();</span><br><span class="line">  &#125;</span><br><span class="line">  _outputBuffer[_outputTail++] = BYTE_LCURLY;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 写一个普通字符串</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">writeString</span><span class="params">(String text)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">  <span class="keyword">this</span>._verifyValueWrite(<span class="string">&quot;write a string&quot;</span>);</span><br><span class="line">  <span class="keyword">if</span> (text == <span class="keyword">null</span>) &#123;</span><br><span class="line">    <span class="keyword">this</span>._writeNull();</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="keyword">int</span> len = text.length();</span><br><span class="line">    <span class="keyword">if</span> (len &gt; <span class="keyword">this</span>._outputMaxContiguous) &#123;</span><br><span class="line">      <span class="keyword">this</span>._writeStringSegments(text, <span class="keyword">true</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="keyword">if</span> (<span class="keyword">this</span>._outputTail + len &gt;= <span class="keyword">this</span>._outputEnd) &#123;</span><br><span class="line">        <span class="keyword">this</span>._flushBuffer();</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">this</span>._outputBuffer[<span class="keyword">this</span>._outputTail++] = <span class="keyword">this</span>._quoteChar;</span><br><span class="line">      <span class="keyword">this</span>._writeStringSegment((String)text, <span class="number">0</span>, len);</span><br><span class="line">      <span class="keyword">if</span> (<span class="keyword">this</span>._outputTail &gt;= <span class="keyword">this</span>._outputEnd) &#123;</span><br><span class="line">        <span class="keyword">this</span>._flushBuffer();</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">this</span>._outputBuffer[<span class="keyword">this</span>._outputTail++] = <span class="keyword">this</span>._quoteChar;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// flush</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">_flushBuffer</span><span class="params">()</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">  <span class="keyword">int</span> len = <span class="keyword">this</span>._outputTail;</span><br><span class="line">  <span class="keyword">if</span> (len &gt; <span class="number">0</span>) &#123;</span><br><span class="line">    <span class="keyword">this</span>._outputTail = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">this</span>._outputStream.write(<span class="keyword">this</span>._outputBuffer, <span class="number">0</span>, len);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 验证写入是否正确</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">_verifyValueWrite</span><span class="params">(String typeMsg)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">  <span class="keyword">int</span> status = <span class="keyword">this</span>._writeContext.writeValue();</span><br><span class="line">  <span class="keyword">if</span> (<span class="keyword">this</span>._cfgPrettyPrinter != <span class="keyword">null</span>) &#123;</span><br><span class="line">    <span class="keyword">this</span>._verifyPrettyValueWrite(typeMsg, status);</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="keyword">byte</span> b;</span><br><span class="line">    <span class="keyword">switch</span>(status) &#123;</span><br><span class="line">      <span class="keyword">case</span> <span class="number">0</span>:</span><br><span class="line">      <span class="keyword">case</span> <span class="number">4</span>:</span><br><span class="line">      <span class="keyword">default</span>:</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">      <span class="keyword">case</span> <span class="number">1</span>:</span><br><span class="line">        b = <span class="number">44</span>;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">      <span class="keyword">case</span> <span class="number">2</span>:</span><br><span class="line">        b = <span class="number">58</span>;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">      <span class="keyword">case</span> <span class="number">3</span>:</span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">this</span>._rootValueSeparator != <span class="keyword">null</span>) &#123;</span><br><span class="line">          <span class="keyword">byte</span>[] raw = <span class="keyword">this</span>._rootValueSeparator.asUnquotedUTF8();</span><br><span class="line">          <span class="keyword">if</span> (raw.length &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">this</span>._writeBytes(raw);</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">      <span class="keyword">case</span> <span class="number">5</span>:</span><br><span class="line">        <span class="keyword">this</span>._reportCantWriteValueExpectName(typeMsg);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">this</span>._outputTail &gt;= <span class="keyword">this</span>._outputEnd) &#123;</span><br><span class="line">      <span class="keyword">this</span>._flushBuffer();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">this</span>._outputBuffer[<span class="keyword">this</span>._outputTail++] = b;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>我们忽略_cfgPrettyPrinter这个东西，它不是关键。有要点</p>
<ul>
<li>流式API的输出原理：维护一个输出流，维护一个缓存字节数组。每次写入，只是写入缓存数组中，只有主动调用flush()或缓存长度超过设定值(_outputEnd)时，才会将数据批量写入输入流，这样可以提升效率</li>
<li>每次写入前，都会调用_verifyValueWrite对当前的状态进行验证，它验证的内容其实是即将写入的内容是否符合Json格式，这是通过JsonStreamContext实现的（对写，对应JsonWriteContext），它维护了序列化过程中，当前的写入状态。比如，刚刚写入了一个key，现在必须写入一个value，否则就会报错。</li>
<li>在写对象的起始符时，也创建了jsonContext的子context，可见，Context是有层次结构的，其结构和Json的层次结构保持一致。</li>
</ul>
<p>看看JsonContext的层次结构，我们大概能猜出其工作原理</p>
<p><img src="https://gdz.oss-cn-shenzhen.aliyuncs.com/local/image-20211013173735959.png" alt="image-20211013173735959"></p>
<ul>
<li><p>三个type（TYPE_ROOT等），是Context的类型，对应了根、数组、对象三种</p>
</li>
<li><p>几个status（STATUS_OK_AS_IS等），是Context检查后返回给调用者的结果，其中</p>
<ul>
<li>STATUS_OK_AS_IS：表明格式检查正确</li>
<li>STATUS_OK_AFTER_COMMA：表明格式检查正确，且当前位置后面应该添加逗号</li>
<li>STATUS_OK_AFTER_COLON：表明格式正确，且当前位置后面应该添加冒号</li>
<li>STATUS_OK_AFTER_SPACE：表明格式正确，且当前位置后面应该添加空白符</li>
<li>STATUS_EXPECT_VALUE：表明格式错误，预期是一个值</li>
<li>STATUS_EXPECT_NAME：表明格式错误，预期是一个字段名</li>
</ul>
<p>对它们的处理方式，在上面展示的方式_verifyValueWrite中也能看到。</p>
</li>
<li><p>其余属性，是为了维持当前状态用，根据状态判定当前调用是否合法，我们忽略”重复属性检查”，主要有两个方法，逻辑见注释</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 写字段名</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">writeFieldName</span><span class="params">(String name)</span> <span class="keyword">throws</span> JsonProcessingException </span>&#123;</span><br><span class="line">  <span class="comment">// 当前类型是对象或已经写过了字段名，肯定就错了嘛</span></span><br><span class="line">  <span class="keyword">if</span> ((_type != TYPE_OBJECT) || _gotName) &#123;</span><br><span class="line">    <span class="keyword">return</span> STATUS_EXPECT_VALUE;</span><br><span class="line">  &#125;</span><br><span class="line">  _gotName = <span class="keyword">true</span>;</span><br><span class="line">  _currentName = name;</span><br><span class="line">  <span class="keyword">if</span> (_dups != <span class="keyword">null</span>) &#123; _checkDup(_dups, name); &#125;</span><br><span class="line">  <span class="comment">// 如果这是第一个键值对，则啥都不管，否则，需要在这个键前面加逗号</span></span><br><span class="line">  <span class="keyword">return</span> (_index &lt; <span class="number">0</span>) ? STATUS_OK_AS_IS : STATUS_OK_AFTER_COMMA;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 写值</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">writeValue</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (_type == TYPE_OBJECT) &#123;</span><br><span class="line">    <span class="comment">// 如果还没有设置键，应该先设置键</span></span><br><span class="line">    <span class="keyword">if</span> (!_gotName) &#123;</span><br><span class="line">      <span class="keyword">return</span> STATUS_EXPECT_NAME;</span><br><span class="line">    &#125;</span><br><span class="line">    _gotName = <span class="keyword">false</span>;</span><br><span class="line">    ++_index;</span><br><span class="line">    <span class="comment">// 在值前面加冒号</span></span><br><span class="line">    <span class="keyword">return</span> STATUS_OK_AFTER_COLON;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (_type == TYPE_ARRAY) &#123;</span><br><span class="line">    <span class="keyword">int</span> ix = _index;</span><br><span class="line">    ++_index;</span><br><span class="line">    <span class="comment">// 如果是数组，如果数组里还一个值都没有，啥也不做，否则，应该在这个之前面加逗号</span></span><br><span class="line">    <span class="keyword">return</span> (ix &lt; <span class="number">0</span>) ? STATUS_OK_AS_IS : STATUS_OK_AFTER_COMMA;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  ++_index;</span><br><span class="line">  <span class="comment">// 否则就是根对象咯，如果根对象里还没有元素，就啥也不错，否则应该在前面加空格</span></span><br><span class="line">  <span class="keyword">return</span> (_index == <span class="number">0</span>) ? STATUS_OK_AS_IS : STATUS_OK_AFTER_SPACE;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<p><strong>编解码器</strong></p>
<p>如果了解Kotlin的序列化设计策略，就很好理解编解码器了，可以将它类比SerialFormat——为了将流式API的复杂逻辑封装起来，提供一个简单易用的API，我们看它的接口定义。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">ObjectCodec</span> <span class="keyword">extends</span> <span class="title">TreeCodec</span> <span class="keyword">implements</span> <span class="title">Versioned</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="title">ObjectCodec</span><span class="params">()</span> </span>&#123; &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> Version <span class="title">version</span><span class="params">()</span></span>;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">abstract</span> &lt;T&gt; <span class="function">T <span class="title">readValue</span><span class="params">(JsonParser p, Class&lt;T&gt; valueType)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">abstract</span> &lt;T&gt; <span class="function">T <span class="title">readValue</span><span class="params">(JsonParser p, TypeReference&lt;T&gt; valueTypeRef)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">abstract</span> &lt;T&gt; <span class="function">T <span class="title">readValue</span><span class="params">(JsonParser p, ResolvedType valueType)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">abstract</span> &lt;T&gt; <span class="function">Iterator&lt;T&gt; <span class="title">readValues</span><span class="params">(JsonParser p, Class&lt;T&gt; valueType)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">abstract</span> &lt;T&gt; <span class="function">Iterator&lt;T&gt; <span class="title">readValues</span><span class="params">(JsonParser p, TypeReference&lt;T&gt; valueTypeRef)</span></span>;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">abstract</span> &lt;T&gt; <span class="function">Iterator&lt;T&gt; <span class="title">readValues</span><span class="params">(JsonParser p, ResolvedType valueType)</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function">    <span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">writeValue</span><span class="params">(JsonGenerator gen, Object value)</span> <span class="keyword">throws</span> IOException</span>;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">abstract</span> &lt;T extends TreeNode&gt; <span class="function">T <span class="title">readTree</span><span class="params">(JsonParser p)</span> <span class="keyword">throws</span> IOException</span>;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">writeTree</span><span class="params">(JsonGenerator gen, TreeNode tree)</span> <span class="keyword">throws</span> IOException</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> TreeNode <span class="title">createObjectNode</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> TreeNode <span class="title">createArrayNode</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> JsonParser <span class="title">treeAsTokens</span><span class="params">(TreeNode n)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">abstract</span> &lt;T&gt; <span class="function">T <span class="title">treeToValue</span><span class="params">(TreeNode n, Class&lt;T&gt; valueType)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Deprecated</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> JsonFactory <span class="title">getJsonFactory</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> getFactory(); &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> JsonFactory <span class="title">getFactory</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> getJsonFactory(); &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>可以看到，它提供的方法非常有限，大致分为两类</p>
<ul>
<li>针对一般类型及其集合类型的读、写方法，接收JsonParser/JsonGenerator、类型参数</li>
<li>针对树模型的读写方法</li>
</ul>
<h3 id="ObjectMapper"><a href="#ObjectMapper" class="headerlink" title="ObjectMapper"></a>ObjectMapper</h3><p>ObjectMapper是data-bind最主要的类，而他，直接继承ObjectCodec，也就是说，可以直接使用ObjectCodec中定义的那些方法。但会发现，最常用的却不是它们，类似SerialFormat，尽管ObjectCodec已经为我们提供了一些方法，但它们只是将流式API的端点和类型联系了起来，还是不够易用，因此data-bind定义了更多易用的方法，将JsonGenerator之类的创建封装在类内部，于是我们就有了writeValueAsString()这样的方法可以直接使用。</p>
<p><img src="https://gdz.oss-cn-shenzhen.aliyuncs.com/local/image-20211013193907907.png" alt="image-20211013193907907"></p>
<p>来看写方法，其实所有的写方法内部实现都是一样的，writeValueAsString也只是在其内部用一个流缓存序列化输出，再转换为字符串。它们的重点，在于com.fasterxml.jackson.databind.ObjectMapper#_writeValueAndClose</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 所有写方法都会调用的内部方法</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">_writeValueAndClose</span><span class="params">(JsonGenerator g, Object value)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">  SerializationConfig cfg = getSerializationConfig();</span><br><span class="line">  <span class="keyword">if</span> (cfg.isEnabled(SerializationFeature.CLOSE_CLOSEABLE) &amp;&amp; (value <span class="keyword">instanceof</span> Closeable)) &#123;</span><br><span class="line">    _writeCloseable(g, value, cfg);</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="comment">// 重点在serializeValue</span></span><br><span class="line">    _serializerProvider(cfg).serializeValue(g, value);</span><br><span class="line">  &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">    ClassUtil.closeOnFailAndThrowAsIOE(g, e);</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  g.close();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 序列化值</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">serializeValue</span><span class="params">(JsonGenerator gen, Object value)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">  _generator = gen;</span><br><span class="line">  <span class="keyword">if</span> (value == <span class="keyword">null</span>) &#123;</span><br><span class="line">    _serializeNull(gen);</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">final</span> Class&lt;?&gt; cls = value.getClass();</span><br><span class="line">  <span class="comment">// 这是重点</span></span><br><span class="line">  <span class="keyword">final</span> JsonSerializer&lt;Object&gt; ser = findTypedValueSerializer(cls, <span class="keyword">true</span>, <span class="keyword">null</span>);</span><br><span class="line">  PropertyName rootName = _config.getFullRootName();</span><br><span class="line">  <span class="keyword">if</span> (rootName == <span class="keyword">null</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> (_config.isEnabled(SerializationFeature.WRAP_ROOT_VALUE)) &#123;</span><br><span class="line">      _serialize(gen, value, ser, _config.findRootName(cls));</span><br><span class="line">      <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span> (!rootName.isEmpty()) &#123;</span><br><span class="line">    _serialize(gen, value, ser, rootName);</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  _serialize(gen, value, ser);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 写入JsonGenerator</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">_serialize</span><span class="params">(JsonGenerator gen, Object value, JsonSerializer&lt;Object&gt; ser, PropertyName rootName)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">  <span class="keyword">try</span> &#123;</span><br><span class="line">    gen.writeStartObject();</span><br><span class="line">    gen.writeFieldName(rootName.simpleAsEncoded(_config));</span><br><span class="line">    ser.serialize(value, gen, <span class="keyword">this</span>);</span><br><span class="line">    gen.writeEndObject();</span><br><span class="line">  &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">    <span class="keyword">throw</span> _wrapAsIOE(gen, e);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>我们展示了三层调用层次的方法，排除干扰项，要点如下</p>
<ul>
<li>获取待序列化的类型对应的序列化器</li>
<li>使用找到的序列化器，执行最后的序列化逻辑<ul>
<li>向JsonGenerator写入对象起始符</li>
<li>向JsonGenerator写入根字段名</li>
<li>用得到的序列化器向JsonGenerator写入对象相关信息</li>
<li>向JsonGenerator写入对象结束符</li>
</ul>
</li>
</ul>
<p>这里出现了一个新的概念：序列化器，之前是没有见过的。序列化器和反序列化器的创建，是data-bind的重要内容，我们可以想象一下：序列化器负责对整个对象的序列化，这里的序列化，其实是将对象属性转换为json的token的过程。我们又没有创建序列化器，那要么是编译器创建，要么是运行时创建，很显然前者是不可能的。可以猜测，序列化器的生成，包含了以下逻辑（反序列化类似）</p>
<ul>
<li>包含对Json注解的支持，反射读取注解，然后体现在序列化器上</li>
<li>包含对各种功能的支持，目前data-bind的功能主要有MapperFeature、SerializationFeature、DeserializationFeature的支持，生成序列化器时，根据这些条件动态调整转换行为。这其实最终体现在了SerializationConfig中。</li>
<li>对新增逻辑的支持，module的扩展性，应该要靠它来支持</li>
</ul>
<p>有关序列化器的生成逻辑，主要在SerializerProvider，比较深，有兴趣自己跟跟看，解析一下其生成逻辑。对于一个自定义的POJO，创建逻辑最终会来到这里：com.fasterxml.jackson.databind.ser.BeanSerializerFactory#constructBeanOrAddOnSerializer，逻辑过于复杂，所有上面说的那些都交织在其中，有兴趣可以自己研究。下图展示了构建过程中判断MapperFeature.USE_STATIC_TYPING开关的情况。</p>
<p><img src="https://gdz.oss-cn-shenzhen.aliyuncs.com/local/image-20211013204532184.png" alt="image-20211013204532184"></p>
<p>实际上，序列化器会首先在预先设置的序列化器中查找，然后从缓存中查找，实在没有，才会自动生成，且生成后的序列化器会添加到缓存，避免多次生成，从而提升性能。而那些针对Jackson的三方库，基本都是自定义类型的处理方式，是否可以推测，所谓第三方库，其实就是自己提前定义的序列化器和反序列化器，然后注册进来就好。</p>
<h3 id="正确认识ObjectMapper"><a href="#正确认识ObjectMapper" class="headerlink" title="正确认识ObjectMapper"></a>正确认识ObjectMapper</h3><p>ObjectMapper是Jackson使用的核心，一般来说，一个ObjectMapper实例对应了一套配置，配置一旦添加不可去除，如果想用多套不同的配置，则需维护多个ObjectMapper，这也是常规使用方法，你看整个Spring中，正常情况下，都只有一个ObejctMapper实例的。</p>
<h3 id="module"><a href="#module" class="headerlink" title="module"></a>module</h3><p>在Jackson主项目下，能看到很多第三方插件（数据类型模块），我们来探究它是如何工作的。</p>
<p><img src="https://gdz.oss-cn-shenzhen.aliyuncs.com/local/image-20211013205612048.png" alt="image-20211013205612048"></p>
<p>注册一个module的调用方式是</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line">ObjectMapper().registerModule(JavaTimeModule())</span><br></pre></td></tr></table></figure>

<p>它干了啥呢？参见com.fasterxml.jackson.databind.ObjectMapper#registerModule（代码太长就不贴了），简单说来</p>
<ul>
<li>将Module依赖的Module进行递归注册</li>
<li>将Module中定义的序列化器和反序列化器注册到ObjectMapper</li>
</ul>
<p>当然，能够自定义的，肯定不止序列化器，看com.fasterxml.jackson.databind.Module.SetupContext</p>
<p><img src="https://gdz.oss-cn-shenzhen.aliyuncs.com/local/image-20211013210926397.png" alt="image-20211013210926397"></p>
<p>可以看到，它提供了多种配置能力，这些能力怎么用，后面可以单独开一篇文章介绍。</p>
<ul>
<li>可开启各种功能</li>
<li>可添加各种序列化器、反序列化器</li>
<li>可添加序列化和反序列化描述符</li>
<li>添加类型解析器</li>
<li>添加注解</li>
<li>注册子类型（用于多态）</li>
<li>混入</li>
<li>命名策略</li>
</ul>
<h2 id="自定义Module"><a href="#自定义Module" class="headerlink" title="自定义Module"></a>自定义Module</h2><p>Jackson提供了SimpleModule，帮助我们在自定义类型module时简化开发，现在我们自定义一个Module。</p>
<p>假设有一系列类型（这里就展示一个），比如</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">data</span> <span class="class"><span class="keyword">class</span> <span class="title">Operation2</span></span>(</span><br><span class="line">    <span class="keyword">val</span> id: <span class="built_in">Int</span>?</span><br><span class="line">)</span><br></pre></td></tr></table></figure>

<p>现在希望Jackson支持它们，于是可以定义一个Module，它需要包含针对这些类型的序列化器，将这些序列化器包装进一个自定义Module，如下</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">OperationSerializer</span> : <span class="type">StdSerializer</span>&lt;<span class="type">Operation2</span>&gt;</span>(Operation2::<span class="keyword">class</span>.java) &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">serialize</span><span class="params">(value: <span class="type">Operation2</span>?, gen: <span class="type">JsonGenerator</span>, provider: <span class="type">SerializerProvider</span>?)</span></span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (value == <span class="literal">null</span>) &#123;</span><br><span class="line">            gen.writeNull()</span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line">        &#125;</span><br><span class="line">        gen.writeStartObject()</span><br><span class="line">        gen.writeNumberField(<span class="string">&quot;operationId&quot;</span>, value.id!!)</span><br><span class="line">        gen.writeEndObject()</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">OperationModule</span> : <span class="type">SimpleModule</span></span>() &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">init</span> &#123;</span><br><span class="line">        addSerializer(OperationSerializer())</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">getModuleName</span><span class="params">()</span></span>: String &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>::<span class="keyword">class</span>.qualifiedName.toString()</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>然后，在使用时就可以注册并使用了</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">val</span> objectMapper = ObjectMapper().registerModule(OperationModule())</span><br><span class="line">    println(objectMapper.writeValueAsString(Operation2(<span class="number">1</span>)))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>输出如下</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">&#123;<span class="string">&quot;operationId&quot;</span>:1&#125;</span><br></pre></td></tr></table></figure>

<h2 id="与Kotlin序列化对比"><a href="#与Kotlin序列化对比" class="headerlink" title="与Kotlin序列化对比"></a>与Kotlin序列化对比</h2><p>相对而言，Kotlin序列化功能还非常年轻，有类似也有不同，将二者进行对比，有助于理解。</p>
<table>
<thead>
<tr>
<th>Jackson接口</th>
<th>Kotlin接口</th>
<th>用途</th>
</tr>
</thead>
<tbody><tr>
<td>JsonGenerator/JsonParser</td>
<td>Encoder/Decoder</td>
<td>底层接口，负责将支持的基本类型编码到流中</td>
</tr>
<tr>
<td>JsonSerializer/JsonDeserializer</td>
<td>KSerializer</td>
<td>序列化器/反序列化器，负责将具有结构的对象，转换为基本类型</td>
</tr>
<tr>
<td>ObjectCodec/ObjectMapper</td>
<td>SerialFormat/Json</td>
<td>编解码器，略有不同，不过都是对用户隐藏了实现，暴露简单接口</td>
</tr>
<tr>
<td>TreeNode</td>
<td>JsonElement</td>
<td>树抽象模型，二者都有，不过Jackson的更加强大</td>
</tr>
<tr>
<td>Module</td>
<td>serializerModule</td>
<td>功能完全不一样，但思想类似，都是维护一堆上下文对象。<br />区别在于，前者功能更多；后者只有上下文和多态的声明</td>
</tr>
</tbody></table>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>初以为Jackson，区区一Json序列化库，能复杂到哪里去；看了官方手册，不知道是它写的乱，还是我悟性不好，看半天反正不知道在讲啥；后来耐着性子看，并尝试了不少方式，发现用起来还挺简单，模型上又和Kotlin序列化有几分类似，原理上也没那么难懂嘛；多翻一些源码，发现这个历史悠久的库果然不是泛泛之辈，功能太多了，眼花缭乱的，很多功能单拎出来都能写一篇长文，也不怪得网络上那么多Jackson专栏。所以它也不是那种一两天就能搞定的库，更不是一篇文章能说清楚的。</p>
<p>本文我们简要介绍了Jackson的基础能力、基本原理、基本模型等。抓住Jackson主干是主要目的，细枝末节，更加高级偏僻的功能，留待日后探索。通过本文，你应该知道了</p>
<ul>
<li>Jackson由core提供核心能力，data-bind提供各种功能，annotations提供注解支持</li>
<li>Jackson的常用场景使用方法</li>
<li>Jackson和核心原理，Module的工作原理</li>
</ul>
<h2 id="What’s-Next"><a href="#What’s-Next" class="headerlink" title="What’s Next"></a>What’s Next</h2><p>有了本文的基础，我们就能更加流畅地去看其他文章了，<a href="https://github.com/FasterXML/jackson#tutorials">官网推荐的那些</a>就很好</p>
<p><img src="https://gdz.oss-cn-shenzhen.aliyuncs.com/local/image-20211014120133817.png" alt="image-20211014120133817"></p>
]]></content>
      <categories>
        <category>后端</category>
      </categories>
      <tags>
        <tag>序列化</tag>
      </tags>
  </entry>
  <entry>
    <title>我不会Java反射</title>
    <url>/2021/10/21/%E6%88%91%E4%B8%8D%E4%BC%9AJava%E5%8F%8D%E5%B0%84-wo-bu-hui-java-fan-she/</url>
    <content><![CDATA[<p>我会写Java反射，我知道反射是用来获取、改变程序运行时状态的方式，通过反射API我们能够获取类对象、类的方法、成员变量、注解等。</p>
<p>我不会写Java反射，我不知道Type和Class有啥关系，ParameteredType、TypeVariable呢？</p>
<p>我会Java反射吗？不，我不会。</p>
<span id="more"></span>

<h2 id="反射是什么？"><a href="#反射是什么？" class="headerlink" title="反射是什么？"></a>反射是什么？</h2><p>反射是什么，镜子里看自己。往小了说，就是Java提供的一组能够在运行时查看和修改对象信息的API；往大了说，从计算机专业来看，是编程语言提供的运行时动态更新自身状态的能力，Java的反射只是其中的一种。Go、C#、JS等都实现了自己的反射机制。</p>
<p>吐槽”反射“这个翻译，英文”Reflection“、”Reflective“。说这个翻译名不好吧，它是直译，且一定程度能够反应其含义：程序能够看到本身；但说他准确也并不能让人信服，翻译成内省个人认为会更好一点，但无奈Java中内省是另外一套API。</p>
<p>照我的意思，就别翻译了，就Reflection和Instropection就好，英文原意，哪怕你不能完全理解，总比被翻译曲解来得好。</p>
<h2 id="理解其组成"><a href="#理解其组成" class="headerlink" title="理解其组成"></a>理解其组成</h2><p>就API能力来说，反射无非是让我们获取类对象的各个组成部分，并提供对类对应的实例相应部分的修改。因此，首先要理解类的各个组成部分和反射API接口之间的对应关系，用一张思维导图说明。</p>
<p><img src="https://gdz.oss-cn-shenzhen.aliyuncs.com/local/image-20211021122902091.png"></p>
<p>可以看到，Java中的每种元素，都有对应的反射抽象对应</p>
<ul>
<li>所有类型，包括类、接口、抽象类、注解、枚举等，由Class类进行抽象。在一个完全面向对象的语言中，运行时查看和修改的也肯定是对象的信息，因此它也是反射的入口。</li>
<li>对类中的成员，有构造方法、普通方法、字段，分别由Constructor、Mehtod、Field抽象</li>
<li>对特殊的数组类型，有Array抽象</li>
<li>对泛型，根据情况有TypeVariable、GenericArrayType、ParameterizedType、WildcardType分别进行抽象</li>
</ul>
<p>所有这些抽象的目的，都是为了能够让我们通过某条路径获取到确定的那个元素，如字段声明<code>List&lt;String&gt; str</code>，为了获取到List中的泛型String，需要通过如下路径调用</p>
<ol>
<li>获取字段所属类的Class对象clazz</li>
<li><code>clazz.getDeclaredFiled(&quot;str&quot;)</code>获取到该Field</li>
<li><code>field.getGenericType()</code>获取泛型类型ft，并强转为ParameterizedType</li>
<li><code>ft.getActualTypeArguments()[0]</code>获取该泛型的具体参数String</li>
</ol>
<p>Java反射用的好不好，就看反射的API用的熟不熟。</p>
<h2 id="几个抽象树"><a href="#几个抽象树" class="headerlink" title="几个抽象树"></a>几个抽象树</h2><p>针对不同元素的特性，反射API从不同维度进行了抽象，下面依次看一下。</p>
<h3 id="Type"><a href="#Type" class="headerlink" title="Type"></a>Type</h3><p>Java 1.5之前，反射只有Class对象，并没有各种Type，但1.5之后引入了泛型，考虑到兼容性，Class对象并没有修改，而是将新的泛型表示抽象了出来。Class自然也是Type的子类，但由于其方法过多，我们没有画出来</p>
<p><img src="https://gdz.oss-cn-shenzhen.aliyuncs.com/local/image-20211021125002864.png" alt="image-20211021125002864"></p>
<p>Type的上述几个类型，都是泛型的各种形态。</p>
<h3 id="AnnotatedElement"><a href="#AnnotatedElement" class="headerlink" title="AnnotatedElement"></a>AnnotatedElement</h3><p>表示可被注解的元素，可以看到，包括了包、Module、参数、类对象、可访问对象（方法、构造方法、字段）、各种泛型类型</p>
<p>一个可被注解的元素，能够获取到自己上面的所有注解。</p>
<p><img src="https://gdz.oss-cn-shenzhen.aliyuncs.com/local/image-20211021125118611.png" alt="image-20211021125118611"></p>
<h3 id="GenericDeclaration"><a href="#GenericDeclaration" class="headerlink" title="GenericDeclaration"></a>GenericDeclaration</h3><p>可声明泛型变量的元素，有类、构造方法、方法。泛型变量指的是T这样的东西。</p>
<p>一个可生命泛型变量的元素，能够获取到该元素的所有类型变量，即TypeVariable数组。</p>
<p><img src="https://gdz.oss-cn-shenzhen.aliyuncs.com/local/image-20211021140853046.png" alt="image-20211021140853046"></p>
<h3 id="AccessibleObject"><a href="#AccessibleObject" class="headerlink" title="AccessibleObject"></a>AccessibleObject</h3><p>可访问对象，有方法、构造函数、字段。访问他们需要权限。<code>xxx.setAccessible(true)</code>我们一定很熟悉。</p>
<p>一个可访问对象，实现了Java的访问控制策略，能够限制用户对自己的访问。</p>
<p><img src="https://gdz.oss-cn-shenzhen.aliyuncs.com/local/%E6%88%AA%E5%B1%8F2021-10-21%20%E4%B8%8B%E5%8D%882.12.58.png" alt="截屏2021-10-21 下午2.12.58"></p>
<h3 id="Member"><a href="#Member" class="headerlink" title="Member"></a>Member</h3><p>成员，可作为成员的对象。有方法、构造函数、字段。</p>
<p>一个成员，能够获取该成员的名称、获取修饰符、获取声明该成员的类对象。</p>
<p><img src="https://gdz.oss-cn-shenzhen.aliyuncs.com/local/%E6%88%AA%E5%B1%8F2021-10-21%20%E4%B8%8B%E5%8D%882.15.52.png" alt="截屏2021-10-21 下午2.15.52"></p>
<h2 id="一个例子"><a href="#一个例子" class="headerlink" title="一个例子"></a>一个例子</h2><p>不展示常用的获取类成员的例子，我们展示一个泛型的例子：在Json反序列化过程中，由于类型擦除，我们无法判定具体值的类型，一般的库如Jackson、Fastjson提供了TypeReference&lt;XXX&gt;帮助我们决定反序列化的类型，Gson中的TypeToken&lt;XXX&gt;也是同样的作用。我们来模仿一下这个过程。</p>
<p><strong>题目</strong>：给出一个字符串，将其转换成指定的泛型类型</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 实现Comparable，并不是为了比较，而是为了得到泛型T的实际类型</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">TypeReference</span>&lt;<span class="title">T</span>&gt; </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Type type;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="title">TypeReference</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        Type superClass = getClass().getGenericSuperclass();</span><br><span class="line">        <span class="keyword">this</span>.type = ((ParameterizedType) superClass).getActualTypeArguments()[<span class="number">0</span>];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Type <span class="title">getType</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> type;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ReflectUtils</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 根据给定的类型，将字符串转换为对应实例</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> &lt;R&gt; <span class="function">R <span class="title">convertReflective</span><span class="params">(String source, TypeReference&lt;R&gt; type)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        Type actualType = type.getType();</span><br><span class="line">        <span class="keyword">if</span> (actualType <span class="keyword">instanceof</span> ParameterizedType) &#123;</span><br><span class="line">            <span class="keyword">return</span> convertReflectiveForParameterizedType(source, actualType);</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (actualType <span class="keyword">instanceof</span> Class) &#123;</span><br><span class="line">            <span class="keyword">return</span> convertReflectiveForClass(source, actualType);</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (actualType <span class="keyword">instanceof</span> GenericArrayType) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> Exception(<span class="string">&quot;尚未实现&quot;</span>);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> Exception(<span class="string">&quot;啥类型都不是呀&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 带泛型的类型</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> &lt;R&gt; <span class="function">R <span class="title">convertReflectiveForParameterizedType</span><span class="params">(String source, Type type)</span> </span>&#123;</span><br><span class="line">        ParameterizedType rType = (ParameterizedType) type;</span><br><span class="line">        Object result = <span class="keyword">null</span>;</span><br><span class="line">        Type rawType = rType.getRawType();</span><br><span class="line">        Type[] actualTypes = rType.getActualTypeArguments();</span><br><span class="line">        <span class="keyword">if</span> (rawType.equals(List.class)) &#123;</span><br><span class="line">            Type actualType = actualTypes[<span class="number">0</span>];</span><br><span class="line">            result = Arrays.stream(source.substring(<span class="number">1</span>, source.length() - <span class="number">1</span>).split(<span class="string">&quot;,&quot;</span>))</span><br><span class="line">                .map(String::trim)</span><br><span class="line">                .map((String it) -&gt; convertReflectiveForClass(it, actualType))</span><br><span class="line">                .collect(Collectors.toList());</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;暂不支持&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> (R) result;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 非泛型的普通类型</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> &lt;R&gt; <span class="function">R <span class="title">convertReflectiveForClass</span><span class="params">(String source, Type type)</span> </span>&#123;</span><br><span class="line">        Object result = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span> (String.class.equals(type)) &#123;</span><br><span class="line">            result = source;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (Integer.class.equals(type)) &#123;</span><br><span class="line">            result = Integer.valueOf(source);</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (Long.class.equals(type)) &#123;</span><br><span class="line">            result = Long.valueOf(source);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            result = source;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> (R) result;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Demo</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        <span class="comment">// 字符串转字符串</span></span><br><span class="line">        String s = ReflectUtils.convertReflective(<span class="string">&quot;这是普通字符串&quot;</span>, <span class="keyword">new</span> TypeReference&lt;String&gt;() &#123;&#125;);</span><br><span class="line">        System.out.println(s);</span><br><span class="line">        <span class="comment">// 字符串转列表</span></span><br><span class="line">        List&lt;String&gt; list = ReflectUtils.convertReflective(<span class="string">&quot;[1,2,字符串]&quot;</span>, <span class="keyword">new</span> TypeReference&lt;List&lt;String&gt;&gt;() &#123;&#125;);</span><br><span class="line">        list.forEach(System.out::println);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>输出</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">这是普通字符串</span><br><span class="line">1</span><br><span class="line">2</span><br><span class="line">字符串</span><br></pre></td></tr></table></figure>

<p>简单讲解</p>
<ul>
<li><p>定义<code>TypeReference&lt;T&gt;</code>泛型抽象类，使用时候构建的是它的匿名子类，如<code>new TypeReference&lt;List&lt;String&gt;&gt;() &#123;&#125;</code></p>
<p>为什么要构建子类呢？因为<code>TypeReference&lt;T&gt;</code>的泛型在反射系统中永远是T，这是其类定义决定的，运行时给定的类型，统统会被擦除，因此是无法只使用<code>TypeReference&lt;T&gt;</code>就获取到指定的类型的；通过构建匿名子类<code>new TypeReference&lt;List&lt;String&gt;&gt;() &#123;&#125;</code>，对应新的类对象，其泛型就是具体的类型了，此时通过<code>getClass().getGenericSuperclass()</code>就能获取到<code>TypeReference&lt;List&lt;String&gt;&gt;</code>这一<code>ParameterizedType</code>。</p>
<p>这点很重要，是实现这个功能的关键之一。</p>
</li>
<li><p>取得的泛型中的类型，依然可能是带有泛型，因此我们要递归判断。上面简单写，针对几个基本类型和List做了处理</p>
</li>
</ul>
<h2 id="反射工具库"><a href="#反射工具库" class="headerlink" title="反射工具库"></a>反射工具库</h2><p>很多库提供反射工具，比如<a href="https://www.hutool.cn/docs/#/core/%E5%B7%A5%E5%85%B7%E7%B1%BB/%E5%8F%8D%E5%B0%84%E5%B7%A5%E5%85%B7-ReflectUtil">hutool的ReflectUtil</a>，我们看一下它做了什么。。。。。。它们也没做什么，就是将常用的操作封装到一个静态方法，比如直接获取构造方法，比我们自己做，多了些检查。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> &lt;T&gt; <span class="function">Constructor&lt;T&gt; <span class="title">getConstructor</span><span class="params">(Class&lt;T&gt; clazz, Class&lt;?&gt;... parameterTypes)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (<span class="keyword">null</span> == clazz) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">final</span> Constructor&lt;?&gt;[] constructors = getConstructors(clazz);</span><br><span class="line">  Class&lt;?&gt;[] pts;</span><br><span class="line">  <span class="keyword">for</span> (Constructor&lt;?&gt; constructor : constructors) &#123;</span><br><span class="line">    pts = constructor.getParameterTypes();</span><br><span class="line">    <span class="keyword">if</span> (ClassUtil.isAllAssignableFrom(pts, parameterTypes)) &#123;</span><br><span class="line">      <span class="comment">// 构造可访问</span></span><br><span class="line">      setAccessible(constructor);</span><br><span class="line">      <span class="keyword">return</span> (Constructor&lt;T&gt;) constructor;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>其它的呢，也都差不多。</p>
<h2 id="反射的实现"><a href="#反射的实现" class="headerlink" title="反射的实现"></a>反射的实现</h2><p>类的描述信息，它就在class文件中，因此在Class对象中可以看到。运行时修改的内容这个，可以去研究一下Java虚拟机实现。</p>
<h2 id="反射和内省"><a href="#反射和内省" class="headerlink" title="反射和内省"></a>反射和内省</h2><p>内省指的是Introspector，是Java提供的另一个类，对应Java Bean规范，用以运行时查看Java Bean的属性、方法、事件等状态。其实现，也是通过反射。可以理解为使用反射为Java Bean提供了快捷访问方法，此时重点就要落在Java Bean上。如果你操作的是一个Bean，请直接用Introspector，如果你操作的是一个普通的类，那就用反射。</p>
<p>此外，Java Bean规范，有空的时候，也可以研究一下。看看它，到底是不是自己认识的那个样子。</p>
<h2 id="反射很慢吗？"><a href="#反射很慢吗？" class="headerlink" title="反射很慢吗？"></a>反射很慢吗？</h2><p>反射很慢吗？哪方面慢？慢多少？</p>
<p>我们用JMH测试针对自定义对象的某个空方法的调用，对比反射调用100万次、1亿次，和直接调用的差别。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyClass</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testMethod</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@BenchmarkMode(Mode.SingleShotTime)</span></span><br><span class="line"><span class="meta">@Warmup(iterations = 1, time = 10)</span></span><br><span class="line"><span class="meta">@Measurement(iterations = 1, time = 1)</span></span><br><span class="line"><span class="meta">@State(Scope.Thread)</span></span><br><span class="line"><span class="meta">@OutputTimeUnit(TimeUnit.MILLISECONDS)</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ReflectionBenchmark</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Param(&#123;&quot;1000000&quot;, &quot;100000000&quot;&#125;)</span></span><br><span class="line">    <span class="keyword">int</span> times;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Benchmark</span></span><br><span class="line">    <span class="meta">@Fork(1)</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">invokeReflective</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        MyClass myClass = <span class="keyword">new</span> MyClass();</span><br><span class="line">        Method method = MyClass.class.getDeclaredMethod(<span class="string">&quot;testMethod&quot;</span>);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; times; i++) &#123;</span><br><span class="line">            method.invoke(myClass);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Benchmark</span></span><br><span class="line">    <span class="meta">@Fork(1)</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">invokeDirect</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        MyClass myClass = <span class="keyword">new</span> MyClass();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; times; i++) &#123;</span><br><span class="line">            myClass.testMethod();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> RunnerException </span>&#123;</span><br><span class="line">        Options options = <span class="keyword">new</span> OptionsBuilder()</span><br><span class="line">            .include(ReflectionBenchmark.class.getSimpleName())</span><br><span class="line">            .build();</span><br><span class="line">        <span class="keyword">new</span> Runner(options).run();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>测试结果如下，可见，反射确实会慢一些。上面的测试是调用空方法，次数非常多，会放大这种速度对比。但这个测试只能说明反射比直接调用慢。慢的程度，呈倍数关系比较合理。</p>
<p><img src="https://gdz.oss-cn-shenzhen.aliyuncs.com/local/%E6%88%AA%E5%B1%8F2021-10-21%20%E4%B8%8B%E5%8D%885.17.34.png" alt="截屏2021-10-21 下午5.17.34"></p>
<p>转换成图表如下，更加直观。<img src="https://gdz.oss-cn-shenzhen.aliyuncs.com/local/%E6%88%AA%E5%B1%8F2021-10-21%20%E4%B8%8B%E5%8D%885.23.19.png" alt="截屏2021-10-21 下午5.23.19"></p>
<p>相关知乎问答：<a href="https://www.zhihu.com/question/19826278">Java反射到底慢在哪里</a></p>
<p>一篇分析反射方法调用的文章（传说中的R大）：<a href="https://www.iteye.com/blog/rednaxelafx-548536">关于反射调用方法的一个log</a></p>
<p>一篇针对反射的性能测试（我持保留看法）：<a href="https://zhuanlan.zhihu.com/p/55075493">Java的反射调用性能很低吗?</a></p>
<p>总体来说，反射确实会慢一些，对空方法来说，可能会慢个几倍吧，但对正常方法来说，还好。慢的原因，一是多了中间步骤，比如MethodAccessor的创建、参数的包装、一些条件判断等；二就是较为底层的实现了。</p>
<p>要想完全了解反射调用的原理，还是得从底层出发，需要对虚拟机实现、JIT即时编译实现细节有所了解，这是暂时还没什么时间去做的事情，所以就此打住吧。</p>
<h2 id="还可以去看的文章"><a href="#还可以去看的文章" class="headerlink" title="还可以去看的文章"></a>还可以去看的文章</h2><ul>
<li><p><a href="https://en.wikipedia.org/wiki/Reflective_programming">Reflective programming</a></p>
</li>
<li><p><a href="https://stackoverflow.com/questions/37628/what-is-reflection-and-why-is-it-useful">What is reflection and why is it useful?</a></p>
</li>
<li><p><a href="https://www.zhihu.com/question/361153307">为什么c/c++没有反射？</a></p>
</li>
</ul>
]]></content>
      <categories>
        <category>后端</category>
        <category>编程语言</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>反射</tag>
      </tags>
  </entry>
  <entry>
    <title>序列化探索之二 - Kotlin</title>
    <url>/2021/10/09/%E5%BA%8F%E5%88%97%E5%8C%96%E6%8E%A2%E7%B4%A2%E4%B9%8B%E4%BA%8C%20-%20Kotlin-xu-lie-hua-tan-suo-zhi-er-kotlin/</url>
    <content><![CDATA[<blockquote>
<p>文章不长，但代码演示居多，可选择性阅读</p>
</blockquote>
<p>Kotlin以扩展包的形式提供了序列化能力，使得能够以“Kotlin方式”进行序列化。Kotlin设计目标，是提供一个序列化抽象，具体格式实现可用Json、CBOR、Protobuf、Properties、Yaml等进行替换。但就目前的进度，仅提供了对Json的稳定支持。其它格式都处于试验阶段。</p>
<p>因此，我们看Kotlin的序列化，主要看的就是数据对象与Json之间的序列化和反序列化。</p>
<span id="more"></span>

<h2 id="能力展示"><a href="#能力展示" class="headerlink" title="能力展示"></a>能力展示</h2><p>场景假设：需要序列化一个数据类，包含五个字段</p>
<ul>
<li>resourceId：资源ID</li>
<li>resourceType：资源类型</li>
<li>updatedTime：更新时间</li>
<li>usn：更新序列号</li>
<li>data：资源数据</li>
</ul>
<p>为方便演示，这些字段的类型和组织结构依据场景的不同而不同，下面演示针对这个数据类的对象的序列化。</p>
<h3 id="基础能力"><a href="#基础能力" class="headerlink" title="基础能力"></a>基础能力</h3><p>开局一段基础代码，下面的使用方式应该是我们能够使用得最多的场景和方式。</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Serializable</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ResourceBasic</span>&lt;<span class="type">T</span>&gt; </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@SerialName(<span class="meta-string">&quot;id&quot;</span>)</span></span><br><span class="line">    <span class="keyword">var</span> resourceId: String? = <span class="literal">null</span></span><br><span class="line"></span><br><span class="line">    <span class="meta">@SerialName(<span class="meta-string">&quot;type&quot;</span>)</span></span><br><span class="line">    <span class="keyword">var</span> resourceType: String? = <span class="literal">null</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">var</span> updatedTime: <span class="built_in">Long</span>? = <span class="literal">null</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">var</span> usn: <span class="built_in">Long</span>? = <span class="literal">null</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">var</span> <span class="keyword">data</span>: T? = <span class="literal">null</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">toString</span><span class="params">()</span></span>: String &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;ResourceBasic(resourceId=<span class="variable">$resourceId</span>, resourceType=<span class="variable">$resourceType</span>, updatedTime=<span class="variable">$updatedTime</span>, usn=<span class="variable">$usn</span>, data=<span class="variable">$data</span>)&quot;</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">val</span> resource = ResourceBasic&lt;JsonElement&gt;().apply &#123;</span><br><span class="line">        <span class="keyword">this</span>.resourceId = UUID.randomUUID().toString()</span><br><span class="line">        <span class="keyword">this</span>.resourceType = <span class="string">&quot;record&quot;</span></span><br><span class="line">        <span class="keyword">this</span>.updatedTime = LocalDateTime.now().toInstant(ZoneOffset.UTC).toEpochMilli()</span><br><span class="line">        <span class="keyword">this</span>.usn = <span class="literal">null</span></span><br><span class="line">        <span class="keyword">this</span>.<span class="keyword">data</span> = buildJsonObject &#123;</span><br><span class="line">            put(<span class="string">&quot;images&quot;</span>, buildJsonArray &#123; add(<span class="string">&quot;https://www.ppp.com/cdwrgwarhg.png&quot;</span>) &#125;)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">val</span> jsonFormat = Json &#123;</span><br><span class="line">        prettyPrint = <span class="literal">true</span></span><br><span class="line">        encodeDefaults = <span class="literal">true</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 序列化</span></span><br><span class="line">    <span class="keyword">val</span> jsonString = jsonFormat.encodeToString(resource)</span><br><span class="line">    println(jsonString)</span><br><span class="line">    <span class="comment">// 反序列化</span></span><br><span class="line">    <span class="keyword">val</span> decodedResource = jsonFormat.decodeFromString&lt;ResourceBasic&lt;JsonElement&gt;&gt;(jsonString)</span><br><span class="line">    println(decodedResource)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>输出</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    &quot;id&quot;: &quot;74020041-79c4-456c-bd42-c372a4049d61&quot;,</span><br><span class="line">    &quot;type&quot;: &quot;record&quot;,</span><br><span class="line">    &quot;updatedTime&quot;: 1633780307486,</span><br><span class="line">    &quot;usn&quot;: null,</span><br><span class="line">    &quot;data&quot;: &#123;</span><br><span class="line">        &quot;images&quot;: [</span><br><span class="line">            &quot;https://www.ppp.com/cdwrgwarhg.png&quot;</span><br><span class="line">        ]</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">ResourceBasic(resourceId=74020041-79c4-456c-bd42-c372a4049d61, resourceType=record, updatedTime=1633780307486, usn=null, data=&#123;&quot;images&quot;:[&quot;https://www.ppp.com/cdwrgwarhg.png&quot;]&#125;)</span><br></pre></td></tr></table></figure>

<p>上面展示了Kotlin序列化的最基础能力</p>
<ol>
<li>被序列化的类上必须添加@Serializable注解</li>
<li>被序列化的类可以带泛型</li>
<li>可以通过@SerialName注解修改序列化的键名</li>
<li>序列化时调用Json.encodeToString即可</li>
<li>反序列化时调用Json.decodeFromString即可</li>
</ol>
<p>更多参考<a href="https://github.com/Kotlin/kotlinx.serialization/blob/master/docs/basic-serialization.md">官方手册</a></p>
<h3 id="自定义序列化逻辑"><a href="#自定义序列化逻辑" class="headerlink" title="自定义序列化逻辑"></a>自定义序列化逻辑</h3><p>上例中更新时间为Long，但实际代码编写中使用LocalDateTime更为方便，此时我们需要为LocalDateTime写一个自定义序列化器。</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Serializable</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ResourceInCustomSerializer</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">var</span> resourceId: String? = <span class="literal">null</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">var</span> resourceType: String? = <span class="literal">null</span></span><br><span class="line"></span><br><span class="line">    <span class="meta">@Serializable(with = LocalDateTimeAsLongSerializer::class)</span></span><br><span class="line">    <span class="keyword">var</span> updatedTime: LocalDateTime? = <span class="literal">null</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">var</span> usn: <span class="built_in">Long</span>? = <span class="literal">null</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">var</span> <span class="keyword">data</span>: JsonElement? = <span class="literal">null</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">toString</span><span class="params">()</span></span>: String &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;ResourceBasic(resourceId=<span class="variable">$resourceId</span>, resourceType=<span class="variable">$resourceType</span>, updatedTime=<span class="variable">$updatedTime</span>, usn=<span class="variable">$usn</span>, data=<span class="variable">$data</span>)&quot;</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">object</span> LocalDateTimeAsLongSerializer : KSerializer&lt;LocalDateTime&gt; &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">override</span> <span class="keyword">val</span> descriptor: SerialDescriptor = buildClassSerialDescriptor(<span class="string">&quot;java.util.LocalDateTime&quot;</span>)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">serialize</span><span class="params">(encoder: <span class="type">Encoder</span>, value: <span class="type">LocalDateTime</span>)</span></span> &#123;</span><br><span class="line">        encoder.encodeLong(value.toInstant(ZoneOffset.UTC).toEpochMilli())</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">deserialize</span><span class="params">(decoder: <span class="type">Decoder</span>)</span></span>: LocalDateTime &#123;</span><br><span class="line">        <span class="keyword">return</span> LocalDateTime.ofInstant(Instant.ofEpochMilli(decoder.decodeLong()), ZoneOffset.UTC)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">val</span> resource = ResourceInCustomSerializer().apply &#123;</span><br><span class="line">        <span class="keyword">this</span>.resourceId = UUID.randomUUID().toString()</span><br><span class="line">        <span class="keyword">this</span>.resourceType = <span class="string">&quot;record&quot;</span></span><br><span class="line">        <span class="keyword">this</span>.updatedTime = LocalDateTime.now()</span><br><span class="line">        <span class="keyword">this</span>.usn = <span class="literal">null</span></span><br><span class="line">        <span class="keyword">this</span>.<span class="keyword">data</span> = buildJsonObject &#123;</span><br><span class="line">            put(<span class="string">&quot;images&quot;</span>, buildJsonArray &#123; add(<span class="string">&quot;https://www.ppp.com/cdwrgwarhg.png&quot;</span>) &#125;)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">val</span> jsonFormat = Json &#123;</span><br><span class="line">        prettyPrint = <span class="literal">true</span></span><br><span class="line">        encodeDefaults = <span class="literal">true</span></span><br><span class="line">    &#125;</span><br><span class="line">  	<span class="comment">// 序列化</span></span><br><span class="line">    <span class="keyword">val</span> jsonString = jsonFormat.encodeToString(resource)</span><br><span class="line">    println(jsonString)</span><br><span class="line">  	<span class="comment">// 反序列化</span></span><br><span class="line">    <span class="keyword">val</span> decodedResource = jsonFormat.decodeFromString&lt;ResourceInCustomSerializer&gt;(jsonString)</span><br><span class="line">    println(decodedResource)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>要点</p>
<ul>
<li>自定义LocalDateTimeAsLongSerializer，实现KSerializer接口，重写一个属性，两个方法<ul>
<li>descriptor：类型描述</li>
<li>serialize：序列化逻辑</li>
<li>deserialize：反序列化逻辑</li>
</ul>
</li>
<li>@Serializable(with = LocalDateTimeAsLongSerializer::class)标注在目标属性上</li>
</ul>
<h3 id="上下文"><a href="#上下文" class="headerlink" title="上下文"></a>上下文</h3><p>上面的例子再变一下，updateTime有时可能想要转换为Long，有时却想要转换为ISO8601格式的字符串。即，要求根据不同<strong>上下文</strong>的变化选择不同的序列化器。</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Serializable</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ResourceInCustomSerializer</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">var</span> resourceId: String? = <span class="literal">null</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">var</span> resourceType: String? = <span class="literal">null</span></span><br><span class="line"></span><br><span class="line">    <span class="meta">@Contextual</span></span><br><span class="line">    <span class="keyword">var</span> updatedTime: LocalDateTime? = <span class="literal">null</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">var</span> usn: <span class="built_in">Long</span>? = <span class="literal">null</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">var</span> <span class="keyword">data</span>: JsonElement? = <span class="literal">null</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">toString</span><span class="params">()</span></span>: String &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;ResourceBasic(resourceId=<span class="variable">$resourceId</span>, resourceType=<span class="variable">$resourceType</span>, updatedTime=<span class="variable">$updatedTime</span>, usn=<span class="variable">$usn</span>, data=<span class="variable">$data</span>)&quot;</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">object</span> LocalDateTimeAsLongSerializer : KSerializer&lt;LocalDateTime&gt; &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">override</span> <span class="keyword">val</span> descriptor: SerialDescriptor = buildClassSerialDescriptor(<span class="string">&quot;java.util.LocalDateTime&quot;</span>)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">serialize</span><span class="params">(encoder: <span class="type">Encoder</span>, value: <span class="type">LocalDateTime</span>)</span></span> &#123;</span><br><span class="line">        encoder.encodeLong(value.toInstant(ZoneOffset.UTC).toEpochMilli())</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">deserialize</span><span class="params">(decoder: <span class="type">Decoder</span>)</span></span>: LocalDateTime &#123;</span><br><span class="line">        <span class="keyword">return</span> LocalDateTime.ofInstant(Instant.ofEpochMilli(decoder.decodeLong()), ZoneOffset.UTC)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">object</span> LocalDateTimeAsStringSerializer : KSerializer&lt;LocalDateTime&gt; &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">override</span> <span class="keyword">val</span> descriptor: SerialDescriptor = buildClassSerialDescriptor(<span class="string">&quot;java.util.LocalDateTime&quot;</span>)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">serialize</span><span class="params">(encoder: <span class="type">Encoder</span>, value: <span class="type">LocalDateTime</span>)</span></span> &#123;</span><br><span class="line">        encoder.encodeString(value.toString())</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">deserialize</span><span class="params">(decoder: <span class="type">Decoder</span>)</span></span>: LocalDateTime &#123;</span><br><span class="line">        <span class="keyword">return</span> LocalDateTime.parse(decoder.decodeString())</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">val</span> resource = ResourceInCustomSerializer().apply &#123;</span><br><span class="line">        <span class="keyword">this</span>.resourceId = UUID.randomUUID().toString()</span><br><span class="line">        <span class="keyword">this</span>.resourceType = <span class="string">&quot;record&quot;</span></span><br><span class="line">        <span class="keyword">this</span>.updatedTime = LocalDateTime.now()</span><br><span class="line">        <span class="keyword">this</span>.usn = <span class="literal">null</span></span><br><span class="line">        <span class="keyword">this</span>.<span class="keyword">data</span> = buildJsonObject &#123;</span><br><span class="line">            put(<span class="string">&quot;images&quot;</span>, buildJsonArray &#123; add(<span class="string">&quot;https://www.ppp.com/cdwrgwarhg.png&quot;</span>) &#125;)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">var</span> jsonFormat = Json &#123;</span><br><span class="line">        prettyPrint = <span class="literal">true</span></span><br><span class="line">        encodeDefaults = <span class="literal">true</span></span><br><span class="line">        serializersModule = serializersModuleOf(LocalDateTime::<span class="class"><span class="keyword">class</span>, <span class="type">LocalDateTimeAsLongSerializer)</span></span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// LocalDateTime转换为Long的序列化和反序列化</span></span><br><span class="line">    <span class="keyword">var</span> jsonString = jsonFormat.encodeToString(resource)</span><br><span class="line">    println(jsonString)</span><br><span class="line">    <span class="keyword">var</span> decodedResource = jsonFormat.decodeFromString&lt;ResourceInCustomSerializer&gt;(jsonString)</span><br><span class="line">    println(decodedResource)</span><br><span class="line"></span><br><span class="line">    jsonFormat = Json &#123;</span><br><span class="line">        prettyPrint = <span class="literal">true</span></span><br><span class="line">        encodeDefaults = <span class="literal">true</span></span><br><span class="line">        serializersModule = serializersModuleOf(LocalDateTime::<span class="class"><span class="keyword">class</span>, <span class="type">LocalDateTimeAsStringSerializer)</span></span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// LocalDateTime转换为String的序列化和反序列化</span></span><br><span class="line">    jsonString = jsonFormat.encodeToString(resource)</span><br><span class="line">    println(jsonString)</span><br><span class="line">    decodedResource = jsonFormat.decodeFromString&lt;ResourceInCustomSerializer&gt;(jsonString)</span><br><span class="line">    println(decodedResource)</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>要点</p>
<ul>
<li>目标字段使用@Contextual注解，表明该字段的序列化器到上下文中去找</li>
<li>定义多个针对LocalDateTime的序列化器</li>
<li>在Json实例中，指定当前所用序列化模块，为LocalDateTime注册对应的序列化器，上面，我们用了两个Json实例，分别对应不同的上下文，注册不同的序列化器，对同一个对象的序列化结果有了不同的行为</li>
</ul>
<h3 id="序列化的多态"><a href="#序列化的多态" class="headerlink" title="序列化的多态"></a>序列化的多态</h3><p>如果我们的Resource有两个版本，它们拥有共同的三个属性：resourceId、resourceType、data，其中一个版本拥有updatedTime，另一个版本拥有usn，于是有了类型的层次结构。现在假设我有一个列表，该列表同时有两个版本的数据，为了在反序列化时能够恢复出具体元素的类型，在序列化时就需要将元素的类型信息也进行序列化，这就是序列化的多态。如果你觉得对这个概念模式，谷歌一下“jackson @class”，一定是似曾相识。</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Serializable</span></span><br><span class="line"><span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">ResourceBase</span> </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> resourceId: String? = <span class="literal">null</span></span><br><span class="line">    <span class="keyword">var</span> resourceType: String? = <span class="literal">null</span></span><br><span class="line">    <span class="keyword">var</span> <span class="keyword">data</span>: String? = <span class="literal">null</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Serializable</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ResourceWithUsn</span> : <span class="type">ResourceBase</span></span>() &#123;</span><br><span class="line">    <span class="keyword">var</span> usn: <span class="built_in">Long</span>? = <span class="literal">null</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Serializable</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ResourceWithUpdatedTime</span> : <span class="type">ResourceBase</span></span>() &#123;</span><br><span class="line">    <span class="keyword">var</span> updatedTime: <span class="built_in">Long</span>? = <span class="literal">null</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">val</span> resources = listOf(</span><br><span class="line">        ResourceWithUsn().apply &#123;</span><br><span class="line">            <span class="keyword">this</span>.resourceId = <span class="string">&quot;1&quot;</span></span><br><span class="line">            <span class="keyword">this</span>.resourceType = <span class="string">&quot;record&quot;</span></span><br><span class="line">            <span class="keyword">this</span>.<span class="keyword">data</span> = <span class="string">&quot;这是数据&quot;</span></span><br><span class="line">            <span class="keyword">this</span>.usn = <span class="number">123</span></span><br><span class="line">        &#125;,</span><br><span class="line">        ResourceWithUpdatedTime().apply &#123;</span><br><span class="line">            <span class="keyword">this</span>.resourceId = <span class="string">&quot;2&quot;</span></span><br><span class="line">            <span class="keyword">this</span>.resourceType = <span class="string">&quot;tag&quot;</span></span><br><span class="line">            <span class="keyword">this</span>.<span class="keyword">data</span> = <span class="string">&quot;这是标签&quot;</span></span><br><span class="line">            <span class="keyword">this</span>.updatedTime = Instant.now().toEpochMilli()</span><br><span class="line">        &#125;</span><br><span class="line">    )</span><br><span class="line"></span><br><span class="line">    <span class="keyword">val</span> jsonFormat = Json &#123;</span><br><span class="line">        prettyPrint = <span class="literal">true</span></span><br><span class="line">        classDiscriminator = <span class="string">&quot;@class&quot;</span></span><br><span class="line">        serializersModule = SerializersModule &#123;</span><br><span class="line">            polymorphic(ResourceBase::<span class="class"><span class="keyword">class</span>) </span>&#123;</span><br><span class="line">                subclass(ResourceWithUpdatedTime::<span class="class"><span class="keyword">class</span>)</span></span><br><span class="line">                subclass(ResourceWithUsn::<span class="class"><span class="keyword">class</span>)</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">val</span> jsonString = jsonFormat.encodeToString(resources)</span><br><span class="line">    println(jsonString)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>序列化结果</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="string">&quot;@class&quot;</span>: <span class="string">&quot;com.gitee.floyd.serialization.kotlin.ResourceWithUsn&quot;</span>,</span><br><span class="line">        <span class="string">&quot;resourceId&quot;</span>: <span class="string">&quot;1&quot;</span>,</span><br><span class="line">        <span class="string">&quot;resourceType&quot;</span>: <span class="string">&quot;record&quot;</span>,</span><br><span class="line">        <span class="string">&quot;data&quot;</span>: <span class="string">&quot;这是数据&quot;</span>,</span><br><span class="line">        <span class="string">&quot;usn&quot;</span>: 123</span><br><span class="line">    &#125;,</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="string">&quot;@class&quot;</span>: <span class="string">&quot;com.gitee.floyd.serialization.kotlin.ResourceWithUpdatedTime&quot;</span>,</span><br><span class="line">        <span class="string">&quot;resourceId&quot;</span>: <span class="string">&quot;2&quot;</span>,</span><br><span class="line">        <span class="string">&quot;resourceType&quot;</span>: <span class="string">&quot;tag&quot;</span>,</span><br><span class="line">        <span class="string">&quot;data&quot;</span>: <span class="string">&quot;这是标签&quot;</span>,</span><br><span class="line">        <span class="string">&quot;updatedTime&quot;</span>: 1633753842785</span><br><span class="line">    &#125;</span><br><span class="line">]</span><br></pre></td></tr></table></figure>

<p>要点</p>
<ul>
<li>父类和子类都要标注@Serializable</li>
<li>Json实例中，注册多态声明，这里，我们声明ResourceBase的子类包含ResourceWithUpdatedTime、ResourceWithUsn</li>
<li>可以通过classDiscriminator自定义类型标记的key，这里写成@class，是为了让读者回想起jackson</li>
</ul>
<p>Kotlin实际的多态稍有不同，由于Kotlin序列化的大部分工作都是在编译期完成的，因此将一个待序列化的对象声明为其父类型，也能够触发多态。还有接口、密封类在多态中也有不同的特性，具体参见<a href="https://github.com/Kotlin/kotlinx.serialization/blob/master/docs/polymorphism.md">官方手册</a></p>
<blockquote>
<p><strong>Java会有多态问题吗？</strong></p>
<p>不会，Java序列化结果是二进制流，其中已经包含类型信息，不存在反序列化时候不知道具体类型的情况。也就是说，序列化的多态问题，只是对语言无关的序列化格式如Json有意义。</p>
</blockquote>
<h3 id="Json能力"><a href="#Json能力" class="headerlink" title="Json能力"></a>Json能力</h3><p>之前在使用Vertx时，深感其提供的Json库好用至极；Jackson也提供了Tree Mode，让用户能够在不创建类对象的情况下灵活构建Json对象；kotlin也提供了类似的能力——JsonElement，不过它没那么强大：能够凭空构建一个JsonElement，能够遍历其中的数据，却不能修改其中的数据。</p>
<p>当然，Json能力并非本文的重点，我们的重点在于探究Kotlin序列化的使用方式和原理，因此有关Json能力，参考<a href="https://github.com/Kotlin/kotlinx.serialization/blob/master/docs/json.md#json-elements">官方手册</a>。</p>
<h2 id="原理解析"><a href="#原理解析" class="headerlink" title="原理解析"></a>原理解析</h2><p>Kotlin序列化几乎所有逻辑都在编译期生成。因此，配置Kotlin序列化时，需要同时引入序列化插件和序列化包</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line">plugins &#123;</span><br><span class="line">    kotlin(<span class="string">&quot;plugin.serialization&quot;</span>) version <span class="string">&quot;1.5.31&quot;</span></span><br><span class="line">&#125;</span><br><span class="line">dependencies &#123;</span><br><span class="line">  implementation(<span class="string">&quot;org.jetbrains.kotlinx:kotlinx-serialization-json:1.3.0&quot;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="从-Serializable讲起"><a href="#从-Serializable讲起" class="headerlink" title="从@Serializable讲起"></a>从@Serializable讲起</h3><p>为目标类添加@serializable注解，编译器会自动生成序列化逻辑，以一个最简单的类进行展示</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Serializable</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SimpleData</span> </span>&#123;</span><br><span class="line">    <span class="keyword">val</span> id: <span class="built_in">Long</span>? = <span class="literal">null</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>其字节码反编译结果整理之后如下（去除了多余的噪声）</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">SimpleData</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">final</span> Long id;</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> SimpleData.Companion Companion = ... ...</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> Long <span class="title">getId</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>.id;</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  ... ...</span><br><span class="line"></span><br><span class="line">  <span class="meta">@JvmStatic</span></span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">void</span> write$Self(SimpleData self, CompositeEncoder output, SerialDescriptor serialDesc) &#123;</span><br><span class="line">    <span class="keyword">if</span> (Intrinsics.areEqual(self.id, (Object)<span class="keyword">null</span>) ^ <span class="keyword">true</span> || output.shouldEncodeElementDefault(serialDesc, <span class="number">0</span>)) &#123;</span><br><span class="line">      output.encodeNullableSerializableElement(serialDesc, <span class="number">0</span>, (KSerializer)LongSerializer.INSTANCE, self.id);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">Companion</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line">    ... ...</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> KSerializer <span class="title">serializer</span><span class="params">()</span> </span>&#123;</span><br><span class="line">      <span class="keyword">return</span> (KSerializer)SimpleData.$serializer.INSTANCE;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> $<span class="title">serializer</span> <span class="keyword">implements</span> <span class="title">GeneratedSerializer</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> SimpleData.$serializer INSTANCE;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> SerialDescriptor $$serialDesc;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> $serializer() &#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">      SimpleData.$serializer var0 = <span class="keyword">new</span> SimpleData.$serializer();</span><br><span class="line">      INSTANCE = var0;</span><br><span class="line">      PluginGeneratedSerialDescriptor var1 = <span class="keyword">new</span> PluginGeneratedSerialDescriptor(<span class="string">&quot;com.gitee.floyd.serialization.kotlin.SimpleData&quot;</span>, (GeneratedSerializer)INSTANCE, <span class="number">1</span>);</span><br><span class="line">      var1.addElement(<span class="string">&quot;id&quot;</span>, <span class="keyword">true</span>);</span><br><span class="line">      $$serialDesc = var1;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@NotNull</span></span><br><span class="line">    <span class="keyword">public</span> KSerializer[] typeParametersSerializers() &#123;</span><br><span class="line">      <span class="keyword">return</span> DefaultImpls.typeParametersSerializers(<span class="keyword">this</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@NotNull</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> SerialDescriptor <span class="title">getDescriptor</span><span class="params">()</span> </span>&#123;</span><br><span class="line">      <span class="keyword">return</span> $$serialDesc;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">serialize</span><span class="params">(Encoder encoder, SimpleData value)</span> </span>&#123;</span><br><span class="line">      SerialDescriptor var3 = $$serialDesc;</span><br><span class="line">      Encoder encoder = encoder.beginStructure(var3);</span><br><span class="line">      SimpleData.write$Self(value, encoder, var3);</span><br><span class="line">      encoder.endStructure(var3);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">serialize</span><span class="params">(Encoder var1, Object var2)</span> </span>&#123;</span><br><span class="line">      <span class="keyword">this</span>.serialize(var1, (SimpleData)var2);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> SimpleData <span class="title">deserialize</span><span class="params">(Decoder decoder)</span> </span>&#123;</span><br><span class="line">      SerialDescriptor var2 = $$serialDesc;</span><br><span class="line">      <span class="keyword">int</span> var4 = <span class="number">0</span>;</span><br><span class="line">      Long var5 = <span class="keyword">null</span>;</span><br><span class="line">      Decoder decoder = decoder.beginStructure(var2);</span><br><span class="line">      <span class="keyword">if</span> (decoder.decodeSequentially()) &#123;</span><br><span class="line">        var5 = (Long)decoder.decodeNullableSerializableElement(var2, <span class="number">0</span>, (KSerializer)LongSerializer.INSTANCE, var5);</span><br><span class="line">        var4 = Integer.MAX_VALUE;</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">while</span>(<span class="keyword">true</span>) &#123;</span><br><span class="line">          <span class="keyword">int</span> var3 = decoder.decodeElementIndex(var2);</span><br><span class="line">          <span class="keyword">switch</span>(var3) &#123;</span><br><span class="line">            <span class="keyword">case</span> <span class="number">0</span>:</span><br><span class="line">              var5 = (Long)decoder.decodeNullableSerializableElement(var2, <span class="number">0</span>, (KSerializer)LongSerializer.INSTANCE, var5);</span><br><span class="line">              var4 |= <span class="number">1</span>;</span><br><span class="line">              <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">default</span>:</span><br><span class="line">              <span class="keyword">throw</span> (Throwable)(<span class="keyword">new</span> UnknownFieldException(var3));</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      decoder.endStructure(var2);</span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">new</span> SimpleData(var4, var5, (SerializationConstructorMarker)<span class="keyword">null</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">deserialize</span><span class="params">(Decoder var1)</span> </span>&#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">this</span>.deserialize(var1);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>解读一下生成的这个类</p>
<ul>
<li>编译器生成了伴生类Companion，同时附带serializer()方法，返回一个KSerializer对象</li>
<li>类本身新增静态方法<code>write$Self(SimpleData self, CompositeEncoder output, SerialDescriptor serialDesc)</code>，在生成的序列化器中有被调用</li>
<li>看生成的序列化器内部——getDescriptor方法，返回一个SerialDescriptor对象</li>
<li>看生成的序列化器内部——serialize方法<ul>
<li>传入Encoder对象、数据类对象</li>
<li>调用Encoder的方法，将数据类型写入</li>
</ul>
</li>
<li>看生成的序列化器内部——deserialize方法<ul>
<li>传入Decoder</li>
<li>从decoder中解析出字段，构建新的SimpleData对象并传入</li>
</ul>
</li>
<li>看生成的序列化器，跟上面我们自己写的序列化器，像不像，其实它们就是一样的。</li>
</ul>
<p>要点</p>
<ul>
<li><p>添加了@Serializable的类，会自动生成属于自己类的序列化器</p>
</li>
<li><p>实际上随着Kotlin序列化库的引入，你会发现，所有Kotlin原生类型也都被添加了一个扩展方法，serializer()</p>
<p><img src="https://gdz.oss-cn-shenzhen.aliyuncs.com/local/image-20211009145331561.png" alt="image-20211009145331561"></p>
<p>点进去看看他们的逻辑，依然是内置实现了KSerializer</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="function"><span class="keyword">fun</span> String.Companion.<span class="title">serializer</span><span class="params">()</span></span>: KSerializer&lt;String&gt; = StringSerializer</span><br><span class="line"></span><br><span class="line"><span class="keyword">internal</span> <span class="keyword">object</span> StringSerializer : KSerializer&lt;String&gt; &#123;</span><br><span class="line">    <span class="keyword">override</span> <span class="keyword">val</span> descriptor: SerialDescriptor = PrimitiveSerialDescriptor(<span class="string">&quot;kotlin.String&quot;</span>, PrimitiveKind.STRING)</span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">serialize</span><span class="params">(encoder: <span class="type">Encoder</span>, value: <span class="type">String</span>)</span></span>: <span class="built_in">Unit</span> = encoder.encodeString(value)</span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">deserialize</span><span class="params">(decoder: <span class="type">Decoder</span>)</span></span>: String = decoder.decodeString()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>我们会发现几个关键定义：KSerializer、SerialDescriptor、Encoder、Decoder、SerialKind，搞清楚它们之间的联系，就基本清楚了Kotlin的序列化原理。</p>
</li>
</ul>
<h3 id="Kotlin序列化的设计思路"><a href="#Kotlin序列化的设计思路" class="headerlink" title="Kotlin序列化的设计思路"></a>Kotlin序列化的设计思路</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">+---------+  Serialization  +------------+  Encoding  +---------------+</span><br><span class="line">| Objects | --------------&gt; | Primitives | ---------&gt; | Output format |</span><br><span class="line">+---------+                 +------------+            +---------------+</span><br></pre></td></tr></table></figure>

<p>这张图取自<a href="https://github.com/Kotlin/kotlinx.serialization/blob/master/docs/basic-serialization.md#basics">官方手册</a>，对于理解至关重要。Kotlin将序列化分为两个阶段</p>
<ul>
<li>阶段一（序列化）：将目标对象序列化成基础类型，如Long、Char、String等，这一步是通用的，与最终序列化格式无关。这一步对应KSerializer</li>
<li>阶段二（编码）：基础类型编码为最终格式，如Json、Protobuf。这一步对应Encoder、Decoder</li>
</ul>
<h3 id="核心类解析"><a href="#核心类解析" class="headerlink" title="核心类解析"></a>核心类解析</h3><p>现在我们可以来看那几个关键定义</p>
<ul>
<li><p>KSerializer</p>
<p>它定义了Encoder和目标对象value的关系，即控制了编码器编码和解码目标对象的逻辑。编码时，需要用到类描述信息SerialDescriptor</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">KSerializer</span>&lt;<span class="type">T</span>&gt; : <span class="type">SerializationStrategy</span>&lt;<span class="type">T</span>&gt;, <span class="type">DeserializationStrategy</span>&lt;<span class="type">T</span>&gt; </span>&#123;</span><br><span class="line">    <span class="keyword">override</span> <span class="keyword">val</span> descriptor: SerialDescriptor</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">SerializationStrategy</span>&lt;<span class="type">in T</span>&gt; </span>&#123;</span><br><span class="line">  </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">val</span> descriptor: SerialDescriptor</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="function"><span class="keyword">fun</span> <span class="title">serialize</span><span class="params">(encoder: <span class="type">Encoder</span>, value: <span class="type">T</span>)</span></span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">DeserializationStrategy</span>&lt;<span class="type">T</span>&gt; </span>&#123;</span><br><span class="line">  </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">val</span> descriptor: SerialDescriptor</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="function"><span class="keyword">fun</span> <span class="title">deserialize</span><span class="params">(decoder: <span class="type">Decoder</span>)</span></span>: T</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>SerialDescriptor</p>
<p>从名称就可得知，它定义了目标类型的描述信息，它的常规实现是SerialDescriptorImpl</p>
<ul>
<li>serialName：序列化名称，一般是类名</li>
<li>kind：目标类型，下文会讲</li>
<li>elements：当为类类型时，会包含多个属性，它们是以元素集合的形式提供的，具体可以看SerialDescriptorImpl实现</li>
</ul>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">SerialDescriptor</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">val</span> serialName: String</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">val</span> kind: SerialKind</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">val</span> isNullable: <span class="built_in">Boolean</span> <span class="keyword">get</span>() = <span class="literal">false</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">val</span> isInline: <span class="built_in">Boolean</span> <span class="keyword">get</span>() = <span class="literal">false</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">val</span> elementsCount: <span class="built_in">Int</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">val</span> annotations: List&lt;Annotation&gt; <span class="keyword">get</span>() = emptyList()</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="function"><span class="keyword">fun</span> <span class="title">getElementName</span><span class="params">(index: <span class="type">Int</span>)</span></span>: String</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="function"><span class="keyword">fun</span> <span class="title">getElementIndex</span><span class="params">(name: <span class="type">String</span>)</span></span>: <span class="built_in">Int</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="function"><span class="keyword">fun</span> <span class="title">getElementAnnotations</span><span class="params">(index: <span class="type">Int</span>)</span></span>: List&lt;Annotation&gt;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="function"><span class="keyword">fun</span> <span class="title">isElementOptional</span><span class="params">(index: <span class="type">Int</span>)</span></span>: <span class="built_in">Boolean</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>Encoder/Decoder</p>
<p>上面说了，Encoder负责从原始类型向最终类型的转换，从接口定义就能看出</p>
<ul>
<li>serializersModule：这是一个专门为上下文和多态准备的类，下面会讲到</li>
<li>encodeXXX：写入各种类型的数据，其中枚举和内联类一般会特殊处理</li>
<li>beginStructure：当要编码的是一个复杂对象时，就需要用到CompositeEncoder，具体参见其源码，不过原理和Encoder差不多，套娃而已</li>
<li>最后两个方法只是快捷方法，用户自定义序列化器的情况：其实也只是套娃而已。</li>
</ul>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Encoder</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">val</span> serializersModule: SerializersModule</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="function"><span class="keyword">fun</span> <span class="title">encodeNotNullMark</span><span class="params">()</span></span> &#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="function"><span class="keyword">fun</span> <span class="title">encodeNull</span><span class="params">()</span></span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="function"><span class="keyword">fun</span> <span class="title">encodeBoolean</span><span class="params">(value: <span class="type">Boolean</span>)</span></span></span><br><span class="line"></span><br><span class="line">    ... ... <span class="comment">//所有原始类型的编码方法</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="function"><span class="keyword">fun</span> <span class="title">encodeString</span><span class="params">(value: <span class="type">String</span>)</span></span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="function"><span class="keyword">fun</span> <span class="title">encodeEnum</span><span class="params">(enumDescriptor: <span class="type">SerialDescriptor</span>, index: <span class="type">Int</span>)</span></span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="function"><span class="keyword">fun</span> <span class="title">encodeInline</span><span class="params">(inlineDescriptor: <span class="type">SerialDescriptor</span>)</span></span>: Encoder</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="function"><span class="keyword">fun</span> <span class="title">beginStructure</span><span class="params">(descriptor: <span class="type">SerialDescriptor</span>)</span></span>: CompositeEncoder</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="function"><span class="keyword">fun</span> <span class="type">&lt;T : Any?&gt;</span> <span class="title">encodeSerializableValue</span><span class="params">(serializer: <span class="type">SerializationStrategy</span>&lt;<span class="type">T</span>&gt;, value: <span class="type">T</span>)</span></span> &#123;</span><br><span class="line">        serializer.serialize(<span class="keyword">this</span>, value)</span><br><span class="line">    &#125;</span><br><span class="line">  </span><br><span class="line">    <span class="keyword">public</span> <span class="function"><span class="keyword">fun</span> <span class="type">&lt;T : Any&gt;</span> <span class="title">encodeNullableSerializableValue</span><span class="params">(serializer: <span class="type">SerializationStrategy</span>&lt;<span class="type">T</span>&gt;, value: <span class="type">T</span>?)</span></span> &#123;</span><br><span class="line">        <span class="keyword">val</span> isNullabilitySupported = serializer.descriptor.isNullable</span><br><span class="line">        <span class="keyword">if</span> (isNullabilitySupported) &#123;</span><br><span class="line">            <span class="keyword">return</span> encodeSerializableValue(serializer <span class="keyword">as</span> SerializationStrategy&lt;T?&gt;, value)</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (value == <span class="literal">null</span>) &#123;</span><br><span class="line">            encodeNull()</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            encodeNotNullMark()</span><br><span class="line">            encodeSerializableValue(serializer, value)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>SerialKind</p>
<p>枚举了所有类型，其中CONTEXTUAL（上下文）和PolymorphicKind（多态）下文有详细讲解</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">sealed</span> <span class="class"><span class="keyword">class</span> <span class="title">SerialKind</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">object</span> ENUM : SerialKind()</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">object</span> CONTEXTUAL : SerialKind()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">sealed</span> <span class="class"><span class="keyword">class</span> <span class="title">PrimitiveKind</span> : <span class="type">SerialKind</span></span>() &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">object</span> BOOLEAN : PrimitiveKind()</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">object</span> BYTE : PrimitiveKind()</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">object</span> CHAR : PrimitiveKind()</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">object</span> SHORT : PrimitiveKind()</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">object</span> INT : PrimitiveKind()</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">object</span> LONG : PrimitiveKind()</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">object</span> FLOAT : PrimitiveKind()</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">object</span> DOUBLE : PrimitiveKind()</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">object</span> STRING : PrimitiveKind()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">sealed</span> <span class="class"><span class="keyword">class</span> <span class="title">StructureKind</span> : <span class="type">SerialKind</span></span>() &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">object</span> CLASS : StructureKind()</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">object</span> LIST : StructureKind()</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">object</span> MAP : StructureKind()</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">object</span> OBJECT : StructureKind()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">sealed</span> <span class="class"><span class="keyword">class</span> <span class="title">PolymorphicKind</span> : <span class="type">SerialKind</span></span>() &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">object</span> SEALED : PolymorphicKind()</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">object</span> OPEN : PolymorphicKind()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="看看Json序列化的实现"><a href="#看看Json序列化的实现" class="headerlink" title="看看Json序列化的实现"></a>看看Json序列化的实现</h3><p>先引入一个定义：SerialFormat，它是专门定义用来作为序列化入口的接口，我们的实现类都使用它，包括Json类（这里的serializersModule暂且忽略）</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">SerialFormat</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">val</span> serializersModule: SerializersModule</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>最常用的它的子类：StringFormat，定义了针对字符串的操作方式，及其快捷方式</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">StringFormat</span> : <span class="type">SerialFormat &#123;</span></span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="function"><span class="keyword">fun</span> <span class="type">&lt;T&gt;</span> <span class="title">encodeToString</span><span class="params">(serializer: <span class="type">SerializationStrategy</span>&lt;<span class="type">T</span>&gt;, value: <span class="type">T</span>)</span></span>: String</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="function"><span class="keyword">fun</span> <span class="type">&lt;T&gt;</span> <span class="title">decodeFromString</span><span class="params">(deserializer: <span class="type">DeserializationStrategy</span>&lt;<span class="type">T</span>&gt;, string: <span class="type">String</span>)</span></span>: T</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">inline</span> <span class="function"><span class="keyword">fun</span> <span class="type">&lt;<span class="keyword">reified</span> T&gt;</span> StringFormat.<span class="title">encodeToString</span><span class="params">(value: <span class="type">T</span>)</span></span>: String =</span><br><span class="line">    encodeToString(serializersModule.serializer(), value)</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">inline</span> <span class="function"><span class="keyword">fun</span> <span class="type">&lt;<span class="keyword">reified</span> T&gt;</span> StringFormat.<span class="title">decodeFromString</span><span class="params">(string: <span class="type">String</span>)</span></span>: T =</span><br><span class="line">    decodeFromString(serializersModule.serializer(), string)</span><br></pre></td></tr></table></figure>

<p>最常用的序列化方法是<code>StringFormat.encodeToString(value: T)</code>，实际调用<code>Json.encodeToString</code>，它的逻辑：创建StreamingJsonEncoder（Encoder的实现类），将数据写入JsonStringBuilder，完成后转换为字符串进行返回。进入StreamingJsonEncoder查看，可以看到它定义了Composer类，控制Json格式的组合</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="type">&lt;T&gt;</span> <span class="title">encodeToString</span><span class="params">(serializer: <span class="type">SerializationStrategy</span>&lt;<span class="type">T</span>&gt;, value: <span class="type">T</span>)</span></span>: String &#123;</span><br><span class="line">  <span class="keyword">val</span> result = JsonStringBuilder()</span><br><span class="line">  <span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="keyword">val</span> encoder = StreamingJsonEncoder(</span><br><span class="line">      result, <span class="keyword">this</span>,</span><br><span class="line">      WriteMode.OBJ,</span><br><span class="line">      arrayOfNulls(WriteMode.values().size)</span><br><span class="line">    )</span><br><span class="line">    encoder.encodeSerializableValue(serializer, value)</span><br><span class="line">    <span class="keyword">return</span> result.toString()</span><br><span class="line">  &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">    result.release()</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如果我们去AbstractJsonLexer.kt下面看，还可以看到预定义的各种Json元字符。</p>
<img src="https://gdz.oss-cn-shenzhen.aliyuncs.com/local/image-20211009154534756.png" alt="image-20211009154534756" style="zoom:80%;" />

<h3 id="实现上下文和多态"><a href="#实现上下文和多态" class="headerlink" title="实现上下文和多态"></a>实现上下文和多态</h3><p>前文我们能够看到，在使用上下文和多态功能时，会创建SerializersModule，事实上，SerializersModule就是专门为上下文和多态设计的，因此首先要拆解SerializersModule，可以看到，它只包含了两类方法，上下文和多态，其中上下文返回的是KSerializer，多态在序列化和反序列化各自定义了一个方法。</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">sealed</span> <span class="class"><span class="keyword">class</span> <span class="title">SerializersModule</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="function"><span class="keyword">fun</span> <span class="type">&lt;T : Any&gt;</span> <span class="title">getContextual</span><span class="params">(kclass: <span class="type">KClass</span>&lt;<span class="type">T</span>&gt;)</span></span>: KSerializer&lt;T&gt;? =</span><br><span class="line">        getContextual(kclass, emptyList())</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">abstract</span> <span class="function"><span class="keyword">fun</span> <span class="type">&lt;T : Any&gt;</span> <span class="title">getContextual</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">        kClass: <span class="type">KClass</span>&lt;<span class="type">T</span>&gt;,</span></span></span><br><span class="line"><span class="params"><span class="function">        typeArgumentsSerializers: <span class="type">List</span>&lt;<span class="type">KSerializer</span>&lt;*&gt;&gt; = emptyList()</span></span></span><br><span class="line">    ): KSerializer&lt;T&gt;?</span><br><span class="line">  </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">abstract</span> <span class="function"><span class="keyword">fun</span> <span class="type">&lt;T : Any&gt;</span> <span class="title">getPolymorphic</span><span class="params">(baseClass: <span class="type">KClass</span>&lt;<span class="type">in</span> <span class="type">T</span>&gt;, value: <span class="type">T</span>)</span></span>: SerializationStrategy&lt;T&gt;?</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">abstract</span> <span class="function"><span class="keyword">fun</span> <span class="type">&lt;T : Any&gt;</span> <span class="title">getPolymorphic</span><span class="params">(baseClass: <span class="type">KClass</span>&lt;<span class="type">in</span> <span class="type">T</span>&gt;, serializedClassName: <span class="type">String</span>?)</span></span>: DeserializationStrategy&lt;<span class="keyword">out</span> T&gt;?</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>其唯一的实现类SerialModuleImpl如下，它维护了四个map</p>
<ul>
<li>class2ContextualFactory：存储类型和上下文Provider的映射，上下文Provider根据类型参数得到最终的序列化器</li>
<li>polyBase2Serializers：存储了基类和具体值的真实类型的序列化器的映射关系，用于多态序列化</li>
<li>polyBase2NamedSerializers：存储了基类和序列化后的类名的反序列化器的映射关系，用于多态反序列化</li>
<li>polyBase2DefaultProvider：存储了针对基类的默认反序列化器</li>
</ul>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">internal</span> <span class="class"><span class="keyword">class</span> <span class="title">SerialModuleImpl</span></span>(</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">val</span> class2ContextualFactory: Map&lt;KClass&lt;*&gt;, ContextualProvider&gt;,</span><br><span class="line">  <span class="meta">@JvmField</span> <span class="keyword">val</span> polyBase2Serializers: Map&lt;KClass&lt;*&gt;, Map&lt;KClass&lt;*&gt;, KSerializer&lt;*&gt;&gt;&gt;,</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">val</span> polyBase2NamedSerializers: Map&lt;KClass&lt;*&gt;, Map&lt;String, KSerializer&lt;*&gt;&gt;&gt;,</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">val</span> polyBase2DefaultProvider: Map&lt;KClass&lt;*&gt;, PolymorphicProvider&lt;*&gt;&gt;</span><br><span class="line">) : SerializersModule() &#123;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="type">&lt;T : Any&gt;</span> <span class="title">getPolymorphic</span><span class="params">(baseClass: <span class="type">KClass</span>&lt;<span class="type">in</span> <span class="type">T</span>&gt;, value: <span class="type">T</span>)</span></span>: SerializationStrategy&lt;T&gt;? &#123;</span><br><span class="line">    <span class="keyword">if</span> (!value.isInstanceOf(baseClass)) <span class="keyword">return</span> <span class="literal">null</span></span><br><span class="line">    <span class="keyword">return</span> polyBase2Serializers[baseClass]?.<span class="keyword">get</span>(value::<span class="class"><span class="keyword">class</span>) <span class="title">as</span>? <span class="title">SerializationStrategy</span>&lt;<span class="type">T</span>&gt;</span></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="type">&lt;T : Any&gt;</span> <span class="title">getPolymorphic</span><span class="params">(baseClass: <span class="type">KClass</span>&lt;<span class="type">in</span> <span class="type">T</span>&gt;, serializedClassName: <span class="type">String</span>?)</span></span>: DeserializationStrategy&lt;<span class="keyword">out</span> T&gt;? &#123;</span><br><span class="line">    <span class="comment">// Registered</span></span><br><span class="line">    <span class="keyword">val</span> registered = polyBase2NamedSerializers[baseClass]?.<span class="keyword">get</span>(serializedClassName) <span class="keyword">as</span>? KSerializer&lt;<span class="keyword">out</span> T&gt;</span><br><span class="line">    <span class="keyword">if</span> (registered != <span class="literal">null</span>) <span class="keyword">return</span> registered</span><br><span class="line">    <span class="comment">// Default</span></span><br><span class="line">    <span class="keyword">return</span> (polyBase2DefaultProvider[baseClass] <span class="keyword">as</span>? PolymorphicProvider&lt;T&gt;)?.invoke(serializedClassName)</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="type">&lt;T : Any&gt;</span> <span class="title">getContextual</span><span class="params">(kClass: <span class="type">KClass</span>&lt;<span class="type">T</span>&gt;, typeArgumentsSerializers: <span class="type">List</span>&lt;<span class="type">KSerializer</span>&lt;*&gt;&gt;)</span></span>: KSerializer&lt;T&gt;? &#123;</span><br><span class="line">    <span class="keyword">return</span> (class2ContextualFactory[kClass]?.invoke(typeArgumentsSerializers)) <span class="keyword">as</span>? KSerializer&lt;T&gt;?</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>现在我们可以按照步骤来看上下文和多态的实现方方法了</p>
<ol>
<li><p>注册类和对应的序列化器，实际上就是创建SerialModuleImpl对象，并赋值给SerialFormat的serializersModule属性。</p>
<p>实际写入的是SerialModuleImpl.class2ContextualFactory属性</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line">Json &#123;</span><br><span class="line">  serializersModule = serializersModuleOf(LocalDateTime::<span class="class"><span class="keyword">class</span>, <span class="type">LocalDateTimeAsLongSerializer)</span></span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>调用StringFormat.encodeToString()，它调用serializersModule.serializer()方法获取对应的序列化器</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">inline</span> <span class="function"><span class="keyword">fun</span> <span class="type">&lt;<span class="keyword">reified</span> T&gt;</span> StringFormat.<span class="title">encodeToString</span><span class="params">(value: <span class="type">T</span>)</span></span>: String =</span><br><span class="line">    encodeToString(serializersModule.serializer(), value)</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">inline</span> <span class="function"><span class="keyword">fun</span> <span class="type">&lt;<span class="keyword">reified</span> T&gt;</span> SerializersModule.<span class="title">serializer</span><span class="params">()</span></span>: KSerializer&lt;T&gt; &#123;</span><br><span class="line">    <span class="keyword">return</span> serializer(typeOf&lt;T&gt;()).cast()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>重点就在<code>serializer(typeOf&lt;T&gt;())</code>了，根据类型确定序列化器（走反射），源码过长过碎，这里就不展示了，只说大致逻辑</p>
<ul>
<li>如果类型是枚举，则创建枚举序列化器</li>
<li>如果是接口，则创建PolymorphicSerializer，即多态序列化器，</li>
<li>如果伴生对象中存在序列化器，则直接使用（@Serializable自动生成的那个）</li>
<li>如果有Polymorphic注解，或者Serializable直接中明确指明使用PolymorphicSerializer，则返回多态序列化器</li>
<li>否则，调用SerialModuleImpl.getContextual()方法，根据类获取之前注册到上下文中的序列化器。</li>
</ul>
<p>可以看到，在不同的情况下，会返回不同的序列化器，所谓上下文和多态，都是通过序列化器实现的。这里要多提的一点是，多态一定是通过PolymorphicSerializer实现的，因为它需要添加一个type字段。</p>
</li>
</ol>
<h4 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h4><p>可以看到，上下文和多态，实际上都只是根据类型确定序列化器和反序列化器的过程，而这些序列化器默认来自SerializersModule。</p>
<p>当然，我们最终也可以显式地指定序列化器，跳过这个决定的过程，毕竟，StringFormat的方法都可以接收序列化器。</p>
<h2 id="开发属于自己的序列化格式"><a href="#开发属于自己的序列化格式" class="headerlink" title="开发属于自己的序列化格式"></a>开发属于自己的序列化格式</h2><p>这里做一个小演示，如果我想要实现自己的序列化格式，只需要三步</p>
<ol>
<li>实现Encoder</li>
<li>实现SerialFormat</li>
<li>使用</li>
</ol>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 实现Encoder</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">FloydEncoder</span></span>(</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">val</span> sb: StringBuilder,</span><br><span class="line">    <span class="keyword">override</span> <span class="keyword">val</span> serializersModule: SerializersModule</span><br><span class="line">) : AbstractEncoder() &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">encodeValue</span><span class="params">(value: <span class="type">Any</span>)</span></span> &#123;</span><br><span class="line">        sb.append(<span class="string">&quot;<span class="variable">$value</span>&#125;&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">encodeElement</span><span class="params">(descriptor: <span class="type">SerialDescriptor</span>, index: <span class="type">Int</span>)</span></span>: <span class="built_in">Boolean</span> &#123;</span><br><span class="line">        sb.append(<span class="string">&quot;&#123;<span class="subst">$&#123;descriptor.getElementName(index)&#125;</span>=&quot;</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 实现SerialFormat</span></span><br><span class="line"><span class="keyword">object</span> Floyd : StringFormat &#123;</span><br><span class="line">    <span class="keyword">override</span> <span class="keyword">val</span> serializersModule: SerializersModule = EmptySerializersModule</span><br><span class="line"></span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="type">&lt;T&gt;</span> <span class="title">decodeFromString</span><span class="params">(deserializer: <span class="type">DeserializationStrategy</span>&lt;<span class="type">T</span>&gt;, string: <span class="type">String</span>)</span></span>: T &#123;</span><br><span class="line">        TODO(<span class="string">&quot;Not yet implemented&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="type">&lt;T&gt;</span> <span class="title">encodeToString</span><span class="params">(serializer: <span class="type">SerializationStrategy</span>&lt;<span class="type">T</span>&gt;, value: <span class="type">T</span>)</span></span>: String &#123;</span><br><span class="line">        <span class="keyword">val</span> sb = StringBuilder()</span><br><span class="line">        FloydEncoder(sb, serializersModule).encodeNullableSerializableValue(serializer, value).toString()</span><br><span class="line">        <span class="keyword">return</span> sb.toString()</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 使用</span></span><br><span class="line"><span class="meta">@Serializable</span></span><br><span class="line"><span class="keyword">data</span> <span class="class"><span class="keyword">class</span> <span class="title">Resource</span></span>(</span><br><span class="line">    <span class="keyword">val</span> id: String,</span><br><span class="line">    <span class="keyword">val</span> desc: String</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">val</span> resource = Resource(<span class="string">&quot;1&quot;</span>, <span class="string">&quot;用于测试自定义Encoder的资源&quot;</span>)</span><br><span class="line">    <span class="keyword">val</span> encodeString = Floyd.encodeToString(resource)</span><br><span class="line">    println(encodeString)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>输出</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">&#123;id=1&#125;&#123;desc=用于测试自定义Encoder的资源&#125;</span><br></pre></td></tr></table></figure>

<h2 id="哪些文档能看"><a href="#哪些文档能看" class="headerlink" title="哪些文档能看"></a>哪些文档能看</h2><p>这里只讲了主要部分，具体细节还有更多，目前网络上系统介绍Kotlin序列化的文章不多，还是以官方文档为主</p>
<ul>
<li>首推<a href="https://github.com/Kotlin/kotlinx.serialization/blob/master/docs/serialization-guide.md">官方文档</a></li>
<li>然后<a href="https://kotlin.github.io/kotlinx.serialization/kotlinx-serialization-core/kotlinx-serialization-core/index.html">Kotlin 序列化Api doc</a></li>
<li>然后是源码</li>
</ul>
<p>不过看源码有一个很重的感受：Kotlin库总是将抽象本身定义得比较抽象，然后大量使用扩展方法来为这些抽象增加能力，这会导致代码片段比较碎。如果用IDEA查看源码，会出现库的索引页全是类型，极不方便查找，但事实上可能只有少数几个kt源文件，所以需要探寻更加时刻Kotlin库的源码查看方式。</p>
<h2 id="总结-1"><a href="#总结-1" class="headerlink" title="总结"></a>总结</h2><p>优点</p>
<ul>
<li>Kotlin原生，使用起来相对优雅</li>
<li>其抽象逻辑具有很强的扩展性，要基于此实现自己的序列化格式也比较容易</li>
<li>序列化逻辑编译期生成，可能会比较快，这点尚未验证</li>
</ul>
<p>缺点</p>
<ul>
<li>太新，不够成熟，尽管Json版本已经稳定了，但其中很多API还是被标注为“实验性”的。如果线上要使用，我可能还是会选择Jackson吧。</li>
<li>不能很好滴和第三方库如Spring等很好地融合。</li>
</ul>
<p>此外，本文所有代码，都能在<a href="https://gitee.com/zou8944/play-floyd/tree/master/serialization/src/main/kotlin/com/gitee/floyd/serialization/kotlin">这里</a>找到。</p>
]]></content>
      <categories>
        <category>后端</category>
      </categories>
      <tags>
        <tag>kotlin</tag>
        <tag>序列化</tag>
      </tags>
  </entry>
  <entry>
    <title>一些思考 - 我们应该如何做测试</title>
    <url>/2022/05/29/%E6%88%91%E4%BB%AC%E5%BA%94%E8%AF%A5%E5%A6%82%E4%BD%95%E6%B5%8B%E8%AF%95/</url>
    <content><![CDATA[<h2 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h2><p>我们到底应该如何测试？</p>
<p>TDD的想法是非常美好的；单元测试、集成测试、系统测试、验收测试等构成的测试金字塔是非常美好的；通过测试，尽早地将问题暴露出来的想法也是非常美好的。但测试带来的收益和成本应该如何衡量呢？大团队应该如何测试？两三个人的小团队又应该如何测试？</p>
<p>如果你所在的团队已经有明确的测试规范，那不用操心这些问题；但如果是专注业务的小团队，各方面尚未有明确规范，测试应该做到什么程度，会是一个值得思考的问题。</p>
<span id="more"></span>

<h2 id="一点实践"><a href="#一点实践" class="headerlink" title="一点实践"></a>一点实践</h2><p>伊始，对测试算是一知半解，主要认知还来自主观认识，知道单元测试、集成测试基本概念，大致了解JUnit、Mock等工具或概念。于是想要系统了解，去看书、去阅读手册，了解了TDD，对一个项目从头到尾添加了单元测试，耗费两周，得到了数千行测试代码。但在后续开发中，还是没能坚持同步添加新功能的测试代码。分析了一下，有如下几点原因</p>
<ul>
<li>测试太细：controller层单独测试请求参数验证逻辑、service层针对大部分方法都添加了测试、repository层针对每个表、每个方法、每个约束条件都写了测试。</li>
<li>测试代码维护不方便：由于采用了分层结构，且service依赖dao层，也可能自己相互依赖，还有被调用方法等，存在带量的mock，阅读时违反直觉（我怎么知道你这个业务方法里有哪些依赖，这就还得去研究业务方法，但好的测试不应该是这样）。</li>
</ul>
<p>汲取教训，很多地方其实根本不用单元测试覆盖，以集成测试+关键逻辑单元测试的方法才是最好的。但矫枉过正，这次甚至不想要写测试代码就能把集成测试这块搞定了，期望的效果是：用文件（excel、数据库或json文件）将接口地址、输入、预期输出等进行声明，代码自动生成测试。但实际操作下来可行性不高，接口地址、输入等不变量好书，但对输出的验证是个麻烦：确切地直接匹配、验证某些字段存在、验证某些字段的值、只验证状态码；且有时需要接口调用之间有依赖关系，以便测试一个完整的使用case。于是本该简化的集成测试声明，有需要为了这些个性化需求订一套规则，这无疑又是在造轮子，万万是不可取的。</p>
<p>仔细想想，我就是在寻找针对测试的银弹，但世界上没有银弹，所以这注定失败。取而代之，最终我还是使用MockMvc进行集成测试，不同的是，我将它整理得更加易读。</p>
<h2 id="一点思考"><a href="#一点思考" class="headerlink" title="一点思考"></a>一点思考</h2><p>我在测试上做的这些事情，总归可以用一个问题来概括：业务项目应该如何测试？我的想法是，业务无非几点：路由、数据、业务逻辑。可按照如下逻辑写测试</p>
<ul>
<li><p>主要业务场景的集成测试，这部分使用@SpringBootTest，启动整个项目，可以用EmbeddedDatabase作数据库，使得测试时数据变现可预期。由于@SpringBootTest启动非常耗时，因此所有集成测试都写在一个类中。</p>
<p>这一步的主要作用是验证代码的修改对主要功能没有影响。</p>
</li>
<li><p>针对controller层的参数验证测试，使用@WebMvcTest单独启动controller层。</p>
<p>这一步的主要作用是确保API各种非法数据能够被正确处理，从入口上拒绝脏数据。</p>
</li>
<li><p>针对核心逻辑写传统意义上的单元测试。核心逻辑尽量写成无状态函数，方便测试也方便阅读。</p>
</li>
<li><p>其它部分：自由发挥。</p>
<p>前三部分是产出投入比最高的部分，是必须的，也肯定不会亏。这一步性价比相对低很多，写不写完全看自己。</p>
</li>
</ul>
<blockquote>
<p>PS：没有测试的心，再好再简单的测试工具也不会好用。相反，如果你想要写测试，总能写出方便阅读又有效的测试代码。</p>
</blockquote>
<h2 id="一点想法"><a href="#一点想法" class="headerlink" title="一点想法"></a>一点想法</h2><p>上面仅仅保证了代码本身没有问题，我们再加上部署呢？</p>
<p>从项目维护角度来说，可用性非常重要，如何确保每次CD之后都是可用的？我的想法是：将冒烟测试加入CI/CD流程，CD灰度发布，对灰度部分进行冒烟测试。通过则全量更新，否则回滚并报错。冒烟测试按优先级从高到低应包含如下</p>
<ul>
<li>测试健康检查接口：证明可达性没有问题</li>
<li>调用需要使用外部服务的接口：证明依赖服务没有问题</li>
<li>调用主要业务case接口：证明主要业务没有问题</li>
</ul>
<p>至此，我们构成了一个相对完整且安全的开发-发布链，能够满足大部分需求。</p>
]]></content>
      <categories>
        <category>devops</category>
      </categories>
      <tags>
        <tag>测试</tag>
      </tags>
  </entry>
  <entry>
    <title>我为什么喜欢鲁鲁修</title>
    <url>/2021/09/06/%E6%88%91%E4%B8%BA%E4%BB%80%E4%B9%88%E5%96%9C%E6%AC%A2%E9%B2%81%E9%B2%81%E4%BF%AE--wo-wei-shen-me-xi-huan-lu-lu-xiu-httpswwwnotionsoa72043b53a5a48f3beb069ab6a18be9b/</url>
    <content><![CDATA[<p>《反叛的鲁鲁修》好看吗？毫无疑问我认为是好看的，但细想，为啥我会觉得好看呢？不能凭感觉，好看总有个理由，必须是客观上的。</p>
<span id="more"></span>

<h2 id="世界设定"><a href="#世界设定" class="headerlink" title="世界设定"></a>世界设定</h2><p>动漫吸引我的很大原因，在于想象力。火影忍者凭空架设出一个完整的忍者世界，海贼王的海贼世界，无一不让我惊叹这些作者丰富的想象力。鲁鲁修给的世界让人感觉非常有意思——直接根据现实世界改变而来。</p>
<p>世界地图，就是真实的世界地图，不同的是所属国家的变化。全球分为三大部分：布里塔尼亚——美洲、EU——欧洲、中华联邦——亚洲大部分。布里塔尼亚就是美帝的翻版，占领日本，也仿佛是在影射二战。并且，和现实一样，布里塔尼亚研究出核武器并在日本本土进行了投放。</p>
<p>这样直接根据历史而来的世界背景设定，是我第一次见到（动漫还是看得少。。。）</p>
<h2 id="反叛和翻转"><a href="#反叛和翻转" class="headerlink" title="反叛和翻转"></a>反叛和翻转</h2><p>反叛的鲁鲁修，“反叛”一词。起初的理解类似叛逆，一个少年的反叛，与叛逆无异。</p>
<p>果然还是我太年轻。就感觉和写主题作文一样，片中好像一直在点题。第一季，为了妹妹娜娜莉，顶着布里塔尼亚人的身份，以ZERO之名，直接反叛布里塔尼亚政府；反叛兄弟朱雀；反叛恋人莎莉；反叛皇妹尤菲米娅；最终为救娜娜莉甚至客观反叛黑色骑士团。第二季更为彻底，反叛妹妹娜娜莉。</p>
<p>伴随反叛的，就是不停地反转。我要战败了。。。诶反转，我有了最新武器，无敌的存在；我要被黑色骑士团制裁了。。。诶反转，我摇身一变成了布里塔利亚的皇帝；我要将世界以自己的方式进行有利的改造，要与世界为伍。。。诶反转，我变成了全世界的公敌；我要专制独裁统治全世界。。。诶反转，我将仇恨带到地狱，留给世界一片祥和。</p>
<p>只能说。。。简直了。</p>
<h2 id="英雄主义"><a href="#英雄主义" class="headerlink" title="英雄主义"></a>英雄主义</h2><p>就像漫画中活跃的电台制作人迪特哈尔特·里德一样，我相信现实生活中的很多人都对个人英雄主义都有别样的喜爱之情，不然《玫瑰岛共和国》这样的电影为什么能够高分。为一个人，与全世界最强政府为敌，以独特的人格魅力和领导才能，左右着世界的风云变化；从与一个国家为敌，到与全世界为敌，将全世界的邪与恶集中于自己一人，再慷慨赴死，换取世界长久的和平。这样极致到如此彻底的个人英雄主义，极致到带有浓重的浪漫主义色彩，也是完美的理想主义。怎能不让人喜欢。</p>
<h2 id="战争与和平"><a href="#战争与和平" class="headerlink" title="战争与和平"></a>战争与和平</h2><p>动漫里有很多嘴遁环节，出现最多的话题是——和平。查尔斯国王和玛丽安娜王妃想让大家活在虚无的，没有实际战争和纷杂的精神世界中（这不就是。。。无限月读吗）；修奈泽尔的解决方案是核威慑；鲁鲁修则给全世界人们施以“愿望”的Geass，让大家憧憬美好的明天。</p>
<p>客观理性地讲是鲁鲁修正确，但凡事无绝对呀。</p>
]]></content>
      <categories>
        <category>随笔</category>
      </categories>
      <tags>
        <tag>反叛的鲁鲁修</tag>
      </tags>
  </entry>
  <entry>
    <title>序列化探索之四 - Fastjson</title>
    <url>/2021/10/15/%E5%BA%8F%E5%88%97%E5%8C%96%E6%8E%A2%E7%B4%A2%E4%B9%8B%E5%9B%9B%20-%20Fastjson-xu-lie-hua-tan-suo-zhi-fastjson/</url>
    <content><![CDATA[<p>开局一吐槽，Fastjson的文档，比Jackson还差。Jackson只是位置不明确，如果安下心来看看，还是能够理清楚的。而Fastjson是位置不明确，如果安下心来看看，还会发现，它的文档零零散散，中英文混杂，找不准主线在哪儿。我记得知乎上有个问题，<a href="https://www.zhihu.com/question/44199956">fastjson这么快老外为啥还是热衷 jackson?</a>，就这文档，让老外用个啥。</p>
<p>不过看还是要看的，毕竟它是目前主流序列化框架之一。老样子，我们还是从基本使用方法和原理分析两部分着手。</p>
<span id="more"></span>

<h2 id="能力"><a href="#能力" class="headerlink" title="能力"></a>能力</h2><p>Fastjson仅仅针对json，尚不支持其它任何格式，也没有看到谁为它进行格式扩展。因为这并不是它的目的，库如其名，它是为了更快地序列化Json而存在。因此，使用上来，会简单许多。具体分为几个部分</p>
<ul>
<li>常规使用</li>
<li>注解</li>
<li>自定义序列化器</li>
<li>自定义过滤器</li>
<li>树模型</li>
</ul>
<h3 id="基础能力"><a href="#基础能力" class="headerlink" title="基础能力"></a>基础能力</h3><figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">testBase</span><span class="params">()</span></span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">data</span> <span class="class"><span class="keyword">class</span> <span class="title">Resource</span></span>(</span><br><span class="line">        <span class="keyword">var</span> id: String,</span><br><span class="line">        <span class="keyword">var</span> type: Type</span><br><span class="line">    )</span><br><span class="line"></span><br><span class="line">    <span class="keyword">val</span> jsonString = JSON.toJSONString(Resource(<span class="string">&quot;1&quot;</span>, Type.RECORD))</span><br><span class="line">    println(jsonString)</span><br><span class="line">    <span class="keyword">val</span> resource = JSON.parseObject(jsonString, Resource::<span class="keyword">class</span>.java)</span><br><span class="line">    println(resource)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li><p>序列化：<code>JSON.toJSONString(对象)</code></p>
</li>
<li><p>反序列化：<code>JSON.parseObject(jsonString, 对象class)</code></p>
</li>
<li><p>注意</p>
<ul>
<li><p>默认情况下，是根据getter和setter方法取得和设置字段的，如果没有，将得不到输出</p>
</li>
<li><p>也可以基于属性获取和设置字段，考虑下面的例子</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">testBasedOnFields</span><span class="params">()</span></span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">data</span> <span class="class"><span class="keyword">class</span> <span class="title">Resource</span></span>(</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">var</span> id: String,</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">var</span> type: Type</span><br><span class="line">    )</span><br><span class="line">	</span><br><span class="line">  	<span class="comment">// 设置基于字段的序列化</span></span><br><span class="line">    <span class="keyword">val</span> serializeConfig = SerializeConfig(<span class="literal">true</span>)</span><br><span class="line">  	<span class="comment">// 设置基于字段反序列化</span></span><br><span class="line">    <span class="keyword">val</span> parserConfig = ParserConfig(<span class="literal">true</span>)</span><br><span class="line">    <span class="keyword">val</span> jsonString = JSON.toJSONString(Resource(<span class="string">&quot;1&quot;</span>, Type.RECORD), serializeConfig)</span><br><span class="line">    println(jsonString)</span><br><span class="line">    <span class="keyword">val</span> resource = JSON.parseObject&lt;Resource&gt;(jsonString, Resource::<span class="keyword">class</span>.java, parserConfig)</span><br><span class="line">    println(resource)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
</ul>
<h3 id="注解"><a href="#注解" class="headerlink" title="注解"></a>注解</h3><p>注解方面它采取了另一种思路，它只有两个注解，但将功能放在注解的属性中</p>
<ul>
<li>@JSONType：放在类上的注解 ，可设置<ul>
<li>alphabetic：字段按照字母顺序排序</li>
<li>asm：反序列化时是否使用asm</li>
<li>orders：字段之间的顺序</li>
<li>includes：需要包含哪些字段</li>
<li>excludes：需要排除哪些字段</li>
<li>serializeFeatures：需要包含的序列化功能</li>
<li>parseFeatures：需要包含的反序列化功能</li>
<li>mappingTo：映射成某个类</li>
<li>builder：指定反序列化的构建器</li>
<li>serializer：指定序列化器</li>
<li>deserializer：指定反序列化器</li>
<li>naming：指定命名策略</li>
<li>serialzeFilters：指定过滤器</li>
</ul>
</li>
<li>@JSONField：放在属性上的注解 ，可设置<ul>
<li>ordinal：序列化后字段的位置</li>
<li>name：序列化后的名字</li>
<li>format：指定日期的格式</li>
<li>serialize：是否参与序列化</li>
<li>deserialize：是否参与反序列化</li>
<li>serializeFeatures：需要包含的序列化功能</li>
<li>parseFeatures：需要包含的反序列化功能</li>
<li>label：标签，这是内部功能，结合过滤器可实现类似分组的功能</li>
<li>serializeUsing：指定序列化器</li>
<li>deseializeUsing：指定反序列化器</li>
<li>alternateNames：指定别名，反序列化时可用</li>
<li>unwrapped：将带有结构的对象的属性提取到顶层</li>
<li>defaultValue：反序列化时的默认值</li>
</ul>
</li>
</ul>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 一个简单的修改属性名字献给大家</span></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">testAnnotations</span><span class="params">()</span></span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@JSONType(alphabetic = false, ignores = [<span class="meta-string">&quot;id&quot;</span>])</span></span><br><span class="line">    <span class="keyword">data</span> <span class="class"><span class="keyword">class</span> <span class="title">Resource</span></span>(</span><br><span class="line">        <span class="keyword">val</span> id: String,</span><br><span class="line">        <span class="meta">@JSONField(name = <span class="meta-string">&quot;resourceType&quot;</span>)</span></span><br><span class="line">        <span class="keyword">val</span> type: Type,</span><br><span class="line">        <span class="keyword">val</span> updatedTime: Date</span><br><span class="line">    )</span><br><span class="line"></span><br><span class="line">    println(JSON.toJSONString(Resource(<span class="string">&quot;1&quot;</span>, Type.RECORD, Date()), SerializerFeature.PrettyFormat))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>仔细想想，从注解能力上来说，还是有所差别的</p>
<ul>
<li>@JsonRawValue，将字段作为原生json看待</li>
<li>@JsonAutoDetect，自定义属性检测的可见性修饰符</li>
<li>@JsonView，同一个POJO的多种序列化结果，可通过label实现</li>
<li>@JsonAnyGetter、@JsonAnySetter，多余的字段塞到map，以及反过程</li>
<li>@JsonValue，将POJO的某个字段作为整个POJO的序列化结果</li>
<li>@JsonInclude，根据情况决定是否将字段加入序列化</li>
<li>@JsonEnumDefaultValue，给枚举设置默认值</li>
<li>@JsonInject，给某个字段强行注入</li>
<li>多态，不过可以通过其它方式变相达成：SerializeFeature.WriteClassName</li>
<li>@JsonManagedReference等循环引用的解决方式，Fastjson也有解决，不过它是采用$ref的方式，而非jackson的去除或使用某个字段替代。</li>
<li>@JsonRootName，将对象序列化到一个指定名称的属性下</li>
</ul>
<h3 id="自定义序列化器"><a href="#自定义序列化器" class="headerlink" title="自定义序列化器"></a>自定义序列化器</h3><p>不多解释，传统技能：为LocalDateTime自定义序列化器</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">testCustomSerializer</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">data</span> <span class="class"><span class="keyword">class</span> <span class="title">Resource</span></span>(</span><br><span class="line">        <span class="keyword">val</span> id: String,</span><br><span class="line">        <span class="keyword">val</span> type: Type,</span><br><span class="line">        <span class="keyword">val</span> updatedTime: LocalDateTime</span><br><span class="line">    )</span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">LocalDateTimeSerializer</span> : <span class="type">ObjectSerializer &#123;</span></span></span><br><span class="line">        <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">write</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">            serializer: <span class="type">JSONSerializer</span>,</span></span></span><br><span class="line"><span class="params"><span class="function">            `<span class="keyword">object</span>`: <span class="type">Any</span>?,</span></span></span><br><span class="line"><span class="params"><span class="function">            fieldName: <span class="type">Any</span>?,</span></span></span><br><span class="line"><span class="params"><span class="function">            fieldType: <span class="type">java</span>.<span class="type">lang</span>.<span class="type">reflect</span>.<span class="type">Type</span>?,</span></span></span><br><span class="line"><span class="params"><span class="function">            features: <span class="type">Int</span></span></span></span><br><span class="line"><span class="params"><span class="function">        )</span></span> &#123;</span><br><span class="line">            <span class="keyword">val</span> <span class="keyword">out</span> = serializer.<span class="keyword">out</span></span><br><span class="line">            <span class="keyword">if</span> (`<span class="keyword">object</span>` == <span class="literal">null</span>) &#123;</span><br><span class="line">                <span class="keyword">out</span>.writeNull()</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">out</span>.writeLong((`<span class="keyword">object</span>` <span class="keyword">as</span> LocalDateTime).toInstant(ZoneOffset.UTC).toEpochMilli())</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    SerializeConfig.globalInstance.put(LocalDateTime::<span class="keyword">class</span>.java, LocalDateTimeSerializer())</span><br><span class="line">    println(JSON.toJSONString(Resource(<span class="string">&quot;1&quot;</span>, Type.RECORD, LocalDateTime.now())))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>不过这序列化器注册的方式嘛，是不是不大友好呀。要么全局注册，要么序列化时传参进去，并不能持有多套配置JSON对象。</p>
<h3 id="自定义过滤器"><a href="#自定义过滤器" class="headerlink" title="自定义过滤器"></a>自定义过滤器</h3><p>过滤器是Fastjson比较独有的概念，也比较好理解：在序列化的多个阶段提供给用户参与调整的机会。</p>
<p><img src="https://gdz.oss-cn-shenzhen.aliyuncs.com/local/image-20211015152451901.png" alt="image-20211015152451901"></p>
<p>具体怎么用，只能靠猜，源码也没有注释，文档也不好找，需要的时候再去找吧。这里就展示怎么注册：把所有名称都设置为大写</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">testCustomFilter</span><span class="params">()</span></span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">data</span> <span class="class"><span class="keyword">class</span> <span class="title">Resource</span></span>(</span><br><span class="line">        <span class="keyword">val</span> id: String,</span><br><span class="line">        <span class="keyword">val</span> type: Type,</span><br><span class="line">        <span class="keyword">val</span> updatedTime: LocalDateTime</span><br><span class="line">    )</span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">IdFilter</span> : <span class="type">NameFilter &#123;</span></span></span><br><span class="line">        <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">process</span><span class="params">(`<span class="keyword">object</span>`: <span class="type">Any</span>?, name: <span class="type">String</span>, value: <span class="type">Any</span>)</span></span>: String? &#123;</span><br><span class="line">            <span class="keyword">return</span> name.uppercase(Locale.getDefault())</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    SerializeConfig.globalInstance.addFilter(Resource::<span class="keyword">class</span>.java, IdFilter())</span><br><span class="line">    println(JSON.toJSONString(Resource(<span class="string">&quot;1&quot;</span>, Type.RECORD, LocalDateTime.now())))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="树模型的使用"><a href="#树模型的使用" class="headerlink" title="树模型的使用"></a>树模型的使用</h3><p>没错，它也有树模型，只是功能没那么强大而已，它也只有两个对象</p>
<ul>
<li>JSONObject：可直接理解为Map，事实上它也是继承了Map</li>
<li>JSONArray：理解为List</li>
</ul>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">testTreeModel</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">val</span> resource = JSONObject()</span><br><span class="line">        .fluentPut(<span class="string">&quot;ID&quot;</span>, <span class="number">1</span>)</span><br><span class="line">        .fluentPut(</span><br><span class="line">            <span class="string">&quot;data&quot;</span>, JSONArray()</span><br><span class="line">                .fluentAdd(</span><br><span class="line">                    JSONObject()</span><br><span class="line">                        .fluentPut(<span class="string">&quot;images&quot;</span>, <span class="string">&quot;[]&quot;</span>)</span><br><span class="line">                )</span><br><span class="line">        )</span><br><span class="line">    println(JSON.toJSONString(resource, SerializerFeature.PrettyFormat, SerializerFeature.SortField))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>输出如下，这里可以看到一个问题：Fastjson默认序列化后所有的字段都是排序的，这就很不好。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">	<span class="string">&quot;data&quot;</span>:[</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="string">&quot;images&quot;</span>:<span class="string">&quot;[]&quot;</span></span><br><span class="line">		&#125;</span><br><span class="line">	],</span><br><span class="line">	<span class="string">&quot;ID&quot;</span>:1</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="其它功能"><a href="#其它功能" class="headerlink" title="其它功能"></a>其它功能</h3><p>其它功能，主要就是在Feature中指定的内容了，基本都是置顶序列化和反序列化时遵循的特性。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 序列化相关的功能</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">enum</span> <span class="title">SerializerFeature</span> </span>&#123;</span><br><span class="line">  	<span class="comment">// 字段名用引号引起来</span></span><br><span class="line">    QuoteFieldNames,</span><br><span class="line">    <span class="comment">// 使用单引号</span></span><br><span class="line">    UseSingleQuotes,</span><br><span class="line">    WriteMapNullValue,</span><br><span class="line">    <span class="comment">// 枚举调用toString()输出</span></span><br><span class="line">    WriteEnumUsingToString,</span><br><span class="line">    <span class="comment">// 枚举调用name()输出</span></span><br><span class="line">    WriteEnumUsingName,</span><br><span class="line">    <span class="comment">// 日期使用ISO8601格式</span></span><br><span class="line">    UseISO8601DateFormat,</span><br><span class="line">    <span class="comment">// 列表的null输出为[]</span></span><br><span class="line">    WriteNullListAsEmpty,</span><br><span class="line">    <span class="comment">// 字符串的null输出为空串</span></span><br><span class="line">    WriteNullStringAsEmpty,</span><br><span class="line">    <span class="comment">// 数字的null输出为0</span></span><br><span class="line">    WriteNullNumberAsZero,</span><br><span class="line">    <span class="comment">// 布尔的null输出为false</span></span><br><span class="line">    WriteNullBooleanAsFalse,</span><br><span class="line">    <span class="comment">// 忽略被transient标记的字段</span></span><br><span class="line">    SkipTransientField,</span><br><span class="line">    <span class="comment">// 为字段排序</span></span><br><span class="line">    SortField,</span><br><span class="line">    <span class="comment">// 格式化输出</span></span><br><span class="line">    PrettyFormat,</span><br><span class="line">    <span class="comment">// 输出结果添加类名，可用来实现多态</span></span><br><span class="line">    WriteClassName,</span><br><span class="line">		<span class="comment">// 关闭循环引用检测</span></span><br><span class="line">    DisableCircularReferenceDetect,</span><br><span class="line">		<span class="comment">// 将斜线当做特殊符号</span></span><br><span class="line">    WriteSlashAsSpecial,</span><br><span class="line">		<span class="comment">// 浏览器兼容</span></span><br><span class="line">    BrowserCompatible,</span><br><span class="line">		<span class="comment">// Date使用日期格式输出</span></span><br><span class="line">    WriteDateUseDateFormat,</span><br><span class="line">		<span class="comment">// 不写根类的名字</span></span><br><span class="line">    NotWriteRootClassName,</span><br><span class="line">    <span class="comment">// 将java bean的字段以数组的形式输出，而不是对象</span></span><br><span class="line">    BeanToArray,</span><br><span class="line">		<span class="comment">// 将非字符串的key当做字符串输出</span></span><br><span class="line">    WriteNonStringKeyAsString,</span><br><span class="line">    <span class="comment">// 不为没有值的属性写默认值</span></span><br><span class="line">    NotWriteDefaultValue,</span><br><span class="line">    <span class="comment">// 浏览器安全</span></span><br><span class="line">    BrowserSecure,</span><br><span class="line">    <span class="comment">// 忽略没有幕后字段的getter</span></span><br><span class="line">    IgnoreNonFieldGetter,</span><br><span class="line">    <span class="comment">// 将非字符串的值当做字符串输出</span></span><br><span class="line">    WriteNonStringValueAsString,</span><br><span class="line">    <span class="comment">// getter报错时忽略</span></span><br><span class="line">    IgnoreErrorGetter,</span><br><span class="line">		<span class="comment">// 将bigdecimal当做字符串输出</span></span><br><span class="line">    WriteBigDecimalAsPlain,</span><br><span class="line">		<span class="comment">// map输出时也要将字段排序</span></span><br><span class="line">    MapSortField;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 反序列化相关的功能</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">enum</span> <span class="title">Feature</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 读取完后自动关闭读取源</span></span><br><span class="line">    AutoCloseSource,</span><br><span class="line">    <span class="comment">// 允许注释出现</span></span><br><span class="line">    AllowComment,</span><br><span class="line">    <span class="comment">// 允许未被引号包含的字段名</span></span><br><span class="line">    AllowUnQuotedFieldNames,</span><br><span class="line">   	<span class="comment">// 允许单引号</span></span><br><span class="line">    AllowSingleQuotes,</span><br><span class="line">    <span class="comment">// 字段名intern化，主要用于节省空间</span></span><br><span class="line">    InternFieldNames,</span><br><span class="line">    <span class="comment">// 允许ISO8601格式的日期格式</span></span><br><span class="line">    AllowISO8601DateFormat,</span><br><span class="line">		<span class="comment">// 允许任意数量的逗号间隔</span></span><br><span class="line">    AllowArbitraryCommas,</span><br><span class="line">		<span class="comment">// 数字使用BigDecinal接收</span></span><br><span class="line">    UseBigDecimal,</span><br><span class="line">    <span class="comment">// 字段不匹配时忽略，不报错</span></span><br><span class="line">    IgnoreNotMatch,</span><br><span class="line">		<span class="comment">// 启用有序字段的匹配算法，会更快</span></span><br><span class="line">    SortFeidFastMatch,</span><br><span class="line">    <span class="comment">// 不启用ASM</span></span><br><span class="line">    DisableASM,</span><br><span class="line">    <span class="comment">// 关闭循环引用的检测</span></span><br><span class="line">    DisableCircularReferenceDetect,</span><br><span class="line">    <span class="comment">// 字符串类型的字段初始化为空串</span></span><br><span class="line">    InitStringFieldAsEmpty,</span><br><span class="line">    <span class="comment">// 支持将数组转换为bean</span></span><br><span class="line">    SupportArrayToBean,</span><br><span class="line">    <span class="comment">// 字段排序</span></span><br><span class="line">    OrderedField,</span><br><span class="line">    <span class="comment">// 关闭特殊字符检测</span></span><br><span class="line">    DisableSpecialKeyDetect,</span><br><span class="line">    <span class="comment">// 使用对象数组</span></span><br><span class="line">    UseObjectArray,</span><br><span class="line">		<span class="comment">// 支持非public的字段写入</span></span><br><span class="line">    SupportNonPublicField,</span><br><span class="line">		<span class="comment">// 忽略autotype，即多态的功能</span></span><br><span class="line">    IgnoreAutoType,</span><br><span class="line">		<span class="comment">// disable field smart match, improve performance in some scenarios.</span></span><br><span class="line">    DisableFieldSmartMatch,</span><br><span class="line">		<span class="comment">// 开启自动类型转换</span></span><br><span class="line">    SupportAutoType,</span><br><span class="line">		<span class="comment">// 非字符串的key转化为string</span></span><br><span class="line">    NonStringKeyAsString,</span><br><span class="line">		<span class="comment">// 使用自定义的Map的反序列化器</span></span><br><span class="line">    CustomMapDeserializer,</span><br><span class="line">		<span class="comment">// 枚举不匹配时报错</span></span><br><span class="line">    ErrorOnEnumNotMatch,</span><br><span class="line">		<span class="comment">// 安全模式</span></span><br><span class="line">    SafeMode,</span><br><span class="line">		<span class="comment">// 字符串字段去除两头空字符</span></span><br><span class="line">    TrimStringFieldValue</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h2><p>看了kotlinx.serialization、Jackson，再看Fastjson，发现它们的组成基本一致，无非三个部分，可能根据情况其命名和具体实现方式会有所不同。这部分没啥新意，自己追一下方法就OK了。</p>
<ul>
<li>门面：JSON</li>
<li>将原始对象写入流：SerializeWriter、JSONReaderScanner</li>
<li>将自定义对象转换为原始对象：ObjectSerializer、ObjectDeserializer</li>
</ul>
<p>Fastjson的特点在于快，为什么这么快呢？据说是算法，<a href="https://www.iteye.com/blog/wenshao-1142031">作者自己的博客——Fastjson技术内幕</a>有所描述，归结起来大概就是</p>
<ul>
<li>自定义SerializeWriter，提供两部并做一步走之类的方法writeIntAndChar，减少越界检查</li>
<li>使用ASM避免反射</li>
<li>自定义IdentityHashMap，避免equals操作</li>
<li>默认字段有序，以便为反序列化性能提升做准备</li>
<li>balabalabalabalabala</li>
</ul>
<p>所以Fastjson的原理，重点是算法，而不在结构上。而这些算法，是不是有点奇技淫巧了🤔。</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>看了官方手册、网上相关文章，翻阅了源码，试用了基本功能，Fastjson给人最大的感觉——偏科生。</p>
<p>偏在哪里？速度，大家都在强调快快快，一切以快为目标。作者告诉我们Fastjson是目前已知的最快的Json序列化库，给出benchmark，晒出获奖记录，好像要脚踩Jackson，拳打Gson，唯我独尊，甚至和Protobuf进行了对比（这个对比我觉得就很扯）；网文介绍Fastjson的功能时，快是一定要强调的。大家好像陷入一种狂热状态，好像Json序列化最主要的功能就是为了快，这明显是不正常的。</p>
<p>典型的Web场景，数据库读取几十ms，序列化几ms，如果序列化不是以指数形式加速，快个小几倍个人认为意义不大，可能对于京东淘宝这种超大吞吐量有意义，对一般的网站，Jackson已经足够快速。</p>
<p>作为一个序列化库，更重要的是稳定性、安全性、可用性。这几方面FastJson做的貌似都不大好，文档混乱、代码没有注释、类命名还是有奇怪的地方，当然作为一个人撸出来的代码，也不能苛求太多。</p>
<p>对此，我个人的观点是，Fastjson只适合少数特定场景下的使用，并不能作为一个通用的Json序列化框架。目前看起来，我用Jackson。</p>
]]></content>
      <categories>
        <category>后端</category>
      </categories>
      <tags>
        <tag>序列化</tag>
      </tags>
  </entry>
  <entry>
    <title>我对跨域可能有些误解</title>
    <url>/2021/09/08/%E6%88%91%E5%AF%B9%E8%B7%A8%E5%9F%9F%E5%8F%AF%E8%83%BD%E6%9C%89%E4%BA%9B%E8%AF%AF%E8%A7%A3-2021-09-08-22-42-45/</url>
    <content><![CDATA[<h2 id="已知"><a href="#已知" class="headerlink" title="已知"></a>已知</h2><p>不得不说，我(们)对跨域可能有些误解。确切地讲，是对跨域的使用有些误解。</p>
<p>我的跨域知识从哪里来？从这里——<a href="https://developer.mozilla.org/zh-CN/docs/Web/HTTP/CORS">跨源资源共享（CORS） - HTTP | MDN</a></p>
<span id="more"></span>

<p>能总结出几点</p>
<ul>
<li>跨域是一种允许服务端对来自浏览器的访问进行控制的机制</li>
<li>它涉及到一系列专用的请求头<ul>
<li>浏览器端<ul>
<li>Origin：声明源站</li>
<li>Access-Control-Request-Method：声明自己将要使用什么方法</li>
<li>Access-Control-Request-Headers：声明自己将要携带哪些自定义头部</li>
</ul>
</li>
<li>服务端<ul>
<li>Access-Control-Allow-Origin：声明本站允许的源站</li>
<li>Access-Control-Allow-Methods：声明本站允许的方法</li>
<li>Access-Control-Allow-Headers：声明本真允许的自定义头部</li>
<li>Access-Control-Max-Age：声明一个预检请求的有效期，有效期内同一个请求无须再次预检</li>
</ul>
</li>
</ul>
</li>
<li>请求被划分为简单请求和复杂请求<ul>
<li>复杂请求在请求实际发出之前，会发出OPTIONS预检请求进行跨域询问</li>
<li>简单请求不需要预检</li>
</ul>
</li>
</ul>
<p>在实际使用中，我们为了方便，尝尝会将服务端的所有响应配置为“*”，即允许所有源站、方法、自定义首部的请求进行访问。</p>
<p>然而，这招在需要传输Cookie的请求中，行不通，浏览器会报如下错误。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">xxx from origin <span class="string">&#x27;xxxx&#x27;</span> has been blocked by CORS policy: The value of the <span class="string">&#x27;Access-Control-Allow-Origin&#x27;</span> header <span class="keyword">in</span> the response must not be the wildcard <span class="string">&#x27;*&#x27;</span> when the request<span class="string">&#x27;s credentials mode is &#x27;</span>include<span class="string">&#x27;. The credentials mode of requests initiated by the XMLHttpRequest is controlled by the withCredentials attribute.</span></span><br></pre></td></tr></table></figure>

<h2 id="盲区"><a href="#盲区" class="headerlink" title="盲区"></a>盲区</h2><p>出现这个问题，是因为漏掉了关键的一点：附带身份凭证的请求。其明确规定一点</p>
<ul>
<li><p>对于附带身份凭证的请求，服务器不得设置 Access-Control-Allow-Origin 的值为“*”</p>
<p>  相应的，它必须是确切地和请求中的Origin进行匹配，即，如果请求的Origin是<a href="http://xyc.com,则响应的access-control-allow-origin也必须为http//xyc.com">http://xyc.com，则响应的Access-Control-Allow-Origin也必须为http://xyc.com</a></p>
</li>
</ul>
<p>这一点可以验证，并且牵出一个新的响应请求头</p>
<ul>
<li>Access-Control-Allow-Credentials: 是否允许跨域携带凭证。为true时，代表允许，相应地Access-Control-Allow-Origin 就一定不会为“*”</li>
</ul>
<p>出现上面的错误只有一种情况，即响应只有Access-Control-Allow-Origin: *，而没有Access-Control-Allow-Credentials，或者其值为false。</p>
<p>解决办法，加上Access-Control-Allow-Credentials: true，并修改Access-Control-Allow-Origin。</p>
<h2 id="Spring对跨域的支持"><a href="#Spring对跨域的支持" class="headerlink" title="Spring对跨域的支持"></a>Spring对跨域的支持</h2><p>所有Spring Web模块，都支持直接配置跨域。下面是正确且唯一正确的配置</p>
<p>web服务的代码中配置</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Bean</span></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">corsFilter</span><span class="params">()</span></span>: CorsFilter &#123;</span><br><span class="line">    <span class="keyword">val</span> config = CorsConfiguration()</span><br><span class="line">    <span class="comment">// 预检请求有效期</span></span><br><span class="line">    config.maxAge = <span class="number">3600</span></span><br><span class="line">    <span class="comment">// 允许跨域发送身份凭证</span></span><br><span class="line">    config.allowCredentials = <span class="literal">true</span></span><br><span class="line">    <span class="comment">// 允许跨域的源为所有，注意与origin:*进行区分</span></span><br><span class="line">    config.addAllowedOriginPattern(<span class="string">&quot;*&quot;</span>)</span><br><span class="line">    <span class="comment">// 允许所有请求头</span></span><br><span class="line">    config.addAllowedHeader(<span class="string">&quot;*&quot;</span>)</span><br><span class="line">    <span class="comment">// 允许所有请求方法</span></span><br><span class="line">    config.addAllowedMethod(<span class="string">&quot;*&quot;</span>)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">val</span> source = UrlBasedCorsConfigurationSource().apply &#123;</span><br><span class="line">        <span class="comment">// 上述配置针对所有请求路径生效</span></span><br><span class="line">        registerCorsConfiguration(<span class="string">&quot;/**&quot;</span>, config)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> CorsFilter(source)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Spring Gateway中配置文件的配置</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="comment"># /**表示配置针对所有路径</span></span><br><span class="line"><span class="comment"># 允许</span></span><br><span class="line"><span class="string">spring.cloud.gateway.globalcors.cors-configurations.[/**].allowed-headers=*</span></span><br><span class="line"><span class="string">spring.cloud.gateway.globalcors.cors-configurations.[/**].allowed-methods=*</span></span><br><span class="line"><span class="string">spring.cloud.gateway.globalcors.cors-configurations.[/**].allowed-origin-patterns=*</span></span><br><span class="line"><span class="string">spring.cloud.gateway.globalcors.cors-configurations.[/**].allow-credentials=true</span></span><br></pre></td></tr></table></figure>

<p>这里尤其注意区分</p>
<p><code>addAllowedOriginPattern(&quot;*&quot;)</code>和<code>addOrigins(&quot;*&quot;)</code>的区别</p>
<ul>
<li><p>前者的*表示通配符，用来匹配请求的Origin，如果匹配成功，响应的Access-Control-Allow-Origin就直接被设置为请求的Origin</p>
</li>
<li><p>后者表示直接将所有的Access-Control-Allow-Origin值都设置为”*“。这个在和allowCredentials=true一起使用的情况下要注意</p>
</li>
<li><p>如果两个都设置，将会是<code>addOrigins(&quot;*&quot;)</code>生效。这一点可以去翻源码</p>
<p>  位置：org.springframework.web.cors.CorsConfiguration#checkOrigin</p>
</li>
</ul>
<h2 id="请求头冲突的问题"><a href="#请求头冲突的问题" class="headerlink" title="请求头冲突的问题"></a>请求头冲突的问题</h2><p>如果使用Spring Gateway作为网关，后面再挂着Spring Web作为服务，并且它们都正确配置了跨域。那么正常情况下，响应的请求头就会出现两份完全一样的跨域头部，像下面这样</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">vary:</span> <span class="string">Origin</span></span><br><span class="line"><span class="attr">access-control-allow-credentials:</span> <span class="literal">true</span></span><br><span class="line"><span class="attr">access-control-allow-origin:</span> <span class="string">xxxx</span></span><br><span class="line"><span class="attr">vary:</span> <span class="string">Origin</span></span><br><span class="line"><span class="attr">access-control-allow-credentials:</span> <span class="literal">true</span></span><br><span class="line"><span class="attr">access-control-allow-origin:</span> <span class="string">xxxx</span></span><br></pre></td></tr></table></figure>

<p>这似乎不违反HTTP关于请求头重复的规定，但在跨域的机制中，却是不可接收的，可能出现这种错误</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">Access to XMLHttpRequest at <span class="string">&#x27;xxxxx&#x27;</span> from origin <span class="string">&#x27;http://localhost:3200&#x27;</span> has been blocked by CORS policy: </span><br><span class="line">The <span class="string">&#x27;Access-Control-Allow-Origin&#x27;</span> header contains multiple values <span class="string">&#x27;*, http://localhost:3200&#x27;</span>, but only one is allowed.</span><br></pre></td></tr></table></figure>

<p>解决办法就是在网关对重复的头部进行处理，我们可以用过滤器：DedupeResponseHeader</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="string">spring.cloud.gateway.default-filters[0]=DedupeResponseHeader=Vary</span> <span class="string">Access-Control-Allow-Origin</span> <span class="string">Access-Control-Allow-Credentials</span></span><br></pre></td></tr></table></figure>

<p>它默认保留重复头中的第一个，具体参见<a href="%5Bhttps://docs.spring.io/spring-cloud-gateway/docs/current/reference/html/#the-deduperesponseheader-gatewayfilter-factory%5D(https://docs.spring.io/spring-cloud-gateway/docs/current/reference/html/#the-deduperesponseheader-gatewayfilter-factory)">手册</a></p>
<h2 id="Vary怎么说"><a href="#Vary怎么说" class="headerlink" title="Vary怎么说"></a>Vary怎么说</h2><p>我们总是能看到响应中有Vary头部，它有什么用？服务端是如何生成的？</p>
<p>根据<a href="%5Bhttps://developer.mozilla.org/zh-CN/docs/Web/HTTP/Headers/Vary%5D(https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Headers/Vary)">标准</a>，它是被服务器用来声明一个请求的响应的变化依据，浏览器可用它来控制缓存。比如对<code>Vary: Origin</code>，它表示，对同一个请求，服务器针对不同的源站有不同的响应。</p>
<p>服务端是如何生成的呢？确切地讲，不同场景下有不同的生成方式，比如Spring Web中如果开启了跨域，默认会在响应上添加Vary请求头，写死的，其值包含</p>
<ul>
<li>Origin</li>
<li>Access-Control-Request-Method</li>
<li>Access-Control-Request-Headers</li>
</ul>
<p>源码参见：org.springframework.web.cors.reactive.DefaultCorsProcessor#VARY_HEADERS</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> List&lt;String&gt; VARY_HEADERS = Arrays.asList(</span><br><span class="line">			HttpHeaders.ORIGIN, HttpHeaders.ACCESS_CONTROL_REQUEST_METHOD, HttpHeaders.ACCESS_CONTROL_REQUEST_HEADERS);</span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">process</span><span class="params">(<span class="meta">@Nullable</span> CorsConfiguration config, ServerWebExchange exchange)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	ServerHttpRequest request = exchange.getRequest();</span><br><span class="line">	ServerHttpResponse response = exchange.getResponse();</span><br><span class="line">	HttpHeaders responseHeaders = response.getHeaders();</span><br><span class="line"></span><br><span class="line">	List&lt;String&gt; varyHeaders = responseHeaders.get(HttpHeaders.VARY);</span><br><span class="line">        <span class="comment">// 如果当前响应没有包含Vary，则加上</span></span><br><span class="line">	<span class="keyword">if</span> (varyHeaders == <span class="keyword">null</span>) &#123;</span><br><span class="line">		responseHeaders.addAll(HttpHeaders.VARY, VARY_HEADERS);</span><br><span class="line">	&#125;</span><br><span class="line">	... ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="Spring-Cloud同时使用DedupeResponseHeader和WebSocket"><a href="#Spring-Cloud同时使用DedupeResponseHeader和WebSocket" class="headerlink" title="Spring Cloud同时使用DedupeResponseHeader和WebSocket"></a>Spring Cloud同时使用DedupeResponseHeader和WebSocket</h2><p>Spring Cloud中同时使用DedupeResponseHeader和WebSocket会报错。如下，这是握手成功后抛出的异常。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">java.lang.UnsupportedOperationException</span><br><span class="line">	at org.springframework.http.ReadOnlyHttpHeaders.set(ReadOnlyHttpHeaders.java:106)</span><br></pre></td></tr></table></figure>

<p><strong>原因</strong></p>
<p>Spring Cloud对WebSocket有特殊处理，位于过滤器WebsocketRoutingFilter中，与这部分相关的逻辑位于：org.springframework.web.reactive.socket.server.upgrade.ReactorNettyRequestUpgradeStrategy#upgrade</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> Mono&lt;<span class="built_in">Void</span>&gt; upgrade(ServerWebExchange exchange, WebSocketHandler handler,</span><br><span class="line">		<span class="meta">@Nullable</span> String subProtocol, Supplier&lt;HandshakeInfo&gt; handshakeInfoFactory) &#123;</span><br><span class="line"></span><br><span class="line">	ServerHttpResponse response = exchange.getResponse();</span><br><span class="line">	HttpServerResponse reactorResponse = ServerHttpResponseDecorator.getNativeResponse(response);</span><br><span class="line">	HandshakeInfo handshakeInfo = handshakeInfoFactory.<span class="keyword">get</span>();</span><br><span class="line">	NettyDataBufferFactory bufferFactory = (NettyDataBufferFactory) response.bufferFactory();</span><br><span class="line">	URI uri = exchange.getRequest().getURI();</span><br><span class="line"></span><br><span class="line">	<span class="comment">// Trigger WebFlux preCommit actions and upgrade</span></span><br><span class="line">	<span class="keyword">return</span> response.setComplete()</span><br><span class="line">			.then(Mono.defer(() -&gt; &#123;</span><br><span class="line">				WebsocketServerSpec spec = buildSpec(subProtocol);</span><br><span class="line">				<span class="keyword">return</span> reactorResponse.sendWebsocket((<span class="keyword">in</span>, <span class="keyword">out</span>) -&gt; &#123;</span><br><span class="line">					ReactorNettyWebSocketSession session =</span><br><span class="line">							new ReactorNettyWebSocketSession(</span><br><span class="line">									<span class="keyword">in</span>, <span class="keyword">out</span>, handshakeInfo, bufferFactory, spec.maxFramePayloadLength());</span><br><span class="line">					<span class="keyword">return</span> handler.handle(session).checkpoint(uri + <span class="string">&quot; [ReactorNettyRequestUpgradeStrategy]&quot;</span>);</span><br><span class="line">				&#125;, spec);</span><br><span class="line">			&#125;));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>其中的关键点是，response.setComplete()，这里已经将response设置为完成状态，后续过滤器就无法再操作其内容，而我们设置的DedupeResponseHeader过滤器就在它的后面，因此报错。</p>
<p><strong>解决</strong></p>
<p>这里，要明白两个点</p>
<ul>
<li>WebSocket握手成功后的响应头，不会存在重复的情况，这一点由WebSocket相关的Filter自己去保证</li>
<li>DedupeResponseHeader，不会去判断response是否已经完成</li>
</ul>
<p>为此，可以自定义DedupeResponseHeader，加上对response的完成状态进行判断的逻辑。如下，整个逻辑完全照抄DedupeResponseHeaderGatewayFilterFactory，连Config和Strategy都沿用，这样能够使得对它的使用上完全和DedupeResponseHeader一致。</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">CustomDedupeResponseHeaderGatewayFilterFactory</span> : <span class="type">AbstractGatewayFilterFactory</span>&lt;<span class="type">Config</span>&gt;</span>(Config::<span class="keyword">class</span>.java) &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">init</span> &#123;</span><br><span class="line">        log.info(<span class="string">&quot;Loaded GatewayFilterFactory [CustomDedupeResponseHeader]&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">shortcutFieldOrder</span><span class="params">()</span></span>: List&lt;String&gt; &#123;</span><br><span class="line">        <span class="keyword">return</span> listOf(NAME_KEY, <span class="string">&quot;strategy&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">apply</span><span class="params">(config: <span class="type">Config</span>)</span></span> = GatewayFilter &#123; exchange, chain -&gt;</span><br><span class="line">        chain.filter(exchange).then(Mono.fromRunnable &#123;</span><br><span class="line">            <span class="keyword">if</span> (!exchange.response.isCommitted) &#123;</span><br><span class="line">                dedupe(exchange.response.headers, config)</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="function"><span class="keyword">fun</span> <span class="title">dedupe</span><span class="params">(headers: <span class="type">HttpHeaders</span>?, config: <span class="type">Config</span>)</span></span> &#123;</span><br><span class="line">        <span class="keyword">val</span> names = config.name</span><br><span class="line">        <span class="keyword">val</span> strategy = config.strategy</span><br><span class="line">        <span class="keyword">if</span> (headers == <span class="literal">null</span> || names == <span class="literal">null</span> || strategy == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (name <span class="keyword">in</span> names.split(<span class="string">&quot; &quot;</span>.toRegex()).toTypedArray()) &#123;</span><br><span class="line">            dedupe(headers, name.trim &#123; it &lt;= <span class="string">&#x27; &#x27;</span> &#125;, strategy)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="function"><span class="keyword">fun</span> <span class="title">dedupe</span><span class="params">(headers: <span class="type">HttpHeaders</span>, name: <span class="type">String</span>, strategy: <span class="type">Strategy</span>)</span></span> &#123;</span><br><span class="line">        <span class="keyword">val</span> values = headers[name]</span><br><span class="line">        <span class="keyword">if</span> (values == <span class="literal">null</span> || values.size &lt;= <span class="number">1</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">when</span> (strategy) &#123;</span><br><span class="line">            Strategy.RETAIN_FIRST -&gt; headers[name] = values[<span class="number">0</span>]</span><br><span class="line">            Strategy.RETAIN_LAST -&gt; headers[name] = values[values.size - <span class="number">1</span>]</span><br><span class="line">            Strategy.RETAIN_UNIQUE -&gt; headers[name] = values.stream().distinct().collect(Collectors.toList())</span><br><span class="line">            <span class="keyword">else</span> -&gt; <span class="built_in">Unit</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>配置</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line">spring.cloud.gateway.default-filters[<span class="number">0</span>]=CustomDedupeResponseHeader=Vary Access-Control-Allow-Origin Access-Control-Allow-Credentials</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>后端</category>
        <category>网络基础</category>
      </categories>
      <tags>
        <tag>CORS</tag>
      </tags>
  </entry>
  <entry>
    <title>我有点想要写博客了</title>
    <url>/2019/09/06/%E6%88%91%E6%9C%89%E7%82%B9%E6%83%B3%E8%A6%81%E5%86%99%E5%8D%9A%E5%AE%A2%E4%BA%86-%E6%88%91%E6%9C%89%E7%82%B9%E6%83%B3%E8%A6%81%E5%86%99%E5%8D%9A%E5%AE%A2%E4%BA%86/</url>
    <content><![CDATA[<blockquote>
<p>自从入职新公司，在印象中应该是一直没有打开过自己的CSDN主页，甚至完全忘记了自己还有一个博客这件事。<br>今天偶然间看到一篇博文，说的是搭建一个自己的博客。想着自己也一直有着这样的想法，于是回来看了看。并想着：我得重新开始写博客</p>
</blockquote>
<span id="more"></span>
<h2 id="这篇博文的目的"><a href="#这篇博文的目的" class="headerlink" title="这篇博文的目的"></a>这篇博文的目的</h2><p>这就是一个随笔，不是技术文章</p>
<h2 id="这段时间干啥了"><a href="#这段时间干啥了" class="headerlink" title="这段时间干啥了"></a>这段时间干啥了</h2><p>翻看了一下记录，上次写博客已经是非常久以前了，多久呢，得追溯到四月份。从年前开始，我一直在筹备着换工作，原来在一家外包公司，着实没有什么发展前途，学不到什么东西，博主这渣渣水平在里面都算优秀的。于是年假一回来就提了辞呈，领导也很痛快，反正外包公司不愁没人。<br>三月中旬正式离职，两份工作之间间隔了整整一个月。前两周结合离职前几个失败的面试经历整理了一下技能树，补充了一些急需的知识盲区。第三周正式开始投简历找工作，统计了一下，前后面试了十几家公司，实力所限，没有大厂。不过最终也拿到了令人满意的offer。<br>我算是一个半路出家的Coder，以前是做硬件的，自学得来的技术栈也相当有限，第一份工作对自己提升实在有限。新公司所用技术比较新，可以说入司时的技术栈和公司使用的技术栈唯一重合点就是Java这门语言以及一些通用知识，所以免不得很忙，哪怕工作还算轻松，但多数时间都花在学习上。<br>新的工作氛围和新同事都很棒。技术氛围浓厚，尽管我尚未适应，但这就是我想要的。在这里我新学习了很多好玩的东西：函数式编程、Kotlin语言、Vertx、Postgresql、Python、Django、Rxjava。一个项目里根据不同的需要，尽量结合各种技术的优点加以应用，有很大灵活空间。这在我之前是很难想象的，以前无论是看各种网络教程还是Java相关文章，学习路线大多千篇一律，且看起来枯燥乏味。现在有了新的思路：去接触更多好玩的技术，学习它所专注解决的问题。技术不断在演进，要让自己跟着时代走。</p>
<h2 id="怎么想起写博客了"><a href="#怎么想起写博客了" class="headerlink" title="怎么想起写博客了"></a>怎么想起写博客了</h2><p>今天看到一篇博文，有一句话：不会分享的程序员技术实力再强大，最终也只能做一个Coder。这不一定对，但我认为非常好。</p>
<h3 id="从技术分享说起"><a href="#从技术分享说起" class="headerlink" title="从技术分享说起"></a>从技术分享说起</h3><p>新公司有个不成文的规定，每个员工都要做技术分享，轮着来。之前由于自己确实太渣，学习都来不及，也没啥可分享给别人的，就一直没做。现在转正了，不做也确实说不过去。于是想着就分享Kotlin吧，虽然也是新学习的，但好歹用了一个多月了。<br>进入准备PPT阶段，自己头脑中有无数个想法，感觉能够讲的点很多，但真到写PPT时，竟然不知道该从何写起。而且针对每个技术点，也只能三言两语进行描述，无法深层次地进行解释。于是一个一个问题地钻，并进行记录，我第一次如此深切地感受到通过记录进行知识梳理能够如此有用。<br>试想：如果针对自己学习的每一门知识，在学完之后都通过整理PPT的方式进行知识梳理，这应该会解决很多原本一知半解的问题。对技术实力的提升是很有帮助的</p>
<h3 id="我的一篇博文访问量破了1-8W"><a href="#我的一篇博文访问量破了1-8W" class="headerlink" title="我的一篇博文访问量破了1.8W"></a>我的一篇博文访问量破了1.8W</h3><p>这是我万万没想到的事情，随便写一写的博文竟然会有1.8W的访问量，而且有好几个评论和点赞。第一次感受到通过网络文章给自己带来的快乐。这让我觉得，花时间和经历维护一个博客获取是一件不错的事情。</p>
<h3 id="自己搭建网站"><a href="#自己搭建网站" class="headerlink" title="自己搭建网站"></a>自己搭建网站</h3><p>前段时间参加公司发起的阿里云团购，买了一台ECS，想着也没有别的用途，也不能浪费，那就搭建一个自己的网站吧，毕竟不能浪费钱。而且自己建站也不是空穴来风，这个想法都想了很久了。那篇1.8W访问量的博文就是在之前准备网页时写的。<br>最初是想从零开始搭建，现在想想也是没啥意义，完全可以使用WordPress或DJango搭建嘛，这样周期较短，自己也不容易被劝退。</p>
<h3 id="立个Flag"><a href="#立个Flag" class="headerlink" title="立个Flag"></a>立个Flag</h3><p>一个月内自己的网站要建好，且每个月最少发布两篇博文，CSDN和自建网站同步更新。<br>网友提的问题必须要回答（CKEditor的问题，恕在下实在忘记了，无法回答）</p>
]]></content>
      <categories>
        <category>随笔</category>
      </categories>
  </entry>
  <entry>
    <title>技术巡礼 - Akka和Lightend</title>
    <url>/2019/09/25/%E6%8A%80%E6%9C%AF%E5%B7%A1%E7%A4%BC%20-%20Akka%E5%92%8CLightend-%E6%8A%80%E6%9C%AF%E5%B7%A1%E7%A4%BC-akka%E5%92%8Clightend/</url>
    <content><![CDATA[<blockquote>
<p>akka这个技术一致都在听人弹起，只知道它与后端有关，是一个牛B的框架，别的么。。。并不知道。那么，我觉得现在是时候了解一下了。</p>
</blockquote>
<span id="more"></span>

<h1 id="akka"><a href="#akka" class="headerlink" title="akka"></a>akka</h1><p>akka是一个基于actor模式的消息驱动的开源框架，用于解决并发和可伸缩性问题。支持scala和java两种语言，运行于JVM。</p>
<p>在akka中，所有每个功能模块被抽象成一个actor，actor之间没有api可相互调用，他们之间通过message进行异步交流，message可以是任意类型，这样保证了actor之间高度去耦合。这使得代码执行效率得到了很大提升，并且actor降低了各模块之间的耦合，从而能够方便地增减功能。</p>
<p>这里是akka的<a href="https://developer.lightbend.com/guides/akka-quickstart-java/">官方例程</a></p>
<p>这里是akka的<a href="https://developer.lightbend.com/guides/akka-quickstart-java/">github地址</a></p>
<h1 id="Lightend"><a href="#Lightend" class="headerlink" title="Lightend"></a>Lightend</h1><p>这是akka背后的公司，除akka外，该公司还有另一个非常著名的产品：Scala编程语言。同时，基于akka，他们还构建了Web服务框架Play，和微服务框架Lagom。从<a href="https://www.lightbend.com/about-lightbend">Lightend的简介</a>上看，该公司致力于构建一个实时的企业级软件平台，并且在响应式开发做出了很多贡献。</p>
<p>Scala自不必说，这是目前非常流行的语言。另外两个框架，由于是基于akka得来，因此性能上也是差不多的。</p>
<h1 id="actor设计模式"><a href="#actor设计模式" class="headerlink" title="actor设计模式"></a>actor设计模式</h1><p> Actors属于并发组件模型 ，通过组件方式定义并发编程范式的高级阶段，避免使用者直接接触多线程并发或线程池等基础概念。</p>
<p>传统多数流行的语言并发是基于多线程之间的共享内存，使用同步方法防止写争夺，Actors使用消息模型，每个Actors在同一时间处理最多一个消息，可以发送消息给其他Actors，保证了<a href="https://www.jdon.com/performance/singlewriter.html">单独写原则 </a>。从而巧妙避免了多线程写争夺。</p>
<p>Actors模型的特点是：</p>
<ul>
<li>隔离计算实体</li>
<li>“Share nothing”</li>
<li>没有任何地方同步</li>
<li>异步消息传递</li>
<li>不可变的消息 消息模型类似mailbox / queue</li>
</ul>
<p>Actor使用的一个关键是构建出层级关系的Actor树，树中父节点负责监督子节点的运行，使得子节点出错时能够被捕获并恢复，这就是监督机制，它使得Actor模型具有很高的可靠性。</p>
<p><img src="https://yqfile.alicdn.com/img_1aeb3f16f0f7045930299c586806561a.png"></p>
<p>在Akka的Actor模型使用中，只要遵循如下使用原则，就能够得到高并发和高可靠性。</p>
<ul>
<li>所有的计算都是在actor中执行的</li>
<li>actor之间只能通过消息进行通信交流</li>
<li>为了响应消息，actor可以进行下列操作<ul>
<li> 更改状态或行为</li>
<li> 发消息给其他actor</li>
<li> 创建有限数量的子actor</li>
</ul>
</li>
</ul>
<h1 id="akka-VS-vertx"><a href="#akka-VS-vertx" class="headerlink" title="akka VS vertx"></a>akka VS vertx</h1><p>其实vertx也是Actor模式的一种实现，其verticle对应actor，所有Actor要求满足的条件，使用上的限制，vertx同样都有满足，但相比akka会包得更深一些，暴露给用户的部分更加简单易于理解，使用时完全感觉不到他在使用Actor模型。</p>
<p>akka则不一样，它基本上是比较直接地将Actor模型应用起来，熟练使用Akka需要熟练掌握Actor模型的各种概念和使用原则。</p>
<p>此外，在使用场景上我认为二者也略有不同，akka仅仅是一个解决并发的框架，是Actor模式的直接实现。而vertx是一个完整的平台，仅仅是并发部分使用了Actor模式实现，此外它还包括数据库、web服务、微服务、网络等应有尽有的模块。相比而言Lightend公司也仅有akka+play+Lagom这样的基本产品可供选择。</p>
<p>总的来说：</p>
<p>akka和vertx的共同点在于其都使用Actor模式解决并发和伸缩性问题。不同点在于akka专注于Actor模式的实现，提供更加丰富的选择，但同时要求使用者对Actor模式非常熟悉；而vertx在Actor模式部分封装得比较深，对使用者比较友好，更重要的是vertx提供一整套完整的方案，成为了一个工具集或平台级别的框架。</p>
]]></content>
      <categories>
        <category>工具</category>
      </categories>
      <tags>
        <tag>Akka</tag>
        <tag>Lightend</tag>
      </tags>
  </entry>
  <entry>
    <title>我读《认知觉醒》</title>
    <url>/2021/08/31/%E6%88%91%E8%AF%BB%E3%80%8A%E8%AE%A4%E7%9F%A5%E8%A7%89%E9%86%92%E3%80%8B-wo-du--ren-zhi-jue-xing-/</url>
    <content><![CDATA[<p>终于到了写读后感的关键时刻了吗？听取本书作者周岭的建议，今后的读后感不再是一本书的大纲和金句摘抄，而是主要侧重于自己有所感悟的地方，最重要的是要和自己联系起来。以目前我的水平来说，这样的读后感无疑不会受到大家的赞同，因为是专门针对自己的（不过理性分析，以前的读后感也没有人给我点赞呀，因为总想写得很好，但本就缺乏文笔和写作练习的自己，怎么可能写出受大家欢迎的作品呢？）。</p>
<p>我这里分成两部分</p>
<ul>
<li>阐述本书的核心思想。很有必要，因为它是理论指导。</li>
<li>如何将书中方法应用在自己身上？</li>
</ul>
<span id="more"></span>

<h2 id="这本书讲了啥"><a href="#这本书讲了啥" class="headerlink" title="这本书讲了啥"></a>这本书讲了啥</h2><p>全书分为上下两个部分，结构非常清晰。上部客观阐述大脑的组成，从内部分析我们为何会焦虑，为何会莫名倾向娱乐，并提供了解决这些问题的理论基础；下部从外部世界的客观方法入手，讲述了我们应该如何训练专注力、学习力、情绪力，最后章尤其提供了五种具体的方法供读者参考。</p>
<h3 id="大脑的三部分"><a href="#大脑的三部分" class="headerlink" title="大脑的三部分"></a>大脑的三部分</h3><p>首先正确认识我们的大脑，从几十万年前至今，我们的大脑总共发展出三个部分</p>
<ul>
<li>本能脑：让我们在这个世界存活下来，如呼吸，走路</li>
<li>情绪脑：让我们活得更好，如恐惧情绪让我们远离危险</li>
<li>理智脑：让我们学会思考，创建了文明，使人类拥有更高的精神世界，走得更远</li>
</ul>
<p>从运算能力和控制人类最终行为能力的强弱，从前到后依次降低。如果不加控制，本能脑和情绪脑占主导地位，就会使我们总是倾向于更加容易的工作、更加简单的事情、娱乐等即时满足的事项。这也能解释为什么我们在闲时不由自主地喜欢刷抖音、刷微博、聊微信，工作时喜欢不规划直接动手。学习和制定计划等，属于理智脑管辖的范围，比较耗能，并非优先选择。</p>
<p>所以，从客观来说，我们本身就是趋易避难的。理智脑无法占据上风，这是正常的事情，并非我们意志力不足，只是我们没有找到让他们协作的方法。</p>
<h3 id="痛苦和焦虑"><a href="#痛苦和焦虑" class="headerlink" title="痛苦和焦虑"></a>痛苦和焦虑</h3><p>焦虑，来源于能力和欲望之间的巨大差距。</p>
<p>如果在平时的工作和学习中不注重调节，任凭自己跟着感觉走，那多半会落入本能脑和情绪脑的控制中，他让我们变得没有规划，娱乐、娱乐、再娱乐。因此，必须加以控制和引导，使得三者能够通力合作。增长能力，使其距离欲望更近一点，焦虑就少一点。</p>
<h3 id="科学方法"><a href="#科学方法" class="headerlink" title="科学方法"></a>科学方法</h3><ul>
<li><p>耐心：无论工作或学习，耐心必不可少，但是情绪脑让我们变得没有耐心——做这事干啥，还不如去刷会儿抖音，外界的诱惑是耐心的最大敌人。</p>
<p>  解决办法是延迟满足，不是不玩，而是等一会儿再玩。而且长时间娱乐的焦虑感和完成任务后短时间娱乐的愉悦感，高下立判。</p>
<p>  更加终极的办法是，以任务完成的满足感，替代娱乐带来的爽感。情绪脑不就要个开心的感觉么，前者完全可以替代呀。当然这因人而异。</p>
<p>  此外，要明白复利曲线，复利是保持耐心的回报。</p>
<p>  <img src="https://gdz.oss-cn-shenzhen.aliyuncs.com/halo/image_1630419070936.png" alt="image.png"></p>
</li>
<li><p>注意力：工作效率取决于注意力，注意力也是可以锻炼的。</p>
<p>  一个切实有效的物理方法——冥想。</p>
<p>  注意力会随着时间的持续客观地下降，因此劳逸结合有助于保持注意力——番茄工作法。</p>
</li>
<li><p>消除模糊：当我们突然闲下来时，会发现有很多事情可以做，并且权重好像都差不多，就会陷入做这个也不是，做那个也不好的纠结，最终会被情绪脑拉入娱乐，一刷微博就是好久，自己不受控，最终还会产生焦虑。</p>
<p>  解决办法是消除模糊，列个计划，让我们在某个时间需要做的事情只有一件，没得选，让自己很快进入执行状态，不给情绪脑有机可乘。</p>
</li>
<li><p>利用”感觉“：当然这是更加高级的方法，我们真正的喜恶，其实是由情绪脑决定的，比如我们喜欢什么样的人，喜欢从事什么样的工作，想要成为一个什么样的人，这些方面是不能让理智脑决的定，如果那样，得到的答案多半不会长久，因为情绪脑不答应——你不是真正的喜欢。</p>
<p>  由此，可以让情绪脑决定自己的人生大事，再通过理智脑去有条有理地达成。</p>
<p>  此外，还可以利用感觉去寻找对自己有触动的点，然后通过理智脑详细学习。能够触动你的点，对你来说多半是处于拉伸区的，且是能够掌握的。这也是很多学习高手的方法。</p>
</li>
<li><p>反思：知识必须形成闭环，所有事情都一样。做，接受反馈，修正。如此循环，就能够达成理想中的自己。</p>
<p>  反思，是一种非常好的自我反馈的手段，定期总结，予以修正。</p>
<p>  不过，反思时我们需要从多个角度思考，然后给与现在的自己多个角度的反馈。</p>
<p>  <img src="https://gdz.oss-cn-shenzhen.aliyuncs.com/halo/image_1630419091857.png" alt="image.png"></p>
</li>
<li><p>在拉伸区活动：可以将事情难易程度分为三部分：容易区、拉伸区、困难区</p>
<p>  在容易区反复拉扯不会有什么进步，在困难区执行也不会有什么进步，还会造成挫败感。最理想的是在拉伸区活动，这是效率最高的方法。</p>
<p>  <img src="https://gdz.oss-cn-shenzhen.aliyuncs.com/halo/image_1630419116097.png" alt="image.png"></p>
</li>
<li><p>高效学习：尊重学习效率曲线。学习并不是一直坐在那里用功努力，因为随着时间增长，你的深度学习能力是在下降的，都后面越来越低，累积下来的学习效果，很可能不如番茄工作法产生学习效果</p>
<p>  <img src="https://gdz.oss-cn-shenzhen.aliyuncs.com/halo/image_1630419149770.png" alt="image.png"></p>
</li>
<li><p>深度学习：要了解学习金字塔，知道自己的学习处在哪一个程度，并且要向深度学习发展，这样才有意义。我们的目标至少是——实践。最好是——教授给他人。</p>
<p>  <img src="https://gdz.oss-cn-shenzhen.aliyuncs.com/halo/image_1630419164909.png" alt="image.png"></p>
</li>
</ul>
<h2 id="应用于自己"><a href="#应用于自己" class="headerlink" title="应用于自己"></a>应用于自己</h2><p>那我要怎么应用在我的生活和工作中呢。下面分具体情况，反思之前做的不好的地方，以及今后如何改正。</p>
<h3 id="作息习惯"><a href="#作息习惯" class="headerlink" title="作息习惯"></a>作息习惯</h3><p>打开手机睡眠检测，看看睡眠时间，严重不稳定。</p>
<p>存在的问题</p>
<ul>
<li>入睡时间不稳定，早也不过12点，晚却超过1:30</li>
<li>入睡时间过晚</li>
<li>早上虽然8点就醒了，但会被手机耽误将近一个小时，直到9点才起床洗漱</li>
<li>直接导致次日精神状态和身体状态都不好</li>
</ul>
<p><img src="https://gdz.oss-cn-shenzhen.aliyuncs.com/halo/image_1630419189091.png" alt="image.png"></p>
<p>分析原因</p>
<ul>
<li>睡前总是打开B站，然后。。。就到一点多了</li>
<li>起床第一件事就是拿手机，东刷刷，西刷刷。。。就到九点多了</li>
</ul>
<p>如何解决</p>
<ul>
<li>睡前不要打开B站；起床后不要拿手机，而是先想今天要做什么</li>
</ul>
<h3 id="工作"><a href="#工作" class="headerlink" title="工作"></a>工作</h3><p>自认为当前的工作习惯还算OK，有计划，有执行记录等，但工作状态容易失控。</p>
<ul>
<li>在一项工作上花费过久的时间，对其它任务形成挤压，连锁效应导致工作效率降低</li>
<li>容易死磕，只看到问题，看不清解决方案时不是去寻找解决方案，而是凭脑子硬想</li>
</ul>
<p><img src="https://gdz.oss-cn-shenzhen.aliyuncs.com/halo/image_1630419210026.png" alt="image.png"></p>
<p>分析原因：不够冷静和理性。</p>
<ul>
<li>没有站在全局看待工作，当一项任务需要花费比预期多得多的时间去完成时，要么是准备不足，要么是能力不足。此时应该将注意力转移到”完成“上，先完成任务，保证整体进度。事后再提升自己。</li>
<li>没有正视自己的能力，当看不清解决方案时，不应该闭门造车，而是多看看别人怎么做的，去查资料，去讨论。</li>
</ul>
<p>解决方案</p>
<ul>
<li>陷入这类状态时，强制自己休息10分钟</li>
<li>把这篇文章拿出来看</li>
</ul>
<h3 id="看书"><a href="#看书" class="headerlink" title="看书"></a>看书</h3><p>现在的问题</p>
<ul>
<li>啥都想要，想要得到书中的每个知识点，最后却啥都没记住</li>
<li>深度不够，仅仅停留在学习金字塔的被动学习——演示阶段（做笔记，写总结）</li>
</ul>
<p>解决方案</p>
<ul>
<li>放弃通篇做笔记，阅读一遍之后，再浏览一遍，抓取有感触的地方，以此扩展开来写一篇文章</li>
</ul>
<h3 id="学习一门技术"><a href="#学习一门技术" class="headerlink" title="学习一门技术"></a>学习一门技术</h3><p>学习技术的方法上自认为没有大问题，现在最大的问题是</p>
<ul>
<li>无法持续学习，一项技术从开始看，并不能善终，总是学到一半就转移到其它技术了</li>
</ul>
<p>原因</p>
<ul>
<li>焦虑和贪婪在作怪，想学习的技术太多，轻重主次分的不是特别清楚</li>
<li>不舍得花时间，确切地说，是不舍得花大量整块的时间。导致进展缓慢且没有什么成效</li>
</ul>
<p>解决方案</p>
<ul>
<li>列清单分析优先级，以及需要达到的程度。要使得当前需要学习的内容<strong>只有一项</strong>！！！</li>
<li>要有明确的输出要求，如写出一个项目；输出有深度的文章等</li>
<li>投入时间，关键是<strong>保持耐心！！！</strong></li>
</ul>
<h3 id="碎片时间"><a href="#碎片时间" class="headerlink" title="碎片时间"></a>碎片时间</h3><p>当前的问题：不知道该干啥，于是就刷刷新闻，刷刷技术博客，但这么短时间根本刷不出什么。</p>
<p>可以解决：我用flomo记录了挺多闪过脑海的想要了解的东西，可以看那些。</p>
<h3 id="娱乐的处理"><a href="#娱乐的处理" class="headerlink" title="娱乐的处理"></a>娱乐的处理</h3><p>我肯定无法做到以学习的乐趣取代娱乐的。但我能做到</p>
<ul>
<li>改变娱乐项目，从B站、Youtube改为看动漫番</li>
<li>改变娱乐时间段，从没有限制改为每天晚上10点后，11:30前</li>
<li>改变娱乐时长，工作日每天最多一小时；周末每天最多三小时</li>
</ul>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>《认知觉醒》给我带来的感触更多是精神上的，将其中的方法应用上后，我将来的生活节奏也不会发生非常大的变化，可以预期是不会发生三分钟热度这种事。那么，现在来畅想一下我一天的生活吧。</p>
<ul>
<li>早上8点，闹钟响了，我抬起手腕，关闭闹钟。双眼微闭，感受清晨刚醒时浑身放松的感觉。约么十多分钟，起床洗漱</li>
<li>9点，洗漱完毕，准备出门，打开博客，戴上耳机，听取被人的观点</li>
<li>10点，到公司，洗一洗茶杯，吃个早餐，整理一下工位</li>
<li>10:10，花二十分钟整理一下今天要做的事情</li>
<li>10:30，开始工作</li>
<li>中午：照常吃饭，和同事聊聊天。</li>
<li>1:30：给自己10分钟时间安安静静地啥也不做，重新想想今天该做啥。此外，午休必不可少。</li>
<li>2:10：午休完成，继续开始工作</li>
<li>4:00：陷入一个技术问题，脑子反应不过来。去厕所洗个脸，在零食区坐上10分钟，啥也不要想</li>
<li>4:20：想起了工作要以进度有限，应该上自己认知范围内的最好方案，这样才能节省出时间赶进度和学习，才能在以后提出更好的方案。于是暂时绕过该技术问题，日后再说</li>
<li>9:00：下班回家，花10分钟冥想，冷静一下</li>
<li>9:10：写反思：明确白天的问题症结点，提出改进计划并执行</li>
<li>9:30：开始学习</li>
<li>11:00：放松娱乐时间</li>
<li>11:30：洗漱，准备睡觉</li>
</ul>
]]></content>
      <categories>
        <category>读书笔记</category>
      </categories>
      <tags>
        <tag>认知觉醒</tag>
      </tags>
  </entry>
  <entry>
    <title>技术巡礼 - SockJS</title>
    <url>/2019/10/13/%E6%8A%80%E6%9C%AF%E5%B7%A1%E7%A4%BC%20-%20SockJS-%E6%8A%80%E6%9C%AF%E5%B7%A1%E7%A4%BC-sockjs/</url>
    <content><![CDATA[<blockquote>
<p>想要写一篇介绍SockJS的文章，又不知道写什么好，发现官方github项目上这篇文章比较好，于是直接翻译过来。不长不短，正好合适。<br>该文章发布于2016年，某些论述可能已经过时，这里尝试加以纠正，但有谬误，还请指正。</p>
</blockquote>
<span id="more"></span>

<p>原文 —— <a href="https://github.com/sockjs/sockjs-client/wiki/%5BArticle%5D-SockJS:-WebSocket-emulation-done-right">WebSocket emulation done right</a></p>
<h1 id="SockJS-WebSocket模拟器"><a href="#SockJS-WebSocket模拟器" class="headerlink" title="SockJS - WebSocket模拟器"></a>SockJS - WebSocket模拟器</h1><p>WebSocket技术日益发展，但倘若要所有浏览器都支持它，尚需时日（目前主流浏览器基本都支持了）。<br>与此同时有非常多的项目以取代WebSocket为目标，尝试让web app具备“实时”能力。但所有这些项目仅仅解决了众多问题中的一部分，没有任何单个解决方案能够做到不需要部署上的奇技淫巧就能够正常工作且保有可伸缩性。<br>这就是SockJS诞生的原因，同其它项目类似，它又是一个WebSocket的模拟库，但不一样的是，它是一个非常有效的解决方案。</p>
<p>SockJS有着雄心勃勃的目标：</p>
<ul>
<li>提供简单的客户端和服务端API，尽量向WebSocket API靠拢</li>
<li>提供文档周全的扩展和负载均衡技术</li>
<li>传输必须完全支持跨域通信</li>
<li>在限制代理的情况下， 传输必须优雅地回退</li>
<li>建立连接应该快速</li>
<li>客户端不需要Flash，JavaScript就够了</li>
<li>客户端的JavaScript必须经过合理的测试</li>
<li>为了使用不同的语言编写服务端，服务端代码应该简单</li>
</ul>
<h2 id="简单的API"><a href="#简单的API" class="headerlink" title="简单的API"></a>简单的API</h2><p>这听起来很明显，但WebSocket api实际上相当不错。这是伊恩·希克森和其他人领导的巨大努力的结果。不应该忘记，以前也有一些不太成功的尝试来实现类似的东西，因此WebSockets api并不是凭空开发出来的。</p>
<p>到目前位置，我还没有见过任何JS库对WebSocket进行深度模拟。早起Socket.io有尝试这么做，但目前它已渐行渐远。</p>
<p>WebSocket没有定义服务器端api，但是很容易提出一个与客户端具有类似思想和抽象的方案。</p>
<h2 id="关于发布"><a href="#关于发布" class="headerlink" title="关于发布"></a>关于发布</h2><p>SockJS支持开箱即用的跨域通信。你能够并且应该将SockJS服务器独立出来，并放在与你的主网站不同的域名。这种方法有多种优点，坦率地说，它只是唯一合理的部署策略。</p>
<h2 id="关于负载均衡"><a href="#关于负载均衡" class="headerlink" title="关于负载均衡"></a>关于负载均衡</h2><p>单个SockJS服务器容量是有限的。如果您预期单个服务器不足以满足您的需求，请查看下面的扩展场景。</p>
<h3 id="使用多个域"><a href="#使用多个域" class="headerlink" title="使用多个域"></a>使用多个域</h3><p>最简单的方法就是直接将多个SockJS服务器部署在不同的域名下，并且允许客户端随机挑选一个。</p>
<h3 id="使用具有WebSocket能力的负载均衡器"><a href="#使用具有WebSocket能力的负载均衡器" class="headerlink" title="使用具有WebSocket能力的负载均衡器"></a>使用具有WebSocket能力的负载均衡器</h3><p>您可以选择在一个域下托管所有SockJS流量，并使用一个适当的支持WebSocket的负载平衡器来分割流量。有一个<a href="https://github.com/SockJS/SockJS-node/blob/master/examples/haproxy.cfg">示例haproxy配置文件</a>可以作为一个很好的起点。</p>
<h3 id="使用随便什么负载均衡器"><a href="#使用随便什么负载均衡器" class="headerlink" title="使用随便什么负载均衡器"></a>使用随便什么负载均衡器</h3><p>这不是一个推荐的方案，但这使得即使在不支持WebSocket的负载均衡器的环境中运行可扩展的SockJS服务称为可能。共享托管提供商就是这样做的——比如CloudFoundry。为了更快地建立连接，可以在客户端和服务器端禁用WebSocket协议。</p>
<p>在这样的环境中，负载平衡器必须将单个SockJS会话的所有请求转发到单个SockJS服务器。负载平衡器必须支持以下两种变体之一的粘性会话(会话关联):</p>
<ul>
<li>基于前缀的粘性会话。所有SockJS的请求都带有session id前缀，好的负载均衡器会使用它作为会话关联算法的线索（比如HAProxy）</li>
<li>JSESSIONID粘性会话。默认情况下，SockJS服务端会设置cookie。一些负载均衡器能够利用这些cookie（比如CloudFoundry）</li>
</ul>
<h2 id="健壮的传输协议"><a href="#健壮的传输协议" class="headerlink" title="健壮的传输协议"></a>健壮的传输协议</h2><p>除了WebSocket本身，SockJS还支持几个精挑细选的协议，并且它们都支持跨域通信</p>
<p>其基本思想是，每个浏览器都应该有一个像样的流和轮询协议。轮询者必须在具有限制代理的环境中工作，并支持旧浏览器。每个浏览器可以通过三种方式建立连接：</p>
<h3 id="WebSocket方式"><a href="#WebSocket方式" class="headerlink" title="WebSocket方式"></a>WebSocket方式</h3><p>WebSocket是最快最好的传输协议，它支持开箱即用的跨域连接。不幸的是它目前并不被所有浏览器支持。同时，一些浏览器可能在使用代理时会有问题。因此在浏览器的支持度和代理问题解决上可能还要花一些时间</p>
<h3 id="流协议"><a href="#流协议" class="headerlink" title="流协议"></a>流协议</h3><p>SockJS的流协议是基于Http 1.1的chunking的</p>
<ul>
<li>它允许浏览器接收一个带有多个部分的http响应。很好的流协议的例子是EventSource和基于Ajax的流。从浏览器发出的消息被使用另一个Ajax请求传输<br>每个浏览器都支持不同的流协议集，它们通常无法进行跨域通信。幸运的是，SockJS能够通过使用iframe并使用html5 postmessage api与之通信来克服这一限制。这相当复杂，但幸运的是大多数浏览器（ie7除外）都支持它。</li>
</ul>
<h3 id="轮训传输"><a href="#轮训传输" class="headerlink" title="轮训传输"></a>轮训传输</h3><p>SockJS对远古浏览器（包括ie7）支持几种旧轮询协议。不幸的是，这些技术相当缓慢，并且没什么优化的空间。<br>在客户端代理不支持WebSockets或http分块的情况下，也可以使用轮询传输。</p>
<h2 id="快速建立连接"><a href="#快速建立连接" class="headerlink" title="快速建立连接"></a>快速建立连接</h2><p>打开SockJS连接应该很快，在某些部署中，可能需要在用户访问的每个http页面上建立SockJS连接。<br>如果浏览器支持，SockJS将首先尝试打开本机WebSocket连接。根据网络和服务器设置，它可能成功或失败。失败应该发生得很快，除非客户端在一个行为异常的代理后面-在这种情况下，可能需要5秒的超时时间。<br>WebSocket连接失败后，SockJS打开xhr请求，检查代理是否支持分块。满足不支持HTTP分块的代理并不少见。在这样的环境中运行流协议将失败并超时。<br>如果分块工作正常，SockJS会选择浏览器支持的最佳流协议。否则使用轮询传输。<br>所有这些，根据浏览器的不同，可能需要3到4次从浏览器到服务器的往返时间，外加一个dns请求。除非你的代理有问题，或者住在南极洲，不然它应该是相当快的。<br>这就是SockJS避免使用flash传输的原因之一——如果端口843被阻塞，flash连接至少需要3秒。</p>
<h2 id="简单的服务端"><a href="#简单的服务端" class="headerlink" title="简单的服务端"></a>简单的服务端</h2><p>目前，SockJS节点实现在coffeescript中使用了大约1200行代码。WebSocket协议使用大约340个，简单的HTTP抽象使用220个，核心SockJS逻辑仅使用大约230个。<br>浏览器和服务器之间使用的SockJS协议已经非常简单，我们正在努力使其更加简单。<br>我们打算至少支持node和erlang服务器，我们也很高兴看到python和ruby的实现。Sockjs是多基因的。</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>sockjs还很年轻，还有很多工作要做，但我们相信它足够稳定，适合真正的应用程序。如果你打算做实时网络应用，试试吧。</p>
]]></content>
      <categories>
        <category>工具</category>
      </categories>
      <tags>
        <tag>SockJS</tag>
      </tags>
  </entry>
  <entry>
    <title>技术巡礼 - Angular 和 Vue 和 React</title>
    <url>/2019/10/13/%E6%8A%80%E6%9C%AF%E5%B7%A1%E7%A4%BC%20-%20Angular%20%E5%92%8C%20Vue%20%E5%92%8C%20React-%E6%8A%80%E6%9C%AF%E5%B7%A1%E7%A4%BC-angular%E5%92%8Cvue%E5%92%8Creact/</url>
    <content><![CDATA[<p>我是前端菜鸟，并不知道这三个是啥玩意儿，只是查查资料，让自己稍微了解一些。顺便说，这篇文章都是从别的地方抄来的。</p>
<span id="more"></span>
<h1 id="是什么"><a href="#是什么" class="headerlink" title="是什么"></a>是什么</h1><h2 id="React"><a href="#React" class="headerlink" title="React"></a>React</h2><p>React是一个用于构建Web应用程序UI组件的JavaScript库。React由Facebook维护，许多领先的科技品牌在其开发环境中使用React。React被Facebook，Uber，Netflix，Twitter，Udemy，Paypal，Reddit，Tumblr，Walmart 等使用。来自Facebook的另一个受欢迎的企业React Native用于使用JavaScript和React构建本机移动应用程序。许多知名公司因其出色的特性和功能而转向React开发。该 阵营与Vue.js 主题也在网络上嗡嗡作响，为您提供了选择最佳框架的充分见解。</p>
<h2 id="Angular-js"><a href="#Angular-js" class="headerlink" title="Angular.js"></a>Angular.js</h2><p>是一款基于TypeScript的优秀的JavaScript框架，于2009年被创建，后被Google收购。Angular开发在全球开发人员中广泛流行，并被谷歌，福布斯，WhatsApp，Instagram，healthcare.gov和许多财富500强公司等大型组织使用。</p>
<h2 id="Vue-js"><a href="#Vue-js" class="headerlink" title="Vue.js"></a>Vue.js</h2><p>是由Angular.js启发而来，因此他们的语法和一些API设计比较相似。于2014年正式发布。相比前者，Vue.js更轻，学习更加简单，更易于扩展。Vue被阿里巴巴，GitLab，百度使用，并受到全球开发人员和设计师的赞赏。</p>
<h1 id="三者对比"><a href="#三者对比" class="headerlink" title="三者对比"></a>三者对比</h1><h2 id="开发本机应用程序"><a href="#开发本机应用程序" class="headerlink" title="开发本机应用程序"></a>开发本机应用程序</h2><p>原生应用程序是为特定平台构建的。React拥有React Native，您可以使用它为iOS和Android开发本机应用程序。Angular的NativeScript已经被很多人用来开发本机应用程序，而Ionic框架在制作混合应用程序时广受欢迎。</p>
<p>Vue的Weex平台正在不断发展，目前似乎还没有计划进一步发展，使其成为一个成熟的交叉开发平台。</p>
<h2 id="单向数据流与双向数据绑定"><a href="#单向数据流与双向数据绑定" class="headerlink" title="单向数据流与双向数据绑定"></a>单向数据流与双向数据绑定</h2><p>这是React和Angular之间的主要区别之一。双向数据绑定是指UI字段绑定到动态建模的机制。当UI元素发生变化时，模型数据也会相应地更改。另一方面，单向数据流意味着只有一个单一的事实来源 - 模型。应用程序的数据以单一方向流动，只有模型才能更改应用程序的状态。</p>
<p>Angular使用双向数据绑定，React用于单数据流，Vue支持两者。在这里，重点是，Angular的双向方法提供了有效的编码结构，开发人员发现它易于使用。React提供了更好的概述和理解，因为数据是在一个方向上管理的。</p>
<h2 id="图片对比"><a href="#图片对比" class="headerlink" title="图片对比"></a>图片对比</h2><p><img src="https://gdz.oss-cn-shenzhen.aliyuncs.com/hexo/%E6%8A%80%E6%9C%AF%E5%B7%A1%E7%A4%BC%20-%20AngularJS/JsFrameWorkComparison.jpeg" alt="图片对比"></p>
<h2 id="简单说"><a href="#简单说" class="headerlink" title="简单说"></a>简单说</h2><p>如果您比其他功能更喜欢灵活性，请使用React。</p>
<p>如果您喜欢在TypeScript中编码，请选择Angular。</p>
<p>如果您是JavaScript爱好者，请使用React，因为它完全与JavaScript有关。</p>
<p>如果您喜欢干净的代码，请在您的应用程序中使用Vue。</p>
<p>Vue提供最简单的学习曲线，是初学者的理想选择。</p>
<p>如果要在应用程序中分离关注点，请使用Vue。</p>
<p>如果您喜欢面向对象的编程，Angular绝对是您的选择。</p>
]]></content>
      <categories>
        <category>工具</category>
      </categories>
      <tags>
        <tag>Angular</tag>
        <tag>Vue</tag>
        <tag>React</tag>
      </tags>
  </entry>
  <entry>
    <title>我重构了什么</title>
    <url>/2022/07/28/%E6%88%91%E9%87%8D%E6%9E%84%E4%BA%86%E4%BB%80%E4%B9%88/</url>
    <content><![CDATA[<p>两个多月前，我重构了支付服务苹果IAP部分代码，完善了苹果支付逻辑；大半个月前，以加强可维护性为目的重构了用户服务的代码；上周三开始，以同样的理由，重构了支付服务剩余的代码。这三次重构工作，前前后后加起来得有一个月工作量，这里进行总结：到底重构了什么。</p>
<span id="more"></span>

<h2 id="概览"><a href="#概览" class="headerlink" title="概览"></a>概览</h2><p>需求文档、方案设计文档当然是必要的，一般来说也已经有了。但这并不足以快速理解代码，于是我增加了两个文档：项目领域图、重构笔记。</p>
<p>其中，项目领域图是理解设计后画的，能够阐述项目整体上的逻辑结构；重构笔记主要记录了写代码过程中需要反复斟酌的或者逻辑比较复杂的地方。这对后来人维护上手可以提供帮助。</p>
<p>用户服务的领域图如下。该系统中，以用户(User)为核心，一个用户对应多种登录方式、拥有多个token。如果以DDD的角度，构建一个Aggregate，则以User为根，所有根据方式和Token都能够被包含在该Aggregate。业务上会好理解很多。</p>
<p><img src="https://gdz.oss-cn-shenzhen.aliyuncs.com/local/image-20220728174842114.png" alt="image-20220728174842114"></p>
<p>支付服务的领域如如下，与用户服务类似，该系统也是单核心——Order，一个Order可能由各种支付方式完成。</p>
<p><img src="https://gdz.oss-cn-shenzhen.aliyuncs.com/local/image-20220728174955902.png" alt="image-20220728174955902"></p>
<p>两个系统有一个共同点，即关键操作如三方登录、三方支付，都可以从业务抽离到基础设施层，抽离后，两个层的粘合程度可以非常低。实际情况也是，重构抽离后，业务代码看起来清爽了许多。</p>
<p>重构笔记看起来如下</p>
<img src="https://gdz.oss-cn-shenzhen.aliyuncs.com/local/image-20220728180018993.png" alt="image-20220728180018993" style="zoom:50%;" />

<p>下面按照具体服务说一下重构了什么。</p>
<h2 id="细节-支付服务"><a href="#细节-支付服务" class="headerlink" title="细节 - 支付服务"></a>细节 - 支付服务</h2><h3 id="删除删除再删除"><a href="#删除删除再删除" class="headerlink" title="删除删除再删除"></a>删除删除再删除</h3><p>支付服务中，删除了大量代码</p>
<img src="https://gdz.oss-cn-shenzhen.aliyuncs.com/local/image-20220728180200706.png" alt="image-20220728180200706" style="zoom:50%;" />

<p>被删除的内容主要有如下两点</p>
<ul>
<li><p>无用代码：存在大量实际没有用到的代码。让这个项目从开始看起来非常复杂的样子，实际精简之后这个项目逻辑非常简单。就下单、支付回调、订单创建和支付状态的流转、通知每记后端几个步骤。</p>
</li>
<li><p>过度封装的代码：比如不必要的BO、套用了三四层的HTTP调用、过度分离的配置等。</p>
</li>
</ul>
<h3 id="清理层边界"><a href="#清理层边界" class="headerlink" title="清理层边界"></a>清理层边界</h3><ul>
<li><p>分了几个层：Controller、Service、Repository、Infrastructue。如果业务复杂，建议增加Domain层，架空Service，将主要逻辑转移到Domain。</p>
</li>
<li><p>Infrastructue的配置Properties类不应该出现在其它层，只应该也只需要出现在基础设施层，在容器启动期间注入</p>
</li>
<li><p>将位于Controller层的逻辑按实际情况转移到基础设施层或Service层</p>
</li>
<li><p>将SQL相关DSL转移到ORM层。不得不说，MyBatisPlus的ServiceImpl害了不少人，至少我个人觉得在业务逻辑里写SQL DSL会使得本来就不大清晰的代码逻辑更加不清晰，而且还不方便Mock。</p>
</li>
</ul>
<h3 id="清理业务边界"><a href="#清理业务边界" class="headerlink" title="清理业务边界"></a>清理业务边界</h3><p>支付服务核心在OrderService，作为记录支付过程的PaymentService其次。可以说整个项目都围绕二者进行，但后者只是一个辅助作用。所有支付的行为都是在辅助Order实现状态流转，所以二者包含的业务主要是</p>
<ul>
<li><p>OrderService：负责订单创建、订单状态的流转</p>
</li>
<li><p>PaymentService：仅负责支付过程的维护，一个支付过程完成后，通知OrderService流转状态</p>
</li>
</ul>
<p>订单不应该包含支付的逻辑，支付也不应该包含订单的逻辑。重构时将未被上述原则的逻辑都移动到了该在的位置</p>
<h3 id="层之间不一定要以接口粘合"><a href="#层之间不一定要以接口粘合" class="headerlink" title="层之间不一定要以接口粘合"></a>层之间不一定要以接口粘合</h3><p>Service层不一定要IService+ServiceImpl的方式定义，小项目里面没有什么多实现，硬要这样定义就显得有点书本化了。</p>
<h3 id="基础设施下沉"><a href="#基础设施下沉" class="headerlink" title="基础设施下沉"></a>基础设施下沉</h3><p>源代码中三方支付相关逻辑主要集中于PaymentHelper，部分分散于PaymentServier和OrderService。调用关系比较混乱，我们添加三个单例类，AliPay、WechatPay、ApplePay，分别持有这三种支付方式的配置、常用方法。</p>
<img src="https://gdz.oss-cn-shenzhen.aliyuncs.com/local/image-20220728183058690.png" style="zoom:50%;" />

<p>其中配置在项目启动时通过配置形式注入</p>
<img src="https://gdz.oss-cn-shenzhen.aliyuncs.com/local/image-20220728183242494.png" alt="image-20220728183242494" style="zoom:50%;" />

<h3 id="命名"><a href="#命名" class="headerlink" title="命名"></a>命名</h3><ul>
<li>修改过度中性的命名。如直接使用方法名作为方法调用结果变量的名称。</li>
<li>枚举类不一定非要加上Enums，xxxType、xxxStatus已经能够表述枚举状态</li>
<li>ORM的实体类叫Entity或者Model都可以，关键是要有一致性，不能混用，从头到尾都要保持一致</li>
</ul>
<h3 id="状态流转收拢"><a href="#状态流转收拢" class="headerlink" title="状态流转收拢"></a>状态流转收拢</h3><p>支付服务中，Order、Payment的状态存在先后关系和依赖关系，原代码在代码的各处单独流转，重构后将其收拢为一个状态机，每次流转时检查前置状态，并根据流转事件得出新的状态</p>
<img src="https://gdz.oss-cn-shenzhen.aliyuncs.com/local/image-20220728181830769.png" alt="image-20220728181830769" style="zoom:50%;" />

<h3 id="关于when表达式"><a href="#关于when表达式" class="headerlink" title="关于when表达式"></a>关于when表达式</h3><ul>
<li><p>when中使用枚举时，最好不要用else，而是将所有分支的case都写出来，明确且不易出错。</p>
</li>
<li><p>当匹配的维度超过一维时，枚举无法表达，可以使用密封类。比如上面的状态机的事件参数，事件是可枚举的，但其中一两个事件如支付回调通知又包含支付结果，最终的状态需要根据支付结果判定。用密封类声明如下</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">sealed</span> <span class="class"><span class="keyword">interface</span> <span class="title">StatusSwitchEvent</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">object</span> PrePayEvent : StatusSwitchEvent</span><br><span class="line"></span><br><span class="line"><span class="keyword">object</span> ApplePaySuccessEvent : StatusSwitchEvent</span><br><span class="line"></span><br><span class="line"><span class="keyword">object</span> NotifiedUpstreamEvent : StatusSwitchEvent</span><br><span class="line"></span><br><span class="line"><span class="keyword">object</span> CancelOrderEvent : StatusSwitchEvent</span><br><span class="line"></span><br><span class="line"><span class="keyword">data</span> <span class="class"><span class="keyword">class</span> <span class="title">AliPayNotifyEvent</span></span>(<span class="keyword">val</span> payState: AliTradeStatus) : StatusSwitchEvent</span><br><span class="line"></span><br><span class="line"><span class="keyword">data</span> <span class="class"><span class="keyword">class</span> <span class="title">WechatPayNotifyEvent</span></span>(<span class="keyword">val</span> payState: WechatTradeStatus) : StatusSwitchEvent</span><br></pre></td></tr></table></figure>

<p>使用时如下</p>
<img src="https://gdz.oss-cn-shenzhen.aliyuncs.com/local/image-20220728182402677.png" alt="image-20220728182402677" style="zoom:50%;" /></li>
</ul>
<blockquote>
<p>当然这还是不够简洁，需要两层匹配，但Kotlin的模式匹配特性只能支持到这了。</p>
</blockquote>
<h3 id="善用叫名函数"><a href="#善用叫名函数" class="headerlink" title="善用叫名函数"></a>善用叫名函数</h3><p>PaymentEntity对应payment表，多个字段是必须的，使用叫名函数构建一个简单的工厂方法，可以定死哪些字段是必须的</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">companion</span> <span class="keyword">object</span> &#123;</span><br><span class="line">  <span class="comment">// 简单的工厂方法：指定哪些字段是必须的。payment字段比较多，构建工厂方法指导使用者如何创建对象是有必要的</span></span><br><span class="line">  <span class="function"><span class="keyword">fun</span> <span class="title">create</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">    userId: <span class="type">Int</span>,</span></span></span><br><span class="line"><span class="params"><span class="function">    beneficiaryId: <span class="type">String</span>,</span></span></span><br><span class="line"><span class="params"><span class="function">    orderId: <span class="type">String</span>,</span></span></span><br><span class="line"><span class="params"><span class="function">    paymentMethod: <span class="type">PaymentMethod</span>,</span></span></span><br><span class="line"><span class="params"><span class="function">    amountActual: <span class="type">Double</span>,</span></span></span><br><span class="line"><span class="params"><span class="function">    amountCharge: <span class="type">Double</span>,</span></span></span><br><span class="line"><span class="params"><span class="function">    <span class="comment">// 阿里云的预支付交易ID可能为null</span></span></span></span><br><span class="line"><span class="params"><span class="function">    refNoOrTransactionId: <span class="type">String</span>?,</span></span></span><br><span class="line"><span class="params"><span class="function">    originalTransactionId: <span class="type">Long</span>? = <span class="literal">null</span>,</span></span></span><br><span class="line"><span class="params"><span class="function">    status: <span class="type">PaymentStatus</span>,</span></span></span><br><span class="line"><span class="params"><span class="function">    paidAt: <span class="type">OffsetDateTime</span>? = <span class="literal">null</span></span></span></span><br><span class="line"><span class="params"><span class="function">  )</span></span>: PaymentEntity &#123;</span><br><span class="line">    <span class="keyword">return</span> PaymentEntity().apply &#123;</span><br><span class="line">      <span class="keyword">this</span>.userId = userId</span><br><span class="line">      <span class="keyword">this</span>.beneficiaryId = beneficiaryId</span><br><span class="line">      <span class="keyword">this</span>.orderId = orderId</span><br><span class="line">      <span class="keyword">this</span>.paymentMethod = paymentMethod</span><br><span class="line">      <span class="keyword">this</span>.amountCharge = amountCharge</span><br><span class="line">      <span class="keyword">this</span>.amountActual = amountActual</span><br><span class="line">      <span class="keyword">this</span>.paymentRefId = refNoOrTransactionId</span><br><span class="line">      <span class="keyword">this</span>.originalRefId = originalTransactionId</span><br><span class="line">      <span class="keyword">this</span>.status = status</span><br><span class="line">      <span class="keyword">this</span>.paidAt = paidAt</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="像ORM那样去用ORM框架"><a href="#像ORM那样去用ORM框架" class="headerlink" title="像ORM那样去用ORM框架"></a>像ORM那样去用ORM框架</h3><p>这一点见仁见智，我的意见是，用ORM时，绝大多数的数据库操作都可以通过Entity和ORM框架自带的方法完成。理想情况下，自己甚至不需要定义任何SQL语句。哪怕只需要更新一个字段值都可以用Entity。至于效率？那是后话。</p>
<h3 id="Kotlin特性相关"><a href="#Kotlin特性相关" class="headerlink" title="Kotlin特性相关"></a>Kotlin特性相关</h3><ul>
<li><p>手动构建toString()是不明智的，即使在Spring中，data class也是可行的。比如如下类是能够正常接收请求体内容的，关键是要用var</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">data</span> <span class="class"><span class="keyword">class</span> <span class="title">UploadTransactionDTO</span></span>(</span><br><span class="line">    <span class="keyword">var</span> signedTransactionInfo: String</span><br><span class="line">)</span><br></pre></td></tr></table></figure></li>
<li><p>all open：Spring AOP要求类必须是可继承的，为此kotlin提供了 all open插件。可以设置特定注解注解的类被编译为可继承的类</p>
</li>
<li><p>当一个类属性被声明为var时，它就已经拥有幕后字段、getter、setter，不需要再手动定义了</p>
</li>
<li><p>Kotlin的简单工厂模式或者构造器模式，不一定要构建一个构造器类，使用叫名函数看起来更简单</p>
</li>
</ul>
<h3 id="尽量保持不可变性"><a href="#尽量保持不可变性" class="headerlink" title="尽量保持不可变性"></a>尽量保持不可变性</h3><p>由于Spring运行时动态修改对象属性的特点，在bean中使用val是一件比较困难的事，但在函数中还是应该尽量少用var。临时对象一次性构建完成，尽量不要将构建后的属性赋值过程分散到函数的各处，这样看起来比较分裂。</p>
<p>函数副作用减到最小。</p>
<h3 id="订阅状态计算"><a href="#订阅状态计算" class="headerlink" title="订阅状态计算"></a>订阅状态计算</h3><p>优化计算逻辑，重构后的逻辑是一个无状态函数，去除了原来的中间状态，输入订单历史记录，即时计算指定日期的订阅状态。这带来几个优点</p>
<ul>
<li>可测试性：无状态函数非常好测试</li>
<li>灵活性高：临时可修改，因为测试需要可以删除或添加订单历史记录，触发计算逻辑即可得到新的状态。如果出现问题，也方便修复</li>
</ul>
<h3 id="业务正确性"><a href="#业务正确性" class="headerlink" title="业务正确性"></a>业务正确性</h3><p>修复了一些业务上的逻辑问题，有些是正确性问题，有些则是逻辑优化。</p>
<h2 id="细节-用户服务"><a href="#细节-用户服务" class="headerlink" title="细节 - 用户服务"></a>细节 - 用户服务</h2><p>用户服务的问题比较单一，主要集中在业务逻辑不清晰这一点。当然支付服务存在的问题这里有些也是存在的，重复的忽略，这里只说差异的。</p>
<h3 id="Service简化"><a href="#Service简化" class="headerlink" title="Service简化"></a>Service简化</h3><p>之前Service和数据表数量对应，基础服务也算Service，过多的Service让人无所适从，不知道哪个起到了主导作用。简化后剩下4个Service</p>
<ul>
<li>AuthService：主要负责登录和三方登录绑定</li>
<li>UserService：主要负责用户相关操作</li>
<li>TokenService：负责Token的创建、验证</li>
<li>UtilService：负责非业务功能，如短信发送、邮件发送等</li>
</ul>
<h3 id="登录过程模板化"><a href="#登录过程模板化" class="headerlink" title="登录过程模板化"></a>登录过程模板化</h3><p>采用模板方法模式，将所有三方登录过程统一抽象，形成如下接口。从流程上，登录的主要流程为</p>
<ul>
<li>并发处理：加锁</li>
<li>验证三方登录凭证，得到凭证验证结果</li>
<li>根据凭证验证结果执行登录操作——创建用户</li>
</ul>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">AuthHandler</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 分布式锁的key</span></span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">getLockKey</span><span class="params">(req: <span class="type">SignInReq</span>)</span></span>: String</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 验证登录凭证</span></span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">verifyCredential</span><span class="params">(req: <span class="type">SignInReq</span>)</span></span>: CredentialVerifyResult</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 登录操作：创建对应资源</span></span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">login</span><span class="params">(verifyResult: <span class="type">CredentialVerifyResult</span>)</span></span>: User</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在AuthService中有它的使用方法</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">signIn</span><span class="params">(req: <span class="type">SignInReq</span>)</span></span>: SignInResp &#123;</span><br><span class="line">  <span class="keyword">val</span> authHandler = chooseHandler(req.type)</span><br><span class="line"></span><br><span class="line">  <span class="keyword">val</span> lockKey = authHandler.getLockKey(req)</span><br><span class="line">  <span class="keyword">val</span> lock = redisLock.obtain(lockKey)</span><br><span class="line">  <span class="keyword">val</span> locked = lock.tryLock(<span class="number">6</span>, TimeUnit.SECONDS)</span><br><span class="line">  <span class="keyword">if</span> (!locked) <span class="keyword">throw</span> IllegalStateException(<span class="string">&quot;未获取到锁: <span class="variable">$lockKey</span>&quot;</span>)</span><br><span class="line"></span><br><span class="line">  <span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="comment">// 验证登录凭证</span></span><br><span class="line">    <span class="keyword">val</span> verifyResult = authHandler.verifyCredential(req).apply &#123;</span><br><span class="line">      <span class="keyword">this</span>.relateUuid = req.relateUserReq.uuid.takeIf &#123; it.isNotBlank() &#125;</span><br><span class="line">      <span class="keyword">this</span>.relateGlobalKey = req.relateUserReq.globalKey?.takeIf &#123; it.isNotBlank() &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 处理两步登录</span></span><br><span class="line">    <span class="keyword">val</span> twoStepResult = twoStepLoginHandler.handle(req, verifyResult)</span><br><span class="line">    <span class="keyword">if</span> (twoStepResult != <span class="literal">null</span>) &#123;</span><br><span class="line">      <span class="keyword">return</span> renderTwoStepResult(twoStepResult.first, twoStepResult.second)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 实际的登录操作，登录成功后能够得到领域对象</span></span><br><span class="line">    <span class="keyword">val</span> user = authHandler.login(verifyResult)</span><br><span class="line">    <span class="comment">// 游客关联</span></span><br><span class="line">    <span class="keyword">if</span> (req.type != SignType.TOURIST &amp;&amp; verifyResult.relateUuid != <span class="literal">null</span>) &#123;</span><br><span class="line">      userFactory.getByTourist(verifyResult.relateUuid!!)?.let &#123; tourist -&gt; user.relateOther(tourist) &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 用户数据持久化</span></span><br><span class="line">    userRepository.persistent(user)</span><br><span class="line">    <span class="keyword">return</span> renderLoginResult(user)</span><br><span class="line">  &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">    lock.unlock()</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="创建领域层"><a href="#创建领域层" class="headerlink" title="创建领域层"></a>创建领域层</h3><p>创建了User这个Aggregate，包含了Token之外的各种信息：用户信息、各平台的登录信息。</p>
<p>创建了UserFactory负责User的创建（可以凭空创建，也可以从数据库中恢复，根据创建的来源不同，可以知道该用户是否是新建的）。</p>
<p>创建了UserRepository负责User的持久化。</p>
<p>为了方便，上述三个领域对象只是对各种ORM对象的封装，严格来说不算领域对象，但实用为主。</p>
<p>于是所有登录操作、查询操作，都变成了基于User进行的操作。以苹果登录为例，流程如下</p>
<ul>
<li>验证苹果登录凭证</li>
<li>调用UserFactory.getByApple()根据登录凭证获取User</li>
<li>如果获取不到，调用UserFactory.getByEmail()根据邮箱获取User</li>
<li>如果获取不到，调用UserFactory.create()创建新用户</li>
<li>调用User.updateAppleLoginInfo()保存登录凭证信息</li>
<li>调用UserRepository.persistent()持久化User信息。其内部会同时持久化User表和AppleLogin表</li>
</ul>
<p>相较而言，没有User对象的操作可能是这样</p>
<ul>
<li>验证苹果登录凭证</li>
<li>调用AppleLoginDao.getByxxx()获取苹果登录凭证</li>
<li>如果获取不到，调用UserDao.getByEmail()根据邮箱获取User</li>
<li>如果获取不到，调用UserDao.save()创建新的User信息</li>
<li>调用AppleLoginDao.updateById()保存登录凭证信息</li>
</ul>
<p>二者比较，领域操作只有一个入口：User，看起来更像是业务逻辑；而后者常规的操作有几个表就有几个入口，就逻辑而言，就是在面向过程编程。如果业务复杂一点，常规的方式就很难看懂了（其唯一的有点，就是快）。</p>
<p>这一点在微信登录和电话登录体现得比较明显。</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>实际地说，支付服务和用户服务功能和逻辑比较单一，之所以重构，是原代码将本来简单的逻辑复杂化了。当然这不是代码作者的问题：需求会迭代，coder在写项目的过程中对需求的理解也会发生变化，可能刚拿到需求就要开始编码，因为项目进度要求又没时间进行优化。就造成了现在的结果。</p>
<p>《领域驱动设计》那本书有两点我很认同：</p>
<ul>
<li><p>持续重构：随着项目的进行，工程师对领域的认识会发生改变，可能昨天对的事情，今天就是另外一个现象。所以项目代码的重构总是需要不断进行</p>
<p>这一点是促使我重构如上两个项目的直接动机。正好它们从开始开发就没怎么变过，现在的业务理解，可能和开始时不同，我看着都有点不大好理解，后面接手的人肯定更难。</p>
</li>
<li><p>领域模型：项目进行的过程中持续建模</p>
<p>经常听到有人说CRUD没意思，但如果试试应用DDD，或许就会变得有趣一点。而且就算代码中不用，画个领域模型图也会让我们对项目的理解更加立体，这比很多文档都管用。</p>
</li>
</ul>
<p>当然，程序员1接手程序员0的项目时，觉得是一座屎山，于是决定重写，以为井井有条，实际上可能只有他自己看得懂，自己并没认识到他只是创造了另一座屎山；程序员2接手程序员1的项目时，又会重写一遍。这是个调侃，也有一点道理，和大佬相比，我可能啥都不是。</p>
<p><a href="https://jmmv.dev/2021/04/always-be-quitting.html">Always be quitting</a>是去年某个月的每月一稿中某位同事分享的，让代码变得可维护，也是一个重要的点。</p>
<p>写好代码是我长久以来的愿望，但奈何这一点做的不够好，上面的那些点见仁见智，如果有不同看法，欢迎交流。</p>
]]></content>
      <categories>
        <category>业务</category>
      </categories>
      <tags>
        <tag>搬砖</tag>
      </tags>
  </entry>
  <entry>
    <title>换个角度看X.509证书</title>
    <url>/2022/06/12/%E6%8D%A2%E4%B8%AA%E8%A7%92%E5%BA%A6%E7%9C%8BX-509%E8%AF%81%E4%B9%A6/</url>
    <content><![CDATA[<blockquote>
<p>我每篇博客的书写都是有动机的，它们或是对一段时间的工作总结、或是对某个事物的感悟。这次要写X.509的博客，是因接入IAP时，从网上搜索的各种问题发现一个惊人的事实：很多人不知道X.509证书的验证方式，当然也包括我。</p>
</blockquote>
<span id="more"></span>

<p>初识X.509证书，多半是HTTPS协议，SSL或TLS握手阶段，需要用证书传输公钥，建立加密的传输信道。于是在印象中X.509就和HTTPS绑定在了一起。这种绑定有些许先入为主。实际上X.509证书的用途不止如此。</p>
<h2 id="现成的知识"><a href="#现成的知识" class="headerlink" title="现成的知识"></a>现成的知识</h2><p>网上已经很多写得好的文章，推荐一篇：<a href="https://zhuanlan.zhihu.com/p/36832100">X.509数字证书的基本原理及应用</a>。从中我们可以总结出几个要点</p>
<ul>
<li>数字证书的目的在于安全地分发公钥</li>
<li>数字证书 = 公钥 + 公钥所属实体 + 签名</li>
<li>数字证书分多级，一般有根证书、中间证书、叶子证书，根证书安装在系统中，叶子证书和中间证书需要根证书进行验证</li>
</ul>
<p>除此之外，没有更多的理论信息。博客的输出往往只是作者知识学习过程的输出，常很片面，仅能作为知识交流和了解的方式，不能作为严肃学习的主要来源（包括我这篇）。优秀如此文，看完也还是虚空之感，因为我们不知道还有多少相关知识是不知道的。</p>
<h2 id="原材料"><a href="#原材料" class="headerlink" title="原材料"></a>原材料</h2><p>学习X.509的误区之一，是将它与HTTPS、TLS等协议结合在一起，然后被这些协议的其它知识点搞得头昏目眩。就像JWT，如果只是和登录鉴权结合在一起，就会忽略它本身的特性。</p>
<blockquote>
<p>我们往往对一个技术的支撑技术缺乏了解，甚至缺乏了解的耐心。</p>
</blockquote>
<p>最好的方式还是阅读RFC，相关文档如下</p>
<ul>
<li><a href="https://datatracker.ietf.org/doc/html/rfc5280">RFC5280</a>：主协议，描述X.509用途、结构、验证方式等</li>
<li><a href="https://datatracker.ietf.org/doc/html/rfc2560#legend">RFC2560</a>：OCSP协议，在线证书状态协议，描述如何实时获取证书的状态，即有效性</li>
<li><a href="https://datatracker.ietf.org/doc/html/rfc4491">RFC4491</a>、<a href="https://datatracker.ietf.org/doc/html/rfc3279#legend">RFC3279</a>、<a href="https://datatracker.ietf.org/doc/html/rfc4055#legend">RFC4055</a>：附加协议，描述了在证书中使用的加密算法</li>
</ul>
<p>其中，RFC5280需要认真阅读，其它协议选读，了解即可。</p>
<h2 id="RFC5280"><a href="#RFC5280" class="headerlink" title="RFC5280"></a>RFC5280</h2><h3 id="基础"><a href="#基础" class="headerlink" title="基础"></a>基础</h3><ul>
<li><p>证书是什么</p>
<p>全面地说应该叫做公钥证书，它是一种数据结构，用来绑定公钥值，该绑定加上了CA签名让它变得可信。CA通过技术手段使得这种可信变得有保证。一般来说，这种技术手段是操作系统内置根证书+证书的路径验证。</p>
</li>
<li><p>用途</p>
<ul>
<li><p>网站通信，即常规的HTTPS</p>
</li>
<li><p>电子邮件</p>
</li>
<li><p>用户鉴权，可参考JWS的x5c字段</p>
</li>
<li><p>IPsec</p>
</li>
</ul>
</li>
<li><p>证书生命周期</p>
<p>证书的证书的生命周期，是根据它的签名内容而定的，即证书并不是永久的。因为证书可能被仿冒。</p>
<blockquote>
<p>现在很多以年为单位，这可能只是业务上的生命周期，并不一定是技术上的生命周期，理论上说这有一定的安全隐患。</p>
</blockquote>
</li>
<li><p><strong>证书path</strong></p>
<p>用户拿到证书，如果不拥有颁发该证书的CA的可信的公钥，此时需要另一个证书来获取该CA的可信公钥。这样可以形成一个证书链，这叫做证书路径。</p>
</li>
<li><p>证书分类</p>
<ul>
<li><p><strong>CA证书</strong></p>
<ul>
<li>交叉证书：签发方和证书主体来自不同的实体。用于描述两个CA的互信关系</li>
<li>自签发证书：签发方和证书主体是同一个实体</li>
<li>自签名证书：属于自签发证书的一种，它的签名可以用证书自带的公钥验证。这个用在证书路径的根部，即根证书</li>
</ul>
</li>
<li><p>终端实体证书</p>
<p>颁发给无权颁发证书的实体</p>
</li>
</ul>
</li>
<li><p>证书撤回</p>
<p>签发的证书在实际有效期前可以被撤销，是通过Certificate Revoke List的方式，即CA定期发布CRL，使用证书的系统，除了验证证书本身的有效性，还需要检查证书是不是在CRL，如果在，则证书不可用。</p>
<blockquote>
<p>一些情况下，客户端需要马上知道证书的有效性，如金融和证券行业，CRL无法满足这个实时性需求，于是有了OCSP，它提供在线查询某个证书是否有效的服务</p>
</blockquote>
</li>
</ul>
<h3 id="证书结构"><a href="#证书结构" class="headerlink" title="证书结构"></a>证书结构</h3><p>协议中的结构描述过于严谨和复杂，这里借用前面提到的博客的截图，比较易于理解。</p>
<img src="https://pic1.zhimg.com/v2-9b7cbd5eb1b56c6e6632f1ccb1c4a448_r.jpg" alt="preview" style="zoom:50%;" />

<h3 id="证书验证方式"><a href="#证书验证方式" class="headerlink" title="证书验证方式"></a>证书验证方式</h3><p>RFC5280第六小结阐述了客户端如何处理证书路径的算法，所有使用证书的客户端都必须实现该算法。</p>
<p><strong>路径验证的主要目标是根据信任目标的公钥验证证书主题的名称（或备用名称）和证书主题公钥之间的绑定</strong>。具体来说，验证的是路径是否满足如下条件</p>
<ol>
<li>对于{1, …, n-1} 中的所有 x ，证书x的主题是证书x+1的颁发者</li>
<li>证书1由信任目标颁发，即我们常说的根证书，一般是提前下载到操作系统</li>
<li>证书n是要验证的目标证书，即叶子证书</li>
<li>对于所有证书x，都必须在有效时间内</li>
</ol>
<p>现实应用的举例：</p>
<ul>
<li><p>在JWS规定的头部中的x5c字段，会将整个证书路径全部给出，根据这些证书我们可以验证1、3、4条件，至于2，则是根据具体厂商的不同而不同，比如IAP Storekit2提供的JWS，就需要我们从apple开发者网站手动下载可信的根证书。</p>
</li>
<li><p>DNS证书是我们接触得最多的证书，其本身是一个叶子证书，证书内部指明了签发该证书的中间证书，中间证书指向安装在本地的根证书，由三个证书构成一条路径，验证可完全满足上述条件。</p>
<p>以知乎为例，查看其证书信息</p>
<img src="https://gdz.oss-cn-shenzhen.aliyuncs.com/local/image-20220612151129845.png" alt="image-20220612151129845" style="zoom:50%;" />

<img src="https://gdz.oss-cn-shenzhen.aliyuncs.com/local/image-20220612151246083.png" alt="image-20220612151246083" style="zoom:40%;" />

<blockquote>
<p>还可以看到，DNS证书的域名是主题名称和备用名称的并集，比如RFC官网的证书，域名是datatracker.ietf.org，主题名称却是sni.cloudflaressl.com，备用名称是datatracker.ietf.org</p>
<img src="https://gdz.oss-cn-shenzhen.aliyuncs.com/local/image-20220612151643845.png" alt="image-20220612151643845" style="zoom:50%;" />

<img src="https://gdz.oss-cn-shenzhen.aliyuncs.com/local/image-20220612151609922.png" alt="image-20220612151609922" style="zoom:50%;" />

<img src="https://gdz.oss-cn-shenzhen.aliyuncs.com/local/image-20220612151628066.png" alt="image-20220612151628066" style="zoom:50%;" />
</blockquote>
<blockquote>
<p>可以多看几个证书的结构，加深印象</p>
</blockquote>
</li>
<li><p>抓包工具fiddler或charles，如果需要抓取HTTPS，需要自己安装根证书，解决的就是受信的问题。</p>
</li>
</ul>
<h3 id="CA机构之间的关系"><a href="#CA机构之间的关系" class="headerlink" title="CA机构之间的关系"></a>CA机构之间的关系</h3><p><strong>为什么会有中间证书</strong>？</p>
<p>证书需求量巨大，根证书处理不过来，于是将部分证书签发的权限分发给其它CA供应商。这种结构在RFC5280第三节中的管理协议和操作协议中有所阐述，即PKI各个实体之前的关系</p>
<ul>
<li>CA可以授权给下一级CA，也可以授权给RA</li>
<li>RA即注册授权机构，只能颁发证书，其证书签发者是上层CA</li>
<li>CA可以颁发证书和CRL，签发者可以是自己（根证书），也可以是上层CA</li>
<li>CRL签发机构，权限来自上层CA下放，只能颁发CRL</li>
</ul>
<img src="https://gdz.oss-cn-shenzhen.aliyuncs.com/local/image-20220612152408807.png" alt="image-20220612152408807" style="zoom:50%;" />

<blockquote>
<p><strong>什么是PKI？</strong></p>
<p>即Public Key Infrastructure，公钥基础设施，即利用公开秘钥机制建立起来的基础设施，上图就描述了PKI的主要组成部分。</p>
<p>PKI users即普通个人或公司，用终端实体表示，我们申请证书的机构就是RA或CA，CA又是有层级的。这一堆东西，构成了当前网络访问的安全基础设施。因此，PKI指的是整个证书分发机制构成的宏大系统。</p>
</blockquote>
<h2 id="其它协议"><a href="#其它协议" class="headerlink" title="其它协议"></a>其它协议</h2><p>其它协议都很短，RFC2560看看摘要就知道什么是OCSP了，就是一个普通的状态查询接口。</p>
<h2 id="实践"><a href="#实践" class="headerlink" title="实践"></a>实践</h2><p>这里展示代码验证IAP证书路径的过程（暂时忽略了有效期的验证）</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">val</span> appleRootCert = PathMatchingResourcePatternResolver()</span><br><span class="line">        .getResources(<span class="string">&quot;classpath:cert/AppleRootCA-G3.cer&quot;</span>).first().inputStream.readBytes()</span><br><span class="line"></span><br><span class="line"><span class="comment">// 解码并验证时接收到的通知</span></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">decodeAndVerifyAppleNotification</span><span class="params">(rawNotification: <span class="type">String</span>)</span></span>: AppleNotificationPayload &#123;</span><br><span class="line">  ... ...</span><br><span class="line">  <span class="comment">// 验证证书链，并获取叶子证书携带的公钥</span></span><br><span class="line">  <span class="keyword">val</span> targetPublicKey = verifyAppleNotificationCertsThenReturnPublicKey(<span class="keyword">this</span>)</span><br><span class="line">  ... ...</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="function"><span class="keyword">fun</span> <span class="title">verifyAppleNotificationCertsThenReturnPublicKey</span><span class="params">(jwt: <span class="type">DecodedJWT</span>)</span></span>: PublicKey &#123;</span><br><span class="line">  <span class="keyword">val</span> certFactory = CertificateFactory.getInstance(<span class="string">&quot;X.509&quot;</span>)</span><br><span class="line">  <span class="comment">// 根证书，已经提前下好了</span></span><br><span class="line">  <span class="keyword">val</span> appleRootCert = certFactory.generateCertificate(ByteArrayInputStream(appleRootCert)) <span class="keyword">as</span> X509Certificate</span><br><span class="line">  <span class="comment">// 放在x5c字段中的证书链</span></span><br><span class="line">  <span class="keyword">val</span> jwsCertChain = jwt.getHeaderClaim(<span class="string">&quot;x5c&quot;</span>).asList(String::<span class="keyword">class</span>.java).map &#123;</span><br><span class="line">    certFactory.generateCertificate(ByteArrayInputStream(Base64.getDecoder().decode(it)))</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 关键点1：验证根证书</span></span><br><span class="line">  <span class="keyword">if</span> (jwsCertChain.last() != appleRootCert) <span class="keyword">throw</span> Exception(<span class="string">&quot;根证书错误&quot;</span>)</span><br><span class="line">  <span class="comment">// 关键点2：验证证书链，证书x签发了证书x+1</span></span><br><span class="line">  <span class="keyword">for</span> (index <span class="keyword">in</span> <span class="number">0.</span>.jwsCertChain.size - <span class="number">2</span>) &#123;</span><br><span class="line">    jwsCertChain[index].verify(jwsCertChain[index + <span class="number">1</span>].publicKey)</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 关键点3：第叶子证书的公钥即为验证整个JWS的公钥</span></span><br><span class="line">  <span class="keyword">return</span> jwsCertChain.first().publicKey</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>写得再好的博客文章，都是经过别人消化系统呈现的冰山一角，会经历知识衰减。永远比不上一手资料，即使是不仔细看的一手资料。</p>
<p>回到X.509证书本身，抓住几个重点</p>
<ol>
<li>证书结构：主题（包括主题机构、名、公钥信息）、签发者、有效期、签名（又叫做指纹）</li>
<li>证书路径：通过主题名或主题备用名与签发者串联，能够产生证书路径，即证书链</li>
<li>证书如何使用：通过证书路径验证即可保证证书是可信的，使用的目标是证书携带的公钥（证书只是安全携带公钥的工具而已）</li>
<li>众多CA、RA共同构成了PKI</li>
</ol>
]]></content>
      <categories>
        <category>协议</category>
      </categories>
      <tags>
        <tag>X.509</tag>
      </tags>
  </entry>
  <entry>
    <title>推荐系统 - 概述</title>
    <url>/2019/09/08/%E6%8E%A8%E8%8D%90%E7%B3%BB%E7%BB%9F%20-%20%E6%A6%82%E8%BF%B0-%E6%8E%A8%E8%8D%90%E7%B3%BB%E7%BB%9F-%E6%A6%82%E8%BF%B0/</url>
    <content><![CDATA[<h1 id="什么是推荐系统"><a href="#什么是推荐系统" class="headerlink" title="什么是推荐系统"></a>什么是推荐系统</h1><p>推荐系统让用户能够发现对自己有价值的信息，另一方面，能够让信息展现在对它感兴趣的用户面前。实现消费者和生产者的双赢。</p>
<span id="more"></span>

<h1 id="几个理论"><a href="#几个理论" class="headerlink" title="几个理论"></a>几个理论</h1><h2 id="长尾理论"><a href="#长尾理论" class="headerlink" title="长尾理论"></a>长尾理论</h2><p>来自市场营销上的说法。即传统认为，厂商80%的收入很可能来自20%热门商品。但在互联网条件下，由于铺货成本极其低廉，那些不热门的商品销售数量可能极其庞大，使得其销售收入与热门商品相当甚至更多。推荐系统就是基于长尾理论, 将长尾商品推荐给用户, 实现收益增加</p>
<h2 id="幂律分布"><a href="#幂律分布" class="headerlink" title="幂律分布"></a>幂律分布</h2><p>一种分布， 曲线如下。长尾理论就是幂律分布的通俗体现。常见幂律分布：英文单词、个人收入等</p>
<p><img src="https://bkimg.cdn.bcebos.com/pic/b7003af33a87e95043a921b111385343faf2b4b5?x-bce-process=image/watermark,image_d2F0ZXIvYmFpa2U5Mg==,g_7,xp_5,yp_5/format,f_auto" alt="img"></p>
<h2 id="马太效应"><a href="#马太效应" class="headerlink" title="马太效应"></a>马太效应</h2><p>即两极分化效应，强者越强， 弱者越弱</p>
<p>出自《新约·马太福音》： “凡有的，还要加倍给他叫他多余；没有的，连他所有的也要夺过来”</p>
<h1 id="推荐系统原理"><a href="#推荐系统原理" class="headerlink" title="推荐系统原理"></a>推荐系统原理</h1><p>推荐系统并没有特别高深的理论，它只不过将我们平常的检索进行了自动化</p>
<ul>
<li>社会化推荐：对应于向好友咨询</li>
<li>基于内容的推荐：对应于我们手动搜索电影片名或演员名</li>
<li>基于协同过滤的推荐：对应于查看排行榜，找到广受好评的电影</li>
</ul>
<p>推荐的本质是将用户和物品联系起来。而不同的推荐系统只是利用了不同的联系方式</p>
<h1 id="推荐做得好的应用"><a href="#推荐做得好的应用" class="headerlink" title="推荐做得好的应用"></a>推荐做得好的应用</h1><ul>
<li>亚马逊<ul>
<li>让每个用户像是拥有自己的专属商店一样</li>
<li>20-30%收入来自推荐系统</li>
</ul>
</li>
<li>Netflix<ul>
<li>举办了推荐系统比赛</li>
<li>自己宣称有60%的用户是通过推荐系统找到自己喜欢的影片的</li>
</ul>
</li>
<li>Youtube<ul>
<li>其实验表明。个性化推荐的视频点击率是热门视频点击率的两倍</li>
</ul>
</li>
<li>音乐电台<ul>
<li>豆瓣电台：用户无法自己选取歌曲。只能标记喜欢或不喜欢，模型建立完成后就能够推荐用户感兴趣的歌曲。</li>
</ul>
</li>
<li>facebook<ul>
<li>利用推荐系统推荐广告、推荐信息流、推荐好友</li>
<li>退出了API，称为Instant Personalization，能够推荐用户的好友喜欢的物品。</li>
</ul>
</li>
<li>阅读推荐<ul>
<li>今日头条等</li>
</ul>
</li>
</ul>
<h1 id="什么是好的推荐系统"><a href="#什么是好的推荐系统" class="headerlink" title="什么是好的推荐系统"></a>什么是好的推荐系统</h1><p>合格的满足如下三点</p>
<ul>
<li>用户能够得到自己的感兴趣的推荐内容</li>
<li>商品提供方的物品要能够被推荐到合适的用户手中</li>
<li>能够收集到高质量的用户反馈， 从而不断完善推荐系统， 提高推荐准确性。</li>
</ul>
<p>好的推荐系统还满足一点</p>
<ul>
<li>不仅能够预测用户的行为， 还能扩展用户的视野，帮助其发现潜在的新东西</li>
</ul>
<p>注意， 准确性并不能完全决定推荐算法的好坏。 比如预测太阳从东方升起，这是100%准确的预测， 但是也是一个毫无意义的预测。</p>
<h1 id="如何测试推荐系统"><a href="#如何测试推荐系统" class="headerlink" title="如何测试推荐系统"></a>如何测试推荐系统</h1><ul>
<li>离线测试：即使用现有的数据集对系统进行测试</li>
<li>用户调查：直接上线前的测试，先做用户调查，让用户为推荐系统进行评价</li>
<li>在线实验：用户调查完成后上线。评价的标准是做AB test，即和原有的算法进行比较。</li>
</ul>
<p>上面三个处于推荐系统的不同开发阶段。先离线测试，OK后做用户调查，OK后上线实验</p>
<h2 id="测试标准"><a href="#测试标准" class="headerlink" title="测试标准"></a>测试标准</h2><ul>
<li><p>用户满意度</p>
</li>
<li><p>预测准确度</p>
</li>
<li><p>覆盖率：即对长尾物品的发掘能力。如果所有物品都出现在推荐列表中， 并且出现次数差不多， 则长尾发掘能力就好很多</p>
<p>两个指标定义覆盖率</p>
<ul>
<li><p>信息熵：<a href="https://www.cnblogs.com/IamJiangXiaoKun/p/9455689.html%E3%80%82%E7%AE%80%E5%8D%95%E8%AF%B4%EF%BC%8C%E4%BF%A1%E6%81%AF%E7%86%B5%E5%B0%B1%E6%98%AF%E5%AF%B9%E4%B8%80%E4%B8%AA%E4%B8%8D%E7%A1%AE%E5%AE%9A%E4%BA%8B%E4%BB%B6%E5%8F%91%E7%94%9F%E6%89%80%E5%8F%AF%E8%83%BD%E4%BA%A7%E7%94%9F%E7%9A%84%E4%BF%A1%E6%81%AF%E9%87%8F%E7%9A%84%E6%9C%9F%E6%9C%9B%E3%80%82%E8%80%8C%E4%BF%A1%E6%81%AF%E9%87%8F%E5%92%8C%E8%AF%A5%E6%97%B6%E9%97%B4%E5%8F%91%E7%94%9F%E6%A6%82%E7%8E%87%E7%9A%84%E5%AF%B9%E6%95%B0%E7%9A%84%E5%80%92%E6%95%B0%E6%9C%89%E5%85%B3%E3%80%82%E5%8D%B3%E4%B8%80%E4%B8%AA%E4%BA%8B%E4%BB%B6%E5%8F%91%E7%94%9F%E6%A6%82%E7%8E%87%E8%B6%8A%E9%AB%98%EF%BC%8C%E5%88%99%E4%BA%A7%E7%94%9F%E7%9A%84%E4%BF%A1%E6%81%AF%E9%87%8F%E8%B6%8A%E5%B0%8F%EF%BC%9B%E6%A6%82%E7%8E%87%E8%B6%8A%E4%BD%8E%EF%BC%8C%E4%BA%A7%E7%94%9F%E7%9A%84%E4%BF%A1%E6%81%AF%E9%87%8F%E8%B6%8A%E5%A4%A7%E3%80%82">https://www.cnblogs.com/IamJiangXiaoKun/p/9455689.html。简单说，信息熵就是对一个不确定事件发生所可能产生的信息量的期望。而信息量和该时间发生概率的对数的倒数有关。即一个事件发生概率越高，则产生的信息量越小；概率越低，产生的信息量越大。</a></p>
</li>
<li><p>基尼系数：用于衡量收入分配是否均匀之类的问题。计算方法是A/B。当A为0时，基尼系数为0.说明绝对平等了。当A很大时，说明非常不平衡。</p>
</li>
</ul>
</li>
<li><p>多样性：推荐多种多样的商品</p>
</li>
<li><p>新颖性：推荐用户没听说过的商品</p>
</li>
<li><p>惊喜度：相比新颖性，还能让用户感觉使用之后很惊喜</p>
</li>
<li><p>信任度：涉及推荐的方式，要让用户新人所推荐的内容，愿意购买商品</p>
</li>
<li><p>实时性：比如用户新买了一个iphone，及时给他推荐手机壳之类的</p>
</li>
<li><p>健壮性：抗击作弊</p>
</li>
</ul>
]]></content>
      <categories>
        <category>算法</category>
        <category>推荐</category>
      </categories>
      <tags>
        <tag>推荐</tag>
      </tags>
  </entry>
  <entry>
    <title>深入Nginx的server和location匹配算法</title>
    <url>/2020/02/22/%E6%B7%B1%E5%85%A5Nginx%E7%9A%84server%E5%92%8Clocation%E5%8C%B9%E9%85%8D%E7%AE%97%E6%B3%95-%E6%B7%B1%E5%85%A5nginx%E7%9A%84server%E5%92%8Clocation%E5%8C%B9%E9%85%8D%E7%AE%97%E6%B3%95/</url>
    <content><![CDATA[<blockquote>
<p>前两天使用K8S的ingress配置，遇到两个有包含关系的uri需要匹配到两个不同的容器中的情况，找了一下具体的匹配规则，主要来自<a href="https://www.digitalocean.com/community/tutorials/understanding-Nginx-server-and-location-block-selection-algorithms">这篇文章</a></p>
</blockquote>
<p>根据墨菲定律，可能会发生的事就一定会发生。如果对Nginx的路径配置一直存疑，迟早会出问题。因此，搞懂很重要。</p>
<p>总体来说，Nginx将配置根据不同的server分成了不同的块，每当一个请求过来时，Nginx都会根据一定的算法确定哪一个配置块来处理该请求。其中起关键性作用的是server块和location块。前者定义了一个虚拟服务器，管理员通常会定义多个server块，然后根据请求的域名，端口或IP决定匹配到哪一个；后者存在于server块内，根据URI对虚拟服务器进行更加详细的区分。二者组合起来能够实现非常灵活的配置。</p>
<span id="more"></span>

<h1 id="server"><a href="#server" class="headerlink" title="server"></a>server</h1><p>在server块内，主要通过listen指令和server_name指令配置</p>
<h2 id="listen"><a href="#listen" class="headerlink" title="listen"></a>listen</h2><p>首先，Nginx查看请求的IP地址和端口，将它与每个server块的listen匹配。</p>
<p>listen指令用于定义server块需要响应的IP和端口。默认情况下，任何不包含listen指令的server块都将被分配一个默认值：对于root用户，将被设置为0.0.0.0:80；对于普通用户，将被设置为0.0.0.0:8080。</p>
<p>listen指令有如下几种可能性。</p>
<ul>
<li>IP + Port</li>
<li>单独的IP，此时Port将被设为默认值80</li>
<li>单独的Port， 此时将会监听该端口上的所有接口</li>
<li>Unix的socket文件路径</li>
</ul>
<p>匹配时，算法如下</p>
<ul>
<li>首先将不完整的listen指令使用默认值填充完整<ul>
<li>没有设置listen指令的，使用0.0.0.0:80替换</li>
<li>单独的IP，端口默认设为80</li>
<li>单独的端口，IP默认设为0.0.0.0</li>
</ul>
</li>
<li>将IP-Port和请求的IP-Port对比</li>
<li>如果只有一个server块匹配成功，则该server为最终结果。如果有多个server块匹配成功，则继续根据server_name进行匹配。</li>
</ul>
<p>注意哟：server_name只有在需要区分listen匹配的多个结果时才会被使用。一个典型的例子，如果example.com被解析到192.168.1.10，此时要在80上进行匹配。则下面两个配置永远只会匹配到第一个。</p>
<figure class="highlight nginx"><table><tr><td class="code"><pre><span class="line"><span class="section">server</span> &#123;</span><br><span class="line">    <span class="attribute">listen</span> <span class="number">192.168.1.10</span>;</span><br><span class="line">    . . .</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="section">server</span> &#123;</span><br><span class="line">    <span class="attribute">listen</span> <span class="number">80</span>;</span><br><span class="line">    <span class="attribute">server_name</span> example.com;</span><br><span class="line">    . . .</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="server-name"><a href="#server-name" class="headerlink" title="server_name"></a>server_name</h2><p>当listen指令匹配到多个结果时，server_name就发挥作用了。</p>
<p>Nginx会检查请求的<strong>Host头部</strong>，根据如下算法，将其值与server_name指令配置内容进行对比</p>
<ul>
<li>首先进行精确匹配，如果匹配数量为1，则使用；如果精确匹配到多个，则使用第一个；如果匹配为0，则继续</li>
<li>匹配以*开头的配置值，如匹配数量为1，则使用；如匹配到多个，则使用最长那个；如果匹配为0，则继续</li>
<li>匹配以*结尾的配置值，如匹配数量为1，则使用；如匹配到多个，则使用最长那个；如果匹配为0，则继续</li>
<li>使用正则表达式匹配，使用匹配到的第一个；如果匹配为0，则继续</li>
<li>到这里还没有匹配到，则使用该IP和Port对应的默认server块</li>
</ul>
<p>注意哟：一个IP和Port对应的默认server块，就是根据listen匹配结果集的第一个，或包含了default_server选项的server块。</p>
<p>例一：host1.example.com会匹配第二个server块。满足算法第一点。</p>
<figure class="highlight nginx"><table><tr><td class="code"><pre><span class="line"><span class="section">server</span> &#123;</span><br><span class="line">    <span class="attribute">listen</span> <span class="number">80</span>;</span><br><span class="line">    <span class="attribute">server_name</span> <span class="regexp">*.example.com</span>;</span><br><span class="line">    . . .</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="section">server</span> &#123;</span><br><span class="line">    <span class="attribute">listen</span> <span class="number">80</span>;</span><br><span class="line">    <span class="attribute">server_name</span> host1.example.com;</span><br><span class="line">    . . .</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>例二：<a href="http://www.example.org匹配第二个server块.满足算法第二点./">www.example.org匹配第二个server块。满足算法第二点。</a></p>
<figure class="highlight nginx"><table><tr><td class="code"><pre><span class="line"><span class="section">server</span> &#123;</span><br><span class="line">    <span class="attribute">listen</span> <span class="number">80</span>;</span><br><span class="line">    <span class="attribute">server_name</span> <span class="regexp">www.example.*</span>;</span><br><span class="line">    . . .</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="section">server</span> &#123;</span><br><span class="line">    <span class="attribute">listen</span> <span class="number">80</span>;</span><br><span class="line">    <span class="attribute">server_name</span> <span class="regexp">*.example.org</span>;</span><br><span class="line">    . . .</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="section">server</span> &#123;</span><br><span class="line">    <span class="attribute">listen</span> <span class="number">80</span>;</span><br><span class="line">    <span class="attribute">server_name</span> <span class="regexp">*.org</span>;</span><br><span class="line">    . . .</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>例三：<a href="http://www.example.org匹配第三个server块.满足算法第三点./">www.example.org匹配第三个server块。满足算法第三点。</a></p>
<figure class="highlight nginx"><table><tr><td class="code"><pre><span class="line"><span class="section">server</span> &#123;</span><br><span class="line">    <span class="attribute">listen</span> <span class="number">80</span>;</span><br><span class="line">    <span class="attribute">server_name</span> host1.example.com;</span><br><span class="line">    . . .</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="section">server</span> &#123;</span><br><span class="line">    <span class="attribute">listen</span> <span class="number">80</span>;</span><br><span class="line">    <span class="attribute">server_name</span> example.com;</span><br><span class="line">    . . .</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="section">server</span> &#123;</span><br><span class="line">    <span class="attribute">listen</span> <span class="number">80</span>;</span><br><span class="line">    <span class="attribute">server_name</span> <span class="regexp">www.example.*</span>;</span><br><span class="line">    . . .</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>例四：<a href="http://www.example.org匹配第二个server块.满足算法第四点./">www.example.org匹配第二个server块。满足算法第四点。</a></p>
<figure class="highlight nginx"><table><tr><td class="code"><pre><span class="line"><span class="section">server</span> &#123;</span><br><span class="line">    <span class="attribute">listen</span> <span class="number">80</span>;</span><br><span class="line">    <span class="attribute">server_name</span> example.com;</span><br><span class="line">    . . .</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="section">server</span> &#123;</span><br><span class="line">    <span class="attribute">listen</span> <span class="number">80</span>;</span><br><span class="line">    <span class="attribute">server_name</span> ~^(www|host1).*\.example\.com$;</span><br><span class="line">    . . .</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="section">server</span> &#123;</span><br><span class="line">    <span class="attribute">listen</span> <span class="number">80</span>;</span><br><span class="line">    <span class="attribute">server_name</span> ~^(subdomain|set|www|host1).*\.example\.com$;</span><br><span class="line">    . . .</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="location"><a href="#location" class="headerlink" title="location"></a>location</h1><h2 id="语法"><a href="#语法" class="headerlink" title="语法"></a>语法</h2><p>介绍算法前，先讲讲语法，标准语法如下</p>
<figure class="highlight nginx"><table><tr><td class="code"><pre><span class="line"><span class="attribute">location</span> optional_modifier location_match &#123;</span><br><span class="line">    . . .</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>其中optional_modifier取下面几种可能的值</p>
<ul>
<li>(none) : 即没有optional_modifier，按照前缀进行匹配</li>
<li>= : 完全匹配</li>
<li>~ : 按照大小写敏感的正则表达式匹配</li>
<li>~* : 按照大小写不敏感的正则表达式匹配</li>
<li>^~ : 不按照正则表达式匹配，注意，这里是显式地抑制正则表达式的解析</li>
</ul>
<p>下面举例</p>
<figure class="highlight nginx"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 匹配/site /site/page/index.html /site/index.html等</span></span><br><span class="line"><span class="attribute">location</span> /site &#123;</span><br><span class="line">    . . .</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment"># 只能匹配 /site</span></span><br><span class="line"><span class="attribute">location</span> = /site &#123;</span><br><span class="line">     . . .</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment"># 可匹配/hello.jpg，但是不能匹配/hello.JPG</span></span><br><span class="line"><span class="attribute">location</span> <span class="regexp">~ \.(jpe?g|png|gif|ico)$</span> &#123;</span><br><span class="line">    . . .</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment"># 上面的大小写不敏感版本</span></span><br><span class="line"><span class="attribute">location</span> <span class="regexp">~* \.(jpe?g|png|gif|ico)$</span> &#123;</span><br><span class="line">    . . .</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment"># 能够匹配/customs/hello.html</span></span><br><span class="line"><span class="attribute">location</span><span class="regexp"> ^~</span> /customs &#123;</span><br><span class="line">    . . . </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="匹配算法"><a href="#匹配算法" class="headerlink" title="匹配算法"></a>匹配算法</h2><p>location的匹配方式和server块类似，都是找最优匹配，具体算法如下</p>
<ul>
<li>找出所有匹配URI前缀的location块，作为备选</li>
<li>检查精确匹配的项（即=修饰的项），如果有结果，则直接使用它最为最终匹配结果。否则进行下一步</li>
<li>如果没有精确项匹配，开始匹配不精确项。找出最长前缀匹配的项，按照如下规则检查<ul>
<li>若最长前缀匹配的项被^~修饰，则使用它作为结果</li>
<li>若最长前缀匹配的项未被^~修饰，则此结果会被Nginx暂存起来</li>
</ul>
</li>
<li>解析正则表达式（包含了大小写敏感和不敏感），在上面的按照最长前缀匹配的项中有任何包含正则表达式的项，则进行正则表达式匹配。一旦匹配成功，则用它作为结果</li>
<li>如果没有正则表达式匹配成功，就使用之前被暂存的匹配项作为结果</li>
</ul>
<p>注意哟：这里所说的基于前缀，意思是location指定的值和请求URI的前缀能够匹配。比如 URI 为 /customs/hello/halo时，<code>location /custom</code>、<code>location /custom/hello</code>、<code>location ~ /.*/hello</code>都是能够匹配的</p>
<p>注意哟：所谓最长前缀匹配项，即尽可能多地匹配URI。比如<code>location /custom/hello</code>相比<code>location /custom</code>，就是较长的匹配项。</p>
<p>注意哟：默认情况下，相对使用前缀，Nginx会优先使用正则表达式进行匹配。但在这里，ngin首先检查所有前缀location，从而允许我们使用=和^~修饰符来覆盖这个原则。</p>
<p>注意哟：Nginx会匹配最长最具体的location，但当一个location被当做匹配结果时，正则表达式的解析就停止了，因此location之间的相对位置也会有所影响。比如例四。</p>
<p>下面举例</p>
<p>例一：访问 /hello/hello，匹配到的是第一个。满足匹配算法第二点。</p>
<figure class="highlight nginx"><table><tr><td class="code"><pre><span class="line"><span class="attribute">location</span> = /hello/hello &#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="attribute">location</span> <span class="regexp">~* /.*/hello</span> &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>例二：访问/hello/hello，匹配到的是第二个。满足匹配算法第四点。</p>
<figure class="highlight nginx"><table><tr><td class="code"><pre><span class="line"><span class="attribute">location</span> /hello/hello &#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="attribute">location</span> <span class="regexp">~* /.*/hello</span> &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>例三：访问/custom/hello，匹配到第一个。满足匹配算法第五点。</p>
<figure class="highlight nginx"><table><tr><td class="code"><pre><span class="line"><span class="attribute">location</span> /custom/hello &#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="attribute">location</span> /custom &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>例四：访问/custom/hello，匹配到第一个。在前缀匹配长度上，他们一致，在解析正则表达式时，第一个首先被解析，符合要求，这样尽管第二个也符合要求，但此时正则表达式的解析已经停止了。</p>
<figure class="highlight nginx"><table><tr><td class="code"><pre><span class="line"><span class="attribute">location</span> <span class="regexp">~ /.*/hello</span> &#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="attribute">location</span> <span class="regexp">~ /custom/.*</span> &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>继续上例，依旧访问/custom/hello，还是匹配到第一个，原因同上。</p>
<figure class="highlight nginx"><table><tr><td class="code"><pre><span class="line"><span class="attribute">location</span> <span class="regexp">~ /custom/.*</span> &#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="attribute">location</span> <span class="regexp">~ /.*/hello</span> &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="location跳到其它location的情况"><a href="#location跳到其它location的情况" class="headerlink" title="location跳到其它location的情况"></a>location跳到其它location的情况</h2><p>一般来说，匹配到一个location后，之后的工作都会在该location下完成。但有几个特殊的场景将会重新触发location匹配。比如如下几个指令。</p>
<ul>
<li><p>index</p>
<p>index如果用来处理请求，则始终会导致重定向。如果我们将一个精确匹配的location配置为一个目录，则可能将其重定向到其它位置。比如下面的配置。</p>
<figure class="highlight nginx"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 当方位 /exact，会被重定向到/index.html，从而重定向到第二个location</span></span><br><span class="line"><span class="attribute">index</span> index.html;</span><br><span class="line"></span><br><span class="line"><span class="attribute">location</span> = /exact &#123;</span><br><span class="line">    . . .</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="attribute">location</span> / &#123;</span><br><span class="line">    . . .</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment"># 解决方案是关闭index并开启autuindex</span></span><br><span class="line"><span class="attribute">location</span> = /exact &#123;</span><br><span class="line">    <span class="attribute">index</span> nothing_will_match;</span><br><span class="line">    <span class="attribute">autoindex</span> <span class="literal">on</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>try_files</p>
<p>该指令告诉Nginx检查是否存在一组命名的文件或目录。 最后一个参数可以是Nginx将对其进行内部重定向的URI。考虑下面的例子。</p>
<figure class="highlight nginx"><table><tr><td class="code"><pre><span class="line"><span class="attribute">root</span> /var/www/main;</span><br><span class="line"><span class="attribute">location</span> / &#123;</span><br><span class="line">    <span class="attribute">try_files</span> $uri $uri.html $uri/ /fallback/index.html;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="attribute">location</span> /fallback &#123;</span><br><span class="line">    <span class="attribute">root</span> /var/www/another;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这里，如果来的请求是/balabala，则Nginx会尝试在/var/www/main下依次尝试寻找balabala、balabala.html、balabala/等文件或文件夹，如果都没有则内部重定向到/fallback/index.html。此时会匹配到第二个location块。</p>
</li>
<li><p>rewrite</p>
<p>rewrite指定将匹配的uri重写成新的uri，并重新匹配新的location。</p>
<figure class="highlight nginx"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 如果uri为/rewriteme/fallback，则重写后的uri变成/fallback，会匹配到下面那个location</span></span><br><span class="line"><span class="attribute">root</span> /var/www/main;</span><br><span class="line"><span class="attribute">location</span> / &#123;</span><br><span class="line">    <span class="attribute">rewrite</span><span class="regexp"> ^/rewriteme/(.*)$</span> /<span class="variable">$1</span> <span class="literal">last</span>;</span><br><span class="line">    <span class="attribute">try_files</span> $uri $uri.html $uri/ /fallback/index.html;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="attribute">location</span> /fallback &#123;</span><br><span class="line">    <span class="attribute">root</span> /var/www/another;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>当然在使用return指令发送301、302重定向时，也会发生类似效果，但那是标准重定向，可以看做新的请求，所以他们还是不同的。</p>
</li>
<li><p>error_page</p>
<p>error_page类似try_files形成的效果，执行的错误页面路径可能在另一个location中。</p>
<figure class="highlight nginx"><table><tr><td class="code"><pre><span class="line"><span class="attribute">root</span> /var/www/main;</span><br><span class="line"></span><br><span class="line"><span class="attribute">location</span> / &#123;</span><br><span class="line">    <span class="attribute">error_page</span> <span class="number">404</span> /another/whoops.html;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="attribute">location</span> /another &#123;</span><br><span class="line">    <span class="attribute">root</span> /var/www;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<h1 id="kubernetes-ingress"><a href="#kubernetes-ingress" class="headerlink" title="kubernetes ingress"></a>kubernetes ingress</h1><p>ingress是K8S中的概念，用于将请求路由到指定的服务，本质上是对nginx的包装。所有配置的ingress都将被转换成nginx的location块。</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">apiVersion:</span> <span class="string">networking.k8s.io/v1beta1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">Ingress</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">test-ingress</span></span><br><span class="line">  <span class="attr">annotations:</span></span><br><span class="line">    <span class="attr">nginx.ingress.kubernetes.io/use-regex:</span> <span class="string">&quot;true&quot;</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line">  <span class="attr">rules:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">host:</span> <span class="string">test.com</span></span><br><span class="line">    <span class="attr">http:</span></span><br><span class="line">      <span class="attr">paths:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="attr">path:</span> <span class="string">/foo/.*</span></span><br><span class="line">        <span class="attr">backend:</span></span><br><span class="line">          <span class="attr">serviceName:</span> <span class="string">test</span></span><br><span class="line">          <span class="attr">servicePort:</span> <span class="number">80</span></span><br></pre></td></tr></table></figure>

<p>上述配置将被翻译成如下配置</p>
<figure class="highlight nginx"><table><tr><td class="code"><pre><span class="line"><span class="attribute">location</span> <span class="regexp">~* &quot;^/foo/.*&quot;</span> &#123;</span><br><span class="line">  ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>本文比较关心的是ingress中配置的路径优先级。</p>
<p>在Nginx中，正则表达式遵循最先匹配原则，因此为了更加准确地进行匹配，在写入nginx配置前，ingress首先会根据路径的长度倒序排序，然后才写入nginx配置。</p>
<p>注意哟，注意下面这种情况此时test.com/foo/bar/bar将会匹配第一个location，而不是第二个location，因为整个ingress开启了正则表达式。当然，如果需要匹配第二个，可以将正则表达式关闭，从而设置 <code>location = /foo/bar/bar</code></p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">apiVersion:</span> <span class="string">networking.k8s.io/v1beta1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">Ingress</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">test-ingress-3</span></span><br><span class="line">  <span class="attr">annotations:</span></span><br><span class="line">    <span class="attr">nginx.ingress.kubernetes.io/use-regex:</span> <span class="string">&quot;true&quot;</span>  <span class="comment"># 注意这里</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line">  <span class="attr">rules:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">host:</span> <span class="string">test.com</span></span><br><span class="line">    <span class="attr">http:</span></span><br><span class="line">      <span class="attr">paths:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="attr">path:</span> <span class="string">/foo/bar/bar</span></span><br><span class="line">        <span class="attr">backend:</span></span><br><span class="line">          <span class="attr">serviceName:</span> <span class="string">test</span></span><br><span class="line">          <span class="attr">servicePort:</span> <span class="number">80</span></span><br><span class="line">      <span class="bullet">-</span> <span class="attr">path:</span> <span class="string">/foo/bar/[A-Z0-9]&#123;3&#125;</span></span><br><span class="line">        <span class="attr">backend:</span></span><br><span class="line">          <span class="attr">serviceName:</span> <span class="string">test</span></span><br><span class="line">          <span class="attr">servicePort:</span> <span class="number">80</span></span><br></pre></td></tr></table></figure>

<p>将会被翻译成</p>
<figure class="highlight nginx"><table><tr><td class="code"><pre><span class="line"><span class="attribute">location</span> <span class="regexp">~* &quot;^/foo/bar/[A-Z0-9]</span>&#123;3&#125;&quot; &#123;</span><br><span class="line">  ...</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="attribute">location</span> <span class="regexp">~* &quot;^/foo/bar/bar&quot;</span> &#123;</span><br><span class="line">  ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>详细了解nignx这些特性，在做网站或接口配置时非常有用。比如有如下需求。</p>
<p>在我开发的项目中，大多数接口均以/admin打头，但只有一个接口以/swagger开头，现在出于需要，我要将项目配置到 <a href="http://www.example.com/abc/admin%E4%B8%8B%E3%80%82">www.example.com/abc/admin下。</a></p>
<ul>
<li><p>在详细了解Nginx配置之前，我的解决方案如下</p>
<p>将接口的admin前缀去除，然后将location为/abc/admin/下的请求转发给我的服务。</p>
<figure class="highlight nginx"><table><tr><td class="code"><pre><span class="line"><span class="attribute">location</span> /abc/admin/ &#123;</span><br><span class="line">    <span class="attribute">proxy_pass</span> http://127.0.0.1:19898/;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>熟悉后，我可以在不改动原来前缀的基础上进行修改。这样看来，上面的操作相当于把Nginx的开发转移到了业务代码中，非常的不好。</p>
<figure class="highlight nginx"><table><tr><td class="code"><pre><span class="line"><span class="attribute">location</span> /abc/admin/ &#123;</span><br><span class="line">    <span class="attribute">proxy_pass</span> http://127.0.0.1:19898/admin/;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="attribute">location</span> /abc/admin/swagger/ &#123;</span><br><span class="line">    <span class="attribute">proxy_pass</span> http://127.0.0.1:19898/swagger/;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<h1 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h1><ol>
<li><a href="https://www.digitalocean.com/community/tutorials/understanding-nginx-server-and-location-block-selection-algorithms">Understanding Nginx Server and Location Block Selection Algorithms</a></li>
<li><a href="https://kubernetes.github.io/ingress-nginx/user-guide/ingress-path-matching/#path-priority">Kubernetes Ingress Path Matching</a></li>
<li><a href="https://www.nginx.com/resources/wiki/start/">Nginx官方手册</a></li>
</ol>
]]></content>
      <categories>
        <category>运维</category>
      </categories>
      <tags>
        <tag>Nginx</tag>
      </tags>
  </entry>
  <entry>
    <title>推荐系统-基于用户行为数据的推荐</title>
    <url>/2019/09/13/%E6%8E%A8%E8%8D%90%E7%B3%BB%E7%BB%9F-%E5%9F%BA%E4%BA%8E%E7%94%A8%E6%88%B7%E8%A1%8C%E4%B8%BA%E6%95%B0%E6%8D%AE%E7%9A%84%E6%8E%A8%E8%8D%90-%E6%8E%A8%E8%8D%90%E7%B3%BB%E7%BB%9F-%E5%9F%BA%E4%BA%8E%E7%94%A8%E6%88%B7%E8%A1%8C%E4%B8%BA%E6%95%B0%E6%8D%AE%E7%9A%84%E6%8E%A8%E8%8D%90/</url>
    <content><![CDATA[<h1 id="基于用户行为的理由"><a href="#基于用户行为的理由" class="headerlink" title="基于用户行为的理由"></a>基于用户行为的理由</h1><h2 id="让用户直接说不就好了吗"><a href="#让用户直接说不就好了吗" class="headerlink" title="让用户直接说不就好了吗"></a>让用户直接说不就好了吗</h2><p>本文标题是利用用户的数据行为, 是根据用户的实际动作进行演算的方法, 那为什么不利用用户语言进行演算呢? 最大的原因就是用户也说不清楚自己到底喜欢什么, 而用户的实际行为往往能够暴露其真实想法, 有些想法用户自己可能都还没有意识到.</p>
<span id="more"></span>

<h2 id="经典的例子-尿布和啤酒"><a href="#经典的例子-尿布和啤酒" class="headerlink" title="经典的例子 - 尿布和啤酒"></a>经典的例子 - 尿布和啤酒</h2><p>一个数据挖掘的经典案例: 一个超市人员发现很多人会同时购买啤酒和尿布, 后来他们认为这是因为很多妇女要在家照顾孩子, 就让自己的丈夫去买尿布, 而丈夫买尿布时还不忘买一下自己喜欢的啤酒, 于是二者产生了联系. 然后超市将这两个商品摆在临近的货架上, 发现销售量增长了.</p>
<p>从中可以看到用户的行为数据中蕴含了很多不是那么显而易见的规律, 而我么的个性化推荐算法的任务就是通过计算机去发现这些规律, 从而为产品的设计提供指导, 提升用户体验.</p>
<h1 id="协同过滤"><a href="#协同过滤" class="headerlink" title="协同过滤"></a>协同过滤</h1><p>协同过滤算法就是指用户可以齐心协力, 通过不断与网站互动, 使自己的推荐列表能够不断过滤掉不感兴趣的物品, 变得越来越个性化, 这也和亚马逊的为每个用户打造一个属于自己的商店的思想不谋而合.</p>
<p>仅基于用户行为数据设计的推荐算法称为协同过滤算法. 在学术界对这方面有深入的研究, 提出来多种方法, 比如基于邻域的算法, 隐语义模型, 基于图的随机游走算法等. 本文仅介绍两种基于邻域的算法.</p>
<ul>
<li>基于用户的协同过滤算法</li>
<li>基于物品的协同过滤算法</li>
</ul>
<h1 id="收集用户的行为"><a href="#收集用户的行为" class="headerlink" title="收集用户的行为"></a>收集用户的行为</h1><p>有多种方式收集用户的行为</p>
<ul>
<li>打日志</li>
<li>收集用户都商品的喜好程度</li>
<li>记录用户所有访问记录等</li>
</ul>
<p>在设计算法前, 需要对收集到的数据进行分析.</p>
<h1 id="基于用户的协同过滤算法"><a href="#基于用户的协同过滤算法" class="headerlink" title="基于用户的协同过滤算法"></a>基于用户的协同过滤算法</h1><p>基于用户的协同过滤算法主要包含如下两个步骤</p>
<ul>
<li>找到和目标用户相似的用户集合</li>
<li>找到这个用户集合中用户喜欢的, 且目标用户没有听说过的物品推荐给用户</li>
</ul>
<p>即先找同类用户, 再找同类用户喜欢的商品</p>
<h2 id="用户相似度的计算"><a href="#用户相似度的计算" class="headerlink" title="用户相似度的计算"></a>用户相似度的计算</h2><p>该算法的难点在于寻找相似的用户集合, 意味着需要对每一个目标用户意外的用户和目标用户进行相似度计算, 取最高的那一部分, 最常规的方法是使用余弦相似度进行计算. 但这样会造成某些用户与目标用户原本一点关系都没有还需要计算一次的浪费. </p>
<p>为了解决这个问题, 可以在物品中添加用户id的冗余数据, 通过对所有物品的用户id组件稀疏矩阵, 只针对有联系的用户进行计算.</p>
<h2 id="目标用户对某一物品感兴趣程度的计算"><a href="#目标用户对某一物品感兴趣程度的计算" class="headerlink" title="目标用户对某一物品感兴趣程度的计算"></a>目标用户对某一物品感兴趣程度的计算</h2><p>就是所有与目标用户相似的用户对该目标物品感兴趣的程度的累加. 即越多相似用户喜欢目标物品, 则用户可能越感兴趣</p>
<h2 id="热门商品的处理"><a href="#热门商品的处理" class="headerlink" title="热门商品的处理"></a>热门商品的处理</h2><p>算到最后会发现, 所有用户都看过或喜欢热门商品, 但目标用户不一定喜欢该热门商品. 比如所有人都买过新华字典, 但这并不能说明他们兴趣相似, 所以推荐新华字典并不是一个好的选择. 换句话说, 两个用户对冷门物品采取过同样的行为更能说明他们的兴趣相似度. 因此计算时应该去除或将其热门商品的权重.</p>
<h1 id="基于物品的协同过滤算法"><a href="#基于物品的协同过滤算法" class="headerlink" title="基于物品的协同过滤算法"></a>基于物品的协同过滤算法</h1><p>该算法是目前业界使用最多的算法. 无论是亚马逊, 还是Netflix, Youtube, 其推荐算法的基础都是该算法.</p>
<h2 id="基于用户的协同过滤算法的问题"><a href="#基于用户的协同过滤算法的问题" class="headerlink" title="基于用户的协同过滤算法的问题"></a>基于用户的协同过滤算法的问题</h2><p>随着用户的增长, 用户相似度矩阵会呈平方增长, 而当今互联网用户量及其庞大, 因此带来了用户相似度计算的浪费.</p>
<p>针对这个问题, 亚马逊提出了基于物品的协同过滤算法. 它主要通过分析用户的行为记录计算物品之间的相似度.</p>
<h2 id="基于物品的协同过滤算法-1"><a href="#基于物品的协同过滤算法-1" class="headerlink" title="基于物品的协同过滤算法"></a>基于物品的协同过滤算法</h2><p>该算法主要分为两步</p>
<ul>
<li>计算物品之间的相似度</li>
<li>根据物品相似度和用户的历史行为给用户生成推荐列表</li>
</ul>
<h2 id="物品相似度计算"><a href="#物品相似度计算" class="headerlink" title="物品相似度计算"></a>物品相似度计算</h2><p>物品i和物品j的相似度, 可以用: 喜欢i的用户中, 喜欢j的用户所占比例 进行计算. 可以想见. 物品相似度的计算, 就是计算物品被很多用户共同喜欢的程度. </p>
<p>是根据用户对物品的历史记录进行计算, 即一个用户对应购买过的多个物品. 这一点恰好和基于用户的协同算法想法( 它是一个物品存储购买过它的用户冗余数据 )</p>
<h2 id="生成推荐列表"><a href="#生成推荐列表" class="headerlink" title="生成推荐列表"></a>生成推荐列表</h2><p>计算出物品相似度, 从高到低排列, 剔除用户购买历史, 即为推荐列表.</p>
<h2 id="去除活跃用户的影响"><a href="#去除活跃用户的影响" class="headerlink" title="去除活跃用户的影响"></a>去除活跃用户的影响</h2><p>活跃用户会造成任何两个物品都存在相似度, 于是物品相似矩阵编程稠密矩阵, 浪费大量的算力. 一个例子就是如果某个书店在当当购买了所有书籍, 把它当成一个常规用户的话, 显然当当的所有书都有一定的相似度了, 显然这是不对的. 因此计算中需要考虑去除活跃用户的影响.</p>
<h1 id="两种领域算法的对比"><a href="#两种领域算法的对比" class="headerlink" title="两种领域算法的对比"></a>两种领域算法的对比</h1><table>
<thead>
<tr>
<th>项目</th>
<th>基于用户的协同过滤算法</th>
<th>基于物品的协同过滤算法</th>
</tr>
</thead>
<tbody><tr>
<td>性能</td>
<td>适用于用户较少场合, 用户过多造成计算用户相似度矩阵过大</td>
<td>适用于物品数量明显小于用户数的场合, 物品过多会造成物品相似度矩阵过大</td>
</tr>
<tr>
<td>场景</td>
<td>时效性较强, 但用户个性化不太明显的场合</td>
<td>长尾物品丰富, 用户个性化需求强烈的领域</td>
</tr>
<tr>
<td>实时性</td>
<td>用户新行为不一定造成推荐结果立即变化</td>
<td>用户新行为一定造成结果立即变化</td>
</tr>
<tr>
<td>冷启动</td>
<td>新用户对很少物品产生行为时, 不能立即进行个性化推荐; 新物品上线后只要有行为就能被推荐给兴趣相似的用户</td>
<td>相反, 这里新用户只要有一个行为就可以推荐; 新物品上线后要有足够的访问量才能被推荐出去</td>
</tr>
<tr>
<td>推荐解释</td>
<td>难以提供给用户信服的推荐理由</td>
<td>利用用户的历史行为做推荐解释, 比较令人信服</td>
</tr>
</tbody></table>
<h1 id="说明"><a href="#说明" class="headerlink" title="说明"></a>说明</h1><p>本文是基础介绍性质的文章, 为能够快速阅读, 并没有任何公式运算, 上述所讲述算法也仅是基本思想, 带大家认识推荐算法. 具体算法需要参考更多文章和书籍.</p>
]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>推荐</tag>
      </tags>
  </entry>
  <entry>
    <title>理解UUID（们）</title>
    <url>/2021/09/30/%E7%90%86%E8%A7%A3UUID%EF%BC%88%E4%BB%AC%EF%BC%89-li-jie-uuid-men-/</url>
    <content><![CDATA[<p>UUID，Universal Unique Identifier，全局唯一标识符。也叫做GUID，Global Unique Identifier。</p>
<p>概念都了解，全局唯一嘛，但怎么实现的？多大概率重复？JDK的UUID和PostgreSQL的UUID一样吗？带着这些问题，我们从RFC，到JDK源码、PG手册，一点点看。</p>
<p>本文包含以下内容：</p>
<ul>
<li>UUID实现原理</li>
<li>自己实现一个UUID</li>
<li>JDK的实现方式</li>
<li>PG的实现方式</li>
<li>其它全局唯一ID</li>
</ul>
<h2 id="实现原理"><a href="#实现原理" class="headerlink" title="实现原理"></a>实现原理</h2><p>老样子，要想了解一项基础技术，最好的方式是阅读一手资料。于UUID，它是<a href="https://www.rfc-editor.org/rfc/pdfrfc/rfc4122.txt.pdf">RFC4122</a>。</p>
<p>这一节，更莫如说是对RFC的总结，毕竟规范这东西，写得太啰嗦了，全文字不说，还没有示意图。</p>
<h3 id="基本特性"><a href="#基本特性" class="headerlink" title="基本特性"></a>基本特性</h3><ul>
<li>长度128个bit位。一般通过16位十六进制字符表示，如：4cc9de16-414b-4f68-9b7e-6feeb8f629b0</li>
<li>不需要中心管理，具有跨越时间和空间的唯一性</li>
<li>按照本标准中的算法，支持每台机器每秒高达1000万次高分配速率</li>
</ul>
<h3 id="组成"><a href="#组成" class="headerlink" title="组成"></a>组成</h3><p>理解UUID有两个重点：一是理解其组成部分；二是理解各版本对各部分的填充方式。我们先看最重要的——组成部分。</p>
<p>为了较为形象地展示，我画了张图。第一行是结果，第二行是十六进制说明，第三行是二进制说明。</p>
<p><img src="https://gdz.oss-cn-shenzhen.aliyuncs.com/local/image-20210930084244949.png" alt="image-20210930084244949"></p>
<ul>
<li>time-low：时间戳低位，占用32个bit</li>
<li>time-mid：时间戳中位，占用16个bit</li>
<li>time-high-and-version：时间戳高位+版本号，前者占12个bit，后者占4个bit，注意区分版本号是在前的</li>
<li>clock-seq-high-and-reserved：时钟序列高位+预留位。前者占6个bit，后者占2个bit，也注意他们的前后顺序</li>
<li>clock-seq-low：时间序列低位，占8个bit</li>
<li>node：节点，占用48个bit</li>
</ul>
<p>引出新概念，time、clock-seq、node</p>
<ul>
<li>time：即时间戳</li>
<li>clock-seq：当时间戳或node重复时，使用clock-seq作为附加保证唯一性</li>
<li>node：机器的节点，一般是机器的MAC地址</li>
</ul>
<h3 id="区分版本"><a href="#区分版本" class="headerlink" title="区分版本"></a>区分版本</h3><p>注意到上面说组成时，有一个version字段。UUID是有多个版本的，目前总计5个。</p>
<p>版本规定了各字段的填充方式，版本2比较特殊这里忽略，其它版本如下</p>
<table>
<thead>
<tr>
<th>版本</th>
<th>Timestamp</th>
<th>Clock sequence</th>
<th>node</th>
</tr>
</thead>
<tbody><tr>
<td>1</td>
<td>从UTC时间1582-10-15 00:00:00起，100ns的个数</td>
<td>第一个clock sequence应该是随机产生的<br />如果知道本机上一次生成UUID的clock sequence，则此次只需要在其基础上加一<br /> 如果不知道，该字段需要设置成一个随机数</td>
<td>MAC地址 如果没有，则使用随机数</td>
</tr>
<tr>
<td>3</td>
<td>命名空间+名称的MD5只的一部分</td>
<td>命名空间+名称的MD5只的一部分</td>
<td>命名空间+名称的MD5只的一部分</td>
</tr>
<tr>
<td>4</td>
<td>随机数的一部分</td>
<td>随机数的一部分</td>
<td>随机数的一部分</td>
</tr>
<tr>
<td>5</td>
<td>命名空间+名称的SHA1只的一部分</td>
<td>命名空间+名称的SHA1只的一部分</td>
<td>命名空间+名称的SHA1只的一部分</td>
</tr>
</tbody></table>
<p>可以看到，所谓的时间戳、时钟序列、node这些字段，仅对版本1有效，其它版本填充进去的值并无逻辑意义。</p>
<h3 id="如何保证唯一性"><a href="#如何保证唯一性" class="headerlink" title="如何保证唯一性"></a>如何保证唯一性</h3><ul>
<li>对Version 1：它通过MAC地址保证空间唯一性，时间戳+序列号保证时间唯一性</li>
<li>对Version 2：和Version 1类似，只不过会把时间戳的前4位置换为POSIX的UID或GID</li>
<li>对Version 3、5：它纯依赖于名字保证唯一性，这就需要一个规整的命名系统：命名空间+名称</li>
<li>对Version 4：它纯通过随机数保证唯一性，此时一个高质量的随机数发生器就显得尤为重要</li>
</ul>
<h3 id="Version-1生成逻辑"><a href="#Version-1生成逻辑" class="headerlink" title="Version 1生成逻辑"></a>Version 1生成逻辑</h3><ol>
<li><p>获取一个系统级别的全局时钟</p>
</li>
<li><p>从一个系统全局共享的的存储位置，读取上一个UUID的状态：时间戳、始终序列、node等</p>
</li>
<li><p>获取当前时间戳：从UTC时间1582-10-15 00:00:00起，100ns的个数</p>
</li>
<li><p>获取nodeid，即MAC地址</p>
</li>
<li><p>如果上一个UUID状态不稳定（不存在、nodeid与新获取的nodeid不一样），生成一个随机clock value</p>
</li>
<li><p>如果状态存在，但时间戳比当前时间戳还晚，则clock sequence自增</p>
</li>
<li><p>将新的状态保存</p>
</li>
<li><p>将上面的三个部分按照格式组成UUID</p>
</li>
</ol>
<p><strong>有一个bug</strong></p>
<p>MAC地址直接放在nodeid中，就是一个bug，这会暴露用户的MAC地址：梅丽莎病毒制作者的位置就是这么暴露的</p>
<h3 id="Version-4生成逻辑"><a href="#Version-4生成逻辑" class="headerlink" title="Version 4生成逻辑"></a>Version 4生成逻辑</h3><ol>
<li>获取一个随机数</li>
<li>将预留位、版本位之外的位，使用该随机数填充，填充位对应方式，参考RFC</li>
</ol>
<h3 id="Version-3、5生成逻辑"><a href="#Version-3、5生成逻辑" class="headerlink" title="Version 3、5生成逻辑"></a>Version 3、5生成逻辑</h3><ol>
<li>命名空间+名字组成字符串，使用MD5或者SHA1计算摘要</li>
<li>将预留位、版本位之外的位，使用该摘要填充，填充位对应方式，参考RFC</li>
</ol>
<h3 id="为什么时间戳从1582-10-15开始"><a href="#为什么时间戳从1582-10-15开始" class="headerlink" title="为什么时间戳从1582-10-15开始"></a>为什么时间戳从1582-10-15开始</h3><p>这是公历改革到基督教日历的日期，说来话长，我也没啥兴趣去详细了解，如果需要，<a href="https://www.zhihu.com/question/300868434">看看知乎吧</a></p>
<h2 id="自己写一个UUID吧"><a href="#自己写一个UUID吧" class="headerlink" title="自己写一个UUID吧"></a>自己写一个UUID吧</h2><p>尝试着实现了一下抽象定义和基于时间戳的版本，发现主要有几个难点：kotlin的进制转换、二进制操作等。</p>
<p>这是一个不能实际使用的UUID版本（实现它也不是本文的目的），仅作演示。</p>
<p>先是UUID的抽象定义，我们使用两个Long作为底层bit持有对象，定义各字段的set方法，主要是二进制操作。</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">UUID</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">companion</span> <span class="keyword">object</span> &#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">const</span> <span class="keyword">val</span> TIME_LOW_MASK = (<span class="number">0xFFFFFFFFL</span>).shl(<span class="number">32</span>)</span><br><span class="line">        <span class="keyword">const</span> <span class="keyword">val</span> TIME_MID_MASK = (<span class="number">0xFFFFFFFFL</span>).shl(<span class="number">16</span>)</span><br><span class="line">        <span class="keyword">const</span> <span class="keyword">val</span> VERSION_MASK = (<span class="number">0xFFL</span>).shl(<span class="number">12</span>)</span><br><span class="line">        <span class="keyword">const</span> <span class="keyword">val</span> TIME_HIGH_MASK = <span class="number">0xFFFFFFL</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">const</span> <span class="keyword">val</span> RESERVED_MASK = (<span class="number">0xFL</span>).shl(<span class="number">62</span>)</span><br><span class="line">        <span class="keyword">const</span> <span class="keyword">val</span> CLOCK_SEQ_HIGH_MASK = (<span class="number">0xFFFL</span>).shl(<span class="number">56</span>)</span><br><span class="line">        <span class="keyword">const</span> <span class="keyword">val</span> CLOCK_SEQ_LOW_MASK = (<span class="number">0xFFFFL</span>).shl(<span class="number">48</span>)</span><br><span class="line">        <span class="keyword">const</span> <span class="keyword">val</span> NODE_MASK = <span class="number">0xFFFFFFFFFFFFL</span></span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">fun</span> <span class="title">timeBasedUUID</span><span class="params">()</span></span>: UUID = UUIDVersion1()</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 高有效位们：靠右</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">var</span> mostSignificantBits = <span class="number">0L</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 低有效位：靠左</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">var</span> leastSignificantBits = <span class="number">0L</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">setTimeLow</span><span class="params">(timeLow: <span class="type">Int</span>)</span></span> &#123;</span><br><span class="line">        leastSignificantBits = leastSignificantBits.or(timeLow.toLong().shl(<span class="number">32</span>).and(TIME_LOW_MASK))</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">setTimeMid</span><span class="params">(timeMid: <span class="type">Int</span>)</span></span> &#123;</span><br><span class="line">        leastSignificantBits = leastSignificantBits.or(timeMid.toLong().shl(<span class="number">16</span>).and(TIME_MID_MASK))</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">setVersion</span><span class="params">(version: <span class="type">Int</span>)</span></span> &#123;</span><br><span class="line">        leastSignificantBits = leastSignificantBits.or(version.toLong().shl(<span class="number">12</span>).and(VERSION_MASK))</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">setTimeHigh</span><span class="params">(timeHigh: <span class="type">Int</span>)</span></span> &#123;</span><br><span class="line">        leastSignificantBits = leastSignificantBits.or(timeHigh.toLong().and(TIME_HIGH_MASK))</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">setReserved</span><span class="params">(reserved: <span class="type">Int</span>)</span></span> &#123;</span><br><span class="line">        mostSignificantBits = mostSignificantBits.or(reserved.toLong().shl(<span class="number">62</span>).and(RESERVED_MASK))</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">setClockSeqHigh</span><span class="params">(clockSeqHigh: <span class="type">Int</span>)</span></span> &#123;</span><br><span class="line">        mostSignificantBits = mostSignificantBits.or(clockSeqHigh.toLong().shl(<span class="number">56</span>).and(CLOCK_SEQ_HIGH_MASK))</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">setClockSeqLow</span><span class="params">(clockSeqLow: <span class="type">Int</span>)</span></span> &#123;</span><br><span class="line">        mostSignificantBits = mostSignificantBits.or(clockSeqLow.toLong().shl(<span class="number">48</span>).and(CLOCK_SEQ_LOW_MASK))</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">setNode</span><span class="params">(nodeId: <span class="type">Int</span>)</span></span> &#123;</span><br><span class="line">        mostSignificantBits = mostSignificantBits.or(nodeId.toLong().and(NODE_MASK))</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">toString</span><span class="params">()</span></span>: String &#123;</span><br><span class="line">        <span class="keyword">val</span> lsbString = leastSignificantBits.toHexString()</span><br><span class="line">        <span class="keyword">val</span> msgString = mostSignificantBits.toHexString()</span><br><span class="line"></span><br><span class="line">        <span class="keyword">val</span> seg1 = lsbString.substring(<span class="number">0</span>, <span class="number">8</span>)</span><br><span class="line">        <span class="keyword">val</span> seg2 = lsbString.substring(<span class="number">8</span>, <span class="number">12</span>)</span><br><span class="line">        <span class="keyword">val</span> seg3 = lsbString.substring(<span class="number">12</span>, <span class="number">16</span>)</span><br><span class="line">        <span class="keyword">val</span> seg4 = msgString.substring(<span class="number">0</span>, <span class="number">4</span>)</span><br><span class="line">        <span class="keyword">val</span> seg5 = msgString.substring(<span class="number">4</span>, <span class="number">16</span>)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;<span class="variable">$seg1</span>-<span class="variable">$seg2</span>-<span class="variable">$seg3</span>-<span class="variable">$seg4</span>-<span class="variable">$seg5</span>&quot;</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>然后是一个粗糙的实现类，实现Version 1</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">UUIDVersion1</span> : <span class="type">UUID</span></span>() &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">init</span> &#123;</span><br><span class="line">        <span class="comment">// 计算time</span></span><br><span class="line">        <span class="keyword">val</span> start = LocalDateTime.of(<span class="number">1582</span>, <span class="number">10</span>, <span class="number">15</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">val</span> end = LocalDateTime.now(ZoneId.of(<span class="string">&quot;UTC&quot;</span>))</span><br><span class="line">        <span class="keyword">val</span> duration = Duration.between(start, end)</span><br><span class="line">        <span class="keyword">val</span> time = duration.toMillis() * <span class="number">10</span></span><br><span class="line">        <span class="comment">// 计算clock seq</span></span><br><span class="line">        <span class="keyword">val</span> clock = <span class="number">0</span></span><br><span class="line">        <span class="comment">// 获取node，我们用随机数替换</span></span><br><span class="line">        <span class="keyword">val</span> node = Random.nextInt()</span><br><span class="line"></span><br><span class="line">        <span class="keyword">this</span>.setTimeLow(time.toInt())</span><br><span class="line">        <span class="keyword">this</span>.setTimeMid(time.shr(<span class="number">32</span>).toInt())</span><br><span class="line">        <span class="keyword">this</span>.setTimeHigh(time.shr(<span class="number">48</span>).toInt())</span><br><span class="line"></span><br><span class="line">        <span class="keyword">this</span>.setClockSeqHigh(clock.shr(<span class="number">8</span>))</span><br><span class="line">        <span class="keyword">this</span>.setClockSeqLow(clock)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">this</span>.setNode(node)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">this</span>.setVersion(<span class="number">0b001</span>)</span><br><span class="line">        <span class="keyword">this</span>.setReserved(<span class="number">0b10</span>)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>我们还可以将生成的UUID转换为JDK的UUID进行验证。</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">val</span> uuidString = UUID.timeBasedUUID().toString()</span><br><span class="line">    println(uuidString)</span><br><span class="line">    <span class="keyword">val</span> uuid = java.util.UUID.fromString(uuidString)</span><br><span class="line">    println(uuid.version())</span><br><span class="line">    println(uuid.variant())</span><br><span class="line">    println(uuid.timestamp())</span><br><span class="line">    println(uuid.clockSequence())</span><br><span class="line">    println(uuid.node())</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>能够得到如下输出</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">51d8c022-7dfc-1000-8000-ffffd963e9ed</span><br><span class="line">1</span><br><span class="line">2</span><br><span class="line">138522658390050</span><br><span class="line">0</span><br><span class="line">281474328947181</span><br></pre></td></tr></table></figure>

<blockquote>
<p>仔细想想，这个时间戳也不一定要从1580年开始，也可以换成自定义的时间戳，完全看需求。</p>
</blockquote>
<h2 id="JDK-UUID"><a href="#JDK-UUID" class="headerlink" title="JDK UUID"></a>JDK UUID</h2><p>JDK只提供Version 3和Version 4两种UUID，实现上也超级简单。</p>
<p>类似地，它也用两个long来组成128位，构建时直接分配位即可</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">  * The most significant 64 bits of this UUID.</span></span><br><span class="line"><span class="comment">  *</span></span><br><span class="line"><span class="comment">  * @serial</span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">long</span> mostSigBits;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">  * The least significant 64 bits of this UUID.</span></span><br><span class="line"><span class="comment">  *</span></span><br><span class="line"><span class="comment">  * @serial</span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">long</span> leastSigBits;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="title">UUID</span><span class="params">(<span class="keyword">byte</span>[] data)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">long</span> msb = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">long</span> lsb = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">assert</span> data.length == <span class="number">16</span> : <span class="string">&quot;data must be 16 bytes in length&quot;</span>;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;<span class="number">8</span>; i++)</span><br><span class="line">    msb = (msb &lt;&lt; <span class="number">8</span>) | (data[i] &amp; <span class="number">0xff</span>);</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">8</span>; i&lt;<span class="number">16</span>; i++)</span><br><span class="line">    lsb = (lsb &lt;&lt; <span class="number">8</span>) | (data[i] &amp; <span class="number">0xff</span>);</span><br><span class="line">  <span class="keyword">this</span>.mostSigBits = msb;</span><br><span class="line">  <span class="keyword">this</span>.leastSigBits = lsb;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="Version-4"><a href="#Version-4" class="headerlink" title="Version 4"></a>Version 4</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> UUID <span class="title">randomUUID</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  SecureRandom ng = Holder.numberGenerator;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">byte</span>[] randomBytes = <span class="keyword">new</span> <span class="keyword">byte</span>[<span class="number">16</span>];</span><br><span class="line">  ng.nextBytes(randomBytes);</span><br><span class="line">  randomBytes[<span class="number">6</span>]  &amp;= <span class="number">0x0f</span>;  <span class="comment">/* clear version        */</span></span><br><span class="line">  randomBytes[<span class="number">6</span>]  |= <span class="number">0x40</span>;  <span class="comment">/* set to version 4     */</span></span><br><span class="line">  randomBytes[<span class="number">8</span>]  &amp;= <span class="number">0x3f</span>;  <span class="comment">/* clear variant        */</span></span><br><span class="line">  randomBytes[<span class="number">8</span>]  |= <span class="number">0x80</span>;  <span class="comment">/* set to IETF variant  */</span></span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> UUID(randomBytes);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>可以看到，重点其实在Holder.numberGenerator，它的随机性决定了UUID的重复概率。而其实现SecureRandom，则涉及到另一个知识点——随机数，我们这里挖个坑，后面再探究随机数生成器到底有多随机。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Holder</span> </span>&#123;</span><br><span class="line">  <span class="keyword">static</span> <span class="keyword">final</span> SecureRandom numberGenerator = <span class="keyword">new</span> SecureRandom();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="Version-3"><a href="#Version-3" class="headerlink" title="Version 3"></a>Version 3</h3><figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> static UUID nameUUIDFromBytes(byte[] name) &#123;</span><br><span class="line">  MessageDigest md;</span><br><span class="line">  <span class="keyword">try</span> &#123;</span><br><span class="line">    md = MessageDigest.getInstance(<span class="string">&quot;MD5&quot;</span>);</span><br><span class="line">  &#125; <span class="keyword">catch</span> (NoSuchAlgorithmException nsae) &#123;</span><br><span class="line">    <span class="keyword">throw</span> new InternalError(<span class="string">&quot;MD5 not supported&quot;</span>, nsae);</span><br><span class="line">  &#125;</span><br><span class="line">  byte[] md5Bytes = md.digest(name);</span><br><span class="line">  md5Bytes[<span class="number">6</span>]  &amp;= <span class="number">0x0f</span>;  <span class="comment">/* clear version        */</span></span><br><span class="line">  md5Bytes[<span class="number">6</span>]  |= <span class="number">0x30</span>;  <span class="comment">/* set to version 3     */</span></span><br><span class="line">  md5Bytes[<span class="number">8</span>]  &amp;= <span class="number">0x3f</span>;  <span class="comment">/* clear variant        */</span></span><br><span class="line">  md5Bytes[<span class="number">8</span>]  |= <span class="number">0x80</span>;  <span class="comment">/* set to IETF variant  */</span></span><br><span class="line">  <span class="keyword">return</span> new UUID(md5Bytes);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这个更简单，做一下MD5，修改相应的bit填入即可，它的唯一性就完全依赖于传入的name了。</p>
<h2 id="PostgreSQL的UUID"><a href="#PostgreSQL的UUID" class="headerlink" title="PostgreSQL的UUID"></a>PostgreSQL的UUID</h2><p>根据<a href="https://www.postgresql.org/docs/current/functions-uuid.html">手册</a>描述，PG的UUID也是Version 4，即基于随机数生成。</p>
<h2 id="UUID重复的概率"><a href="#UUID重复的概率" class="headerlink" title="UUID重复的概率"></a>UUID重复的概率</h2><p>就是个好奇，我们能够大致算一算，UUID重复的概率有多大，其实可以归结如下。</p>
<ul>
<li><p>对基于时间戳的情况，node稳定时，多个节点不可能重复，而单个节点，由于有记录上一个UUID的状态，因此也不会重复。只不过有生成速率限制，以RFC的方式来说，每个节点每100ns，最多能够生成2^14=16384个UUID，换算成秒，即每秒1.6亿个。</p>
</li>
<li><p>基于随机数的情况，取决于随机数生成器的质量</p>
</li>
<li><p>基于名字的情况，取决于命名系统，这种情况UUID只是命名系统的延伸，应该说不会考虑UUID重复的情况，而是命名系统本身的性能</p>
</li>
<li><p>128bit空间本身是否可能重复呢？用尽了就会，不过这个概率，类似流星撞地球吧。</p>
</li>
</ul>
<h2 id="其它全局唯一ID"><a href="#其它全局唯一ID" class="headerlink" title="其它全局唯一ID"></a>其它全局唯一ID</h2><p>最为大家熟知的恐怕就是雪花算法了吧，此外号段模式也算一个。</p>
<h3 id="雪花算法（SnkwFlake）"><a href="#雪花算法（SnkwFlake）" class="headerlink" title="雪花算法（SnkwFlake）"></a>雪花算法（SnkwFlake）</h3><p>了解了UUID Version 1的生成方式后，雪花算法就很容易理解，也是由时间戳-机器id-序列号组成，不同的是其只需要64个bit。且各字段可以根据实际需求调整bit的个数。雪花算法只是一种思想：将各位打散，再赋予不同的用途。UUID Version 1也是这种思想。</p>
<p><img src="https://gdz.oss-cn-shenzhen.aliyuncs.com/local/image-20210930142313559.png" alt="image-20210930142313559"></p>
<p><strong>几个需要考虑的问题</strong></p>
<ul>
<li>时钟回拨问题：常见的方式是容忍小范围回拨，即如果当前时间戳比上一个生成的时间戳早，且在一定范围内，则依旧使用上一次的时间戳。这算一种校准方式，即回拨的这个时间差会被算到上一个时间戳的序列中，随着时间的推移，时间回拨问题会被抹平，但这段期间的生成效率会降低。</li>
<li>机器ID的生成方式：机器ID必须是稳定的，常见的解决方式是融合MAC地址。</li>
</ul>
<p><strong>雪花算法和UUID差别</strong></p>
<p>雪花算法得到的id依旧是64位，就是一个long，且时间戳在高位，是有序递增的。有序性，往往很重要。</p>
<p><strong>一些雪花算法的实现</strong></p>
<ul>
<li><p>百度UidGenerator</p>
<p>它解决时钟回拨的方式，是不容忍任何回拨，直接报错</p>
</li>
<li><p>美团Leaf</p>
<p>可选基于雪花算法或基于号段模式两种方案。其中使用雪花算法时，依赖于Zookeeper来分配WorkerID</p>
<p>它解决时钟回拨问题，和上面我们说的类似</p>
</li>
</ul>
<h3 id="号段模式"><a href="#号段模式" class="headerlink" title="号段模式"></a>号段模式</h3><p>这并不是什么算法，而是一种数据库自增ID的用法，一次取一批ID，用完了再取，保证了唯一性，降低了数据库的访问频率。</p>
<h2 id="分布式ID的选择"><a href="#分布式ID的选择" class="headerlink" title="分布式ID的选择"></a>分布式ID的选择</h2><p>你看，我们已经了解了最重要的全局唯一ID生成方式，那就可以讨论这个问题：分布式ID应该用哪种呢？</p>
<p>UUID优点在于生成简单，唯一性好，几乎所有语言都有标准实现。缺点在于长度过长、不具有单调性，且无意义。</p>
<p>雪花算法优点在于具有单调性，长度适中。缺点在于需要自己实现或引入第三方库。（一说雪花算法缺点在于依赖时间，但要在跨时间上保证唯一性，除了依赖时间，就是依赖随机数，所以我认为也算不上缺点，且时间回拨不是已经有解决方式了嘛）</p>
<p>如果ID需要存入数据库，由于UUID的无序性，可能会使得索引重建花费较长时间，当然使用<strong>雪花算法比较好</strong>。</p>
<h3 id="每记选择UUID作为key，合理吗？"><a href="#每记选择UUID作为key，合理吗？" class="headerlink" title="每记选择UUID作为key，合理吗？"></a>每记选择UUID作为key，合理吗？</h3><p>作为一个离线客户端软件，我们面临以下问题</p>
<ul>
<li>客户端环境千奇百怪，多平台（PC、网页、安卓、IOS等），多版本，总之，就很难信任客户端环境</li>
<li>离线时也要能正常使用</li>
</ul>
<p>如果使用雪花算法，会有几个问题</p>
<ul>
<li>首先，工作机器ID的确定，需要考虑的情况就会比较多，即生成算法需要调试。客户端的时间回拨，那可不就是修正就能够完事的。</li>
<li>其次，即使有序性有了，但多个设备上传的顺序依旧无法保证，受网络、环境影响较大，依旧会造成索引重建时候较多数据的移动</li>
</ul>
<p>如果使用UUID，其实就只有一个问题</p>
<ul>
<li><p>数据库存储的效率：索引重建。如果是聚簇索引，索引重建时移动的数据会很多，这对MySQL的innodb这类引擎来说可能是灾难。但是PgstgreSQL并非以B+树存储数据，所以性能损失并非想象的那么严重。具体如何，待后面详细研究一波PG的各种原理（完蛋，又挖了一个坑）</p>
<p>且，即使是MySQL，依然可以解决：主键设为单调自增的number，来自客户端的UUID仅作为普通字段，在该字段创建索引，会好很多。</p>
</li>
</ul>
<p>综上所述，使用UUID对客户端更方便，在服务端性能也算可以接受，所以说<strong>是合理的</strong>。</p>
<p>作为佐证，我抓了一个印象笔记下类每记产品”印象清单“，它就更加直白了，id字段名为”taskGuid“，值就是UUID。</p>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line">[</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="attr">&quot;syncDataObject&quot;</span>:&#123;</span><br><span class="line">      <span class="attr">&quot;tasks&quot;</span>:[</span><br><span class="line">        &#123;</span><br><span class="line">          <span class="attr">&quot;state&quot;</span>:<span class="number">1</span>,</span><br><span class="line">          <span class="attr">&quot;ruleId&quot;</span>:<span class="string">&quot;&quot;</span>,</span><br><span class="line">          <span class="attr">&quot;description&quot;</span>:<span class="string">&quot;&quot;</span>,</span><br><span class="line">          <span class="attr">&quot;clientUpdatedTime&quot;</span>:<span class="number">1632988316566</span>,</span><br><span class="line">          <span class="attr">&quot;sortIndex&quot;</span>:<span class="number">0</span>,</span><br><span class="line">          <span class="attr">&quot;dueTime&quot;</span>:<span class="number">1632988311635</span>,</span><br><span class="line">          <span class="attr">&quot;operation&quot;</span>:<span class="number">0</span>,</span><br><span class="line">          <span class="attr">&quot;title&quot;</span>:<span class="string">&quot;æµè¯&quot;</span>,</span><br><span class="line">          <span class="attr">&quot;finishedTime&quot;</span>:<span class="number">-1</span>,</span><br><span class="line">          <span class="attr">&quot;taskGuid&quot;</span>:<span class="string">&quot;a1e4836c-4d59-409d-bf00-864d6d31cba0&quot;</span>,</span><br><span class="line">          <span class="attr">&quot;createTime&quot;</span>:<span class="number">1632988316566</span>,</span><br><span class="line">          <span class="attr">&quot;taskListId&quot;</span>:<span class="string">&quot;default&quot;</span>,</span><br><span class="line">          <span class="attr">&quot;reminderTime&quot;</span>:<span class="number">-1</span>,</span><br><span class="line">          <span class="attr">&quot;reminderType&quot;</span>:<span class="number">0</span>,</span><br><span class="line">          <span class="attr">&quot;taskRelatedNote&quot;</span>:[</span><br><span class="line">            </span><br><span class="line">          ]</span><br><span class="line">        &#125;</span><br><span class="line">      ],</span><br><span class="line">      <span class="attr">&quot;rules&quot;</span>:[</span><br><span class="line">        </span><br><span class="line">      ],</span><br><span class="line">      <span class="attr">&quot;taskLists&quot;</span>:[</span><br><span class="line">        </span><br><span class="line">      ]</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">]</span><br></pre></td></tr></table></figure>

<h2 id="好文推荐"><a href="#好文推荐" class="headerlink" title="好文推荐"></a>好文推荐</h2><p>这篇UUID的文章写的不错，如果结合起来看，可以增进理解：<a href="https://www.cnblogs.com/throwable/p/14343086.html#namespace-name-based-md5%E7%89%88%E6%9C%AC%E5%AE%9E%E7%8E%B0">冷饭新炒：理解JDK中UUID的底层实现</a></p>
<p>雪花算法呢，这篇文章看起来还行：<a href="https://zhuanlan.zhihu.com/p/402822041">SnowFlake</a></p>
<p>美团的Leaf，美团技术团队博客有进行说明：<a href="https://tech.meituan.com/2017/04/21/mt-leaf.html">Leaf——美团点评分布式ID生成系统</a></p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>研究UUID的出发点，只是其RFC很短，仅三十多页，有效内容不到二十页。过程中却有几点意外之喜：</p>
<ul>
<li>顺着UUID的实现原理，了解到JDK的实现方式，自此，UUID于我，成了白盒；</li>
<li>能够体会JDK不提供Version1的原因（它太依赖具体系统，而语言级别的实现，一定是要所有情况通用的，显然Version 1的通用实现，不大好办）；</li>
<li>思路发散到分布式ID，详细了解了雪花算法，它和Version 1是如此接近，却只因为将node和seq换了个位置就能够单调递增，如此相似，结果却如此不同；</li>
<li>离线客户端用SnowFlake如何？它们看起来是大型分布式系统，实则与我们后端常说的分布式系统很不一样，这其中最大的不同是客户端环境不可控。</li>
<li>同时，还挖了两个坑：深入研究随机数、深入研究PostgreSQL</li>
</ul>
<p>本着输出驱动输入的方法完成本文，预期一两天，实则因思路发散花了更多时间，结果是令人满意的，因为它让我对技术，又少了一个模糊地带。</p>
<p>也应验了那句话：持续不断地学习，一定会给你带来惊喜。关键词是：<strong>持续不断</strong></p>
]]></content>
      <categories>
        <category>后端</category>
        <category>算法</category>
      </categories>
      <tags>
        <tag>UUID</tag>
      </tags>
  </entry>
  <entry>
    <title>用Prometheus和Grafana监控你的服务器</title>
    <url>/2020/03/21/%E7%94%A8Prometheus%E5%92%8CGrafana%E7%9B%91%E6%8E%A7%E4%BD%A0%E7%9A%84%E6%9C%8D%E5%8A%A1%E5%99%A8-%E7%94%A8prometheus%E5%92%8Cgrafana%E7%9B%91%E6%8E%A7%E4%BD%A0%E7%9A%84%E6%9C%8D%E5%8A%A1%E5%99%A8/</url>
    <content><![CDATA[<p>本文介绍使用Prometheus和Grafana搭建服务器监控的步骤，并简单介绍其中会涉及到的概念。</p>
<span id="more"></span>

<h1 id="基础"><a href="#基础" class="headerlink" title="基础"></a>基础</h1><h2 id="术语"><a href="#术语" class="headerlink" title="术语"></a>术语</h2><ul>
<li><p>时序数据库：Time Series Database（TSDB），顾名思义，就是存放时序数据的数据库，每条数据有时间戳，支持对该类数据的快速读写、持久化、聚合查询等操作。由于有了时间，就可以根据数据回溯，可用于监控、大数据分析、机器学习等。</p>
<p>常见的TSDB有OpenTSDB、InfluxDBm、Prometheus等</p>
</li>
<li><p>Metrics：度量，是Prometheus中的核心概念。直接来看，度量就是一串标识符，例如http_requests_total表示所有http请求的总数</p>
</li>
<li><p>Tags：标签，一个metric可能会记录多种类型数据，比如http_requests_total，可能同时记录了请求的uri，此时就需要标签进行区隔，一个metric可以对应多个标签，此时它就是一个多维数据。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">http_request_total&#123;uri=&quot;ergedd/hello&quot;&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<h1 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h1><h2 id="Prometheus"><a href="#Prometheus" class="headerlink" title="Prometheus"></a>Prometheus</h2><p>Prometheus是一个开源的监控报警软件，整体结构如下</p>
<p><img src="https://gdz.oss-cn-shenzhen.aliyuncs.com/hexo/%E7%94%A8Prometheus%E5%92%8CGrafana%E7%9B%91%E6%8E%A7%E4%BD%A0%E7%9A%84%E6%9C%8D%E5%8A%A1%E5%99%A8/image-20200321213622180.png" alt="image-20200321213622180"></p>
<p>主要组件如下</p>
<ul>
<li><p>Prometheus Server：服务端，包含数据接收模块、时序数据库模块、Http服务模块等</p>
<p>数据接收模块用于连接监控目标，监控目标可以是静态配置的单个服务，也可以是基于服务发现的得到的服务。</p>
<p>时序数据库模块用于存储接收到的时序数据，并存储于硬盘</p>
<p>Http服务暴露API，用于PromQL查询</p>
<p>服务端工作在pull模式，即监控目标需要暴露接口，服务端通过该接口主动拉取数据。</p>
</li>
<li><p>Push Gateway：推送网关。用于接收监控目标主动推送的数据，同时接受服务端的数据拉取</p>
</li>
<li><p>Alter Manager：报警管理器。接收来自服务端的报警推送，并将报警消息发送出去</p>
</li>
<li><p>UI：通过PromQL查询服务端存储的数据，并通过Web页面的形式展示。一般我们不用Prometheus自带的UI模块，而是将数据接入到图形展示功能更加强大的Grafana</p>
</li>
</ul>
<p>此外，完整的Prometheus还应包含针对特定监控目标所编写的Exporter，用于暴露监控数据，对于常规需求，会有开源公共的Exporter，对于特殊需求，可实现自定义的Exporter。</p>
<h2 id="Grafana"><a href="#Grafana" class="headerlink" title="Grafana"></a>Grafana</h2><p>Grafana是一个开源的数据分析和展示系统，有两个主要优点：</p>
<ul>
<li>支持各种数据库：Elasticsearch、Graphite、influxDB、Prometheus</li>
<li>丰富的展示功能，可以图表、文字等各种方式展示数据，全凭使用者的想象力。</li>
</ul>
<h1 id="搭建"><a href="#搭建" class="headerlink" title="搭建"></a>搭建</h1><p>这里仅搭建一个最简单的系统，打通从exporter到grafana数据流，push网关和报警管理器都暂时忽略。</p>
<h2 id="Prometheus-Exporter"><a href="#Prometheus-Exporter" class="headerlink" title="Prometheus Exporter"></a>Prometheus Exporter</h2><p>监控Linux系统状态，需要用到<a href="https://github.com/prometheus/node_exporter">Node_Exporter</a>，安装它有两种方式，一种是通过源码编译，另一种是直接下载运行，在<a href="https://github.com/prometheus/node_exporter/releases">这里</a>，</p>
<p><img src="https://gdz.oss-cn-shenzhen.aliyuncs.com/hexo/%E7%94%A8Prometheus%E5%92%8CGrafana%E7%9B%91%E6%8E%A7%E4%BD%A0%E7%9A%84%E6%9C%8D%E5%8A%A1%E5%99%A8/image-20200321220315917.png" alt="image-20200321220315917"></p>
<p>下载合适的版本，运行，如下</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ ./node_exporter </span><br><span class="line">INFO[0000] Starting node_exporter (version=0.18.1, branch=HEAD, revision=3db77732e925c08f675d7404a8c46466b2ece83e)  <span class="built_in">source</span>=<span class="string">&quot;node_exporter.go:156&quot;</span></span><br><span class="line">INFO[0000] Build context (go=go1.12.5, user=root@b50852a1acba, date=20190604-16:41:18)  <span class="built_in">source</span>=<span class="string">&quot;node_exporter.go:157&quot;</span></span><br><span class="line">INFO[0000] Enabled collectors:                           <span class="built_in">source</span>=<span class="string">&quot;node_exporter.go:97&quot;</span></span><br><span class="line">INFO[0000]  - arp                                        <span class="built_in">source</span>=<span class="string">&quot;node_exporter.go:104&quot;</span></span><br><span class="line">INFO[0000]  - bcache                                     <span class="built_in">source</span>=<span class="string">&quot;node_exporter.go:104&quot;</span></span><br><span class="line">. . . . . .</span><br><span class="line">INFO[0000]  - zfs                                        <span class="built_in">source</span>=<span class="string">&quot;node_exporter.go:104&quot;</span></span><br><span class="line">INFO[0000] Listening on :9100                            <span class="built_in">source</span>=<span class="string">&quot;node_exporter.go:170&quot;</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>此时在本地9100端口暴露了metrics数据，访问<code>http://localhost:9100/metrics</code>可以获取到所有数据，数据格式是直接可读的：metric name + tag: value</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ curl http://localhost:9100/metrics</span><br><span class="line"></span><br><span class="line"><span class="comment"># HELP go_gc_duration_seconds A summary of the GC invocation durations.</span></span><br><span class="line"><span class="comment"># TYPE go_gc_duration_seconds summary</span></span><br><span class="line">go_gc_duration_seconds&#123;quantile=<span class="string">&quot;0&quot;</span>&#125; 1.8648e-05</span><br><span class="line">go_gc_duration_seconds&#123;quantile=<span class="string">&quot;0.25&quot;</span>&#125; 1.8648e-05</span><br><span class="line">go_gc_duration_seconds&#123;quantile=<span class="string">&quot;0.5&quot;</span>&#125; 4.6304e-05</span><br><span class="line">go_gc_duration_seconds&#123;quantile=<span class="string">&quot;0.75&quot;</span>&#125; 4.6304e-05</span><br><span class="line">go_gc_duration_seconds&#123;quantile=<span class="string">&quot;1&quot;</span>&#125; 4.6304e-05</span><br><span class="line">go_gc_duration_seconds_sum 6.4952e-05</span><br><span class="line">go_gc_duration_seconds_count 2</span><br><span class="line"><span class="comment"># HELP go_goroutines Number of goroutines that currently exist.</span></span><br><span class="line"><span class="comment"># TYPE go_goroutines gauge</span></span><br><span class="line">go_goroutines 7</span><br><span class="line"><span class="comment"># HELP go_info Information about the Go environment.</span></span><br><span class="line"><span class="comment"># TYPE go_info gauge</span></span><br><span class="line">go_info&#123;version=<span class="string">&quot;go1.12.5&quot;</span>&#125; 1</span><br><span class="line">. . . . . .</span><br></pre></td></tr></table></figure>

<h2 id="Prometheus-Server"><a href="#Prometheus-Server" class="headerlink" title="Prometheus Server"></a>Prometheus Server</h2><p>Prometheus在github开源，因此可<a href="https://github.com/prometheus/prometheus/releases">直接下载最新版</a>，这里就不再贴图了，假设已经下载好了，我们从解压后开始，在解压后的目录下可观察到有如下几个文件</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ ls</span><br><span class="line">console_libraries  consoles  data  LICENSE  NOTICE  prometheus  prometheus.yml  promtool  tsdb</span><br></pre></td></tr></table></figure>

<p>关注prometheus和prometheus.yml，前者是可执行文件，后者是配置文件。</p>
<p>在配置文件中加上exporter数据源，设置每5秒抓取一次数据，目标地址为localhost:9100，抓取路劲默认为/metrics，因此不用再指明。</p>
<figure class="highlight yml"><table><tr><td class="code"><pre><span class="line"><span class="attr">scrape_configs:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">job_name:</span> <span class="string">&#x27;floyd_T490&#x27;</span></span><br><span class="line">    <span class="attr">scrape_interval:</span> <span class="string">5s</span></span><br><span class="line">    <span class="attr">static_configs:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="attr">targets:</span> [<span class="string">&#x27;localhost:9100&#x27;</span>]</span><br></pre></td></tr></table></figure>

<p>启动，如下输出代表成功。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">./prometheus --config.file=prometheus.yml</span><br><span class="line">level=info ts=2020-03-21T14:18:55.601Z <span class="built_in">caller</span>=main.go:295 msg=<span class="string">&quot;no time or size retention was set so using the default time retention&quot;</span> duration=15d</span><br><span class="line">. . . . . .</span><br><span class="line">level=info ts=2020-03-21T14:18:55.914Z <span class="built_in">caller</span>=main.go:775 msg=<span class="string">&quot;Completed loading of configuration file&quot;</span> filename=prometheus.yml</span><br><span class="line">level=info ts=2020-03-21T14:18:55.914Z <span class="built_in">caller</span>=main.go:630 msg=<span class="string">&quot;Server is ready to receive web requests.&quot;</span></span><br></pre></td></tr></table></figure>

<p>Prometheus Server默认监听9090端口，访问<code>localhost:9090</code>来到server界面，可以进行简单的查询操作。</p>
<p><img src="https://gdz.oss-cn-shenzhen.aliyuncs.com/hexo/%E7%94%A8Prometheus%E5%92%8CGrafana%E7%9B%91%E6%8E%A7%E4%BD%A0%E7%9A%84%E6%9C%8D%E5%8A%A1%E5%99%A8/image-20200321222203367.png" alt="image-20200321222203367"></p>
<h2 id="Grafana-1"><a href="#Grafana-1" class="headerlink" title="Grafana"></a>Grafana</h2><p>Grafana可以安装启动，也可以用docker启动，方便起见，我们使用Docker。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ sudo docker run -p 3000:3000 grafana/grafana</span><br><span class="line">t=2020-03-21T14:25:09+0000 lvl=info msg=<span class="string">&quot;Starting Grafana&quot;</span> logger=server version=6.6.2 commit=3fa63cfc34 branch=HEAD compiled=2020-02-20T12:03:49+0000</span><br><span class="line">t=2020-03-21T14:25:09+0000 lvl=info msg=<span class="string">&quot;Config loaded from&quot;</span> logger=settings file=/usr/share/grafana/conf/defaults.ini</span><br><span class="line">. . . . . .</span><br><span class="line">t=2020-03-21T14:25:10+0000 lvl=info msg=<span class="string">&quot;Backend rendering via phantomJS&quot;</span> logger=rendering renderer=phantomJS</span><br><span class="line">t=2020-03-21T14:25:10+0000 lvl=warn msg=<span class="string">&quot;phantomJS is deprecated and will be removed in a future release. You should consider migrating from phantomJS to grafana-image-renderer plugin.&quot;</span> logger=rendering renderer=phantomJS</span><br><span class="line">t=2020-03-21T14:25:10+0000 lvl=info msg=<span class="string">&quot;Initializing Stream Manager&quot;</span></span><br><span class="line">t=2020-03-21T14:25:10+0000 lvl=info msg=<span class="string">&quot;HTTP Server Listen&quot;</span> logger=http.server address=[::]:3000 protocol=http subUrl= socket=</span><br></pre></td></tr></table></figure>

<p>安装成功，访问<code>localhost:3000</code>，可以看到登录界面，默认用户名密码为 admin / admin</p>
<p><img src="https://gdz.oss-cn-shenzhen.aliyuncs.com/hexo/%E7%94%A8Prometheus%E5%92%8CGrafana%E7%9B%91%E6%8E%A7%E4%BD%A0%E7%9A%84%E6%9C%8D%E5%8A%A1%E5%99%A8/image-20200321222820888.png" alt="image-20200321222820888"></p>
<h3 id="添加Prometheus数据源"><a href="#添加Prometheus数据源" class="headerlink" title="添加Prometheus数据源"></a>添加Prometheus数据源</h3><p>点击设置 - Data Sources - Add data source - Prometheus</p>
<p>来到数据源设置界面，设置URL为Prometheus Server地址<code>http://localhost:9090</code>，Access为Browser，即通过浏览器访问，点击Save &amp; Test，出现下图所示的<code>Data source is working</code>提示即添加成功。</p>
<p><img src="https://gdz.oss-cn-shenzhen.aliyuncs.com/hexo/%E7%94%A8Prometheus%E5%92%8CGrafana%E7%9B%91%E6%8E%A7%E4%BD%A0%E7%9A%84%E6%9C%8D%E5%8A%A1%E5%99%A8/image-20200321223310983.png" alt="image-20200321223310983"></p>
<h3 id="添加Dashboard"><a href="#添加Dashboard" class="headerlink" title="添加Dashboard"></a>添加Dashboard</h3><p>Grafana通过Dashboard展示数据，一个Dashboard上可以有多个图表。可以自己创建，也可以将现有的导入，在<a href="https://grafana.com/grafana/dashboards">Grafana Labs</a>中，有很多分享的Dashboard，我们找一个合适的。</p>
<p><img src="https://gdz.oss-cn-shenzhen.aliyuncs.com/hexo/%E7%94%A8Prometheus%E5%92%8CGrafana%E7%9B%91%E6%8E%A7%E4%BD%A0%E7%9A%84%E6%9C%8D%E5%8A%A1%E5%99%A8/image-20200321223803850.png" alt="image-20200321223803850"></p>
<p>点进去，复制它的ID</p>
<p><img src="https://gdz.oss-cn-shenzhen.aliyuncs.com/hexo/%E7%94%A8Prometheus%E5%92%8CGrafana%E7%9B%91%E6%8E%A7%E4%BD%A0%E7%9A%84%E6%9C%8D%E5%8A%A1%E5%99%A8/image-20200321223832988.png" alt="image-20200321223832988"></p>
<p>回到Grafana，点击 创建 - Import ，输入上面的ID<code>8919</code>，加载成功可显示如下界面</p>
<p><img src="https://gdz.oss-cn-shenzhen.aliyuncs.com/hexo/%E7%94%A8Prometheus%E5%92%8CGrafana%E7%9B%91%E6%8E%A7%E4%BD%A0%E7%9A%84%E6%9C%8D%E5%8A%A1%E5%99%A8/image-20200321224015143.png" alt="image-20200321224015143"></p>
<p>点击导入，Awwwwwwwwwwwwwwwwwwwsome!!! 这里详细地展示了你的设备信息。</p>
<p><img src="https://gdz.oss-cn-shenzhen.aliyuncs.com/hexo/%E7%94%A8Prometheus%E5%92%8CGrafana%E7%9B%91%E6%8E%A7%E4%BD%A0%E7%9A%84%E6%9C%8D%E5%8A%A1%E5%99%A8/image-20200321224109344.png" alt="image-20200321224109344"></p>
<h3 id="轻微探索"><a href="#轻微探索" class="headerlink" title="轻微探索"></a>轻微探索</h3><p>Dashboard中每个图表上方都有菜单按钮，可供我们修改</p>
<p><img src="https://gdz.oss-cn-shenzhen.aliyuncs.com/hexo/%E7%94%A8Prometheus%E5%92%8CGrafana%E7%9B%91%E6%8E%A7%E4%BD%A0%E7%9A%84%E6%9C%8D%E5%8A%A1%E5%99%A8/image-20200321224240393.png" alt="image-20200321224240393"></p>
<p>点击View，全屏显示该图表；点击Edit，进入编辑模式。我们点编辑看看</p>
<p><img src="https://gdz.oss-cn-shenzhen.aliyuncs.com/hexo/%E7%94%A8Prometheus%E5%92%8CGrafana%E7%9B%91%E6%8E%A7%E4%BD%A0%E7%9A%84%E6%9C%8D%E5%8A%A1%E5%99%A8/image-20200321224349682.png" alt="image-20200321224349682"></p>
<p>可以看到图表中的每个数据来自于prometheus提供的metrics，并使用PromQL进行查询的结果。自己添加图标也是如此：写PromQL - 配置图表</p>
<p>至此，最简单的监控服务搭建完成。</p>
<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>本文简单搭建了Linux的监控系统，主要目的在于展示Prometheus和Grafana的工作方式，算是科普文。也介绍了基本的工作原理，给扩展留下了空间。但其它重要部分需要读者自己去探索，比如</p>
<ul>
<li>Alert Manager</li>
<li>Push Gateway</li>
<li>Prometheus和其它TSDB的比较</li>
</ul>
<h1 id="了解更多"><a href="#了解更多" class="headerlink" title="了解更多"></a>了解更多</h1><p>想要更深入了解Prometheus？</p>
<ul>
<li><a href="https://prometheus.io/docs/concepts/metric_types/">Prometheus的四种Metric类型</a></li>
<li><a href="https://prometheus.io/docs/prometheus/latest/configuration/configuration/">Prometheus配置说明书</a></li>
<li><a href="https://prometheus.io/docs/prometheus/latest/querying/basics/">PromQL说明书</a></li>
<li><a href="https://prometheus.io/docs/instrumenting/exporters/">Prometheus已有Exporter</a></li>
<li><a href="https://prometheus.io/docs/instrumenting/writing_exporters/">自己编写Exporter</a></li>
<li><a href="https://prometheus.io/docs/alerting/overview/">Alert Manager</a></li>
</ul>
<p>想要了解Vertx、Kubernetes如何集成Prometheus?</p>
<ul>
<li><a href="https://vertx.io/docs/vertx-micrometer-metrics/java/">Vertx Micro-metrics</a></li>
<li><a href="%5Bhttps://www.aliyun.com/acts/best-practice/preview?spm=a2c4g.11186623.2.25.674a1f60lTaiIT&id=89866&title=%E4%BA%91%E4%B8%8Aprometheus%E7%9B%91%E6%8E%A7%E8%BF%90%E7%BB%B4&aly_as=4Kd8zxsP%5D(https://www.aliyun.com/acts/best-practice/preview?spm=a2c4g.11186623.2.25.674a1f60lTaiIT&id=89866&title=%E4%BA%91%E4%B8%8Aprometheus%E7%9B%91%E6%8E%A7%E8%BF%90%E7%BB%B4&aly_as=4Kd8zxsP)">云上Prometheus监控运维最佳实践</a></li>
</ul>
<h1 id="参考文档"><a href="#参考文档" class="headerlink" title="参考文档"></a>参考文档</h1><ol>
<li><p><a href="https://en.wikipedia.org/wiki/Time_series_database">TSDB维基百科</a></p>
</li>
<li><p><a href="https://zhuanlan.zhihu.com/p/29367404">时间序列数据库漫谈</a></p>
</li>
<li><p><a href="https://github.com/xephonhq/awesome-time-series-database">Awesome time series database</a></p>
</li>
<li><p><a href="https://blog.pvincent.io/2017/12/prometheus-blog-series-part-1-metrics-and-labels/">Prometheus Blog Series (Part 1): Metrics and Labels</a></p>
</li>
<li><p><a href="https://prometheus.io/docs/guides/node-exporter/">MONITORING LINUX HOST METRICS WITH THE NODE EXPORTER</a></p>
</li>
</ol>
]]></content>
      <categories>
        <category>运维</category>
      </categories>
      <tags>
        <tag>Prometheus</tag>
        <tag>Grafana</tag>
      </tags>
  </entry>
  <entry>
    <title>时区问题</title>
    <url>/2021/07/13/%E6%97%B6%E5%8C%BA%E9%97%AE%E9%A2%98-%E6%97%B6%E5%8C%BA%E9%97%AE%E9%A2%98/</url>
    <content><![CDATA[<blockquote>
<p>PostgreSQ中，timstamp是不带时区的类型，timestamp with zone是带时区的类型；函数CURRENT_TIMESTAMP得到的是timestamp with zone的当前时间；函数LOCALTIMESTAMP得到的是timestamp类型的时间。</p>
</blockquote>
<blockquote>
<p>那么你知道，将CURRENT_TIMESTAMP赋值给一个timstamp类型的字段会发生什么吗？</p>
</blockquote>
<span id="more"></span>

<h2 id="时区？偏移量？"><a href="#时区？偏移量？" class="headerlink" title="时区？偏移量？"></a>时区？偏移量？</h2><p>在搞清楚数据库和代码中的时区表达之前，必须掌握好基础知识。</p>
<blockquote>
<p>你能分清GMT、UTC、夏令时、时区等概念吗？</p>
</blockquote>
<p>对于上面四个概念，下面这篇文章算是讲的比较清楚。</p>
<p>简单来说，GMT就是以前的时间标准，以格林威治的时间作为世界标准时间，其它各个时区以此为参考增加或减少小时数；UTC是新的世界时间标准，与GMT不同，GMT是单纯以格林威治这个地方作为标准时参考，UTC是结合了平均太阳时、地轴运动修正、国际原子钟综合得到的精确结果；夏令时，是指在天亮比较早的夏季人为将时间调早一个小时，我们对它不是很熟悉是因为我国1991年开始就已经废除了下令时；时区，理论来说，按照经度划分，每15度为一个时区，全球总共24个时区，每个时区相差一个小时，为啥是理论呢？这是因为实际还会考虑政治因素，很过国家一个国家跨多个时区，但他们都使用一个时区，所以时区不是严格按照经度划分的。</p>
<p><a href="https://www.cnblogs.com/champyin/p/12767852.html">这篇文章可做参考</a></p>
<p>格林威治在哪里，看下面这张图。</p>
<p><img src="1" alt="格林威治时间.png"></p>
<blockquote>
<p>你能分清+08:00、Asia/Shanghai、GMT-这几种表达的区别吗？</p>
</blockquote>
<p><a href="https://blog.csdn.net/zjy_love_java/article/details/107704594">Asia/Shanghai与GMT-8的区别</a></p>
<p>先说Asia/Shanghai，这是以地区命名的地区标准时，叫做CST；+8:00，指的是东八区。现在这个年份来说，二者表述一样，但是前者还包含一些历史时间，比如91年之前，我国实行过一段时间夏令时，如果将时区设置为Asia/Shanghai，那么在获取91年之前的时间时候就会有所差异。</p>
<p>其实地区标准时是非常有必要的，比如我们的日历中，使用地区标准是必须的，91年之前的时间你肯定想要显示当时的计算结果。</p>
<h2 id="LocalDateTime-ZoneOffsetDateTime-ZonedDateTime"><a href="#LocalDateTime-ZoneOffsetDateTime-ZonedDateTime" class="headerlink" title="LocalDateTime/ZoneOffsetDateTime/ZonedDateTime"></a>LocalDateTime/ZoneOffsetDateTime/ZonedDateTime</h2><p>认识它们：</p>
<p><a href="https://segmentfault.com/a/1190000039081645">LocalDateTime、OffsetDateTime、ZonedDateTime互转，这一篇绝对喂饱你</a></p>
<p>ZoneOffset和Zoned的区别，通过解释Asia/Shanghai和+8:00的区别，想必已经了解了。</p>
<p>理解上述的几个关键点</p>
<ul>
<li><p>LocalDateTime不带时区，不带时区不是说它的时间就是UTC时间，而是说它就是一个时间字面量，不能够标识时间线上的某个时间。核心是理解Local这个概念，即当地时间，“当地”，与时区无关。</p>
<p>  它不能表示时间线上的点，因此无法获取其epoch值，要获取时必须指定时区变成时间线上点才行。</p>
</li>
<li><p>ZoneOffsetDateTime，即以偏移量表示的时间。</p>
</li>
<li><p>ZonedDateTime，即以地区时间表示的时间，即我们常说的时区。</p>
</li>
<li><p>ZoneOffsetDateTime与ZonedDateTime区别</p>
<ul>
<li>前者可以自由设置偏移量，后者无法设置偏移量，只能根据时区来设置</li>
<li>后者能够很好得支持夏令时，前者不行</li>
</ul>
</li>
<li><p>为什么它们之间能够相互转换？</p>
<ul>
<li>LocalDateTime不能直接转换为其它两种类型，除非它指定是在哪个时区的本地时间。这也能够理解，本地时间+时区，不就成了通用时间了吗。</li>
<li>偏移量和地区时间如何转换呢？前者转后者比较好做，因为时区包含了偏移量。</li>
</ul>
</li>
</ul>
<h2 id="数据库应该使用带时区还是不带时区的类型？"><a href="#数据库应该使用带时区还是不带时区的类型？" class="headerlink" title="数据库应该使用带时区还是不带时区的类型？"></a>数据库应该使用带时区还是不带时区的类型？</h2><p>当然是带时区的类型啦。</p>
<p>如果不带时区，是无法表示时间线上的某个点的；就会出现，如果数据库的时区设置在东八区，则生成的时间就是东八区的本地时间；如果设置在0时区，则生成的就是0时区的本地时间；二者是不一样的。也就是说，生成的时间在时间线上的位置会随着数据库时区的变化而变化，这显然是不合理的。</p>
<p>如果使用带时区的类型，只不过是在显示该日期时会有所差别，但实际上的时间是没有问题的。</p>
<p>其实，理论上最好的方式是存储epoch值，这样就不用管各种不同的数据库之间时间类型的差异了。</p>
]]></content>
      <categories>
        <category>后端</category>
      </categories>
      <tags>
        <tag>时间</tag>
      </tags>
  </entry>
  <entry>
    <title>瞅瞅动态代理</title>
    <url>/2021/11/03/%E7%9E%85%E7%9E%85%E5%8A%A8%E6%80%81%E4%BB%A3%E7%90%86-chou-chou-dong-tai-dai-li/</url>
    <content><![CDATA[<p>动态代理说大不大，说小不小，可深可浅。往深了说还是对JVM的了解程度要足够深入，时间篇幅有限，本文专注于回答如下问题，不作更深入的探讨。</p>
<ul>
<li>JDK和Cglib动态代理，分别怎么使用</li>
<li>JDK动态代理的原理</li>
<li>Cglib动态代理的原理</li>
<li>为什么JDK动态代理一定要实现接口，而Cglib就不用？</li>
<li>JDK和Cglib，本质上有什么区别？</li>
</ul>
<span id="more"></span>

<h2 id="JDK动态代理"><a href="#JDK动态代理" class="headerlink" title="JDK动态代理"></a>JDK动态代理</h2><h3 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h3><p>一个简单的场景</p>
<ul>
<li>一个Service接口，拥有sayHello()方法</li>
<li>一个ServiceImpl实现类，实现Service</li>
<li>创建一个ServiceImpl的代理类，代理sayHello()方法，在调用原方法的前后，打印锚点</li>
</ul>
<p>例子如下</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">Service</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">sayHello</span><span class="params">()</span></span></span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ActualService</span> : <span class="type">Service &#123;</span></span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">sayHello</span><span class="params">()</span></span> &#123;</span><br><span class="line">        println(<span class="string">&quot;Hello, Java dynamic proxy...&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyHandler</span></span>(<span class="keyword">private</span> <span class="keyword">val</span> service: Service) : InvocationHandler &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * proxy: 生成的代理类</span></span><br><span class="line"><span class="comment">     * method: 方法</span></span><br><span class="line"><span class="comment">     * args: 方法参数</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">invoke</span><span class="params">(proxy: <span class="type">Any</span>, method: <span class="type">Method</span>, args: <span class="type">Array</span>&lt;<span class="type">out</span> <span class="type">Any</span>&gt;?)</span></span>: Any? &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">if</span> (method.name == <span class="string">&quot;sayHello&quot;</span>) &#123;</span><br><span class="line">            println(<span class="string">&quot;调用方法前&quot;</span>)</span><br><span class="line">            method.invoke(service).also &#123;</span><br><span class="line">                println(<span class="string">&quot;调用方法后&quot;</span>)</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="literal">null</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">  	<span class="comment">// 将生成的代理类进行打印</span></span><br><span class="line">    System.setProperty(<span class="string">&quot;jdk.proxy.ProxyGenerator.saveGeneratedFiles&quot;</span>, <span class="string">&quot;true&quot;</span>)</span><br><span class="line">    <span class="keyword">val</span> proxy = Proxy.newProxyInstance(</span><br><span class="line">        Service::<span class="keyword">class</span>.java.classLoader,</span><br><span class="line">        arrayOf(Service::<span class="keyword">class</span>.java),</span><br><span class="line">        MyHandler(ActualService())</span><br><span class="line">    )</span><br><span class="line">    (proxy <span class="keyword">as</span> Service).sayHello()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>总结一下，要点</p>
<ul>
<li>被代理的类要实现接口</li>
<li>代理的逻辑要通过InvocationHandler实现</li>
<li><code>Proxy.newProxyInstance()</code>生成代理类，需要提供类加载器、被代理的接口、InvocationHandler</li>
</ul>
<h3 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h3><p>源码自己跟，最终会来到核心方法</p>
<ul>
<li><p><code>java.lang.reflect.Proxy.ProxyBuilder#defineProxyClass</code></p>
<p>关键逻辑：生成类的字节码流；使用sun.misc.Unsafe直接从流创建Class对象。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> Class&lt;?&gt; defineProxyClass(Module m, List&lt;Class&lt;?&gt;&gt; interfaces) &#123;</span><br><span class="line">	</span><br><span class="line">	...</span><br><span class="line">	<span class="keyword">byte</span>[] proxyClassFile = ProxyGenerator.generateProxyClass(proxyName, interfaces.toArray(EMPTY_CLASS_ARRAY), accessFlags);</span><br><span class="line">  <span class="keyword">try</span> &#123;</span><br><span class="line">    Class&lt;?&gt; pc = UNSAFE.defineClass(proxyName, proxyClassFile, <span class="number">0</span>, proxyClassFile.length, loader, <span class="keyword">null</span>);</span><br><span class="line">    <span class="keyword">return</span> pc;</span><br><span class="line">  &#125; <span class="keyword">catch</span> (ClassFormatError e) &#123;</span><br><span class="line">    ...</span><br><span class="line">  &#125;</span><br><span class="line">	...</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p><code>java.lang.reflect.ProxyGenerator#generateProxyClass(java.lang.String, java.lang.Class&lt;?&gt;[], int)</code>，这里可以看到</p>
<p>这里是类字节码流生成的关键逻辑：凭空构建一个class流</p>
<ul>
<li>常规class字节码文件的组成：魔数、版本号、常量池等</li>
<li>写入父类：固定为<code>&quot;java/lang/reflect/Proxy&quot;</code></li>
<li>写入需要被代理的接口，用户传入的</li>
<li>写入字段和方法，这其中包含了我们传入的InvocationHandler</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">ByteArrayOutputStream bout = <span class="keyword">new</span> ByteArrayOutputStream();</span><br><span class="line">DataOutputStream dout = <span class="keyword">new</span> DataOutputStream(bout);</span><br><span class="line"></span><br><span class="line">dout.writeInt(<span class="number">0xCAFEBABE</span>);</span><br><span class="line"><span class="comment">// u2 minor_version;</span></span><br><span class="line">dout.writeShort(CLASSFILE_MINOR_VERSION);</span><br><span class="line"><span class="comment">// u2 major_version;</span></span><br><span class="line">dout.writeShort(CLASSFILE_MAJOR_VERSION);</span><br><span class="line"></span><br><span class="line">cp.write(dout);             <span class="comment">// (write constant pool)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// u2 access_flags;</span></span><br><span class="line">dout.writeShort(accessFlags);</span><br><span class="line"><span class="comment">// u2 this_class;</span></span><br><span class="line">dout.writeShort(cp.getClass(dotToSlash(className)));</span><br><span class="line"><span class="comment">// u2 super_class;</span></span><br><span class="line">dout.writeShort(cp.getClass(superclassName));</span><br><span class="line"></span><br><span class="line"><span class="comment">// u2 interfaces_count;</span></span><br><span class="line">dout.writeShort(interfaces.length);</span><br><span class="line"><span class="comment">// u2 interfaces[interfaces_count];</span></span><br><span class="line"><span class="keyword">for</span> (Class&lt;?&gt; intf : interfaces) &#123;</span><br><span class="line">  dout.writeShort(cp.getClass(</span><br><span class="line">    dotToSlash(intf.getName())));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// u2 fields_count;</span></span><br><span class="line">dout.writeShort(fields.size());</span><br><span class="line"><span class="comment">// field_info fields[fields_count];</span></span><br><span class="line"><span class="keyword">for</span> (FieldInfo f : fields) &#123;</span><br><span class="line">  f.write(dout);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// u2 methods_count;</span></span><br><span class="line">dout.writeShort(methods.size());</span><br><span class="line"><span class="comment">// method_info methods[methods_count];</span></span><br><span class="line"><span class="keyword">for</span> (MethodInfo m : methods) &#123;</span><br><span class="line">  m.write(dout);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// u2 attributes_count;</span></span><br><span class="line">dout.writeShort(<span class="number">0</span>); <span class="comment">// (no ClassFile attributes for proxy classes)</span></span><br><span class="line"></span><br></pre></td></tr></table></figure></li>
</ul>
<p>通过设置系统属性：<code>System.setProperty(&quot;jdk.proxy.ProxyGenerator.saveGeneratedFiles&quot;, &quot;true&quot;)</code>可以将生成的字节码保存为文件，然后反编译看结果</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.sun.proxy;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> com.gitee.floyd.proxy.Service;</span><br><span class="line"><span class="keyword">import</span> java.lang.reflect.InvocationHandler;</span><br><span class="line"><span class="keyword">import</span> java.lang.reflect.Method;</span><br><span class="line"><span class="keyword">import</span> java.lang.reflect.Proxy;</span><br><span class="line"><span class="keyword">import</span> java.lang.reflect.UndeclaredThrowableException;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> $<span class="title">Proxy0</span> <span class="keyword">extends</span> <span class="title">Proxy</span> <span class="keyword">implements</span> <span class="title">Service</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Method m1;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Method m3;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Method m2;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Method m0;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> $Proxy0(InvocationHandler var1) <span class="keyword">throws</span>  &#123;</span><br><span class="line">        <span class="keyword">super</span>(var1);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">equals</span><span class="params">(Object var1)</span> <span class="keyword">throws</span>  </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> (Boolean)<span class="keyword">super</span>.h.invoke(<span class="keyword">this</span>, m1, <span class="keyword">new</span> Object[]&#123;var1&#125;);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (RuntimeException | Error var3) &#123;</span><br><span class="line">            <span class="keyword">throw</span> var3;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Throwable var4) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> UndeclaredThrowableException(var4);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">sayHello</span><span class="params">()</span> <span class="keyword">throws</span>  </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">super</span>.h.invoke(<span class="keyword">this</span>, m3, (Object[])<span class="keyword">null</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (RuntimeException | Error var2) &#123;</span><br><span class="line">            <span class="keyword">throw</span> var2;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Throwable var3) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> UndeclaredThrowableException(var3);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> String <span class="title">toString</span><span class="params">()</span> <span class="keyword">throws</span>  </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> (String)<span class="keyword">super</span>.h.invoke(<span class="keyword">this</span>, m2, (Object[])<span class="keyword">null</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (RuntimeException | Error var2) &#123;</span><br><span class="line">            <span class="keyword">throw</span> var2;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Throwable var3) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> UndeclaredThrowableException(var3);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">int</span> <span class="title">hashCode</span><span class="params">()</span> <span class="keyword">throws</span>  </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> (Integer)<span class="keyword">super</span>.h.invoke(<span class="keyword">this</span>, m0, (Object[])<span class="keyword">null</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (RuntimeException | Error var2) &#123;</span><br><span class="line">            <span class="keyword">throw</span> var2;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Throwable var3) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> UndeclaredThrowableException(var3);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            m1 = Class.forName(<span class="string">&quot;java.lang.Object&quot;</span>).getMethod(<span class="string">&quot;equals&quot;</span>, Class.forName(<span class="string">&quot;java.lang.Object&quot;</span>));</span><br><span class="line">            m3 = Class.forName(<span class="string">&quot;com.gitee.floyd.proxy.Service&quot;</span>).getMethod(<span class="string">&quot;sayHello&quot;</span>);</span><br><span class="line">            m2 = Class.forName(<span class="string">&quot;java.lang.Object&quot;</span>).getMethod(<span class="string">&quot;toString&quot;</span>);</span><br><span class="line">            m0 = Class.forName(<span class="string">&quot;java.lang.Object&quot;</span>).getMethod(<span class="string">&quot;hashCode&quot;</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (NoSuchMethodException var2) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> NoSuchMethodError(var2.getMessage());</span><br><span class="line">        &#125; <span class="keyword">catch</span> (ClassNotFoundException var3) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> NoClassDefFoundError(var3.getMessage());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>几个要点</p>
<ul>
<li>该代理类直接继承了Proxy类，实现类我们指定的Service接口</li>
<li><code>sayHello()</code>代理的原理：调用<code>InvocationHandler.invoke()</code>完成实际调用</li>
<li>代理类的所有方法，都会调用<code>InvocationHandler.invoke()</code></li>
</ul>
<h3 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h3><p>JDK的动态代理，是从头构建新的类字节码流，然后加载到JVM中达成的。其使用方法必须依赖接口、InvocationHandler、Proxy，并不是非常方便。</p>
<h2 id="CGlib"><a href="#CGlib" class="headerlink" title="CGlib"></a>CGlib</h2><h3 id="使用-1"><a href="#使用-1" class="headerlink" title="使用"></a>使用</h3><p>类似上面，一个简单的场景</p>
<ul>
<li>一个Service类，不用实现任何接口</li>
<li>创建Service的代理类，代理sayHello()方法，在调用原方法的前后，打印锚点</li>
</ul>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">open</span> <span class="class"><span class="keyword">class</span> <span class="title">PersonService</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">open</span> <span class="function"><span class="keyword">fun</span> <span class="title">sayHello</span><span class="params">(name: <span class="type">String</span>)</span></span>: String &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;Hello, <span class="variable">$name</span>&quot;</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">tryMethodInterceptor</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">val</span> enhancer = Enhancer()</span><br><span class="line">    enhancer.setSuperclass(PersonService::<span class="keyword">class</span>.java)</span><br><span class="line">    enhancer.setCallback(MethodInterceptor &#123; obj, method, args, proxy -&gt;</span><br><span class="line">        <span class="keyword">if</span> (method.name == <span class="string">&quot;sayHello&quot;</span>) &#123;</span><br><span class="line">            println(<span class="string">&quot;我先执行一下&quot;</span>)</span><br><span class="line">            proxy.invokeSuper(obj, args).also &#123;</span><br><span class="line">                println(<span class="string">&quot;然后我再执行一下&quot;</span>)</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="literal">null</span></span><br><span class="line">    &#125;)</span><br><span class="line">    <span class="keyword">val</span> proxy = enhancer.create() <span class="keyword">as</span> PersonService</span><br><span class="line">    println(proxy.sayHello(<span class="string">&quot;你好&quot;</span>))</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="comment">// 打印出生成的代理类</span></span><br><span class="line">    System.setProperty(DebuggingClassWriter.DEBUG_LOCATION_PROPERTY, <span class="string">&quot;/Users/zouguodong/Code/Personal/play-floyd/proxy/generatedClass&quot;</span>)</span><br><span class="line">    tryMethodInterceptor()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>总结一下，要点</p>
<ul>
<li>只需要被代理类自己，但被代理类和方法必须是open的，即可被继承和覆盖的</li>
<li>使用Enhancer类，方法拦截使用MethodInterceptor定义代理逻辑</li>
</ul>
<h3 id="原理-1"><a href="#原理-1" class="headerlink" title="原理"></a>原理</h3><p>同样，跟跟源码，发现关键逻辑在：<code>net.sf.cglib.proxy.Enhancer#generateClass</code>，这里是通过ASM库来生成类字节码的，过程比较复杂，需要对ASM API比较了解才能分析，这里这里暂时忽略。直接看生成的代码。</p>
<p>设置系统属性<code>System.setProperty(DebuggingClassWriter.DEBUG_LOCATION_PROPERTY, &quot;xxx&quot;)</code>可以将生成的代理类输出。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">PersonService</span>$$<span class="title">EnhancerByCGLIB</span>$$470<span class="title">f9603</span> <span class="keyword">extends</span> <span class="title">PersonService</span> <span class="keyword">implements</span> <span class="title">Factory</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">boolean</span> CGLIB$BOUND;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> Object CGLIB$FACTORY_DATA;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> ThreadLocal CGLIB$THREAD_CALLBACKS;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Callback[] CGLIB$STATIC_CALLBACKS;</span><br><span class="line">    <span class="keyword">private</span> MethodInterceptor CGLIB$CALLBACK_0;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Object CGLIB$CALLBACK_FILTER;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Method CGLIB$sayHello$<span class="number">0</span>$Method;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> MethodProxy CGLIB$sayHello$<span class="number">0</span>$Proxy;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Object[] CGLIB$emptyArgs;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Method CGLIB$length$<span class="number">1</span>$Method;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> MethodProxy CGLIB$length$<span class="number">1</span>$Proxy;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Method CGLIB$equals$<span class="number">2</span>$Method;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> MethodProxy CGLIB$equals$<span class="number">2</span>$Proxy;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Method CGLIB$toString$<span class="number">3</span>$Method;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> MethodProxy CGLIB$toString$<span class="number">3</span>$Proxy;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Method CGLIB$hashCode$<span class="number">4</span>$Method;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> MethodProxy CGLIB$hashCode$<span class="number">4</span>$Proxy;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Method CGLIB$clone$<span class="number">5</span>$Method;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> MethodProxy CGLIB$clone$<span class="number">5</span>$Proxy;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">void</span> CGLIB$STATICHOOK1() &#123;</span><br><span class="line">        CGLIB$THREAD_CALLBACKS = <span class="keyword">new</span> ThreadLocal();</span><br><span class="line">        CGLIB$emptyArgs = <span class="keyword">new</span> Object[<span class="number">0</span>];</span><br><span class="line">        Class var0 = Class.forName(<span class="string">&quot;com.gitee.floyd.proxy.PersonService$$EnhancerByCGLIB$$470f9603&quot;</span>);</span><br><span class="line">        Class var1;</span><br><span class="line">        Method[] var10000 = ReflectUtils.findMethods(<span class="keyword">new</span> String[]&#123;<span class="string">&quot;equals&quot;</span>, <span class="string">&quot;(Ljava/lang/Object;)Z&quot;</span>, <span class="string">&quot;toString&quot;</span>, <span class="string">&quot;()Ljava/lang/String;&quot;</span>, <span class="string">&quot;hashCode&quot;</span>, <span class="string">&quot;()I&quot;</span>, <span class="string">&quot;clone&quot;</span>, <span class="string">&quot;()Ljava/lang/Object;&quot;</span>&#125;, (var1 = Class.forName(<span class="string">&quot;java.lang.Object&quot;</span>)).getDeclaredMethods());</span><br><span class="line">        CGLIB$equals$<span class="number">2</span>$Method = var10000[<span class="number">0</span>];</span><br><span class="line">        CGLIB$equals$<span class="number">2</span>$Proxy = MethodProxy.create(var1, var0, <span class="string">&quot;(Ljava/lang/Object;)Z&quot;</span>, <span class="string">&quot;equals&quot;</span>, <span class="string">&quot;CGLIB$equals$2&quot;</span>);</span><br><span class="line">        CGLIB$toString$<span class="number">3</span>$Method = var10000[<span class="number">1</span>];</span><br><span class="line">        CGLIB$toString$<span class="number">3</span>$Proxy = MethodProxy.create(var1, var0, <span class="string">&quot;()Ljava/lang/String;&quot;</span>, <span class="string">&quot;toString&quot;</span>, <span class="string">&quot;CGLIB$toString$3&quot;</span>);</span><br><span class="line">        CGLIB$hashCode$<span class="number">4</span>$Method = var10000[<span class="number">2</span>];</span><br><span class="line">        CGLIB$hashCode$<span class="number">4</span>$Proxy = MethodProxy.create(var1, var0, <span class="string">&quot;()I&quot;</span>, <span class="string">&quot;hashCode&quot;</span>, <span class="string">&quot;CGLIB$hashCode$4&quot;</span>);</span><br><span class="line">        CGLIB$clone$<span class="number">5</span>$Method = var10000[<span class="number">3</span>];</span><br><span class="line">        CGLIB$clone$<span class="number">5</span>$Proxy = MethodProxy.create(var1, var0, <span class="string">&quot;()Ljava/lang/Object;&quot;</span>, <span class="string">&quot;clone&quot;</span>, <span class="string">&quot;CGLIB$clone$5&quot;</span>);</span><br><span class="line">        var10000 = ReflectUtils.findMethods(<span class="keyword">new</span> String[]&#123;<span class="string">&quot;sayHello&quot;</span>, <span class="string">&quot;(Ljava/lang/String;)Ljava/lang/String;&quot;</span>, <span class="string">&quot;length&quot;</span>, <span class="string">&quot;(Ljava/lang/String;)I&quot;</span>&#125;, (var1 = Class.forName(<span class="string">&quot;com.gitee.floyd.proxy.PersonService&quot;</span>)).getDeclaredMethods());</span><br><span class="line">        CGLIB$sayHello$<span class="number">0</span>$Method = var10000[<span class="number">0</span>];</span><br><span class="line">        CGLIB$sayHello$<span class="number">0</span>$Proxy = MethodProxy.create(var1, var0, <span class="string">&quot;(Ljava/lang/String;)Ljava/lang/String;&quot;</span>, <span class="string">&quot;sayHello&quot;</span>, <span class="string">&quot;CGLIB$sayHello$0&quot;</span>);</span><br><span class="line">        CGLIB$length$<span class="number">1</span>$Method = var10000[<span class="number">1</span>];</span><br><span class="line">        CGLIB$length$<span class="number">1</span>$Proxy = MethodProxy.create(var1, var0, <span class="string">&quot;(Ljava/lang/String;)I&quot;</span>, <span class="string">&quot;length&quot;</span>, <span class="string">&quot;CGLIB$length$1&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">final</span> String CGLIB$sayHello$<span class="number">0</span>(String var1) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">super</span>.sayHello(var1);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> String <span class="title">sayHello</span><span class="params">(String var1)</span> </span>&#123;</span><br><span class="line">        MethodInterceptor var10000 = <span class="keyword">this</span>.CGLIB$CALLBACK_0;</span><br><span class="line">        <span class="keyword">if</span> (var10000 == <span class="keyword">null</span>) &#123;</span><br><span class="line">            CGLIB$BIND_CALLBACKS(<span class="keyword">this</span>);</span><br><span class="line">            var10000 = <span class="keyword">this</span>.CGLIB$CALLBACK_0;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> var10000 != <span class="keyword">null</span> ? (String)var10000.intercept(<span class="keyword">this</span>, CGLIB$sayHello$<span class="number">0</span>$Method, <span class="keyword">new</span> Object[]&#123;var1&#125;, CGLIB$sayHello$<span class="number">0</span>$Proxy) : <span class="keyword">super</span>.sayHello(var1);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">int</span> CGLIB$length$<span class="number">1</span>(String var1) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">super</span>.length(var1);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">int</span> <span class="title">length</span><span class="params">(String var1)</span> </span>&#123;</span><br><span class="line">        MethodInterceptor var10000 = <span class="keyword">this</span>.CGLIB$CALLBACK_0;</span><br><span class="line">        <span class="keyword">if</span> (var10000 == <span class="keyword">null</span>) &#123;</span><br><span class="line">            CGLIB$BIND_CALLBACKS(<span class="keyword">this</span>);</span><br><span class="line">            var10000 = <span class="keyword">this</span>.CGLIB$CALLBACK_0;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (var10000 != <span class="keyword">null</span>) &#123;</span><br><span class="line">            Object var2 = var10000.intercept(<span class="keyword">this</span>, CGLIB$length$<span class="number">1</span>$Method, <span class="keyword">new</span> Object[]&#123;var1&#125;, CGLIB$length$<span class="number">1</span>$Proxy);</span><br><span class="line">            <span class="keyword">return</span> var2 == <span class="keyword">null</span> ? <span class="number">0</span> : ((Number)var2).intValue();</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">super</span>.length(var1);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">boolean</span> CGLIB$equals$<span class="number">2</span>(Object var1) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">super</span>.equals(var1);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">equals</span><span class="params">(Object var1)</span> </span>&#123;</span><br><span class="line">        MethodInterceptor var10000 = <span class="keyword">this</span>.CGLIB$CALLBACK_0;</span><br><span class="line">        <span class="keyword">if</span> (var10000 == <span class="keyword">null</span>) &#123;</span><br><span class="line">            CGLIB$BIND_CALLBACKS(<span class="keyword">this</span>);</span><br><span class="line">            var10000 = <span class="keyword">this</span>.CGLIB$CALLBACK_0;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (var10000 != <span class="keyword">null</span>) &#123;</span><br><span class="line">            Object var2 = var10000.intercept(<span class="keyword">this</span>, CGLIB$equals$<span class="number">2</span>$Method, <span class="keyword">new</span> Object[]&#123;var1&#125;, CGLIB$equals$<span class="number">2</span>$Proxy);</span><br><span class="line">            <span class="keyword">return</span> var2 == <span class="keyword">null</span> ? <span class="keyword">false</span> : (Boolean)var2;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">super</span>.equals(var1);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">final</span> String CGLIB$toString$<span class="number">3</span>() &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">super</span>.toString();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        MethodInterceptor var10000 = <span class="keyword">this</span>.CGLIB$CALLBACK_0;</span><br><span class="line">        <span class="keyword">if</span> (var10000 == <span class="keyword">null</span>) &#123;</span><br><span class="line">            CGLIB$BIND_CALLBACKS(<span class="keyword">this</span>);</span><br><span class="line">            var10000 = <span class="keyword">this</span>.CGLIB$CALLBACK_0;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> var10000 != <span class="keyword">null</span> ? (String)var10000.intercept(<span class="keyword">this</span>, CGLIB$toString$<span class="number">3</span>$Method, CGLIB$emptyArgs, CGLIB$toString$<span class="number">3</span>$Proxy) : <span class="keyword">super</span>.toString();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">int</span> CGLIB$hashCode$<span class="number">4</span>() &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">super</span>.hashCode();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">int</span> <span class="title">hashCode</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        MethodInterceptor var10000 = <span class="keyword">this</span>.CGLIB$CALLBACK_0;</span><br><span class="line">        <span class="keyword">if</span> (var10000 == <span class="keyword">null</span>) &#123;</span><br><span class="line">            CGLIB$BIND_CALLBACKS(<span class="keyword">this</span>);</span><br><span class="line">            var10000 = <span class="keyword">this</span>.CGLIB$CALLBACK_0;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (var10000 != <span class="keyword">null</span>) &#123;</span><br><span class="line">            Object var1 = var10000.intercept(<span class="keyword">this</span>, CGLIB$hashCode$<span class="number">4</span>$Method, CGLIB$emptyArgs, CGLIB$hashCode$<span class="number">4</span>$Proxy);</span><br><span class="line">            <span class="keyword">return</span> var1 == <span class="keyword">null</span> ? <span class="number">0</span> : ((Number)var1).intValue();</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">super</span>.hashCode();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">final</span> Object CGLIB$clone$<span class="number">5</span>() <span class="keyword">throws</span> CloneNotSupportedException &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">super</span>.clone();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">final</span> Object <span class="title">clone</span><span class="params">()</span> <span class="keyword">throws</span> CloneNotSupportedException </span>&#123;</span><br><span class="line">        MethodInterceptor var10000 = <span class="keyword">this</span>.CGLIB$CALLBACK_0;</span><br><span class="line">        <span class="keyword">if</span> (var10000 == <span class="keyword">null</span>) &#123;</span><br><span class="line">            CGLIB$BIND_CALLBACKS(<span class="keyword">this</span>);</span><br><span class="line">            var10000 = <span class="keyword">this</span>.CGLIB$CALLBACK_0;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> var10000 != <span class="keyword">null</span> ? var10000.intercept(<span class="keyword">this</span>, CGLIB$clone$<span class="number">5</span>$Method, CGLIB$emptyArgs, CGLIB$clone$<span class="number">5</span>$Proxy) : <span class="keyword">super</span>.clone();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> MethodProxy CGLIB$findMethodProxy(Signature var0) &#123;</span><br><span class="line">        String var10000 = var0.toString();</span><br><span class="line">        <span class="keyword">switch</span>(var10000.hashCode()) &#123;</span><br><span class="line">        <span class="keyword">case</span> -<span class="number">1816210712</span>:</span><br><span class="line">            <span class="keyword">if</span> (var10000.equals(<span class="string">&quot;sayHello(Ljava/lang/String;)Ljava/lang/String;&quot;</span>)) &#123;</span><br><span class="line">                <span class="keyword">return</span> CGLIB$sayHello$<span class="number">0</span>$Proxy;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> -<span class="number">508378822</span>:</span><br><span class="line">            <span class="keyword">if</span> (var10000.equals(<span class="string">&quot;clone()Ljava/lang/Object;&quot;</span>)) &#123;</span><br><span class="line">                <span class="keyword">return</span> CGLIB$clone$<span class="number">5</span>$Proxy;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="number">166945484</span>:</span><br><span class="line">            <span class="keyword">if</span> (var10000.equals(<span class="string">&quot;length(Ljava/lang/String;)I&quot;</span>)) &#123;</span><br><span class="line">                <span class="keyword">return</span> CGLIB$length$<span class="number">1</span>$Proxy;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="number">1826985398</span>:</span><br><span class="line">            <span class="keyword">if</span> (var10000.equals(<span class="string">&quot;equals(Ljava/lang/Object;)Z&quot;</span>)) &#123;</span><br><span class="line">                <span class="keyword">return</span> CGLIB$equals$<span class="number">2</span>$Proxy;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="number">1913648695</span>:</span><br><span class="line">            <span class="keyword">if</span> (var10000.equals(<span class="string">&quot;toString()Ljava/lang/String;&quot;</span>)) &#123;</span><br><span class="line">                <span class="keyword">return</span> CGLIB$toString$<span class="number">3</span>$Proxy;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="number">1984935277</span>:</span><br><span class="line">            <span class="keyword">if</span> (var10000.equals(<span class="string">&quot;hashCode()I&quot;</span>)) &#123;</span><br><span class="line">                <span class="keyword">return</span> CGLIB$hashCode$<span class="number">4</span>$Proxy;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> PersonService$$EnhancerByCGLIB$$470f9603() &#123;</span><br><span class="line">        CGLIB$BIND_CALLBACKS(<span class="keyword">this</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> CGLIB$SET_THREAD_CALLBACKS(Callback[] var0) &#123;</span><br><span class="line">        CGLIB$THREAD_CALLBACKS.set(var0);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> CGLIB$SET_STATIC_CALLBACKS(Callback[] var0) &#123;</span><br><span class="line">        CGLIB$STATIC_CALLBACKS = var0;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">void</span> CGLIB$BIND_CALLBACKS(Object var0) &#123;</span><br><span class="line">        PersonService$$EnhancerByCGLIB$$470f9603 var1 = (PersonService$$EnhancerByCGLIB$$470f9603)var0;</span><br><span class="line">        <span class="keyword">if</span> (!var1.CGLIB$BOUND) &#123;</span><br><span class="line">            var1.CGLIB$BOUND = <span class="keyword">true</span>;</span><br><span class="line">            Object var10000 = CGLIB$THREAD_CALLBACKS.get();</span><br><span class="line">            <span class="keyword">if</span> (var10000 == <span class="keyword">null</span>) &#123;</span><br><span class="line">                var10000 = CGLIB$STATIC_CALLBACKS;</span><br><span class="line">                <span class="keyword">if</span> (var10000 == <span class="keyword">null</span>) &#123;</span><br><span class="line">                    <span class="keyword">return</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            var1.CGLIB$CALLBACK_0 = (MethodInterceptor)((Callback[])var10000)[<span class="number">0</span>];</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">newInstance</span><span class="params">(Callback[] var1)</span> </span>&#123;</span><br><span class="line">        CGLIB$SET_THREAD_CALLBACKS(var1);</span><br><span class="line">        PersonService$$EnhancerByCGLIB$$470f9603 var10000 = <span class="keyword">new</span> PersonService$$EnhancerByCGLIB$$470f9603();</span><br><span class="line">        CGLIB$SET_THREAD_CALLBACKS((Callback[])<span class="keyword">null</span>);</span><br><span class="line">        <span class="keyword">return</span> var10000;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">newInstance</span><span class="params">(Callback var1)</span> </span>&#123;</span><br><span class="line">        CGLIB$SET_THREAD_CALLBACKS(<span class="keyword">new</span> Callback[]&#123;var1&#125;);</span><br><span class="line">        PersonService$$EnhancerByCGLIB$$470f9603 var10000 = <span class="keyword">new</span> PersonService$$EnhancerByCGLIB$$470f9603();</span><br><span class="line">        CGLIB$SET_THREAD_CALLBACKS((Callback[])<span class="keyword">null</span>);</span><br><span class="line">        <span class="keyword">return</span> var10000;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">newInstance</span><span class="params">(Class[] var1, Object[] var2, Callback[] var3)</span> </span>&#123;</span><br><span class="line">        CGLIB$SET_THREAD_CALLBACKS(var3);</span><br><span class="line">        PersonService$$EnhancerByCGLIB$$470f9603 var10000 = <span class="keyword">new</span> PersonService$$EnhancerByCGLIB$$470f9603;</span><br><span class="line">        <span class="keyword">switch</span>(var1.length) &#123;</span><br><span class="line">        <span class="keyword">case</span> <span class="number">0</span>:</span><br><span class="line">            var10000.&lt;init&gt;();</span><br><span class="line">            CGLIB$SET_THREAD_CALLBACKS((Callback[])<span class="keyword">null</span>);</span><br><span class="line">            <span class="keyword">return</span> var10000;</span><br><span class="line">        <span class="keyword">default</span>:</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">&quot;Constructor not found&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Callback <span class="title">getCallback</span><span class="params">(<span class="keyword">int</span> var1)</span> </span>&#123;</span><br><span class="line">        CGLIB$BIND_CALLBACKS(<span class="keyword">this</span>);</span><br><span class="line">        MethodInterceptor var10000;</span><br><span class="line">        <span class="keyword">switch</span>(var1) &#123;</span><br><span class="line">        <span class="keyword">case</span> <span class="number">0</span>:</span><br><span class="line">            var10000 = <span class="keyword">this</span>.CGLIB$CALLBACK_0;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">default</span>:</span><br><span class="line">            var10000 = <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> var10000;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setCallback</span><span class="params">(<span class="keyword">int</span> var1, Callback var2)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">switch</span>(var1) &#123;</span><br><span class="line">        <span class="keyword">case</span> <span class="number">0</span>:</span><br><span class="line">            <span class="keyword">this</span>.CGLIB$CALLBACK_0 = (MethodInterceptor)var2;</span><br><span class="line">        <span class="keyword">default</span>:</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> Callback[] getCallbacks() &#123;</span><br><span class="line">        CGLIB$BIND_CALLBACKS(<span class="keyword">this</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> Callback[]&#123;<span class="keyword">this</span>.CGLIB$CALLBACK_0&#125;;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setCallbacks</span><span class="params">(Callback[] var1)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.CGLIB$CALLBACK_0 = (MethodInterceptor)var1[<span class="number">0</span>];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        CGLIB$STATICHOOK1();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>看到</p>
<ul>
<li>生成的代理类直接继承了<code>Service</code>类</li>
<li>方法拦截都是通过<code>MethodInterceptor</code></li>
<li>构建<code>MethodProxy</code>传入，用于真实方法的调用。</li>
</ul>
<p>注意：<code>MethodInterceptor</code>中如果直接调用Method，会造成堆栈溢出。必须通过<code>MethodProxy.invokeSuper()</code>方法调用才行。</p>
<h3 id="小结-1"><a href="#小结-1" class="headerlink" title="小结"></a>小结</h3><p>CGlib是基于ASM进行字节码生成的，在使用上会简单很多。</p>
<h2 id="区别"><a href="#区别" class="headerlink" title="区别"></a>区别</h2><p>可以看到，无论是JDK动态代理，还是CGlib，最终都是生成了代理类的字节码，并将其加载为新的类。从这个角度上看，貌似没啥区别呀？理论上，JDK的动态代理也可以设计成CGlib那样，直接基于类生成代理子类，就像<a href="https://blog.csdn.net/qq_34173920/article/details/105504407">有人做的那样</a>。很多人说，JDK动态代理只能基于接口，是因为代理类继承了Proxy，而Java是单继承，没有办法再继承用户自定义类，我认为这个说法因果倒置了，都说了，如果想要继承自定义类，是能够办到的。对于这个问题，我的看法是JDK设计者故意为之，至于原因嘛，我也不大说得上来（说到底，还是菜）。</p>
<p>JDK代理和CGlib代理的区别，除了API使用上，更重要的是字节码生成方式上的区别：前者凭空生成；后者使用ASM基于被代理类生成。</p>
<p>都是生成，区别在于生成的效率以及生成的代理类的效率。这又涉及到谁效率高的问题了。用JMH大概试一试吧。我们用几乎一样的被代理类，生成代理类，调用方法。测试每个操作所耗费的时间。</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="comment">///////////////////////CGlib的测试case</span></span><br><span class="line"><span class="keyword">open</span> <span class="class"><span class="keyword">class</span> <span class="title">PersonService</span> </span>&#123;</span><br><span class="line">    <span class="keyword">open</span> <span class="function"><span class="keyword">fun</span> <span class="title">sayHello</span><span class="params">()</span></span> &#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">tryMethodInterceptor</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">val</span> enhancer = Enhancer()</span><br><span class="line">    enhancer.setSuperclass(PersonService::<span class="keyword">class</span>.java)</span><br><span class="line">    enhancer.setCallback(MethodInterceptor &#123; obj, method, args, proxy -&gt;</span><br><span class="line">        <span class="keyword">if</span> (method.name == <span class="string">&quot;sayHello&quot;</span>) &#123;</span><br><span class="line">            proxy.invokeSuper(obj, args)</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="literal">null</span></span><br><span class="line">    &#125;)</span><br><span class="line">    (enhancer.create() <span class="keyword">as</span> PersonService).sayHello()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">///////////////////////JDK的测试CASE</span></span><br><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">Service</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">sayHello</span><span class="params">()</span></span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ActualService</span> : <span class="type">Service &#123;</span></span></span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">sayHello</span><span class="params">()</span></span> &#123; &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyHandler</span></span>(<span class="keyword">private</span> <span class="keyword">val</span> service: Service) : InvocationHandler &#123;</span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">invoke</span><span class="params">(proxy: <span class="type">Any</span>, method: <span class="type">Method</span>, args: <span class="type">Array</span>&lt;<span class="type">out</span> <span class="type">Any</span>&gt;?)</span></span>: Any? &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">if</span> (method.name == <span class="string">&quot;sayHello&quot;</span>) &#123;</span><br><span class="line">            method.invoke(service)</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="literal">null</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">testJDKProxy</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">val</span> proxy = Proxy.newProxyInstance(</span><br><span class="line">        Service::<span class="keyword">class</span>.java.classLoader,</span><br><span class="line">        arrayOf(Service::<span class="keyword">class</span>.java),</span><br><span class="line">        MyHandler(ActualService())</span><br><span class="line">    )</span><br><span class="line">    (proxy <span class="keyword">as</span> Service).sayHello()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">///////////////////////测试代码：测试各执行100次，平均每次耗时多少</span></span><br><span class="line"><span class="meta">@Fork(1)</span></span><br><span class="line"><span class="meta">@Threads(10)</span></span><br><span class="line"><span class="meta">@Warmup(iterations = 1)</span></span><br><span class="line"><span class="meta">@State(Scope.Benchmark)</span></span><br><span class="line"><span class="meta">@BenchmarkMode(Mode.AverageTime)</span></span><br><span class="line"><span class="meta">@OutputTimeUnit(TimeUnit.MILLISECONDS)</span></span><br><span class="line"><span class="keyword">open</span> <span class="class"><span class="keyword">class</span> <span class="title">JMHWarm</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Param(<span class="meta-string">&quot;100&quot;</span>)</span></span><br><span class="line">    <span class="keyword">var</span> count: <span class="built_in">Int</span> = <span class="number">0</span></span><br><span class="line"></span><br><span class="line">    <span class="meta">@Benchmark</span></span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">testJDK</span><span class="params">()</span></span> &#123;</span><br><span class="line">        <span class="keyword">for</span> (i <span class="keyword">in</span> <span class="number">1.</span>.count) &#123;</span><br><span class="line">            testJDKProxy()</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Benchmark</span></span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">testCGlib</span><span class="params">()</span></span> &#123;</span><br><span class="line">        <span class="keyword">for</span> (i <span class="keyword">in</span> <span class="number">1.</span>.count) &#123;</span><br><span class="line">            tryMethodInterceptor()</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">val</span> option = OptionsBuilder()</span><br><span class="line">        .include(JMHWarm::<span class="keyword">class</span>.simpleName)</span><br><span class="line">        .resultFormat(ResultFormatType.JSON)</span><br><span class="line">        .build()</span><br><span class="line">    Runner(option).run()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>对于上面的case，当只保留代理类创建逻辑时，测试结果</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">Benchmark          (count)  Mode  Cnt  Score    Error  Units</span><br><span class="line">JMHWarm.testCGlib      100  avgt    5  0.001 ±  0.001  ms/op</span><br><span class="line">JMHWarm.testJDK        100  avgt    5  0.004 ±  0.002  ms/op</span><br></pre></td></tr></table></figure>

<p>当同时保留创建和方法调用逻辑时，测试结果</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">Benchmark          (count)  Mode  Cnt  Score   Error  Units</span><br><span class="line">JMHWarm.testCGlib      100  avgt    5  0.028 ± 0.002  ms/op</span><br><span class="line">JMHWarm.testJDK        100  avgt    5  0.006 ± 0.001  ms/op</span><br></pre></td></tr></table></figure>

<p>当前这样的基准测试是不准确的，但还是大致可以得出代理类的创建CGlib比JDK快，但调用上JDK更快。快多少？快不了多少。</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>按照本文的方式来探索动态代理，还是远远不够的，要想把这一块理解透彻，说到底，还是要对JVM有深入的研究，也就是说，还需要继续探索的点</p>
<ul>
<li><p>ASM库的使用、深入理解</p>
</li>
<li><p>类加载的深入研究，ClassLoader类的剖析</p>
</li>
<li><p>sun.misc.Unsafe类的深入研究</p>
</li>
<li><p>JVM的深入研究</p>
</li>
</ul>
]]></content>
      <categories>
        <category>编程语言</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>反射</tag>
      </tags>
  </entry>
  <entry>
    <title>用notion构建个人任务管理工作流</title>
    <url>/2022/04/13/%E7%94%A8notion%E6%9E%84%E5%BB%BA%E4%BB%BB%E5%8A%A1%E7%AE%A1%E7%90%86%E5%B7%A5%E4%BD%9C%E6%B5%81/</url>
    <content><![CDATA[<blockquote>
<p>项目开发时，会将整个项目各生命周期工作一一列出，总体规划，使得进度可控。</p>
<p>对个人而言，是一样的道理。凡是预则立，不预则废。想做的事很多，东一榔头西一锤子不是办法，得有规划。</p>
<p>最近发现之前基于notion构建的计划模板已经不够用了，于是又折腾个新版本。</p>
</blockquote>
<p>总的来看，我的个人任务管理大概分为三个阶段</p>
<ul>
<li>阶段零：使用有道云笔记做简单记录，列举近期要做的事项，极其简单，相当于没有规划</li>
<li>阶段一：使用notion做了一个年度计划、月计划、周计划模板，预先填好一周要做的事，做完后勾掉</li>
<li>阶段二：使用notion一年半后，根据新需求基于notion的database重新构建的任务模板</li>
</ul>
<span id="more"></span>

<h1 id="旧的方式"><a href="#旧的方式" class="headerlink" title="旧的方式"></a>旧的方式</h1><p>阶段零已经很久远了，无从考证。阶段一的月计划模板大概如下。</p>
<p><img src="https://gdz.oss-cn-shenzhen.aliyuncs.com/local/image-20220413233852108.png" alt="image-20220413233852108"></p>
<p>它主要有一下几个方面</p>
<ul>
<li><p>月度目标：列出了本月期望达成的目标</p>
</li>
<li><p>本月书单：本月待看书籍</p>
</li>
<li><p>本月片单：本月待看电影</p>
</li>
<li><p>本月博客：本月待写博客</p>
</li>
<li><p>周计划：本周每天预计的任务，比如下面是三月第四周的任务规划及完成情况</p>
<p><img src="https://gdz.oss-cn-shenzhen.aliyuncs.com/local/image-20220413234420173.png" alt="image-20220413234420173"></p>
</li>
<li><p>临时记录：记录一下临时想法</p>
</li>
<li><p>四象限图：一个任务池，按照任务的优先级程度放在里面，周计划中的任务从其中拖动而来。展开大概是这样</p>
<p><img src="https://gdz.oss-cn-shenzhen.aliyuncs.com/local/image-20220413234516957.png"></p>
</li>
</ul>
<h2 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h2><p>这种方式总体还算不错，但有一个很大的问题：随着时间的增长，任务池累积得越来越多。本月书单、本月博客、本月片单的量在增大，远远不是本月能够完成的；四象限图任务池中的任务开始爆炸，很多任务可能半年也排不上号。这些情况，会让执行时失焦，还会产生焦虑。因此有待解决。</p>
<p>而且，这种管理方式，解决的是极短期规划和永久记录的问题，并不能解决长久规划的问题。</p>
<h1 id="新的方式"><a href="#新的方式" class="headerlink" title="新的方式"></a>新的方式</h1><h2 id="需求分析"><a href="#需求分析" class="headerlink" title="需求分析"></a>需求分析</h2><p>一言以蔽之，想要的其实就是个人版的任务管理工具。即个人版的TAPD。</p>
<ul>
<li>任务需要有几个属性：优先级、计划开始时间、计划结束时间。优先级用于判断紧急程度；开始结束时间用于长期规划</li>
<li>支持甘特图：能够直观地看到任务排期</li>
<li>支持看板：它取代前一个版本周计划的作用。随时能够知道当前需要做的事</li>
</ul>
<h2 id="工具选择"><a href="#工具选择" class="headerlink" title="工具选择"></a>工具选择</h2><p>市面上工具超多：Things、Todoist、Omini Focus、Agenda，更进一步的有Trello等，不过前面说的这些在甘特图这一点上无法满足。当然也可以选择各种table：黑怕云(停服了)、明道云、Foxtable(还不支持甘特图)。想了一圈，想起来notion的database有timeline视图，就是简单的甘特图呀。</p>
<p>用notion还有一个最大的好处：block关联和page关联。输出的文档可直接关联到对应任务。</p>
<h2 id="总体设计-思路"><a href="#总体设计-思路" class="headerlink" title="总体设计 - 思路"></a>总体设计 - 思路</h2><p><strong>分级</strong></p>
<p>任何<strong>具体任务</strong>，都服务于更<strong>高一级的任务</strong>，背后都有一个更高级的<strong>目标</strong>。这其实可以结合OKR和目标笔记的想法，创建三个database。</p>
<ul>
<li>目标：想要达成的目的，比如每记开发</li>
<li>一级拆分：相对大块和抽象的拆分，比如针对测试的重构</li>
<li>具体任务：能够用来实施的最小单位，比如添加同步逻辑的测试代码。所有的任务规划、状态转移都在这个层级上操作。</li>
</ul>
<p><img src="https://gdz.oss-cn-shenzhen.aliyuncs.com/local/image-20220414002005304.png" alt="image-20220414002005304"></p>
<p><strong>状态转移</strong></p>
<p>将任务分为如下几种状态</p>
<ul>
<li><p>暂缓</p>
<p>已加入任务池，但还没有计划执行</p>
</li>
<li><p>就绪</p>
<p>任务已准备就绪，待执行。执行中的任务清空后，将此状态的任务流转过去</p>
</li>
<li><p>执行中</p>
<p>执行中的任务</p>
</li>
<li><p>长期执行中</p>
<p>当一个任务在执行中停留太久，流转到长期执行中</p>
</li>
<li><p>回顾中</p>
<p>任务已执行完成，但还没做回顾，如笔记整理等。</p>
</li>
<li><p>已完成</p>
<p>彻底做完的任务</p>
</li>
</ul>
<h2 id="构建"><a href="#构建" class="headerlink" title="构建"></a>构建</h2><p>构建效果如下：</p>
<h3 id="database-1-目标"><a href="#database-1-目标" class="headerlink" title="database 1 - 目标"></a>database 1 - 目标</h3><p>目标只包含名称和简要描述：</p>
<p><img src="https://gdz.oss-cn-shenzhen.aliyuncs.com/local/image-20220414002147488.png" alt="image-20220414002147488"></p>
<h3 id="database-2-任务分类"><a href="#database-2-任务分类" class="headerlink" title="database 2 - 任务分类"></a>database 2 - 任务分类</h3><p>任务分类与目标，是多对一的关系</p>
<p><img src="https://gdz.oss-cn-shenzhen.aliyuncs.com/local/image-20220414002214045.png" alt="image-20220414002214045"></p>
<h3 id="database-3-任务池"><a href="#database-3-任务池" class="headerlink" title="database 3 - 任务池"></a>database 3 - 任务池</h3><p>任务池是重点</p>
<ul>
<li>与任务分类是多对一的关系</li>
<li>包含字段：重要性、执行状态、分类、计划时间段、文档关联、完成时间等。<ul>
<li>执行状态上面已经说过了，就那几种</li>
<li>重要性即四象限图</li>
<li>任务分类，用于标识任务另一个层级的重要性：不同类型的任务所产生的影响是不一样的，工作任务和学习任务要均衡</li>
<li>计划时间段，用于做规划，甘特图依据此</li>
<li>完成时间，只为得到一个完成日历。它是有计划时间段列公式计算得来，取得是其结束时间。</li>
</ul>
</li>
</ul>
<p><img src="https://gdz.oss-cn-shenzhen.aliyuncs.com/local/image-20220414002238962.png" alt="image-20220414002238962"></p>
<p>后面介绍基于database 3构建的各种视图</p>
<h3 id="database-3-甘特图"><a href="#database-3-甘特图" class="headerlink" title="database 3 - 甘特图"></a>database 3 - 甘特图</h3><p>这是最需要的功能，在时间跨度上对所有任务进行规划。</p>
<p><img src="https://gdz.oss-cn-shenzhen.aliyuncs.com/local/image-20220414002949572.png" alt="image-20220414002949572"></p>
<h3 id="database-3-状态看板"><a href="#database-3-状态看板" class="headerlink" title="database 3 - 状态看板"></a>database 3 - 状态看板</h3><p>这里可以清除地看到当前应该做什么。关注的是：执行中、长期执行中、回顾中三项</p>
<p><img src="https://gdz.oss-cn-shenzhen.aliyuncs.com/local/image-20220414003113294.png" alt="image-20220414003113294"></p>
<h3 id="database-3-完成日历"><a href="#database-3-完成日历" class="headerlink" title="database 3 - 完成日历"></a>database 3 - 完成日历</h3><p>这个视图主要用于回顾工作用。写年中总结、季度汇报时，从这里能够方便地知道自己做了什么。</p>
<p><img src="https://gdz.oss-cn-shenzhen.aliyuncs.com/local/image-20220414003258173.png" alt="image-20220414003258173"></p>
<h1 id="Notion-tips"><a href="#Notion-tips" class="headerlink" title="Notion tips"></a>Notion tips</h1><p>Notion比你想象中的强大，却也每那么强。折腾过程中几个值得分享的点。</p>
<ul>
<li><p>使用Notion Enhancer。有它和没它，真的差很多，几个功能点还挺好用</p>
<p><img src="https://gdz.oss-cn-shenzhen.aliyuncs.com/local/image-20220414004222259.png" alt="image-20220414004222259"></p>
<ul>
<li>悬浮侧边栏，解决了notion不支持目录固定的问题</li>
<li>缩进提示线，不再头晕</li>
<li>界面缩放，可以显示更多内容</li>
<li>字数统计</li>
<li>增强icon库</li>
<li>代码行号</li>
<li>一键回到顶部</li>
</ul>
</li>
<li><p>使用分栏，让目录更加简洁</p>
<img src="https://gdz.oss-cn-shenzhen.aliyuncs.com/local/image-20220414004312890.png" alt="image-20220414004312890" style="zoom:80%;" /></li>
<li><p>为每个页面设置图标，而不是默认图，感官好很多。有了notion enhancer，图标的选择也更加多样。如果不够用，可以<a href="https://icons8.com/icons/set/go">从这里找</a></p>
<img src="https://gdz.oss-cn-shenzhen.aliyuncs.com/local/image-20220414004442685.png" alt="image-20220414004442685" style="zoom:80%;" /></li>
<li><p>尽可能使用引用，方便很多</p>
</li>
</ul>
]]></content>
      <categories>
        <category>方法论</category>
      </categories>
      <tags>
        <tag>notion</tag>
        <tag>任务管理</tag>
      </tags>
  </entry>
  <entry>
    <title>理解Java IO</title>
    <url>/2020/04/19/%E7%90%86%E8%A7%A3Java%20IO-%E7%90%86%E8%A7%A3javaio/</url>
    <content><![CDATA[<p>BIO、NIO、NIO2、AIO、Reactor、Proactor、EventLoop、Linux五种IO模型</p>
<p>上述术语和概念，相信大多数人都知道或部分知道，但都无法完整表达他们之间的意思，处于模棱两可的状态。我也不例外，而触发写这篇文章的契机，是有人问起我Vertx高性能的原因是什么时？我不假思索地回答NIO，因为在我的印象中，Vertx基于Netty实现，Netty又是对NIO的包装。但仔细想想，用NIO就能高性能吗？NIO和Vertx的EventLoop有什么关系呢？和Reactor又是什么关系呢？——我不禁开始思考人生。</p>
<p>下面就开始探索吧</p>
<span id="more"></span>

<h1 id="疑问"><a href="#疑问" class="headerlink" title="疑问"></a>疑问</h1><p>带着疑问探索是最有效手段。本文专注于搞懂如下几个问题</p>
<ol>
<li>Java中的各种IO概念是怎么回事？</li>
<li>Linux五种IO模型，以及他们和Java IO的关系？</li>
<li>Netty和NIO？</li>
<li>Java IO和Reactor设计模式的关系？</li>
</ol>
<h1 id="Java的IO"><a href="#Java的IO" class="headerlink" title="Java的IO"></a>Java的IO</h1><p>截止目前，Java的IO有三种：BIO、NIO、NIO2(AIO)，他们被引入的时间点如下。</p>
<ul>
<li>JDK 1.0 - JDK1.3 Java都只有BIO，很多Unix的概念或接口在其库中都没有体现。</li>
<li>2002年发布JDK 1.4，增加java.nio包，主要引入了支持异步操作的各种核心类库：管道、缓冲区、Channel、Selector等。</li>
<li>2011年发布JDK 1.7，对原来的NIO包进行了升级，称为NIO2.0，主要提供了AIO功能。</li>
</ul>
<h2 id="BIO"><a href="#BIO" class="headerlink" title="BIO"></a>BIO</h2><p>即传统的Socket API，很多Java程序员的第一个网络程序就是BIO。BIO的问题是数据的读取会阻塞线程，提升性能的方式是引入多线程，而系统能够启动线程的数量有限，不可避免会引入线程池，而线程池又会造成并发处理请求不够多，从而限制吞吐量。且线程切换费时费力，浪费CPU资源。因此在处理高并发网络请求时BIO是不堪重任的。</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="keyword">val</span> PORT = <span class="number">9090</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">val</span> serverSocket = ServerSocket(PORT)</span><br><span class="line"></span><br><span class="line">  <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">    <span class="keyword">val</span> socket = serverSocket.accept()</span><br><span class="line">    <span class="keyword">val</span> inputStream = socket.getInputStream()</span><br><span class="line">    <span class="keyword">val</span> outputStream = socket.getOutputStream()</span><br><span class="line"></span><br><span class="line">    <span class="keyword">val</span> reader = BufferedReader(InputStreamReader(inputStream))</span><br><span class="line">    <span class="keyword">val</span> writer = PrintWriter(OutputStreamWriter(outputStream))</span><br><span class="line"></span><br><span class="line">    <span class="keyword">val</span> line = reader.readLine()</span><br><span class="line">    writer.println(line)</span><br><span class="line">    writer.flush()</span><br><span class="line"></span><br><span class="line">    writer.close()</span><br><span class="line">    socket.close()</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="NIO"><a href="#NIO" class="headerlink" title="NIO"></a>NIO</h2><p>Java NIO引入了多路选择器Selector、通道Channel、缓存区ByteBuffer的概念。通过轮询选择器的方式获取准备好的Channel，数据读取均采用ByteBuffer。</p>
<p>在使用上我们只需要在多路选择器上注册感兴趣的Channel，然后不断轮训该选择器，每当通道就绪时，我们再处理对应的事件，可响应的事件如下</p>
<ul>
<li><p>ACCEPT</p>
<p>服务端事件，表示有客户端连接</p>
</li>
<li><p>CONNCET</p>
<p>客户端时间，表示已经连接到服务端</p>
</li>
<li><p>READ</p>
<p>系统已将数据读取到缓冲区，触发该事件，我们从缓冲区读取数据即可。</p>
</li>
<li><p>WRITE</p>
<p>系统检查缓冲区是否可写，如果可写，触发该事件，我们向缓冲区写入即可。</p>
</li>
</ul>
<p>典型的示例如下。与BIO相比，NIO为我们节省了阻塞等待读取数据的时间，数据不再是我们阻塞等待，而是交给系统读取到执行位置(缓冲区)，我们再直接从缓冲区读取。</p>
<p>NIO的缺点是使用过于复杂，且存在空轮训的bug。</p>
<p>注意NIO != 高性能，当连接数小于1000、并发程度不高时，NIO并没有显著的性能优势。</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 这里使用了两个Selector，其实也完全可以仅仅使用一个Selector进行轮训</span></span><br><span class="line"><span class="comment"> * JDK 的 NIO 底层由 epoll 实现，该实现饱受诟病的空轮询 bug 会导致 cpu 飙升 100%</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">  <span class="comment">// 用于轮询是否有新的连接，当产生新的连接时，将新连接绑定在client selector上进行数据轮训</span></span><br><span class="line">  <span class="keyword">val</span> serverSelector = Selector.<span class="keyword">open</span>()</span><br><span class="line">  <span class="comment">// 轮训连接是否有数据可读</span></span><br><span class="line">  <span class="keyword">val</span> clientSelector = Selector.<span class="keyword">open</span>()</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 处理连接</span></span><br><span class="line">  Thread &#123;</span><br><span class="line">    <span class="keyword">val</span> serverChannel = ServerSocketChannel.<span class="keyword">open</span>()</span><br><span class="line">    serverChannel.socket().bind(InetSocketAddress(<span class="number">9090</span>))</span><br><span class="line">    serverChannel.configureBlocking(<span class="literal">false</span>)</span><br><span class="line">    serverChannel.register(serverSelector, SelectionKey.OP_ACCEPT)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">      <span class="keyword">if</span> (serverSelector.select(<span class="number">1</span>) &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">val</span> it = serverSelector.selectedKeys().iterator()</span><br><span class="line">        <span class="keyword">while</span> (it.hasNext()) &#123;</span><br><span class="line">          <span class="keyword">val</span> key = it.next()</span><br><span class="line">          <span class="keyword">if</span> (key.isAcceptable) &#123;</span><br><span class="line">            <span class="keyword">val</span> clientChannel = (key.channel() <span class="keyword">as</span> ServerSocketChannel).accept()</span><br><span class="line">            clientChannel.configureBlocking(<span class="literal">false</span>)</span><br><span class="line">            clientChannel.register(clientSelector, SelectionKey.OP_READ)</span><br><span class="line">          &#125;</span><br><span class="line">          it.remove()</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;.start()</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 处理数据</span></span><br><span class="line">  Thread &#123;</span><br><span class="line">    <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">      <span class="keyword">if</span> (clientSelector.select(<span class="number">1</span>) &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">val</span> it = clientSelector.selectedKeys().iterator()</span><br><span class="line">        <span class="keyword">while</span> (it.hasNext()) &#123;</span><br><span class="line">          <span class="keyword">val</span> key = it.next()</span><br><span class="line">          <span class="keyword">if</span> (key.isReadable) &#123;</span><br><span class="line">            <span class="keyword">val</span> clientChannel = key.channel() <span class="keyword">as</span> SocketChannel</span><br><span class="line">            <span class="keyword">val</span> byteBuffer = ByteBuffer.allocate(<span class="number">1024</span>)</span><br><span class="line">            clientChannel.read(byteBuffer)</span><br><span class="line">            byteBuffer.flip()</span><br><span class="line">            clientChannel.write(byteBuffer)</span><br><span class="line">            byteBuffer.clear()</span><br><span class="line">            clientChannel.close()</span><br><span class="line">          &#125;</span><br><span class="line">          it.remove()</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;.start()</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="NIO2-AIO"><a href="#NIO2-AIO" class="headerlink" title="NIO2 (AIO)"></a>NIO2 (AIO)</h2><p>NIO2是对NIO的一次升级，但因其主要引入了异步调用IO——AIO，因此也把NIO2称为AIO。对熟悉异步编程的同学，AIO的编程方式是非常自然的，它只需要开启服务器并注册数据处理器即可，系统负责读取数据并调用处理器，整个过程异步。</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">  <span class="keyword">val</span> server = AsynchronousServerSocketChannel.<span class="keyword">open</span>().bind(InetSocketAddress(<span class="number">9090</span>))</span><br><span class="line"></span><br><span class="line">  <span class="keyword">val</span> obj: CompletionHandler&lt;AsynchronousSocketChannel, Any?&gt; = <span class="keyword">object</span> : CompletionHandler&lt;AsynchronousSocketChannel, Any?&gt; &#123;</span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">completed</span><span class="params">(channel: <span class="type">AsynchronousSocketChannel</span>, attachment: <span class="type">Any</span>?)</span></span> &#123;</span><br><span class="line"></span><br><span class="line">      server.accept(<span class="literal">null</span> <span class="keyword">as</span> Any?, <span class="keyword">this</span>)</span><br><span class="line"></span><br><span class="line">      <span class="keyword">val</span> buffer = ByteBuffer.allocate(<span class="number">1024</span>)</span><br><span class="line">      channel.read(buffer).<span class="keyword">get</span>(<span class="number">100</span>, TimeUnit.MILLISECONDS)</span><br><span class="line">      buffer.flip()</span><br><span class="line">      channel.write(buffer)</span><br><span class="line">      channel.close()</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">failed</span><span class="params">(exc: <span class="type">Throwable</span>?, attachment: <span class="type">Any</span>?)</span></span> &#123;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  server.accept(<span class="literal">null</span> <span class="keyword">as</span> Any?, obj)</span><br><span class="line"></span><br><span class="line">  Thread.sleep(<span class="number">1000000000</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="疑问-1"><a href="#疑问-1" class="headerlink" title="疑问"></a>疑问</h2><p>如果只是学习Java的三种IO API，肯定会有很多疑问</p>
<ul>
<li>为什么会有这三种API？</li>
<li>如果我们不阻塞等待数据，而让系统做，那系统就不会阻塞CPU了吗？还有，系统是谁？JVM还是宿主机（Linux、Window server）</li>
</ul>
<p>这里可以简要回答</p>
<ul>
<li>这三种API分别对应Linux的三种IO模型，Java的IO只是对操作系统IO模型的封装。提供这三种API可以仅看成是提供了三种产品，供用户选择。起初Java只提供了BIO，因此在高并发网络编程领域无法站住，提供了NIO后就提供了高并发网络编程的支持。</li>
<li>系统不会阻塞CPU，因为这是IO操作。以网络IO为例，数据读取时，网卡负责接收信号并解析成数据，然后转移到系统内核中，这个过程可以由硬件完成，而BIO读取的等待，就是在等待网卡接收信号并将数据导入系统内核的时间；NIO将这一步等待从用户程序中去除，但用户依然负责从系统内核到用户数据区的数据转移；而AIO中，用户连这一步转义都不需要，系统直接将数据处理到一个内核和用户数据共享的区域，通知用户程序处理即可。</li>
</ul>
<p>要进一步了解，就需要对Linux的网络编程方式及常见IO模型进行了解</p>
<h1 id="Linux的IO模型"><a href="#Linux的IO模型" class="headerlink" title="Linux的IO模型"></a>Linux的IO模型</h1><h2 id="基础"><a href="#基础" class="headerlink" title="基础"></a>基础</h2><p>Linux中网络程序设计完全靠套接字接受和发送消息，Socket是一个接口，它在系统中的位置如下。</p>
<p><img src="https://gdz.oss-cn-shenzhen.aliyuncs.com/hexo/%E7%90%86%E8%A7%A3Java-IO/image-20200419135156288.png" alt="image-20200419135156288"></p>
<p>即意味着，只要在Linux系统上运行的网络程序，其在操作系统层面的操作都是需要通过Socket进行的。通过scoket进行通讯的服务端和客户端调用流程如下，注意其read()、write()等都是Linux提供的方法。</p>
<p><img src="https://gdz.oss-cn-shenzhen.aliyuncs.com/hexo/%E7%90%86%E8%A7%A3Java-IO/image-20200419135442933.png" alt="image-20200419135442933"></p>
<p>Linux/UNIX系统中，有如下五种IO模式</p>
<ul>
<li>阻塞I/O</li>
<li>非阻塞I/O</li>
<li>I/O多路复用</li>
<li>信号驱动I/O（SIGIO）</li>
<li>异步I/O</li>
</ul>
<p>对于一个套接字的输入操作，总的来说一般分为两步。这是大前提，五种IO模式都是在这上面做文章的。</p>
<ul>
<li>等待数据从网络到达本地，当数据到达后，系统将数据从网络层拷贝到内核的缓存</li>
<li>将数据从内核的缓存拷贝到应用程序的数据区中</li>
</ul>
<h2 id="阻塞I-O"><a href="#阻塞I-O" class="headerlink" title="阻塞I/O"></a>阻塞I/O</h2><p>缺省模式，一个socket建立后自动处于阻塞I/O模式。如下图，阻塞I/O大致流程为</p>
<ul>
<li>调用recvfrom发起数据接收</li>
<li>内核尚未收到数据，于是阻塞等待</li>
<li>内核收到数据（数据到了内核缓存），将数据从内核缓存拷贝到应用程序数据区</li>
<li>拷贝完成，recvfrom返回，应用程序处理数据</li>
</ul>
<p><img src="https://gdz.oss-cn-shenzhen.aliyuncs.com/hexo/%E7%90%86%E8%A7%A3Java-IO/image-20200419135918743.png" alt="image-20200419135918743"></p>
<h2 id="非阻塞I-O"><a href="#非阻塞I-O" class="headerlink" title="非阻塞I/O"></a>非阻塞I/O</h2><p>设置为此模式后，相当于告诉内核：当我请求的IO不能马上返回时，不要让我的进程进入休眠，而是返回一个错误给我。而为了能够及时收到数据，应用程序需要循环调用recevfrom来测试一个文件描述符（创建socket时生成）是否有数据可读。这称作polling。应用程序不停滴polling是一个浪费CPU的操作，因此这种模式不是很普遍。</p>
<ul>
<li>调用recvfrom发起数据接收</li>
<li>内核尚未收到数据，响应应用程序EWOULDBLOCK错误，而内核自己则继续等待数据</li>
<li>多次调用recvfrom询问内核数据是否准备好。</li>
<li>当数据终于准备好时，内核将数据拷贝到应用程序数据区，返回recvfrom</li>
<li>应用程序处理数据</li>
</ul>
<p><img src="https://gdz.oss-cn-shenzhen.aliyuncs.com/hexo/%E7%90%86%E8%A7%A3Java-IO/image-20200419135944879.png" alt="image-20200419135944879"></p>
<h2 id="I-O多路复用"><a href="#I-O多路复用" class="headerlink" title="I/O多路复用"></a>I/O多路复用</h2><p>此模式下，在开始接收数据之前，我们不是调用recvfrom函数，而是调用select函数或poll函数，当他们有响应时，再调用recvfrom接收数据，调用select函数时也会阻塞，但它的优点在于，能够同时等待多个文件描述符，只要有一个准备好了，select就会返回。I/O多路复用经常被使用。</p>
<ul>
<li>调用select，阻塞等待直到有文件描述符的数据就绪</li>
<li>有就绪的文件描述符，select返回，应用程序调用recvfrom接收数据</li>
<li>内核将数据拷贝到应用程序数据区，返回recvfrom</li>
<li>应用程序处理数据</li>
</ul>
<p><img src="https://gdz.oss-cn-shenzhen.aliyuncs.com/hexo/%E7%90%86%E8%A7%A3Java-IO/image-20200419140010012.png" alt="image-20200419140010012"></p>
<ul>
<li><p>关于select</p>
<p>select函数可以同时监视多个套接字，它能够告诉你哪一个套接字已经可以读取数据、哪一个套接字已经可以写入数据、哪一个套接字出现了错误等。</p>
</li>
<li><p>epoll</p>
<p>select和poll的使用有较大的局限性，无法满足并发量特别高的情况，epoll是对他们的增强。增强的原理这里不深究。</p>
</li>
</ul>
<h2 id="信号驱动I-O"><a href="#信号驱动I-O" class="headerlink" title="信号驱动I/O"></a>信号驱动I/O</h2><p>该模式将内核等待数据这段时间变主动为被动，在数据就绪时使用SIGIO（或SIGPOLL）信号通知我们。</p>
<p>使用方法上，让套接字工作在信号驱动I/O工作模式中，并安装一个SIGIO处理函数。这样在内核等待数据期间我们就是完全异步的情况了。只需要在SIGIO处理函数中接收数据处理即可。</p>
<ul>
<li>创建套接字，允许工作在信号驱动模式，并注册SIGIO信号处理函数</li>
<li>内核数据就绪后，响应SIGIO信号</li>
<li>事先注册的SIGIO处理函数中调用recvfrom函数</li>
<li>内核将数据拷贝到应用程序数据区，返回recvfrom</li>
<li>应用程序处理数据</li>
</ul>
<p>信号驱动I/O的编程有一个最大的难点是除了数据就绪外，还有很多触发SIGIO信号的场景，区分这些场景是难点。</p>
<p><img src="https://gdz.oss-cn-shenzhen.aliyuncs.com/hexo/%E7%90%86%E8%A7%A3Java-IO/image-20200419140042409.png" alt="image-20200419140042409"></p>
<h2 id="异步I-O"><a href="#异步I-O" class="headerlink" title="异步I/O"></a>异步I/O</h2><p>异步I/O模式下，我们只需要告诉内核我们要进行I/O操作，然后内核马上返回，具体的I/O操作和数据拷贝全部由内核完成，完成后再通知我们的应用程序。与信号驱动I/O所不同的是，这次不仅在等待数据阶段是异步的，连内核数据拷贝都是异步的。</p>
<ul>
<li>创建套接字，工作在异步I/O模式，指定套接字文件描述符、数据需要拷贝到的缓冲区、回调函数等，不需要等待，马上返回</li>
<li>内核负责等待数据病将数据从内核缓冲区拷贝到应用程序数据区</li>
<li>内核拷贝结束后，回调第一步注册的函数，完成应用程序的数据处理</li>
</ul>
<p><img src="https://gdz.oss-cn-shenzhen.aliyuncs.com/hexo/%E7%90%86%E8%A7%A3Java-IO/image-20200419140100782.png" alt="image-20200419140100782"></p>
<h2 id="五种模式总结"><a href="#五种模式总结" class="headerlink" title="五种模式总结"></a>五种模式总结</h2><p>前四种模式都有阻塞的地方——将数据从内核拷贝到应用程序数据区，只有第五种是完全异步的。</p>
<p><img src="https://gdz.oss-cn-shenzhen.aliyuncs.com/hexo/%E7%90%86%E8%A7%A3Java-IO/image-20200419140118975.png" alt="image-20200419140118975"></p>
<h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><p>Java的IO可以看做是对宿主系统的IO模型的封装，BIO对应了阻塞IO模型、NIO对应IO多路复用、AIO则对应了异步IO模型。通过了解Linux的五种IO模型，我们学习了Java的IO从哪里来及基本原理，算是解决了底层原理这个疑问。接下来我们看看Java IO的使用。</p>
<h1 id="Netty和NIO"><a href="#Netty和NIO" class="headerlink" title="Netty和NIO"></a>Netty和NIO</h1><p>Netty是Java非常流行的网络库，基于Java NIO实现，Vertx本身包括众多异步库都基于Netty实现，这里进行简单了解。</p>
<h2 id="为什么使用Netty"><a href="#为什么使用Netty" class="headerlink" title="为什么使用Netty"></a>为什么使用Netty</h2><p>尽管Java已经提供了NIO类库，但实际的网络编程环境非常复杂，NIO并没有完全屏蔽平台差异，它仍然是基于各个操作系统的I/O系统实现的，差异仍然存在。使用NIO做网络编程构建事件驱动模型并不容易，陷阱重重。要开发出一个稳定可用的网络程序使用NIO的周期将会非常长，而Netty封装了各种IO实现，提供简单的API，工作稳定，适用于各种场景。</p>
<p>顺便一提，Java的NIO库存在空轮询的bug：</p>
<p>原本select()方法应该是阻塞的，但JDK的select()方法在一些情况下会在没有事件时返回。造成在死循环中空转，使得CPU达到100%的情况。该bug到2013年才修复</p>
<p>Netty中的解决方式是在短时间内检测到超过一定数量的select()调用，就判定为空转。通过创建新的Selector并将原Selector中的Channel注册到新的Selector达到消除这个问题的目的。</p>
<h2 id="为什么不用AIO"><a href="#为什么不用AIO" class="headerlink" title="为什么不用AIO"></a>为什么不用AIO</h2><p>通过上面的模型讲解，看起来AIO比NIO在模型上要更加先进，那为什么Netty不基于AIO实现呢？从Netty的<a href="https://github.com/netty/netty/issues/2515">这个Issue</a>看，总结起来有几点</p>
<ul>
<li>Netty主要注重Linux，而在Linux上，AIO的底层实现仍然采用EPOLL，性能上没有明显优势，而且既然都采用EPOLL，还不如直接使用NIO方便自定义优化</li>
<li>Netty的线程模型，使用AIO看起来会非常杂乱</li>
<li>AIO在使用前必须预先分配缓冲区，高并发连接时不好优化</li>
</ul>
<p>当然上面几点只是我随他人附和，并没有真正理解，如有需要，可以再详细了解并新开一篇博文描述。</p>
<h2 id="Netty如何使用NIO"><a href="#Netty如何使用NIO" class="headerlink" title="Netty如何使用NIO"></a>Netty如何使用NIO</h2><p>通过不同的配置，Netty能够支持Reactor单线程模式、Reactor多线程模式、主从Reactor多线程模式</p>
<p>这里暂时没有必要去纠结单线程还是多线程，只需要关心Reactor模式。在Netty中，它正是基于NIO的多路复用实现的。</p>
<p>Netty的核心NioEventLoop就是基于NIO的多路复用实现的，除了NIO外，它还兼顾处理两个任务</p>
<ul>
<li>用户通过NioEventLoop.execute方法注册的事件放在消息队列中，由I/O线程执行</li>
<li>用户通过NioEventLoop.schedule方法注册的定时任务</li>
</ul>
<p>他们的简单原理就是在一个死循环内反复轮询Selector、消息队列、定时任务。即，Netty基于NIO构建了自己的EventLoop。</p>
<h2 id="小结-1"><a href="#小结-1" class="headerlink" title="小结"></a>小结</h2><p>这里仅从概念上简单介绍了Netty，没有一点深入了解，其目的仅在于让我们了解NIO和Netty是如何结合的。</p>
<h1 id="EventLoop"><a href="#EventLoop" class="headerlink" title="EventLoop"></a>EventLoop</h1><p>Event Loop是一个程序结构，用于等待和发送消息和事件。</p>
<p>其实，简单地理解EventLoop，就是一个反复定时轮询检查事件队列，并在事件发生时将事件分发到对应的handler中的一个工具。算是一种编程模型。</p>
<p>维基百科对EventLoop的讲解可以说是非常清楚的：</p>
<p>事件循环是一种等待和分发程序中事件或消息的编程结构或设计模式。实际工作上，它通过向事件提供程序（如消息队列、NIO的Selector）发出请求以获取事件，然后调用对应的事件处理程序进行工作。因此它有时也被称为消息分发程序。</p>
<p>事件循环可以和Reactor模式相结合，这就是我们常用的NIO编程。</p>
<p>从原理上说，我们可以自己提供事件消息队列，但一般来说这个消息队列是由对应的运行环境(操作系统)提供的，比如Java的NIO，这样可以将I/O放到系统中进行，避免阻塞工作线程。</p>
<p>事件循环是基于消息传输的系统的典型技术特征。</p>
<h2 id="EventLoop和NIO的关系"><a href="#EventLoop和NIO的关系" class="headerlink" title="EventLoop和NIO的关系"></a>EventLoop和NIO的关系</h2><p>NIO的Selector对应EventLoop模型中的事件提供程序，即事件源，即可以基于NIO构建一个EventLoop程序。如Netty的EventLoop模型，其事件源包括了NIO Selector，也包括了自定义任务队列和定时任务队列。</p>
<h1 id="Reactor-Proactor"><a href="#Reactor-Proactor" class="headerlink" title="Reactor Proactor"></a>Reactor Proactor</h1><h2 id="Reactor"><a href="#Reactor" class="headerlink" title="Reactor"></a>Reactor</h2><p>Reactor是一种设计模式，是一种事件处理模式。IO多路复用就是Reactor模式的一种实现。</p>
<p>它要求存在一个处理结构，接收并发的多个输入请求，并将这些请求同步分发到关联的请求处理handler的情况。</p>
<p>一个反应器的基本结构如下</p>
<ul>
<li><p>资源</p>
<p>可以是向系统发送消息的请求、也可以是从系统获取消息的请求</p>
</li>
<li><p>同步的事件复用器。</p>
<p>用一个EventLoop阻塞地等待所有资源（即请求），比如I/O多路复用模型中的epoll，当资源准备好时EventLoop将资源发送给调度器</p>
</li>
<li><p>Dispatcher分发器</p>
<p>用于管理请求处理器的注册和注销。同时将从复用器中得到的资源分发给对应的请求处理器</p>
</li>
<li><p>请求处理器</p>
<p>定义了资源的处理逻辑</p>
</li>
</ul>
<p>所有的Reacto系统在定义上将都是单线程的，但改良后的可以是多线程的，比如Netty中就对Reactor进行了多线程改进，使得能够发挥最大性能。</p>
<p>实际实现中的Reactor模型常常被用来解决IO并发问题，最常见的就是I/O多路复用。死循环阻塞等待select()就是EventLoop，有事件时调用对应于分发器。</p>
<p>在I/O上，这样能够提高I/O高并发的效率；在编程模型上，它将事件的处理逻辑完全分开。</p>
<p>当然，Reactor并不是只能用于I/O，就像Netty在EventLoop加入用户自定义的task和定时task、Vertx基于EventLoop构建自己的神经系统一样，它也可以用来处理事件请求和处理分离的模式，在运行效率和编程效率上都有所提升。</p>
<h2 id="Proactor"><a href="#Proactor" class="headerlink" title="Proactor"></a>Proactor</h2><p>Proactor也是用于事件处理的设计模式，它可以被看做是同步的Reactor模式的变体。它将需要长时间运行的操作异步执行，在执行完后调用对应的处理器进行结果处理即可。异步I/O就是Proactor模式的一种实现。</p>
<p>模型上的结构和工作流程如下</p>
<p><a href="https://camo.githubusercontent.com/e003cc17f60eb161197e22302dca51c5ab63d569/68747470733a2f2f75706c6f61642e77696b696d656469612e6f72672f77696b6970656469612f636f6d6d6f6e732f362f36312f50726f6163746f722e5653445f53657175656e63654469616772616d2e706e67"><img src="https://camo.githubusercontent.com/e003cc17f60eb161197e22302dca51c5ab63d569/68747470733a2f2f75706c6f61642e77696b696d656469612e6f72672f77696b6970656469612f636f6d6d6f6e732f362f36312f50726f6163746f722e5653445f53657175656e63654469616772616d2e706e67" alt="Proactor.VSD_SequenceDiagram.png (577×325)"></a></p>
<p>在实际应用中，模型中的Asynchronous Operation Processor、Asynchronous Operation、Completion Dispatcher一般依赖于操作系统完成，我们负责发起异步调用和注册完成处理函数。比如LInux的异步IO模型。我们能做的只是发起I/O请求、指明数据要存放的位置、注册处理函数，待系统异步处理完I/O请求后，调用注册的处理函数。</p>
<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>本文以Java IO为切入点，介绍了其在Linux上对应IO模型，使得大家了解了底层工作原理；再以NIO为基础，介绍了流行的网络框架——Netty；由Netty中的一些概念，介绍了EventLoop、Reactor、Proactor三种编程模型和设计模式。使得大家对这一系列概念的联系有了较为完整的认识。</p>
<p>需要注意的是，Java的IO针对不同的系统有不同的具体实现，实际使用过程中存在差异，本文仅介绍了其在Linux中对应的模型，在其它系统中可能会有所不同，这点需要了解。</p>
<p>最后，本文草稿可以在<a href="https://github.com/zou8944/Asynchronous">这里</a>找到，可以看到资料收集的过程。</p>
<p>不足之处，还请评论指出，谢谢。</p>
<h1 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h1><ol>
<li>Linux网络编程 - 第六章（书籍）</li>
<li>Netty权威指南 - 第一、二、十八章（书籍）</li>
<li><a href="https://github.com/Snailclimb/JavaGuide/blob/master/docs/java/BIO-NIO-AIO.md#1-bio-blocking-io">Java NIO BIO AIO简单总结 - 佚名</a></li>
<li><a href="https://zhuanlan.zhihu.com/p/23488863">Java NIO浅析 - 美团技术团队</a></li>
<li><a href="https://www.ruanyifeng.com/blog/2013/10/event_loop.html">什么是EventLoop - 阮一峰</a></li>
<li><a href="https://en.wikipedia.org/wiki/Reactor_pattern">Reactor pattern - Wikipedia</a></li>
<li><a href="https://en.wikipedia.org/wiki/Proactor_pattern">Proactor pattern - Wikipedia</a></li>
</ol>
<h1 id="博文预告"><a href="#博文预告" class="headerlink" title="博文预告"></a>博文预告</h1><p>《Vertx Core源码解析 - 1》</p>
]]></content>
      <categories>
        <category>后端</category>
      </categories>
      <tags>
        <tag>NIO</tag>
      </tags>
  </entry>
  <entry>
    <title>科技随想-20210704</title>
    <url>/2021/07/04/%E7%A7%91%E6%8A%80%E9%9A%8F%E6%83%B3-20210704-%E7%A7%91%E6%8A%80%E9%9A%8F%E6%83%B3-20210704/</url>
    <content><![CDATA[<blockquote>
<p>科技乱炖 - 这个618貌似有点冷</p>
</blockquote>
<h2 id="618有点冷吗？"><a href="#618有点冷吗？" class="headerlink" title="618有点冷吗？"></a>618有点冷吗？</h2><p>先回想一下，今年618我买什么东西了吗？好像有，又好像没有。</p>
<p>如果仅看618的话，我在PDD上买了一堆生活用品，但他们貌似并没有在618更便宜多少。</p>
<p>但如果把618拉长到601来看的话，我买了Apple Watch，然后再618前夕使用保价政策优惠了300块。</p>
<p>今年618动静大吗？我想，除了在朋友圈京东的同学发出来一些备战的状态，其它时候并没有收到太多的宣传。相反，它将整个周期拉长了，从五月下旬就开始预热，部分商品已经便宜了。</p>
<span id="more"></span>

<p>原因是什么呢？</p>
<ul>
<li>周期拉长，人们不必再等到618凌晨那个时间点去抢购优惠</li>
<li>用户对所谓购物节优惠有所免疫，信任度有所下降。都是前两年过于复杂的优惠政策导致的，一顿操作下来，可能就便宜一二十块。</li>
<li>平台所扮演的角色在人们心中的低位不再那么高。直播的兴起、私域流量的兴起，降低了用户的决策成本。平台的吸引力在降低。</li>
<li>国内用户红利到头，平台不再像之前那样大张旗鼓宣传。</li>
</ul>
<h2 id="私域流量"><a href="#私域流量" class="headerlink" title="私域流量"></a>私域流量</h2><p>私域流量，就是具有一定影响力的大佬自带的粉丝群体。</p>
<p>私域流量，从表象看，就是一个微信群，但貌似并不止于此。传统平台的流量只能根据用户针对商品的购买、浏览、收藏行为对用户画像，进行推荐。但私域流量能够通过推送用户文章等提供更为完整的用户画像，从而更好地知道用户想要什么。但从另一个方面说，这又是有一个平台——构建私域流量的平台之间的战斗。</p>
<h2 id="卖货的新方式"><a href="#卖货的新方式" class="headerlink" title="卖货的新方式"></a>卖货的新方式</h2><p>我的购物习惯是京东，它的核心竞争力物流；身边很多女性朋友是淘宝天猫，当然购买服饰居多，淘宝的竞争力是品类齐全；还有很多边缘用户比如父母是拼多多，它的竞争力是便宜、购物流程超级简单。</p>
<p>但所有这些平台，他们说到底都只是充当了一个货架的角色。而这两年掀起风潮的直播带货，私域流量，也扮演着重要角色。他们的好处是一个品类多数时候只有一个产品，品质有一定保证，为我们省下了很大一部分决策成本。</p>
<p>想一想，如果直播带货使用顺丰发货，能够抵消掉京东部分竞争力；决策成本抵消掉淘宝的部分竞争力；品质有保证的前提下价格相对合理，也能侵蚀掉拼多多的部分流量。</p>
<p>这样说来，传统平台的购物方式（没错，淘宝京东算传统了哈哈哈），也有他们的焦虑点在。</p>
<h2 id="字节跳动做CDN了"><a href="#字节跳动做CDN了" class="headerlink" title="字节跳动做CDN了"></a>字节跳动做CDN了</h2><p>CDN相信大家都知道是什么了，那么字节跳动为什么要自建CDN呢？原因主要有几点</p>
<ul>
<li><p>流量较小时，CDN看似便宜，但以字节跳动这么庞大的流量，用于CDN上的费用想必是相当昂贵的，因此从节约成本上来说，自建是一个较好的选择。</p>
<p>  为什么现在搞？字节大部分产品线日趋成熟，出现冗余的技术资源，可以搞这件事</p>
</li>
<li><p>云服务卡脖子：阿里云高速通道开始收费了！！！之前可是不收费的。我们一直说云服务多么好多么好，从技术上说，云服务当然是好的。但其缺点就是将自己的核心业务乃至全部身家都托付给云平台，如果出现一波阿里云高速通道这样的操作，就玩完儿。</p>
</li>
</ul>
]]></content>
      <categories>
        <category>随笔</category>
      </categories>
      <tags>
        <tag>随笔</tag>
      </tags>
  </entry>
  <entry>
    <title>编写一个Maven插件</title>
    <url>/2020/02/29/%E7%BC%96%E5%86%99%E4%B8%80%E4%B8%AAMaven%E6%8F%92%E4%BB%B6-%E7%BC%96%E5%86%99%E4%B8%80%E4%B8%AAmaven%E6%8F%92%E4%BB%B6/</url>
    <content><![CDATA[<p>Maven是个很好用的打包编译工具，也是目前自己正在使用的主力工具。对一些个性化的需求，编写插件，实现一些特有的功能，还是非常有效的。这次刚好，有需求如是：maven编译时用到数据库表描述文件自动生成插件，需要从配置文件中读取账号密码，而目前maven只提供了读取properties文件到声明周期的工具。而项目的通用配置文件是json，如果临时加一个重复的properties文件，显得多余且没必要。于是需求应运而生，开发一个读取json文件到Maven生命周期的工具。</p>
<p>我叫它 json-loader-maven-plugin。</p>
<span id="more"></span>

<p>首先创建一个maven空工程，我们从已有的Maven工程开始。</p>
<h2 id="pom配置"><a href="#pom配置" class="headerlink" title="pom配置"></a>pom配置</h2><h3 id="基础信息"><a href="#基础信息" class="headerlink" title="基础信息"></a>基础信息</h3><p>基础信息和普通项目没什么两样，需要注意的点如下</p>
<ul>
<li>groupId: 组织ID，具有权威性，由于是github中的项目，所以命名为com.github.用户名</li>
<li>artifactId: Apache规定，凡是Maven插件命名必须以 maven-plugin结尾</li>
<li>packagin: 此处开发插件，因此打包类型为 maven-plugin</li>
</ul>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">modelVersion</span>&gt;</span>4.0.0<span class="tag">&lt;/<span class="name">modelVersion</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.github.zou8944<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>json-loader-maven-plugin<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">packaging</span>&gt;</span>maven-plugin<span class="tag">&lt;/<span class="name">packaging</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">version</span>&gt;</span>1.0.0<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h3 id="依赖"><a href="#依赖" class="headerlink" title="依赖"></a>依赖</h3><p>我们会用到Maven Plugin API ，插件相关注解，比如@Mojo，还会用到单元测试（这里使用JUnit）。再加上解决的一些依赖问题，得到必备的依赖项如下</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependencies</span>&gt;</span></span><br><span class="line">  <span class="comment">&lt;!-- 基础组件 --&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.apache.maven<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>maven-plugin-api<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>3.6.2<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">  <span class="comment">&lt;!-- 插件注解 --&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.apache.maven.plugin-tools<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>maven-plugin-annotations<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>3.6.0<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">scope</span>&gt;</span>provided<span class="tag">&lt;/<span class="name">scope</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">  <span class="comment">&lt;!-- maven project API，提供运行的整个project的各种API，比如读取和动态设置依赖项等 --&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.apache.maven<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>maven-project<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.2.1<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">  <span class="comment">&lt;!-- 为解决依赖问题而加，必须和maven-project保持同一版本--&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.apache.maven<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>maven-artifact<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.2.1<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">  <span class="comment">&lt;!-- 单元测试 --&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>junit<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>junit<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>4.13<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">scope</span>&gt;</span>test<span class="tag">&lt;/<span class="name">scope</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">  <span class="comment">&lt;!-- 用于读取json文件 --&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.alibaba<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>fastjson<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.2.61<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependencies</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h2 id="编写Mojo"><a href="#编写Mojo" class="headerlink" title="编写Mojo"></a>编写Mojo</h2><p>Mojo是插件执行的目标类，在使用时和&lt;goal&gt;标签对应，一个插件可以有多个Mojo。</p>
<p>对Mojo的编写，一般集成AbstractMojo类，它实现了Mojo接口的必要方法，只留下一个execute()方法让我们编写业务逻辑。同时我们为定义的类加上@Mojo注解，Maven在运行时就能够检测到它。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Mojo(name = &quot;read-project-json-to-properties&quot;, defaultPhase = LifecyclePhase.INITIALIZE)</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ReadJsonMojo</span> <span class="keyword">extends</span> <span class="title">AbstractMojo</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 注入Maven环境</span></span><br><span class="line">  <span class="meta">@Parameter(defaultValue = &quot;$&#123;project&#125;&quot;, readonly = true, required = true)</span></span><br><span class="line">  <span class="keyword">private</span> MavenProject project;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 注入参数</span></span><br><span class="line">  <span class="meta">@Parameter</span></span><br><span class="line">  <span class="keyword">private</span> File[] files;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">execute</span><span class="params">()</span> <span class="keyword">throws</span> MojoExecutionException, MojoFailureException </span>&#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">      <span class="comment">// 将文件解析为properties对象</span></span><br><span class="line">      Properties properties = parseFileProperties(files);</span><br><span class="line">      <span class="comment">// 将解析的properties对象加入到project实例中</span></span><br><span class="line">      project.getProperties().putAll(properties);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">      <span class="keyword">throw</span> <span class="keyword">new</span> MojoExecutionException(<span class="string">&quot;Error reading json from &quot;</span> + resource, e);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上述代码是简化后的，目的是为了关注到插件的实现上，而不是业务逻辑。针对这段代码，有如下几点说明</p>
<ul>
<li><p>@Mojo</p>
<p>指定了Mojo名，对应goal，可设置默认工作的生命周期节点。</p>
</li>
<li><p>MavenProject属性，代表了pom.xml下的<code>&lt;project&gt;</code>标签下的所有内容，即Maven的运行环境。在Maven上下文创建时将会被注入。</p>
</li>
<li><p>File属性，Maven支持直接将pom文件中指定的路径直接解析成File并注入Mojo类。除了File，还支持如下类型，而他们，都是通过@Parameter注解实现的。</p>
<ul>
<li>Boolean</li>
<li>Integer</li>
<li>Float-Point</li>
<li>Date</li>
<li>File</li>
<li>URL</li>
<li>Plain text</li>
<li>Enum</li>
<li>Array</li>
<li>Collection</li>
<li>Map</li>
<li>Properties</li>
<li>Object class</li>
</ul>
<p>具体的使用方法，可以参考<a href="https://maven.apache.org/guides/plugin/guide-java-plugin-development.html#Parameter">官方文档</a>。</p>
</li>
</ul>
<h2 id="单元测试"><a href="#单元测试" class="headerlink" title="单元测试"></a>单元测试</h2><p>Unit test和普通Maven项目没有太大区别，仅仅在于预设环境的不同，简化代码如下</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ReadPropertiesMojoTest</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">private</span> MavenProject projectStub;</span><br><span class="line">  <span class="keyword">private</span> ReadJsonMojo readJsonMojo;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Before</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setUp</span><span class="params">()</span> </span>&#123;</span><br><span class="line">     <span class="comment">// 创建一个空的MavenProject对象</span></span><br><span class="line">    projectStub = <span class="keyword">new</span> MavenProject();</span><br><span class="line">    <span class="comment">// 创建刚才的Mojo实例</span></span><br><span class="line">    readJsonMojo = <span class="keyword">new</span> ReadJsonMojo();</span><br><span class="line">    <span class="comment">// 显示将MavenProject注入Mojo，set方法前面的代码省略了，请注意。</span></span><br><span class="line">    readJsonMojo.setProject(projectStub);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Test</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">readJsonFile</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">    File testFile = constructTestFile();</span><br><span class="line">    Properties baseProperties = constructComparedProperties();</span><br><span class="line"></span><br><span class="line">    readJsonMojo.setFiles(<span class="keyword">new</span> File[]&#123;testFile&#125;);</span><br><span class="line">    readJsonMojo.execute();</span><br><span class="line"></span><br><span class="line">    Properties projectProperties = projectStub.getProperties();</span><br><span class="line"></span><br><span class="line">    assertNotNull(projectProperties);</span><br><span class="line">    assertNotEquals(<span class="number">0</span>, projectProperties.size());</span><br><span class="line">    assertEquals(baseProperties, projectProperties);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">private</span> File <span class="title">constructTestFile</span><span class="params">()</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">    . . . . . .</span><br><span class="line">    <span class="keyword">return</span> file;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">private</span> Properties <span class="title">constructComparedProperties</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    . . . . . .</span><br><span class="line">    <span class="keyword">return</span> properties;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="安装测试"><a href="#安装测试" class="headerlink" title="安装测试"></a>安装测试</h2><p>单元测试后，可以安装到本地仓库进行测试</p>
<h3 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">mvn clean install</span><br></pre></td></tr></table></figure>

<h3 id="命令行测试"><a href="#命令行测试" class="headerlink" title="命令行测试"></a>命令行测试</h3><p>可以直接通过命令行执行刚才的插件</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 命令行执行格式</span></span><br><span class="line">mvn groupId:artifactId:version:goal</span><br><span class="line"><span class="comment"># 本项目执行如下</span></span><br><span class="line">mvn com.github.zou8944.json-loader-maven-plugin:1.0.0:read-project-json-to-properties</span><br></pre></td></tr></table></figure>

<h3 id="在其它项目中使用"><a href="#在其它项目中使用" class="headerlink" title="在其它项目中使用"></a>在其它项目中使用</h3><p>在本机上的另一个项目中通过如下配置使用它</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">plugin</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.github.zou8944<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>json-loader-maven-plugin<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.0.0<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">executions</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">execution</span>&gt;</span></span><br><span class="line">      <span class="comment">&lt;!-- phase在@Mojo定义时默认为intialize，因此这里实际可以不写 --&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">phase</span>&gt;</span>initialize<span class="tag">&lt;/<span class="name">phase</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">goals</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!-- goal，对应@Mojo设置的name --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">goal</span>&gt;</span>read-project-json-to-properties<span class="tag">&lt;/<span class="name">goal</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;/<span class="name">goals</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">configuration</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">files</span>&gt;</span></span><br><span class="line">           <span class="comment">&lt;!-- 指定文件路径，Maven能够自行解析成文件 --&gt;</span></span><br><span class="line">          <span class="tag">&lt;<span class="name">file</span>&gt;</span>hello.json<span class="tag">&lt;/<span class="name">file</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">files</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;/<span class="name">configuration</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">execution</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">executions</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">plugin</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h2 id="遇到的坑"><a href="#遇到的坑" class="headerlink" title="遇到的坑"></a>遇到的坑</h2><p>开发过程相对顺利，其中一个依赖冲突导致卡了较长时间。</p>
<p>MavenProject类中引入<code>import org.apache.maven.artifact.DependencyResolutionRequiredException</code>类，但该类在默认的Maven-Artifact 3.6.2包中已经没有了，找了几个版本，发现只有2.2.1版本存在，因此参考<a href="https://www.baeldung.com/maven-plugin">baeldung的教程</a>，自定义了依赖项，才使问题得以解决。即，将Maven-Artifact包修改为2.2.1版本</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.apache.maven<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>maven-artifact<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.2.1<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>通过该项目简单地了解了Maven插件的开发方法，虽然简单，却提供了很多种可能性。</p>
<p>此外，本文中的代码均为简化后的，源码在<a href="https://github.com/zou8944/json-loader-maven-plugin">github</a>上，欢迎访问，只不过需要注意：源码的pom中包含了很多其它内容，比如远程发布相关配置、site相关配置，请自行忽略。</p>
<h2 id="参考文档"><a href="#参考文档" class="headerlink" title="参考文档"></a>参考文档</h2><ol>
<li><p><a href="https://maven.apache.org/guides/plugin/guide-java-plugin-development.html">Apache Plugin Developer Centre</a></p>
</li>
<li><p><a href="https://www.baeldung.com/maven-plugin">How to Create a Maven Plugin</a></p>
</li>
<li><p><a href="https://github.com/mojohaus/properties-maven-plugin">MojoHaus Properties Maven Plugin</a></p>
</li>
</ol>
]]></content>
      <categories>
        <category>工具</category>
      </categories>
      <tags>
        <tag>Maven</tag>
      </tags>
  </entry>
  <entry>
    <title>科技随想-20210711</title>
    <url>/2021/07/11/%E7%A7%91%E6%8A%80%E9%9A%8F%E6%83%B3-20210711-ke-ji-sui-xiang--20210711/</url>
    <content><![CDATA[<ul>
<li>韩国成为了发达国家，这意味着什么？</li>
</ul>
<h2 id="发达国家？发展中国家？区别？谁说了算？"><a href="#发达国家？发展中国家？区别？谁说了算？" class="headerlink" title="发达国家？发展中国家？区别？谁说了算？"></a>发达国家？发展中国家？区别？谁说了算？</h2><p>首先说，这并没有一个统一的国际标准说怎么样才是发达国家或者发展中国家。各国际组织标准也不一样。在之前，世界银行、国际货币基金组织、联合国开发计划署等国际机构都已经将韩国列为发达国家。而前几天新闻上说的是联合国贸易与发展会议正式将韩国列为发达国家。</p>
<p>那么，为什么这次韩国反应这么大呢？是因为联合国贸易与发展会议比较重要吗？</p>
<span id="more"></span>

<p><strong>联合国贸易与发展会议</strong></p>
<p>联合国常设机构之一，主要宗旨是促进发展中国家的贸易、投资机会。</p>
<p>韩国转为发达国家，是1964年该会议成立后，第一次有国家转为发达国家。</p>
<p><strong>发达国家 VS 发展中国家</strong></p>
<p>直接理解看，二者的区别在于经济水平的差别。实际上，虽然没有统一标准，但通常以如下几个指标进行评判</p>
<ul>
<li>人均国民生产总值</li>
<li>工业化水平</li>
<li>科学技术水准等</li>
</ul>
<h2 id="发达国家还有哪些？"><a href="#发达国家还有哪些？" class="headerlink" title="发达国家还有哪些？"></a>发达国家还有哪些？</h2><p>如果以世界上主要组织的认定，那么几乎所有欧洲国家、美国、加拿大、日韩、四小龙等，都是发达国家。</p>
<p>但如果只是看此次的贸易与发展会议。</p>
<p>发达国家，即该会议的B类，只有32个国家是发达国家：安道尔、澳大利亚、奥地利、比利时、加拿大、塞浦路斯、丹麦、芬兰、法国、德国、希腊、梵蒂冈、冰岛、爱尔兰、意大利、日本、韩国、列支敦士登、卢森堡、马耳他、摩纳哥、荷兰、新西兰、挪威、葡萄牙、圣马力诺、西班牙、瑞典、瑞士、土耳其、英国和美国。</p>
<p>可以看到，几乎全是欧美国家。日韩、也算欧美。</p>
<h2 id="发达国家有什么好处？"><a href="#发达国家有什么好处？" class="headerlink" title="发达国家有什么好处？"></a>发达国家有什么好处？</h2><p>找了半天也没有找到发达国家的好处。倒是发展中国家往往能够受到经济、政策上的优惠。那么为什么韩国成为发达国家这么高兴呢？</p>
<p>我想应该是反向逻辑吧：韩国经济水平发展很高，很长时间都被当做发达国家来对待，但名分上确没有发达国家。所以这次算是一个名分？</p>
<p>其次，发达国家，也是国际地位的变化，机会不一样，话语权也不一样。</p>
<h2 id="我国距离发达国家还有多大距离？"><a href="#我国距离发达国家还有多大距离？" class="headerlink" title="我国距离发达国家还有多大距离？"></a>我国距离发达国家还有多大距离？</h2><p>只看几个水平的话。</p>
<ul>
<li>人均国民生产总值：国际货币基金组织预测我国2021排名56，韩国26，台湾27</li>
<li>工业化水平：这个找不到，但我国应该很高</li>
<li>人类发展指数：联合国开发计划署，我国2020排名85，韩国23，台湾23，</li>
</ul>
<p>此外，发达国家以服务业为主，发展中国家以工业为主。从这个特征上看，我国正是发展中呀。</p>
]]></content>
      <categories>
        <category>随笔</category>
      </categories>
      <tags>
        <tag>自省</tag>
      </tags>
  </entry>
  <entry>
    <title>设计模式 - 理论部分</title>
    <url>/2021/10/04/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%20-%20%E7%90%86%E8%AE%BA%E9%83%A8%E5%88%86-she-ji-mo-shi--li-lun-bu-fen/</url>
    <content><![CDATA[<blockquote>
<p>这是系列文章</p>
<ul>
<li>设计模式 - 理论（本文）</li>
<li>设计模式 - JDK</li>
<li>设计模式 - Spring</li>
</ul>
</blockquote>
<span id="more"></span>

<h2 id="避免陷阱"><a href="#避免陷阱" class="headerlink" title="避免陷阱"></a>避免陷阱</h2><p>以前也学习过设计模式，而且不止一次，都以失败告终。究其原因：</p>
<p>一是教材选用不对——《大话设计模式》，虽然这本书豆瓣评分8.3，但显然不适合我。讲的太啰嗦，我会讨厌弱智似的故事情节：什么大鸟小鸟老鸟、王二狗林蛋大，读者都是技术人员，作者却还是用小学生作为的语气讲故事，亦或是，难道大家真的都习惯了这种口吻接受知识？</p>
<p>二来，技术书籍也好，网络文章也好，好像都是一个模子刻出来的，上来就是UML图、代码实现，模式解决了什么问题一笔带过。读者注意力转移不说，还很容易流于形式：更多考虑的是这个模式为什么要定义这个接口？而不是什么情况下、为什么使用这个模式？——后者搞清楚了，与模式规定的接口不一样也没有关系。</p>
<p>三是，实践不够多，代码量不够，看到的代码也不够——时机不成熟。</p>
<p>每本设计模式的教材都教我们，不要轻易使用设计模式，只有需要时才使用，以避免过度设计。我觉得这是一个误解，在甚至搞不清楚三个工厂模式具体区别时，弄懂设计模式才是关键。至于使用，我认为该多用，直到熟悉之后，再考虑用得合不合适。</p>
<p>前段时间Github Daily推荐了<a href="https://github.com/kamranahmedse/design-patterns-for-humans">《给人看的设计模式》</a>，没有UML图，短小精悍，再次触发了我学习设计模式的兴趣。</p>
<p>这是一篇总结性的文章，视图用一句话描述一个设计模式存在的价值</p>
<h2 id="设计模式分类"><a href="#设计模式分类" class="headerlink" title="设计模式分类"></a>设计模式分类</h2><h3 id="创造类"><a href="#创造类" class="headerlink" title="创造类"></a>创造类</h3><p>创造类设计模式，主要关注对创建对象的方式，根据不同的创造需求产生了对应的设计模式。</p>
<ul>
<li>当创建一个对象有一定的逻辑复杂度，我们不希望用户直接接触到创建过程，就有了<strong>简单工厂模式</strong>，封装创建过程</li>
<li>当创建一个对象有一定的逻辑复杂度，但创建过程会依据对象的实现而不同，就有了<strong>工厂方法模式</strong>，定义工厂抽象类，具体创建逻辑留在工厂子类实现，这在SPI经常使用</li>
<li>当需要创建一族而不是一个相互关联的对象时，就有了<strong>抽象工厂模式</strong></li>
<li>当创建一个对象可能需要多个步骤，且步骤之间可以自由组合，就有了<strong>建造器模式</strong>，它解决了构造方法地狱的问题</li>
<li>当一个对象的创建是直接来源于同类的其它对象时，就有了<strong>原型模式</strong></li>
<li>当需要控制一个类在整个系统仅有一个对象时，就有了<strong>单例模式</strong></li>
</ul>
<h3 id="结构类"><a href="#结构类" class="headerlink" title="结构类"></a>结构类</h3><p>结构类设计模式，主要关注对象之间的组合方式，即对象之间如何相互作用。关注的是对象之间的关系</p>
<ul>
<li><p>当一个类需要使用另一个类，但类之间接口不兼容时，就有了<strong>适配器模式</strong>，为“另一个类”创建适配器，使其变得兼容</p>
</li>
<li><p>当一个类中的某个特性发生变化，使用继承表达这种变化会引发子类泛滥时，就有了<strong>桥接模式</strong>，将变化的特性抽出，任其自身变化，再“桥接”回原类。</p>
<p>这是一个使用组合替换继承的典型场景</p>
</li>
<li><p>当多个对象本身的逻辑关系为树状结构时，我们自然地通过组合的方式将他们联系在一起，用户只需要获取根对象就能操作整套对象，这就是<strong>组合模式</strong></p>
</li>
<li><p>当需要为一个类动态增加一系列功能，而又不改变原类，且增加的功能要灵活增减，就有了<strong>装饰器模式</strong></p>
</li>
<li><p>当需要为一个功能复杂的类提供一套使用简单的访问接口时，就有了<strong>外观模式</strong></p>
</li>
<li><p>当系统中有大量相同对象，为了减少内容消耗，我们让这些对象共用一个存储位置，就有了<strong>享元模式</strong></p>
</li>
<li><p>当需要在调用对象时增加额外的控制逻辑，或者因某些原因不方便直接调用该对象，就有了<strong>代理模式</strong></p>
</li>
</ul>
<h3 id="行为类"><a href="#行为类" class="headerlink" title="行为类"></a>行为类</h3><p>行为类设计模式关注的是如何在对象之间进行通讯，即如何在软件组件中运行行为</p>
<ul>
<li><p>当对同一个源对象，我们有多套处理方案，或多套处理逻辑，此时可以使用<strong>责任链模式</strong>，将每个方案或逻辑抽象为一个责任对象，他们共同构成责任链，源对象从责任链的这头走到那头，依次应用每一个逻辑</p>
</li>
<li><p>将行为封装在对象中，然后传递给执行者，这就是<strong>命令模式</strong>，它将执行者和行为解耦。想象操作系统是执行者，各种shell命令就是被封装的行为对象。</p>
</li>
<li><p>当我们需要在不暴露底层实现的情况下，提供一个简单的接口访问容器元素，这就是<strong>迭代器模式</strong></p>
</li>
<li><p>当两个或多个对象需要相互交流时，就有了<strong>中介者模式</strong>，中介者定义了这些类交流的行为，提供了一个平台。</p>
</li>
<li><p>当需要永久保留程序运行状态，并提供日后恢复可能性时，就有了<strong>备忘录模式</strong>，它提供了回滚的能力</p>
</li>
<li><p>当一个对象需要对另一个对象的状态变化做出响应时，就有了<strong>观察者模式</strong>，这个就太常用了</p>
</li>
<li><p>当要对一个对象添加更多操作，又不想修改他们时，就有了<strong>访问者模式</strong>，将添加的操作集中到访问者</p>
<p>被访问者需要提供接收访问者的接口；访问者一般访问的是被访问者的实现类</p>
</li>
<li><p>当需要将行为的算法抽象出来，在运行时候动态动态应用不同的算法抽象，就有了<strong>策略模式</strong>，典型的如比较器</p>
</li>
<li><p>当对象的行为需要根据“状态”变化，就有了<strong>状态设计模式</strong>，它允许我们通过修改“状态”来修改对象的行为</p>
</li>
<li><p>当对象的行为步骤固定，但步骤的具体实现要放到子类中实现，就有了<strong>模板方法模式</strong>，他允许我们先定义算法框架，后定义算法实现</p>
</li>
</ul>
<h2 id="自问自答"><a href="#自问自答" class="headerlink" title="自问自答"></a>自问自答</h2><h3 id="三个工厂模式如何区分"><a href="#三个工厂模式如何区分" class="headerlink" title="三个工厂模式如何区分"></a>三个工厂模式如何区分</h3><ul>
<li>简单工厂：静态方法，只是封装了单个对象的创建过程</li>
<li>工厂方法：非静态方法，对象创建的具体过程需要等到子类实现</li>
<li>抽象工厂：非静态方法，提供的是多个创建方法，创建一组关联的对象</li>
</ul>
<p>当抽象工厂的创建方法只有一个时，退化为工厂方法；当工厂方法的实现类和抽象类变成一个，且方法变成静态时，退化为简单工厂</p>
<h3 id="命令模式与策略模式区分"><a href="#命令模式与策略模式区分" class="headerlink" title="命令模式与策略模式区分"></a>命令模式与策略模式区分</h3><p>疑惑点：都是将行为抽象出来</p>
<p>不同点：前者可能会包含命令接收者的状态信息，相对来说，它更加完整，增加一个环境就能运行了；后者只是一个纯粹算法的抽象</p>
<h3 id="迭代器模式和外观模式区分"><a href="#迭代器模式和外观模式区分" class="headerlink" title="迭代器模式和外观模式区分"></a>迭代器模式和外观模式区分</h3><p>疑惑点：都隐藏了底层实现，通过简单接口暴露</p>
<p>不同点：从隐藏底层暴露简单接口这一点看，后者是包含前者的，因为前者仅针对容器类对象；但后者在实现上，是单独创建一个类对原类进行封装；而前者往往是一个可迭代接口</p>
<h3 id="中介者模式和适配器模式区分"><a href="#中介者模式和适配器模式区分" class="headerlink" title="中介者模式和适配器模式区分"></a>中介者模式和适配器模式区分</h3><p>疑惑点：都是为两个对象提供“沟通渠道”</p>
<p>不同点：其实二者完全不同，前者是真的提供沟通渠道；后者只是在接口形式上使得二者兼容</p>
<h3 id="访问者模式和装饰器模式区分"><a href="#访问者模式和装饰器模式区分" class="headerlink" title="访问者模式和装饰器模式区分"></a>访问者模式和装饰器模式区分</h3><p>疑惑点：都是不修改原对象的情况下添加了更多操作</p>
<p>不同点：后者是真的完全不改变原有对象，通过创建新类将原类进行包装，在新类中添加功能，新类除了方法调用外，是访问不到原类内部的；前者并非无痛，访问者为了能够访问到被访问者，需要被访问者暴露方法将访问者注入。</p>
<p>且装饰器模式重点在”添加“功能；访问者模式重点在”访问“，正因为是”访问“，才需要将访问者注入被访问者。</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>本文没有代码，没有UML图，只有使用场景和容易搞混的设计模式区分。适合已经了解设计模式的人加深印象，要想详细了解，还是十分建议去看<a href="https://github.com/kamranahmedse/design-patterns-for-humans">《给人看的设计模式》</a>。此外，强调几个点：</p>
<ul>
<li>忘记UML图，忘记UML图，忘记UML图，重要的事情说三遍。UML图只是形式上的定义，不用想肯定记不住，重点在于理解场景和实现思路。只要思路正确，和标准UML图差一点也没关系，并且，我们实现的代码最终一定会靠向该模式的标准结构。</li>
<li>不要一个一个看，全部看完并理解，才能有对比。</li>
<li>很多设计模式看起来比较相似，实际上他们确实有共通点，此时就需要自己体会了，不大好讲通。</li>
</ul>
]]></content>
      <categories>
        <category>后端</category>
      </categories>
      <tags>
        <tag>设计模式</tag>
      </tags>
  </entry>
  <entry>
    <title>聊一聊Java的缓存</title>
    <url>/2021/09/27/%E8%81%8A%E4%B8%80%E8%81%8AJava%E7%9A%84%E7%BC%93%E5%AD%98-liao-yi-liao-java-de-huan-cun/</url>
    <content><![CDATA[<blockquote>
<p>本文，我们主要聊一下Java中缓存的使用，几个点</p>
<ul>
<li>Java对缓存的抽象——JSR107</li>
<li>Spring对缓存的抽象——Spring Cache</li>
<li>Redis如何集成到Spring中——作为Spring Cache的实现、直接使用RedisCache、使用RedisTemplate</li>
</ul>
</blockquote>
<span id="more"></span>

<h2 id="先说点啥"><a href="#先说点啥" class="headerlink" title="先说点啥"></a>先说点啥</h2><p>缓存嘛，都知道是咋回事。常见的缓存如Memcached、Redis、Caffine等，各自也有对应的API。使用它们，直接操作API即可。当然，本文并非讨论各种缓存的API的用法，而是在Java中使用缓存的标准方法。无关具体实现，即，Java中的缓存抽象。</p>
<p>就Java本身而言，有JSR107，专门对缓存定义的抽象；如果使用Spring，则有Spring Cache抽象，二者虽不同，但大体思想一致，且Spring Cache还提供了对JSR107注解的兼容。我们具体来看。</p>
<h2 id="JSR107"><a href="#JSR107" class="headerlink" title="JSR107"></a>JSR107</h2><p>JSR107是Java针对缓存所定的规范，旨在让Java程序员以最低的学习成本学会缓存的使用。有兴趣可阅读<a href="https://docs.google.com/document/d/1ijduF_tmHvBaUS7VBBU2ZN8_eEBiFaXXg9OI0_ZxCrA/edit">规范原文</a>。<br>简单来讲，它包含几个方面</p>
<ul>
<li>一套核心接口，用于编程式缓存</li>
<li>一套注解，用于声明式缓存</li>
<li>其它</li>
</ul>
<h3 id="核心接口"><a href="#核心接口" class="headerlink" title="核心接口"></a>核心接口</h3><p>定义了如下五个核心接口，也就是说，如果要定义自己的缓存实现，实现这些接口即可。</p>
<table>
<thead>
<tr>
<th>接口</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>CachingProvider</td>
<td>用于管理CacheManager</td>
</tr>
<tr>
<td>CacheManager</td>
<td>用于管理Cache，具体来说，它的作用有<br />- 创建、配置具有特定名称的Cache，配置通过xxxConfiguration类实现<br />- 根据名称获取Cache<br />- 关闭Cache<br />- 销毁Cache及其中的内容<br />- 关闭自己及所管理的Cache<br />- 提供Cache的统计信息<br />- 获取CachingProvider中特定的属性</td>
</tr>
<tr>
<td>Cache</td>
<td>类似Map的数据结构，用于存储键值对，存储的是Entry<br />用于获取、更新、移除这些键值对</td>
</tr>
<tr>
<td>Entry</td>
<td>即一个单独的键值对，存储于Cache中</td>
</tr>
<tr>
<td>ExpiryPolicy</td>
<td>过期策略</td>
</tr>
</tbody></table>
<p>它们之间的关系，用一个图来表示的话（我在网上偷了一张图）。</p>
<p><img src="https://gdz.oss-cn-shenzhen.aliyuncs.com/local/image-20210925225220620.png" alt="image-20210925225220620"></p>
<h3 id="注解"><a href="#注解" class="headerlink" title="注解"></a>注解</h3><p>定义了几个核心注解，Spring兼容的，就是这几个注解</p>
<table>
<thead>
<tr>
<th>注解</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>CacheDefaults</td>
<td>类级别注解。用于设置应用于整个类的属性<br />- 缓存名<br />- 缓存解析器<br />- key生成器</td>
</tr>
<tr>
<td>CacheResult</td>
<td>方法级别注解。表明该方法的返回值将被缓存<br />- 缓存key由方法参数参与生成<br />- 下次调用将优先取缓存中的值</td>
</tr>
<tr>
<td>CachePut</td>
<td>方法级别注解。表明该方法的某个参数将被写入缓存<br />- 目标参数必须用@CacheValue标注，否则会报错</td>
</tr>
<tr>
<td>CacheRemove</td>
<td>方法级别注解。表明方法调用结果对应的缓存entry将被删除，通过key匹配</td>
</tr>
<tr>
<td>CacheRemoveAll</td>
<td>方法级别注解。表明将删除所有匹配的entry，通过value匹配，value满足条件就会被删除</td>
</tr>
</tbody></table>
<h3 id="其它"><a href="#其它" class="headerlink" title="其它"></a>其它</h3><p>下面这些不是该标准的主要内容，但我认为有参考价值，特拿出来讲讲。</p>
<h4 id="Cache和Map的不同"><a href="#Cache和Map的不同" class="headerlink" title="Cache和Map的不同"></a>Cache和Map的不同</h4><p>从API长相来看，Cache和Map大差不差，有很多相似之处，但这里只关注不同点。</p>
<ul>
<li>Cache的key和value都不能为null</li>
<li>Cache的key和value需要支持序列化和反序列化</li>
<li>Cache的entry可以过期</li>
<li>Cache的entry可能因为某种策略被驱逐</li>
<li>Cache支持CAS操作</li>
<li>Cache可以按值存储，也可以按引用存储</li>
</ul>
<blockquote>
<p>注意，这里的不同，仅限于JSR107的定义，在别处不一定是这样</p>
</blockquote>
<h4 id="缓存值还是引用"><a href="#缓存值还是引用" class="headerlink" title="缓存值还是引用"></a>缓存值还是引用</h4><p>这是一个问题。我们常用Redis，它缓存的肯定是值嘛，缓存值时就涉及到序列化问题；但还有一种选择是缓存引用，这在本机的堆缓存是比较有用的，我们不一定能够用到，但要知道还有缓存引用这种方式。</p>
<h4 id="一致性考量"><a href="#一致性考量" class="headerlink" title="一致性考量"></a>一致性考量</h4><p>同上，日常调用时可能不大会用，但要知道。</p>
<p>一致性，指的是并发操作缓存时，缓存所表现出的样子。JSR107定义了三种一致性结果。</p>
<ul>
<li>happen-before：即悲观锁，各个线程依顺序获取锁</li>
<li>last value：无锁，各线程并发调用缓存，但是以最后一个操作成功的线程的结果为准</li>
<li>CAS：乐观锁，即满足给定条件才执行</li>
</ul>
<p>这三种一致性结果应用于不同的API，我们这里大致列一下。</p>
<p><img src="https://gdz.oss-cn-shenzhen.aliyuncs.com/local/image-20210926090210075.png" alt="image-20210926090210075"></p>
<h4 id="哪些没讲"><a href="#哪些没讲" class="headerlink" title="哪些没讲"></a>哪些没讲</h4><p>JSR107涉及到方方面面，当然还有没讲到的，这部分可以直接去看官方手册，列一下。</p>
<ul>
<li>缓存的类型安全保证：分为编译器类型安全和运行时类型安全。前者通过泛型保证，后者通过传入类对象在运行时校验保证</li>
<li>分布式缓存的实现方式：涉及到一系列缓存事件和事件监听器</li>
<li>缓存过期策略：按照缓存创建、访问等时间<br><img src="https://gdz.oss-cn-shenzhen.aliyuncs.com/local/image-20210926091050637.png" alt="image-20210926091050637"></li>
</ul>
<h3 id="哪些缓存实现了JSR107"><a href="#哪些缓存实现了JSR107" class="headerlink" title="哪些缓存实现了JSR107"></a>哪些缓存实现了JSR107</h3><p>说是Java标准，但并非所有库都支持，我们大致看一下。</p>
<table>
<thead>
<tr>
<th>库</th>
<th>支持与否</th>
</tr>
</thead>
<tbody><tr>
<td>Caffeine</td>
<td>支持</td>
</tr>
<tr>
<td>Lettuce</td>
<td>不支持，但可以通过Spring Data变相部分支持</td>
</tr>
<tr>
<td>Jedis</td>
<td>不支持，但可以通过Spring Data变相部分支持</td>
</tr>
<tr>
<td>Hazalcast</td>
<td>支持</td>
</tr>
</tbody></table>
<blockquote>
<p>注：这里说的变相支持，是因为Spring Data底层使用了lettuce或jedis，而Spring Data Cache支持JSR107的注解，因此可以说是部分兼容了。</p>
</blockquote>
<h2 id="Spring-Cache"><a href="#Spring-Cache" class="headerlink" title="Spring Cache"></a>Spring Cache</h2><p>在介绍篇幅上，读者很容易被Spring手册骗了，因为它花了大量篇幅在注解及其功能的介绍上，即更多地关注声明式的使用方式，弱化了编程式的使用方式。其实后者也是可以使用的。</p>
<p>就缓存抽象本身，无论从定义的内容，还是关注的点，和JSR107是差不多的。</p>
<ul>
<li>一套核心接口</li>
<li>一套注解</li>
<li>扩展功能和一致性考量等</li>
</ul>
<h3 id="注解-1"><a href="#注解-1" class="headerlink" title="注解"></a>注解</h3><table>
<thead>
<tr>
<th>Spring注解</th>
<th>说明</th>
<th>对应JSR107注解</th>
</tr>
</thead>
<tbody><tr>
<td>Cacheable</td>
<td>将调用结果作为缓存，且下次调用时直接取缓存</td>
<td>CacheResult</td>
</tr>
<tr>
<td>CacheEvict</td>
<td>缓存驱逐，如果加上allEntries，则是驱逐value值匹配到的所有条目</td>
<td>CacheRemove/CacheRemoveAll</td>
</tr>
<tr>
<td>CachePut</td>
<td>将方法的执行结果放入缓存</td>
<td>CachePut</td>
</tr>
<tr>
<td>Caching</td>
<td>一个大的调用，Caching内部可以使用上面那三个注解</td>
<td></td>
</tr>
<tr>
<td>CacheConfig</td>
<td>针对整个类的配置</td>
<td>CacheDefaults</td>
</tr>
</tbody></table>
<blockquote>
<p>注意，这些注解在语义上和JSR107可以说是一一对应，但在实际使用方式上其实是不同的，比如CachePut，Spring是将方法的执行结果放入缓存，而JSR107是将带有@CacheValue的参数放入缓存。</p>
</blockquote>
<p>Spring Cache兼容JSR107的注解，即，直接使用JSR107的注解，在Spring环境中依然能够正常工作。</p>
<h3 id="核心接口-1"><a href="#核心接口-1" class="headerlink" title="核心接口"></a>核心接口</h3><p>Spring文档开头，指出了实现缓存抽象的关键接口</p>
<ul>
<li>org.springframework.cache.Cache：缓存，实际执行缓存操作的接口</li>
<li>org.springframework.cache.CacheManager：缓存管理器，管理Cache实例</li>
</ul>
<p>如果要为Spring的缓存抽象适配缓存实现，只需要实现这两个接口。比如Redis，有RedisCache和RedisCacheManager实现，使用时只需创建RedisCacheManager并注入容器，其它的就不用管了，RedisCacheManager会为我们创建并管理RedisCache。</p>
<p>具体使用方法，后文会有详细描述。</p>
<h3 id="其它功能"><a href="#其它功能" class="headerlink" title="其它功能"></a>其它功能</h3><ul>
<li>自定义key：可通过注解的key属性+SPEL表达式，还有，keyGenerator属性这两种方式自定义key</li>
<li>同步缓存：通过sync属性指定。这一点对应JSR107的一致性考量</li>
<li>条件缓存：通过condition或unless属性+SPEL表达式指定缓存条件，即什么情况下使用缓存，什么情况下不使用缓存</li>
</ul>
<h2 id="对比"><a href="#对比" class="headerlink" title="对比"></a>对比</h2><p>两相对比，Spring Cache简单不少，毕竟只有两个接口。日常使用较多的还是Spring Cache，JSR107仅作了解。</p>
<h2 id="Spring中使用Redis"><a href="#Spring中使用Redis" class="headerlink" title="Spring中使用Redis"></a>Spring中使用Redis</h2><p>现在来用用看。假设使用场景：一个简单的视频系统——两张表，如下：</p>
<p><img src="https://gdz.oss-cn-shenzhen.aliyuncs.com/local/image-20210927185529108.png" alt="undefined"></p>
<p>video表存储视频的描述信息，如标题、描述、封面地址等；video_play_info存储视频播放地址和来源，他们是一对多的关系。</p>
<p>考虑到这里重缓存的演示，一切从简，数据库使用HashMap模拟；路由层去除，直接在单元测试中调用。于是，总共就这么几个类：配置、数据定义、数据操作、逻辑操作、一些全局变量、Spring Boot启动类。</p>
<p><img src="https://gdz.oss-cn-shenzhen.aliyuncs.com/local/image-20210927151957978.png" alt="undefined"></p>
<p>数据定义</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">data</span> <span class="class"><span class="keyword">class</span> <span class="title">Video</span></span>(</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">val</span> videoId: String,</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">val</span> title: String,</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">val</span> description: String,</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">val</span> coverUrl: String</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">data</span> <span class="class"><span class="keyword">class</span> <span class="title">VideoPlayInfo</span></span>(</span><br><span class="line">    <span class="keyword">val</span> id: String,</span><br><span class="line">    <span class="keyword">val</span> videoId: String,</span><br><span class="line">    <span class="keyword">val</span> playUrl: String,</span><br><span class="line">    <span class="keyword">val</span> source: String</span><br><span class="line">)</span><br></pre></td></tr></table></figure>

<p>repo操作接口，稍后需要在它的实现类添加缓存支持。</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">VideoRelatedRepo</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">addVideo</span><span class="params">(video: <span class="type">Video</span>)</span></span>: <span class="built_in">Boolean</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">getVideo</span><span class="params">(id: <span class="type">String</span>)</span></span>: Video</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">updateVideo</span><span class="params">(video: <span class="type">Video</span>)</span></span>: Video</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">deleteVideo</span><span class="params">(id: <span class="type">String</span>)</span></span>: Video</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">addVideoPlayInfo</span><span class="params">(videoPlayInfo: <span class="type">VideoPlayInfo</span>)</span></span>: <span class="built_in">Boolean</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">listVideoPlayInfo</span><span class="params">(videoIds: <span class="type">List</span>&lt;<span class="type">String</span>&gt;)</span></span>: List&lt;VideoPlayInfo&gt;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">updateVideoPlayInfo</span><span class="params">(videoPlayInfo: <span class="type">VideoPlayInfo</span>)</span></span>: VideoPlayInfo</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">deleteVideoPlayInfo</span><span class="params">(id: <span class="type">String</span>)</span></span>: VideoPlayInfo</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>下面，我们结合实际代码，解读使用方式。</p>
<h3 id="使用前配置"><a href="#使用前配置" class="headerlink" title="使用前配置"></a>使用前配置</h3><p>如前所说，为Spring Cache提供实现，只需要实现CacheManager和Cache接口，而由于Cache实例实际由CacheManager创建和管理，因此在配置时只需提供CacheManager，对于Redis，引入Spring-Data-Redis后，在配置类中创建RedisCacheManger。</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 这里我们提供一个超级简单的配置</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">val</span> REDIS_CACHE_NAME_VIDEO = <span class="string">&quot;VIDEO&quot;</span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">val</span> REDIS_CACHE_NAME_PLAY_INFO = <span class="string">&quot;PLAY_INFO&quot;</span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">val</span> REDIS_CACHE_PREFIX = <span class="string">&quot;SPRING_DEMO_VIDEO&quot;</span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">val</span> REDIS_CACHE_EXPIRE_DAYS = <span class="number">1L</span></span><br><span class="line"></span><br><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="meta">@EnableCaching</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">CacheConfig</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">cacheManager</span><span class="params">(connectionFactory: <span class="type">RedisConnectionFactory</span>)</span></span>: RedisCacheManager &#123;</span><br><span class="line">        <span class="keyword">val</span> objectMapper = jacksonObjectMapper().apply &#123;</span><br><span class="line">            <span class="keyword">this</span>.activateDefaultTyping(</span><br><span class="line">                LaissezFaireSubTypeValidator.instance,</span><br><span class="line">                ObjectMapper.DefaultTyping.EVERYTHING,</span><br><span class="line">                JsonTypeInfo.As.PROPERTY</span><br><span class="line">            )</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">val</span> valueSerializer = GenericJackson2JsonRedisSerializer(objectMapper)</span><br><span class="line">        <span class="keyword">val</span> shareConfiguration = RedisCacheConfiguration.defaultCacheConfig()</span><br><span class="line">            .entryTtl(Duration.ofDays(REDIS_CACHE_EXPIRE_DAYS))</span><br><span class="line">            .disableCachingNullValues()</span><br><span class="line">            .serializeKeysWith(RedisSerializationContext.SerializationPair.fromSerializer(RedisSerializer.string()))</span><br><span class="line">            .serializeValuesWith(RedisSerializationContext.SerializationPair.fromSerializer(valueSerializer))</span><br><span class="line">            .computePrefixWith &#123; cacheName -&gt; <span class="string">&quot;<span class="subst">$&#123;REDIS_CACHE_PREFIX&#125;</span><span class="subst">$&#123;CacheKeyPrefix.SEPARATOR&#125;</span><span class="subst">$&#123;cacheName&#125;</span><span class="subst">$&#123;CacheKeyPrefix.SEPARATOR&#125;</span>&quot;</span> &#125;</span><br><span class="line">        <span class="keyword">return</span> RedisCacheManager</span><br><span class="line">            .builder(connectionFactory)</span><br><span class="line">            .withCacheConfiguration(REDIS_CACHE_NAME_VIDEO, shareConfiguration)</span><br><span class="line">            .withCacheConfiguration(REDIS_CACHE_NAME_PLAY_INFO, shareConfiguration)</span><br><span class="line">            .build()</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>做几点说明</p>
<ol>
<li>需要提供RedisConnectionFactory，即连接信息。如果在配置文件配过了，则直接注入即可；或者直接创建RedisConnectionFactory的bean也可。</li>
</ol>
<figure class="highlight properties"><table><tr><td class="code"><pre><span class="line"><span class="meta">spring.redis.host</span>=<span class="string">120.78.147.168</span></span><br><span class="line"><span class="meta">spring.redis.port</span>=<span class="string">16379</span></span><br><span class="line"><span class="meta">spring.redis.password</span>=<span class="string">test123</span></span><br><span class="line"><span class="meta">spring.redis.database</span>=<span class="string">0</span></span><br><span class="line"><span class="meta">spring.redis.timeout</span>=<span class="string">2000</span></span><br><span class="line"><span class="meta">spring.redis.jedis.pool.max-active</span>=<span class="string">8</span></span><br><span class="line"><span class="meta">spring.redis.jedis.pool.max-idle</span>=<span class="string">8</span></span><br><span class="line"><span class="meta">spring.redis.jedis.pool.min-idle</span>=<span class="string">2</span></span><br></pre></td></tr></table></figure>

<ol>
<li>创建Manager时需要同时提供针对缓存的配置，可以针对特定名的Cache配置，也可以提供针对所有名字的Cache配置。上面，分别为名为video和videoPlayInfo的缓存实例，提供配置。配置类是RedisCacheConfiguration。</li>
<li>RedisCacheConfiguration配置能力如下</li>
</ol>
<ul>
<li><p>TTL</p>
</li>
<li><p>是否缓存null值，这里是指value为null，且缓存null时也并非真的写入一个null进去，而是使用替代对象，如下</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> static <span class="keyword">final</span> byte[] BINARY_NULL_VALUE = RedisSerializer.java().serialize(NullValue.INSTANCE);</span><br></pre></td></tr></table></figure></li>
<li><p>key的前缀，这个最最常用。因为我们往往是多个系统共用一个Redis DB，难免会有key冲突的情况，为每个系统设置自己的前缀，可以避免这个问题。<br>有三种方式提供前缀</p>
</li>
<li><p>写死的字符串</p>
</li>
<li><p>CachePrefix对象</p>
</li>
<li><p>lambda表达式</p>
<p>这里使用了lambda表达式，使得固定前缀为SPRING_DEMO_VIDEO::VIDEO::。其中”::”分隔符来自CachePrefix的常量。</p>
</li>
<li><p>针对key和value的序列化对，即序列化和反序列化器，这个比较常用，如果对序列化有特殊需求，就要配置它们</p>
<p>我们要将对象序列化为json，因此有所自定义，序列化器这点，在下文的“问题”中有所描述。</p>
</li>
<li><p>类型转换器，用的是Spring Core的ConversionService</p>
</li>
</ul>
<p><strong>关于缓存名</strong></p>
<p>问：cache name，即缓存的名字，会发现它无处不在：获取缓存实例时需要、配置缓存时需要、使用注解时也需要。该怎么理解它？</p>
<p>答：它，就是用来区分Cache实例的，一个CacheManager，可以管理多个Cache实例，使用name区分。</p>
<p><strong>关于Cache实例</strong></p>
<p>问：Cache这个接口，及其实例，存在的必要是什么？与缓存连接有什么关系？多个Cache实例之间是什么关系？Cache实例创建几个比较好？</p>
<p>答：这些问题，可以结合Cache接口和RedisCache实现来看。</p>
<p>看Cache接口，它只是提供了缓存的抽象，上面我们说过，Cache和Map很像，Cache接口就用于提供缓存的基本操作的；</p>
<p>再看RedisCache，其主要包含的四个属性。其中CacheWriter中包含了RedisConnectionFactory，是共享的；RedisCacheConfiguration、ConversionService是独享的。可以看出，RedisCache只是为不同场景持有不同的配置提供了方便，即，一个项目，多套配置，使用name区分。比如对用户的缓存需要ttl为1天，对session的缓存只要一小时，这就形成了两套配置需求。</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> String name;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> RedisCacheWriter cacheWriter;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> RedisCacheConfiguration cacheConfig;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> ConversionService conversionService;</span><br></pre></td></tr></table></figure>

<p>针对上面的问题：</p>
<ul>
<li><p>Cache存在的必要</p>
<p>就是缓存的抽象而已。</p>
</li>
<li><p>与Redis的连接关系</p>
<p>没有关系，不管多少个Cache实例，他们共用一个RedisConnectionFactory，连接池共享。</p>
</li>
<li><p>多个Cache实例之间的关系</p>
<p>共享连接池；独享缓存配置。</p>
</li>
<li><p>Cache实例创建几个</p>
<p>依据情况而定，有几个缓存场景就可以创建多少个Cache实例，不会影响性能</p>
</li>
</ul>
<h3 id="声明式缓存-—-注解"><a href="#声明式缓存-—-注解" class="headerlink" title="声明式缓存 — 注解"></a>声明式缓存 — 注解</h3><p>大部分情况，都可以用注解解决问题，在获取单个对象时创建缓存，在更新时更新缓存，在删除时驱逐缓存。下面是对video对象操作的例子：</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Repository</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">VideoRelatedRepoImpl</span></span>(cacheManager: CacheManager) : VideoRelatedRepo &#123;</span><br><span class="line"> </span><br><span class="line">  ... ...</span><br><span class="line">  <span class="meta">@Cacheable(cacheNames = [REDIS_CACHE_NAME_VIDEO], key = <span class="meta-string">&quot;#id&quot;</span>)</span></span><br><span class="line">  <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">getVideo</span><span class="params">(id: <span class="type">String</span>)</span></span>: Video &#123;</span><br><span class="line">    logger.info(<span class="string">&quot;通过数据库获取值&quot;</span>)</span><br><span class="line">    <span class="keyword">return</span> videoDB[id] <span class="keyword">as</span> Video</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@CachePut(cacheNames = [REDIS_CACHE_NAME_VIDEO], key = <span class="meta-string">&quot;#video.id&quot;</span>)</span></span><br><span class="line">  <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">updateVideo</span><span class="params">(video: <span class="type">Video</span>)</span></span>: Video &#123;</span><br><span class="line">    videoDB[video.id] = video</span><br><span class="line">    <span class="keyword">return</span> videoDB[video.id] <span class="keyword">as</span> Video</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@CacheEvict(cacheNames = [REDIS_CACHE_NAME_VIDEO], key = <span class="meta-string">&quot;#id&quot;</span>)</span></span><br><span class="line">  <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">deleteVideo</span><span class="params">(id: <span class="type">String</span>)</span></span>: Video &#123;</span><br><span class="line">    <span class="keyword">return</span> videoDB.remove(id) <span class="keyword">as</span> Video</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  ... ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="编程式缓存-—-RedisCache"><a href="#编程式缓存-—-RedisCache" class="headerlink" title="编程式缓存 — RedisCache"></a>编程式缓存 — RedisCache</h3><p>本例有一个特殊场景，根据videoId批量获取播放信息，由于播放信息可能随时变化，因此缓存单个播放信息比较科学，这就需要部分从缓存中取，部分从数据库中取。此时注解无能为力。需要直接使用RedisCache操作</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Repository</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">VideoRelatedRepoImpl</span></span>(cacheManager: CacheManager) : VideoRelatedRepo &#123;</span><br><span class="line">  </span><br><span class="line">  <span class="comment">// 获取Cache对象的方式</span></span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">val</span> videoPlayInfoCache = cacheManager.getCache(REDIS_CACHE_NAME_PLAY_INFO)!!</span><br><span class="line">  </span><br><span class="line">  ... ...</span><br><span class="line">  <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">listVideoPlayInfo</span><span class="params">(videoIds: <span class="type">List</span>&lt;<span class="type">String</span>&gt;)</span></span>: List&lt;VideoPlayInfo&gt; &#123;</span><br><span class="line">    <span class="comment">// 读取对应关系</span></span><br><span class="line">    <span class="keyword">val</span> playInfoIds = selectIdByVideoIds(videoIds)</span><br><span class="line">    <span class="comment">// 先从缓存获取</span></span><br><span class="line">    <span class="keyword">val</span> infosInCache = playInfoIds.mapNotNull &#123; videoPlayInfoCache.<span class="keyword">get</span>(it, VideoPlayInfo::<span class="keyword">class</span>.java) &#125;</span><br><span class="line">    <span class="keyword">val</span> infoIdsInDB = playInfoIds.filterNot &#123; id -&gt; infosInCache.any &#123; it.id == id &#125; &#125;</span><br><span class="line">    <span class="comment">// 再从数据库获取</span></span><br><span class="line">    <span class="keyword">val</span> infosInDB = videoPlayInfoDB.multiGet(infoIdsInDB).map &#123; it <span class="keyword">as</span> VideoPlayInfo &#125;</span><br><span class="line">    <span class="comment">// 再写入缓存</span></span><br><span class="line">    infosInDB.forEach &#123; videoPlayInfoCache.put(it.id, it) &#125;</span><br><span class="line">    logger.info(<span class="string">&quot;通过缓存获取了<span class="subst">$&#123;infosInCache.size&#125;</span>; 通过数据库获取了<span class="subst">$&#123;infosInDB.size&#125;</span>&quot;</span>)</span><br><span class="line">    <span class="keyword">return</span> infosInCache + infosInDB</span><br><span class="line">  &#125;</span><br><span class="line">  ... ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="RedisTemplate怎么说"><a href="#RedisTemplate怎么说" class="headerlink" title="RedisTemplate怎么说"></a>RedisTemplate怎么说</h3><p>这算乱入了，RedisTemplate和缓存抽象半毛钱关系没有。它只是一个Redis客户端，关于它的使用方式，官方手册也有说明。这里就不说了。</p>
<p>倒是值得分清楚几个问题</p>
<p><strong>分清楚RedisTemplate和CacheManager</strong></p>
<p>我好奇过：为啥配置了CacheManager，还要配置一遍RedisTemplate？</p>
<p>因为它们根本就没关系呀，前者是Spring Cache抽象的一部分；后者是Redis客户端。谁也不包含谁，当然要分开配置。</p>
<p><strong>分清楚RedisCache和RedisTemplate</strong></p>
<p>他俩没关系，前者只是缓存抽象的实现，功能简单，顶多不过put数据、驱逐数据等缓存常规操作；后者是<strong>全功能</strong>Redis客户端。</p>
<p><strong>RedisTemplate强滴很</strong></p>
<p>翻翻看RedisTemplate源码，可以看到它包含了Redis的几乎所有操作，三个字：强滴很。</p>
<p><strong>啥时候用RedisTemplate</strong></p>
<p>它强是强，但用起来也复杂呀，并且能统一设置前缀、过期时间等。</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line">redisTemplate.opsForValue().<span class="keyword">set</span>(<span class="string">&quot;key&quot;</span>, <span class="string">&quot;value&quot;</span>, Duration.ofHours(<span class="number">1</span>))</span><br></pre></td></tr></table></figure>

<p>因此，在只有缓存需求时，使用Cache抽象最方便，有额外需求时，才考虑使用RedisTemplate。</p>
<h3 id="可能会遇到的问题"><a href="#可能会遇到的问题" class="headerlink" title="可能会遇到的问题"></a>可能会遇到的问题</h3><p>上面展示的配置是最终版，但中间是有遇到问题的</p>
<ul>
<li><p>序列化问题：DefaultSerializer requires a Serializable payload but received an object of type [xxx.VideoPlayInfo]</p>
<p>首先，前面提到过我们可以指定key和value的序列化器和反序列化器，如果我们不指定，就会使用DefaultSerializer，而它是要求目标类实现Serializable接口的，然后，我们并没有实现该接口。</p>
<p>解决方案1：为目标类实现Serializable接口，尝试过，这样是OK的。</p>
<p>解决方案2：换一个序列化和反序列化器，我们使用RedisSerializer.json()得到一个json序列化器</p>
</li>
</ul>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 配置片段</span></span><br><span class="line">.serializeValuesWith(RedisSerializationContext.SerializationPair.fromSerializer(RedisSerializer.json()))</span><br></pre></td></tr></table></figure>

<ul>
<li><p>反序列化问题：Could not read JSON: Could not resolve subtype of [simple type, class java.lang.Object]: missing type id property ‘@class’</p>
<p>对象序列化成JSON写入Redis了，读出来却无法转回目标对象。因为少了@class属性。所以这里还少了一点配置。</p>
</li>
</ul>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">val</span> objectMapper = jacksonObjectMapper().apply &#123;</span><br><span class="line">  <span class="comment">// 管家配置</span></span><br><span class="line">  <span class="keyword">this</span>.activateDefaultTyping(</span><br><span class="line">    LaissezFaireSubTypeValidator.instance,</span><br><span class="line">    ObjectMapper.DefaultTyping.EVERYTHING,</span><br><span class="line">    JsonTypeInfo.As.PROPERTY</span><br><span class="line">  )</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">val</span> valueSerializer = GenericJackson2JsonRedisSerializer(objectMapper)</span><br><span class="line"><span class="comment">// 配置片段</span></span><br><span class="line">.serializeValuesWith(RedisSerializationContext.SerializationPair.fromSerializer(valueSerializer))</span><br></pre></td></tr></table></figure>

<h2 id="这里有个Demo"><a href="#这里有个Demo" class="headerlink" title="这里有个Demo"></a>这里有个Demo</h2><p>说是这么说，写是这么写，上面的内容，构建了一个可运行的项目，忘了的时候，可以来看看。</p>
<p><a href="https://gitee.com/zou8944/spring-me/tree/master/spring-cache">&lt;我就是那个项目&gt;</a></p>
<blockquote>
<p>注意，我们没有使用数据库，因此在启动SpringBoot时要排除数据源</p>
</blockquote>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="meta">@SpringBootApplication(exclude = [DataSourceAutoConfiguration::class, HibernateJpaAutoConfiguration::class])</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SpringMeApplication</span></span></span><br></pre></td></tr></table></figure>

<p>运行项目的单元测试，可以观察到缓存内容，如下图展示：一个视频信息、两个播放信息，注意观察key的组成和存储值的格式。<br><img src="https://gdz.oss-cn-shenzhen.aliyuncs.com/local/image-20210927203046805.png" alt="undefined"></p>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ol>
<li><a href="https://docs.google.com/document/d/1ijduF_tmHvBaUS7VBBU2ZN8_eEBiFaXXg9OI0_ZxCrA/edit">JSR107</a></li>
<li><a href="https://docs.spring.io/spring-framework/docs/4.3.x/spring-framework-reference/html/cache.html">Spring Cache Abstraction</a></li>
<li><a href="https://docs.spring.io/spring-data/redis/docs/2.5.5/reference/html/#reference">Spring Data Redis</a></li>
</ol>
]]></content>
      <categories>
        <category>后端</category>
      </categories>
      <tags>
        <tag>缓存</tag>
      </tags>
  </entry>
  <entry>
    <title>通过几个问题了解HTTP协议</title>
    <url>/2018/10/15/%E9%80%9A%E8%BF%87%E5%87%A0%E4%B8%AA%E9%97%AE%E9%A2%98%E4%BA%86%E8%A7%A3HTTP%E5%8D%8F%E8%AE%AE-%E9%80%9A%E8%BF%87%E5%87%A0%E4%B8%AA%E9%97%AE%E9%A2%98%E4%BA%86%E8%A7%A3http%E5%8D%8F%E8%AE%AE/</url>
    <content><![CDATA[<h2 id="Http全称？"><a href="#Http全称？" class="headerlink" title="Http全称？"></a>Http全称？</h2><pre><code>超文本传输协议：Hypertext Transfer protocol
</code></pre>
<span id="more"></span>

<h2 id="常用状态码"><a href="#常用状态码" class="headerlink" title="常用状态码"></a>常用状态码</h2><figure class="highlight html"><table><tr><td class="code"><pre><span class="line">- 200	响应正常</span><br><span class="line">- 400	Bad Request，请求数据有问题</span><br><span class="line">- 401	Unauthorized，权限不足，资源存在但不让访问</span><br><span class="line">- 403	Forbidden，你的IP被屏蔽时会出现</span><br><span class="line">- 404	资源找不到</span><br><span class="line">- 301	重定向</span><br><span class="line">- 500	服务器内部错误</span><br></pre></td></tr></table></figure>

<h2 id="常用method"><a href="#常用method" class="headerlink" title="常用method"></a>常用method</h2><figure class="highlight html"><table><tr><td class="code"><pre><span class="line">- get		用于获取资源</span><br><span class="line">- post		用于发送数据到服务端，常用于提交表单数据</span><br><span class="line">- put		用于修改资源属性</span><br><span class="line">- delete	用于删除资源</span><br></pre></td></tr></table></figure>

<h2 id="Http协议格式"><a href="#Http协议格式" class="headerlink" title="Http协议格式"></a>Http协议格式</h2><pre><code>请求和响应的消息协议是一样的：起始行、消息头、消息体。三部分以CRLF分隔，最后一个消息头有两个CRLF，表示接下来是消息体的内容了。
</code></pre>
<h3 id="起始行"><a href="#起始行" class="headerlink" title="起始行"></a>起始行</h3><pre><code>请求的起始行称为请求行，格式：method uri http/version，如 get /index.html http/1.1

响应的起始行称为状态行，格式 ：http/version code desc，如 http/1.1 200 ok。第三个字段是状态码的简单描述信息。
</code></pre>
<h3 id="消息头"><a href="#消息头" class="headerlink" title="消息头"></a>消息头</h3><pre><code>消息头由很多键值对组成，键值对之间以CRLF作为分隔。
</code></pre>
<h3 id="消息体"><a href="#消息体" class="headerlink" title="消息体"></a>消息体</h3><pre><code>消息体是一个字符串，字符串长度由消息头中的Content-length字段指定。没有指定则没有消息体。
</code></pre>
<h2 id="分块传送"><a href="#分块传送" class="headerlink" title="分块传送"></a>分块传送</h2><pre><code>当浏览器向服务器请求一个资源时，该资源是一个动态资源，服务器无法预知该资源的大小。此时会采用分块传送。

服务器先生成一个chunk，发送这个chunk，再生成一个chunk，再发送一个chunk，直到全部资源传送完成。分块传送需要在请求头增加一个特殊的键值对transfer-encoding: chunked，那么消息体的内容便是分块传送的。

chunked传输格式如下图所示，由一段一段的分块组合而成，每个块由一个长度行和一个分块体组成，最后一个分块长度为0表示结束。
</code></pre>
<p><img src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly9zczAuYmFpZHUuY29tLzZPTldzamlwMFFJWjh0eWhucS9pdC91PTIzNjg2NDEwMjEsMTU4MTE3ODM1MiZmbT0xNzMmYXBwPTI1JmY9SlBFRw?x-oss-process=image/format,png" alt="img"></p>
<h2 id="持久连接的机制是怎样的"><a href="#持久连接的机制是怎样的" class="headerlink" title="持久连接的机制是怎样的"></a>持久连接的机制是怎样的</h2><pre><code>早期的Http 1.0每个请求都会发起一个连接，每个页面数百个请求就会发起数百个连接，非常浪费服务器资源。因此在Http 1.1加入了持久连接的机制，Keep-Alive，使得一个连接可以连续服务多个请求。节省了资源

持久连接并不会一直保持连接，而是通过设置 Keep Alive Timeout和Keep Alive Request限制单个连接的持续时长和最多的请求次数。

如果 Keep Alive Timeout设置为0，则退化到非持久连接。如果Keep Alive Timeout设置为超长，当然也不会一直保持，各个浏览器都有相关的控制。
</code></pre>
<h2 id="什么叫Pipeline管线化"><a href="#什么叫Pipeline管线化" class="headerlink" title="什么叫Pipeline管线化"></a>什么叫Pipeline管线化</h2><pre><code>这也是Http 1.1新引入的特性。之前的请求模式是：一个请求发起，服务器响应完了，再进行下一个请求的发起和响应，这样当请求一多时就会很慢

改进的方式是，将多个请求按顺序打包一起发给服务器，服务器再按顺序将多个响应一起打包回复。这样就快很多了。如下图示很形象地描述了管线化前和管线化后
</code></pre>
<p><img src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly9zczAuYmFpZHUuY29tLzZPTldzamlwMFFJWjh0eWhucS9pdC91PTM0MDIwNDQ4MzgsNzAzNzIwMjE1JmZtPTE3MyZhcHA9MjUmZj1KUEVH?x-oss-process=image/format,png" alt="img"></p>
<p><img src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly9zczIuYmFpZHUuY29tLzZPTllzamlwMFFJWjh0eWhucS9pdC91PTEyOTc0NTkzNDksMTU2MTg5NTk3MSZmbT0xNzMmYXBwPTI1JmY9SlBFRw?x-oss-process=image/format,png" alt="img"></p>
<h2 id="如何理解Http协议的无状态性"><a href="#如何理解Http协议的无状态性" class="headerlink" title="如何理解Http协议的无状态性"></a>如何理解Http协议的无状态性</h2><pre><code>无状态指的是服务器的协议层无需为不同请求之间建立任何相关关系。不过这是协议规定的，但建立在Http协议上的应用会通过Session的方式来达到状态保存的目录。
</code></pre>
<h2 id="GET和POST的区别"><a href="#GET和POST的区别" class="headerlink" title="GET和POST的区别"></a>GET和POST的区别</h2><ul>
<li>GET用于获取资源，POST用于向服务器发送数据</li>
<li>GET将数据添加到URL后，POST则是将数据放在请求消息体中</li>
<li>由第二点导致了如下三点的不同<ul>
<li>GET相对POST能让用户看到传输内容，不安全</li>
<li>GET由于URL长度的限制传输内容有限，POST则好很多</li>
<li>GET由于URL的编码限制只能传输ASCII码，而POST则可以传输正常编码格式的文件</li>
</ul>
</li>
</ul>
<h2 id="常见Http消息头字段"><a href="#常见Http消息头字段" class="headerlink" title="常见Http消息头字段"></a>常见Http消息头字段</h2><h3 id="通用头部字段"><a href="#通用头部字段" class="headerlink" title="通用头部字段"></a>通用头部字段</h3><figure class="highlight html"><table><tr><td class="code"><pre><span class="line">- Date				报文创建时间</span><br><span class="line">- Connection		连接的管理：连续或是此次发送后关闭连接</span><br><span class="line">- Cache-Control		缓存控制，如值为max-age=120，表示缓存120秒有效</span><br><span class="line">- Transfer-Encoding	报文的传输编码格式</span><br></pre></td></tr></table></figure>

<h3 id="请求头部字段"><a href="#请求头部字段" class="headerlink" title="请求头部字段"></a>请求头部字段</h3><figure class="highlight html"><table><tr><td class="code"><pre><span class="line">- Host				请求资源所在服务器：主机+端口</span><br><span class="line">- User-Agent		客户端将本地的操作系统、浏览器和其它属性发送给服务器，非必须，可修改</span><br><span class="line">- Accept			客户端希望接收的媒体类型，如 image/webp,image/apng,image/*,*/*;q=0.8</span><br><span class="line">- Accept-Charset	客户端可接收的字符集</span><br><span class="line">- Accept-Encoding	客户端可接收的内容编码，如 gzip, deflate, br</span><br><span class="line">- Accept-Language	客户端可接收的自然语言，如 zh-CN,zh;q=0.9</span><br><span class="line">- Authorization		用于证明客户端有权查看某个资源</span><br><span class="line">- refer				</span><br><span class="line"></span><br><span class="line">举例</span><br><span class="line">GET /form.html HTTP/1.1 (CRLF)</span><br><span class="line"></span><br><span class="line">Accept:image/gif,image/x-xbitmap,image/jpeg,application/msword,*/* (CRLF)</span><br><span class="line">Accept-Language:zh-cn (CRLF)</span><br><span class="line">Accept-Encoding:gzip,deflate (CRLF)</span><br><span class="line">If-Modified-Since:Wed,05 Jan 2007 11:21:25 GMT (CRLF)</span><br><span class="line">If-None-Match:W/&quot;80b1a4c018f3c41:8317&quot; (CRLF)</span><br><span class="line">User-Agent:Mozilla/4.0(compatible;MSIE6.0;Windows NT 5.0) (CRLF)</span><br><span class="line">Host:www.guet.edu.cn (CRLF)</span><br><span class="line">Connection:Keep-Alive (CRLF)</span><br></pre></td></tr></table></figure>

<h3 id="响应头部字段"><a href="#响应头部字段" class="headerlink" title="响应头部字段"></a>响应头部字段</h3><figure class="highlight html"><table><tr><td class="code"><pre><span class="line">- Accept-Ranges		可接受的字节范围</span><br><span class="line">- Location			让客户端重定向到的URL</span><br><span class="line">- Server			Http服务器的安装信息，如 Apache-Coyote/1.1</span><br></pre></td></tr></table></figure>

<h3 id="实体头部字段"><a href="#实体头部字段" class="headerlink" title="实体头部字段"></a>实体头部字段</h3><figure class="highlight html"><table><tr><td class="code"><pre><span class="line">- Allow				资源可支持的Http方法</span><br><span class="line">- Content-type		实体内容的类型</span><br><span class="line">- Content-Encoding	实体内容的编码方式</span><br><span class="line">- Content-Language	实体内容的语言</span><br><span class="line">- Content-length	实体内容的长度，单位是字节</span><br><span class="line">- Content-Range		实体内容的位置范围，一般是发出部分请求时使用</span><br><span class="line">- Last-Modified		请求资源最后修改时间</span><br></pre></td></tr></table></figure>

<h2 id="其它知识补充"><a href="#其它知识补充" class="headerlink" title="其它知识补充"></a>其它知识补充</h2><h3 id="应用层协议"><a href="#应用层协议" class="headerlink" title="应用层协议"></a>应用层协议</h3><ul>
<li>HTTP</li>
<li>FTP</li>
<li>SMTP</li>
<li>DNS</li>
<li>TELNET</li>
</ul>
]]></content>
      <categories>
        <category>网络基础</category>
      </categories>
      <tags>
        <tag>HTTP</tag>
      </tags>
  </entry>
  <entry>
    <title>读书不应该过于理性</title>
    <url>/2021/08/28/%E8%AF%BB%E4%B9%A6%E4%B8%8D%E5%BA%94%E8%AF%A5%E8%BF%87%E4%BA%8E%E7%90%86%E6%80%A7-du-shu-bu-ying-gai-guo-yu-li-xing/</url>
    <content><![CDATA[<h2 id="我读一本书的鬼样子"><a href="#我读一本书的鬼样子" class="headerlink" title="我读一本书的鬼样子"></a>我读一本书的鬼样子</h2><p>来描绘一下我现在读书的样子。首先我会按照如下顺序去阅读</p>
<ul>
<li>目录</li>
<li>从前往后通读</li>
<li>如果需要，我会做笔记，记录所有看起来重要的知识点</li>
<li>整理并输出笔记</li>
</ul>
<p>于是，我得到了这本书的缩减版，所谓的，把书读薄。</p>
<span id="more"></span>

<p>效果如何呢？我想是很大的，就拿《深入理解kafka》这本书来说，在读完的一个月之内，我对kafka的理解都算是不错的，并且今后对kafka的复习也有了较为快捷的资料，不必去看网上水平参差不齐、各种各样不痛不痒的文章，也不用重新去看一遍整本书，毕竟太长了。</p>
<p>但这样做的缺点很明显，那就是耗时，极度耗时。具体来讲，有这几个缺点</p>
<ul>
<li>耗时，速度极慢。通读，需要大量整块的时间，时间短了无法进入状态，太大块的时间又是很难能够抽出来的。</li>
<li>读完之后整理笔记，更加耗时，且枯燥乏味，完全是凭借毅力在做这件事</li>
<li>阅读过程中会失焦，就算你带着问题，其中还是会涉及到很多平时可能根本接触不到也用不到的知识，它们其实没啥用，还会分散你的注意力。</li>
</ul>
<p>总体看下来，就是读书性价比不高。虽然效果很好，但是时间成本过高，对于还有很多重要知识需要学习的我来说，是不划算的。</p>
<p>就好比最近，我想读一读我们熟悉的那些技术的RFC，如WebSocket、HTTP1.1、HTTP2.0、MQTT、AMPQ等，但每一篇RFC都几乎可以等同于一本书，还是全英文的，我读英文资料的速度会比中文的慢一倍，如果还是照我上面的方法去读，客观理性角度来讲，不大现实。都不是效率高不高的问题了，已经到了无法完成的地步了。因为除此之外，我还想学习历史、哲学。最为重要的，我是一个程序员，需要大量的时间去写代码。想想就可怕。</p>
<h2 id="有所启发和感悟"><a href="#有所启发和感悟" class="headerlink" title="有所启发和感悟"></a>有所启发和感悟</h2><p>按照我读书的节奏，不仅效率低、性价比不高，还容易使人产生焦虑。看似效率问题重要，其实焦虑更应该值得注意。现代人们最大的痛苦来源，莫过于焦虑。</p>
<p>今日读到一本书，说：”在读一本书时，只去全书最触动自己的点，然后尽可能去实践、改变。这样读书不仅收获更大，而且不会焦虑“。</p>
<p>这就是所谓的，借助感性去读书。</p>
<p>我非常赞同，于是结合自己的实际情况，对不同的书，做不同的阅读策略。</p>
<ul>
<li>对文学作品<ul>
<li>通读</li>
<li>写读后感，非感性，不是一首小诗，不是些感慨的话。而是纯理性角度去讨论最令人印象深刻的话题。</li>
<li>如果我不知道它讲了啥，去看别的书评。然后想想再写</li>
</ul>
</li>
<li>对技术书籍<ul>
<li>搜索相关技术的面试笔试题（技术的关键点是纯客观的，面试题无疑是一个很好的点）</li>
<li>目录</li>
<li>根据以下要义选择性粗读或精读相关章节<ul>
<li>这项技术是什么</li>
<li>解决了什么问题</li>
<li>面试题相关内容如何解决</li>
</ul>
</li>
<li>整理笔记：记录对准备的题目的答案即可</li>
</ul>
</li>
</ul>
<h2 id="还有哪里可改进"><a href="#还有哪里可改进" class="headerlink" title="还有哪里可改进"></a>还有哪里可改进</h2><p>上面给出的策略是拍脑袋想出来的，但其实会有更加科学的阅读方式可以参考。我想，我还需要去阅读《如何阅读一本书》。</p>
]]></content>
      <categories>
        <category>随笔</category>
      </categories>
      <tags>
        <tag>读书</tag>
      </tags>
  </entry>
  <entry>
    <title>随笔 - 为什么我们使用PostgreSQL而不用MySQL</title>
    <url>/2020/07/07/%E9%9A%8F%E7%AC%94%20-%20%E4%B8%BA%E4%BB%80%E4%B9%88%E6%88%91%E4%BB%AC%E4%BD%BF%E7%94%A8PostgreSQL%E8%80%8C%E4%B8%8D%E7%94%A8MySQL-sui-bi--wei-shen-me-wo-men-shi-yong-postgresql-er-bu-yong-mysql/</url>
    <content><![CDATA[<h2 id="与MySQL相比，有何优势"><a href="#与MySQL相比，有何优势" class="headerlink" title="与MySQL相比，有何优势"></a>与MySQL相比，有何优势</h2><ol>
<li>SQL标准的null判断用is null，而不是=null。PG可以设置transform_null_equals把=null翻译成is null</li>
</ol>
<span id="more"></span>

<ol start="2">
<li><p>MySQL显示emojji时，需要将字符集设置为<a href="https://dev.mysql.com/doc/refman/8.0/en/charset-unicode.html">utf8mb4</a>。而PG就不用</p>
<p>在MySQL中，对Unicode的支持，主要又如下几种字符集</p>
<ul>
<li>utf8mb4</li>
<li>utf8mb3</li>
<li>utf8</li>
<li>ucs2</li>
<li>utf16</li>
<li>utf16le</li>
<li>utf32</li>
</ul>
<p>这里我们只关心前三个，其中utf8mb4表示使用1-4字节来描述一个Unicode字符；utf8mb3表示使用1-3字节来描述一个Unicode字符。而utf8是utf8mb3的别名。</p>
<p>而Unicode字符分两种</p>
<ul>
<li><p>基本的BMP字符</p>
<p>码点位于U+0000 到 U+FFFF之间；能够使用1-3个字节变长表示；也能使用2字节定长表示；它之间包含了世界上的绝大多数语言。</p>
</li>
<li><p>BMP字符之外的附加字符</p>
<p>码点在U+10000 到 U+10FFFF之间；需要最多四个字节表示</p>
</li>
</ul>
<p>emojji字符也在unicode中，2010年Unicode开始为emojji分配码点。而它就在基础的BMP码点之外。因此utf8mb3是无法表示emojji字符的。</p>
<p>那PostgreSQL是如何做的呢？</p>
<p>依据<a href="https://www.postgresql.org/docs/10/multibyte.html">手册</a>，PostgreSQL的text能够存各种类型的字符集，其中针对Unicode的UTF8，是1-4字节变长，因此PG天然就能存emojji字符。而PG服务端和客户端具体支持的其他字符集类型，还是参见手册。</p>
</li>
</ol>
<h2 id="与其他关系型数据库，有何优势"><a href="#与其他关系型数据库，有何优势" class="headerlink" title="与其他关系型数据库，有何优势"></a>与其他关系型数据库，有何优势</h2><ol>
<li>自带NoSQL属性：可以存储array和json，甚至可以在array和json上建立索引，他的jsonb的性能已经比MongoDB的BSON性能要好了。</li>
<li>自带全文搜索功能，不过中文的话就要额外安装中文分词插件。</li>
<li>他有GIS，即地理信息扩展，可以非常方便地进行地理位置计算，可做地图服务器。这是PG的杀手级功能。</li>
<li>能够高效地处理图结构。</li>
<li>能够当作时序数据库</li>
</ol>
<h2 id="结尾"><a href="#结尾" class="headerlink" title="结尾"></a>结尾</h2><p>PostgreSQL功能强大，基本日常用到的需求它都有了，并且做的都不错。它是一个全栈数据库。</p>
<p>国内比较有名的使用PG的公司是探探。百万日活、上百TB数据量，数据组件还只用了PG。直到千万日活才引入独立的数据仓库。</p>
<p><strong>OLTP</strong>：事务处理是PostgreSQL的本行</p>
<p><strong>OLAP</strong>：citus分布式插件，ANSI SQL兼容，窗口函数，CTE，CUBE等高级分析功能，任意语言写UDF</p>
<p><strong>流处理</strong>：PipelineDB扩展，Notify-Listen，物化视图，规则系统，灵活的存储过程与函数编写</p>
<p><strong>时序数据</strong>：timescaledb时序数据库插件，分区表，BRIN索引</p>
<p><strong>空间数据</strong>：PostGIS扩展（杀手锏），内建的几何类型支持，GiST索引。</p>
<p><strong>搜索索引</strong>：全文搜索索引足以应对简单场景；丰富的索引类型，支持函数索引，条件索引</p>
<p><strong>NoSQL</strong>：JSON，JSONB，XML，HStore原生支持，至NoSQL数据库的外部数据包装器</p>
<p><strong>数据仓库</strong>：能平滑迁移至同属Pg生态的GreenPlum，DeepGreen，HAWK等，使用FDW进行ETL</p>
<p><strong>图数据</strong>：递归查询</p>
<p><strong>缓存</strong>：物化视图</p>
<h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><ol>
<li><a href="https://dev.mysql.com/doc/refman/8.0/en/charset-unicode.html">MySQL手册</a></li>
<li><a href="https://www.postgresql.org/docs/10/multibyte.html">PostgreSQL手册</a></li>
<li><a href="http://www.postgres.cn/downfiles/pg2016conf_day1_s1_pm4.pdf">PostgreSQL和探探见证4亿次心动</a></li>
<li><a href="https://developer.aliyun.com/article/60027">https://developer.aliyun.com/article/60027</a></li>
</ol>
]]></content>
      <categories>
        <category>后端</category>
        <category>数据库</category>
        <category>随笔</category>
      </categories>
      <tags>
        <tag>PostgreSQL</tag>
        <tag>MySQL</tag>
      </tags>
  </entry>
  <entry>
    <title>随笔 - 消息队列客户端从服务端获取消息时的原理</title>
    <url>/2020/08/15/%E9%9A%8F%E7%AC%94%20-%20%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97%E5%AE%A2%E6%88%B7%E7%AB%AF%E4%BB%8E%E6%9C%8D%E5%8A%A1%E7%AB%AF%E8%8E%B7%E5%8F%96%E6%B6%88%E6%81%AF%E6%97%B6%E7%9A%84%E5%8E%9F%E7%90%86-sui-bi--xiao-xi-dui-lie-ke-hu-duan-cong-fu-wu-duan-huo-qu-xiao-xi-shi-de-yuan-li/</url>
    <content><![CDATA[<blockquote>
<p>同事：阿里云MNS获取消息的API使用起来不够方便，需要不断手动长轮询，看起来有点原始。<br>我：em。。。那其它消息队列使用什么方式？难道不是长轮询？</p>
</blockquote>
<p>在使用<a href="https://help.aliyun.com/product/27412.html?spm=a2c4g.11186623.6.540.42f17e2f0aTqZl">阿里云MNS（Message Notification Service）</a>服务时，意识到其从服务端获取消息的方式是手动长轮询。写代码时可能会用到while-true看似危险的控制结构，而查看手册这也是官方推荐的使用方式。于是想找找其它消息队列拉取消息的原理。</p>
<span id="more"></span>

<h2 id="长轮询"><a href="#长轮询" class="headerlink" title="长轮询"></a>长轮询</h2><p>在此之前，我们首先做一些基础知识准备——什么是长轮询？<br>而要回答这个问题之前，我们需要区分：长连接、短链接、长轮询、短轮询。</p>
<h3 id="长连接、短连接"><a href="#长连接、短连接" class="headerlink" title="长连接、短连接"></a>长连接、短连接</h3><p>长短连接，指的的TCP连接。当客户端通过socket连接到服务端时，就建立了一个TCP连接，当双方都不关闭该连接时，它就是长连接。而如果在一次请求-响应后，关闭了这个TCP连接，则称这个连接为短链接。</p>
<p>在TCP协议中，并没有长连接、短连接的概念，这完全是根据使用方法区分。</p>
<p>需要注意TCP长连接会因为网络波动、操作系统环境等问题出现连接丢失的问题，需要进行额外的连接保活工作，如发送定时心跳（心跳保活机制在很多场景下都有使用，比如Zookeeper；比如AMQP）。</p>
<h3 id="长轮询、短轮询"><a href="#长轮询、短轮询" class="headerlink" title="长轮询、短轮询"></a>长轮询、短轮询</h3><p>轮询，即客户端与客户端不断重复 请求数据-消费数据 这一过程。有两种策略</p>
<ul>
<li>客户端请求，服务端有数据则返回数据，没有数据则返回空。</li>
<li>客户端请求，服务端有数据则返回数据，没有数据则将连接保持，等有数据时再返回。<h3 id="HTTP的keep-alive"><a href="#HTTP的keep-alive" class="headerlink" title="HTTP的keep-alive"></a>HTTP的keep-alive</h3>TCP是传输层协议，而HTTP是应用层协议。而头部Connection: Keep-Alive表示维持TCP连接，即我们常说的HTTP长连接。<br>Keep-Alive的工作原理如下：</li>
<li>客户端请求携带Connection: Keep-Alive头部，服务端接收后，会在响应该条HTTP请求后继续保持TCP连接；否则关闭。</li>
<li>客户端在收到的服务端响应后，如果有携带Connection: Keep-Alive头部，则会使用同一个TCP连接发送下一个HTTP请求。</li>
</ul>
<p>此外，Keep-Alive还可以设置timeout参数，用于指定预期的连接超时时间。</p>
<p>注意HTTP协议本身是一个请求-响应协议，无状态，即一个事务在请求-响应后就结束了，再次请求就是一个新事务。而HTTP协议中定义了几种HTTP连接：</p>
<ul>
<li>常规连接：即请求响应后即关闭TCP连接。</li>
<li>持久连接（又称长连接）：即可以传输多个事务的连接，传输后不关闭TCP连接，下次传输继续使用。对应Keep-Alive。</li>
<li>管道式连接：即在一个TCP连接上一次发送多个事务的请求，再依次接收多个事务的请求。传统的是一个事务的请求-响应完成后再进行下一个事务。</li>
</ul>
<h2 id="阿里云MNS"><a href="#阿里云MNS" class="headerlink" title="阿里云MNS"></a>阿里云MNS</h2><p>阿里云MNS的数据传输走的是HTTP协议，意味着无论是点对点、还是发布-订阅模式，都要通过HTTP来进行。这就导致了文章一开始所说的使用方式的问题，由于HTTP协议本身无状态，只能是客户端请求-服务端响应，客户端拉取数据时只能采用轮询的方式。而为了拉取操作过于频繁带来的损失，采用的长轮询：客户端请求，服务端没有消息时，挂起该连接，等到有消息时再响应。</p>
<p>也许你很好奇，如果走HTTP协议，那客户端如何订阅主题，即客户端如何被动收到消息？答案是设置回调地址；或将主题消息推送到另一个队列，然后长轮询该队列。</p>
<p>总之阿里云MNS获取消息的方式因为其采用HTTP传输协议而受到了限制。不过这也有一个好处，就是<strong>任何语言都能使用MNS服务</strong>，甚至不需要SDK，手动调起HTTP接口即可。</p>
<h2 id="RabbitMQ"><a href="#RabbitMQ" class="headerlink" title="RabbitMQ"></a>RabbitMQ</h2><p>RabbitMQ走的是AMQP协议，它和HTTP一样，也是应用层协议，构建于TCP之上。与HTTP不同的是，它专门设计用于消息传输。客户端和服务端采用TCP长连接，前面说过，只要建立了TCP连接，数据就能双向传输。这样就能做到客户端不需要主动轮询，服务端推送消息到客户端的效果。使用起来方便很多。对AMQP协议，就是Basic.Consume。</p>
<h2 id="WebSocket"><a href="#WebSocket" class="headerlink" title="WebSocket"></a>WebSocket</h2><p>既然说到了AMQP的双向传输功能，就联想到了WebSocket，它是如何实现双向传输的呢？在翻看一些资料后，发现它也是建立了一个持久的TCP连接，利用TCP双向传输的特性，实现服务端的消息推送。</p>
<p>通常说WebSocket时，是对比HTTP协议，HTTP协议无状态，事务间隔离，建立在请求-响应这样的被动机制下，在应用上无法实现服务端主动推送消息的场景。WebSocket的出现就是为了解决该问题，</p>
<p>如果把WebSocket和AMQP进行对比，在服务端主动发送消息到客户端这一点来说，二者原理一致。甚至可以说WebSocket是AMQP的功能子集。当然也不能这么说，毕竟他们目标不同，WebSocket聚焦于推送消息，而AMQP聚焦于消息模型的抽象，顺带解决消息传输的问题。且就消息推送这一点来说，尽管原理一致，实现方式可能也是不同的。</p>
<h2 id="还可深入探索的点"><a href="#还可深入探索的点" class="headerlink" title="还可深入探索的点"></a>还可深入探索的点</h2><p>当然消息队列除了上述两个，还有很多其它的，比如流行的Kafka、RocketMQ、ActiveMQ等。由于他们并不是基于AMQP协议，因此具体方式还不知道。不过我想，传输层都是TCP，实现双向传输的机制应该逃不过TCP长连接的。</p>
]]></content>
      <categories>
        <category>随笔</category>
        <category>后端</category>
        <category>消息队列</category>
      </categories>
      <tags>
        <tag>消息队列</tag>
      </tags>
  </entry>
  <entry>
    <title>馒</title>
    <url>/2021/02/08/%E9%A6%92-%E9%A6%92%E5%A4%B4%E7%9A%84%E8%87%AA%E6%88%91%E4%BF%AE%E7%82%BC/</url>
    <content><![CDATA[<h1 id="馒"><a href="#馒" class="headerlink" title="馒"></a>馒</h1><h2 id="写在前面"><a href="#写在前面" class="headerlink" title="写在前面"></a>写在前面</h2><p>在遥远而古老的二十世纪末、二十一世纪初，的四川东北部乡村，家里的面食几乎只有一种——挂面。自家种的小麦，大夏天吭哧吭哧背到大队加工厂，制面机震耳欲聋，眼看着小麦变成面粉，再变成面条，上杆、晾晒，从早上等到下午，中午吃自带的干粮。晾干、切断，用精心裁剪的报纸包装成束，装袋，再吭哧吭哧背回家。半年的面食就算完成了。这几乎是人生前十来年每年必做的工作，就像死亡和税收——无法逃脱。</p>
<span id="more"></span>

<p><img src="https://iknow-pic.cdn.bcebos.com/86d6277f9e2f07082b79175be424b899a901f268?x-bce-process=image/resize,m_lfit,w_600,h_800,limit_1"></p>
<p>对面食的厌恶，也是从这些记忆开始。按照村里的习惯，早、午饭是正餐，晚上可以随便对付——吃面。再好吃的东西，也架不住”每天“这个频率。更何况自家种的小麦其实并不好吃，加上贫乏的调料，面的口感和味道着实不敢恭维。以至于后来闻到挂面的味道就想吐，只能中午留剩饭，晚上家人吃面我吃饭。这个状态，持续到上大学。</p>
<p>对面食态度的大转弯，从北方开始。初到北方，受同学影响，开始尝试各种各样的面：打卤面、大同勾刀面、龙须面、刀削面，算是打开了新世界的大门，不到一个月，甚至连向来鄙夷的挂面也不再觉得难吃；后到西北，肉夹馍、臊子面、比昂比昂面、油泼面，更让自己一度怀疑我可能是个北方人。对面食的喜爱，扩展到了一切以面为主的食物。</p>
<p>对馒头的特殊记忆，来自大三暑假留校，食堂关闭剩一个，早中晚窗口仅开放一个小时。整天泡在实验室，早中饭都行，惟独晚饭怎么也赶不及。于是馒头+泡面+《暴走大事件》陪伴了我大半个暑假（泡面换了好几种，统一香辣牛肉面为最佳；馒头，则一定要是北方大馒头，一个，抵一碗）。</p>
<p><img src="http://n.sinaimg.cn/sinacn10116/205/w640h365/20181211/dbf6-hqackaa2936278.bmp"></p>
<p>有时候会炒个菜，蒸两个馒头，一方面是让自己的住处多一点生活气息，另一方面则只是为了好玩。如果做饭成功，还能顺便改善一下伙食，何乐而不为呢？不过，饭这个东西，不能常常做。一周下厨一两次，是享受生活；一天下厨一两次，就只是生活了。</p>
<h2 id="写在中间"><a href="#写在中间" class="headerlink" title="写在中间"></a>写在中间</h2><h3 id="北方馒头、南方馒头"><a href="#北方馒头、南方馒头" class="headerlink" title="北方馒头、南方馒头"></a>北方馒头、南方馒头</h3><p>南北馒头是不同的，这些差异主要提现在如下几个方面：</p>
<table>
<thead>
<tr>
<th></th>
<th>北方馒头</th>
<th>南方馒头</th>
</tr>
</thead>
<tbody><tr>
<td>口感</td>
<td>紧实、有嚼劲，能有效训练咀嚼肌</td>
<td>松软、弹牙</td>
</tr>
<tr>
<td>形状</td>
<td>多为圆形，个头较大</td>
<td>多为刀切馒头，个头较小</td>
</tr>
<tr>
<td>味道</td>
<td>一般无味</td>
<td>一般为甜味，甚至可以沾炼乳</td>
</tr>
<tr>
<td>防身</td>
<td>个头质量都较大，冬季室外冻硬后可防身</td>
<td>质量、体积、密度均不如北方馒头，因此即使冻硬后也无法防身</td>
</tr>
<tr>
<td>工艺</td>
<td>制作工艺较复杂，尤其在发酵这一步，时间长，工序多，常需要碱面</td>
<td>制作工艺相对简单，一般发酵只需两小时</td>
</tr>
<tr>
<td>示例</td>
<td><img src="https://ss1.bdstatic.com/70cFvXSh_Q1YnxGkpoWK1HF6hhy/it/u=1750289358,327831799&fm=26&gp=0.jpg" alt="北方馒头"></td>
<td><img src="https://ss1.bdstatic.com/70cFvXSh_Q1YnxGkpoWK1HF6hhy/it/u=364620683,599338928&fm=26&gp=0.jpg" alt="南方馒头"></td>
</tr>
</tbody></table>
<p>我认为比较确切的说法</p>
<ul>
<li>北方馒头更加使用用来当做主食，可代替米饭在午饭这样重要的场合下发挥作用</li>
<li>南方馒头偏向点心，顶多只能在早餐这种级别的场合下有所表现</li>
</ul>
<p><strong>这次，我们要做的是：南方馒头</strong></p>
<h3 id="高、中、低筋粉"><a href="#高、中、低筋粉" class="headerlink" title="高、中、低筋粉"></a>高、中、低筋粉</h3><p>常说的高筋、中筋、低筋面粉，其中“筋”指的是蛋白质含量。蛋白质亲水，因此蛋白质含量越高，吸水性越好，做出来的成品越劲道。它们具体区别如下</p>
<table>
<thead>
<tr>
<th></th>
<th>高筋粉</th>
<th>中筋粉</th>
<th>低筋粉</th>
</tr>
</thead>
<tbody><tr>
<td>蛋白质含量</td>
<td>&gt; 12%</td>
<td>9% ~ 11%</td>
<td>&lt; 9%</td>
</tr>
<tr>
<td>适用于</td>
<td>面条、面包等</td>
<td>馒头、包子等</td>
<td>蛋糕、点心等</td>
</tr>
<tr>
<td>制成来源</td>
<td>特殊小麦品种；或中筋粉加工</td>
<td>一般小麦</td>
<td>中筋粉加工</td>
</tr>
</tbody></table>
<p>市面上买到的面粉产品，如未标明，多半属于中筋粉，一般小麦去壳制作即得到中筋面粉。</p>
<h3 id="酵母粉、小苏打、泡打粉"><a href="#酵母粉、小苏打、泡打粉" class="headerlink" title="酵母粉、小苏打、泡打粉"></a>酵母粉、小苏打、泡打粉</h3><p>这几种材料都是用来发面的，但其工作原理不同，得到的结果也不尽相同，区别如下</p>
<table>
<thead>
<tr>
<th></th>
<th>酵母粉</th>
<th>小苏打</th>
<th>泡打粉</th>
</tr>
</thead>
<tbody><tr>
<td>主要成分</td>
<td>酵母菌</td>
<td>碳酸氢钠(NaHCO3)</td>
<td>碳酸氢钠(NaHCO3) + 酸性材料 + 玉米粉</td>
</tr>
<tr>
<td>发面原理</td>
<td>生物反映：酵母菌在有氧的情况下将糖分分解成二氧化碳和水</td>
<td>化学反应：碳酸氢钠加热产生二氧化碳</td>
<td>化学反应：碳酸氢钠加热产生二氧化碳，但因加入了酸性材料，使得结果呈中性</td>
</tr>
<tr>
<td>性质</td>
<td>弱酸性</td>
<td>弱碱性</td>
<td>中性</td>
</tr>
<tr>
<td>使用场景</td>
<td>馒头等</td>
<td>馒头等</td>
<td>糕点</td>
</tr>
</tbody></table>
<p>常用来做馒头的只有酵母粉和小苏打，泡打粉并不适合。而酵母粉由于主要成分是酵母菌，高温下会死亡，30°效果最好。小苏打目前还未使用过，不做评价。</p>
<h3 id="用料比例"><a href="#用料比例" class="headerlink" title="用料比例"></a>用料比例</h3><p>这一项不怎么算理论值，可归于经验值。</p>
<ul>
<li>水:面粉 = 1:2</li>
<li>酵母粉:面粉 = 1:100</li>
<li>人工食用色素：面粉 = 1:1000</li>
</ul>
<h2 id="材料准备"><a href="#材料准备" class="headerlink" title="材料准备"></a>材料准备</h2><h3 id="食材"><a href="#食材" class="headerlink" title="食材"></a>食材</h3><ul>
<li>中筋面粉</li>
<li>酵母粉</li>
<li>色素：自制天然色素或购买的人工色素</li>
<li>温水、清水</li>
</ul>
<h3 id="用具"><a href="#用具" class="headerlink" title="用具"></a>用具</h3><ul>
<li>厨房用称（分辨率0.1g）</li>
<li>不锈钢盆</li>
<li>擀面台</li>
<li>擀面杖</li>
<li>菜刀（锋利，刀切馒头必备）</li>
<li>保鲜膜（用于发酵）</li>
<li>蒸锅 + 纱布</li>
<li>榨汁机（如需使用天然色素）</li>
</ul>
<h2 id="调色"><a href="#调色" class="headerlink" title="调色"></a>调色</h2><h3 id="天然色素"><a href="#天然色素" class="headerlink" title="天然色素"></a>天然色素</h3><p>天然色素即从日常食材中获取到的颜色，做了一些实验，分别得到了如下效果。</p>
<table>
<thead>
<tr>
<th>材料</th>
<th>操作方法</th>
<th>结果</th>
</tr>
</thead>
<tbody><tr>
<td>南瓜段</td>
<td>蒸</td>
<td>黄色</td>
</tr>
<tr>
<td>紫薯</td>
<td>蒸</td>
<td>紫色</td>
</tr>
<tr>
<td>草莓+蓝莓</td>
<td>混合榨汁</td>
<td>紫红色</td>
</tr>
<tr>
<td>草莓+蓝莓+牛奶</td>
<td>混合榨汁</td>
<td>紫色</td>
</tr>
<tr>
<td>甘蓝叶+水</td>
<td>混合榨汁</td>
<td>紫色</td>
</tr>
<tr>
<td>甘蓝叶+蓝莓</td>
<td>混合榨汁</td>
<td>紫红色</td>
</tr>
<tr>
<td>甘蓝叶+橘子</td>
<td>混合榨汁</td>
<td>紫红色</td>
</tr>
<tr>
<td>甘蓝叶+小苏打</td>
<td>混合榨汁</td>
<td></td>
</tr>
</tbody></table>
<p>结合实际来看，黄色和紫色最容易得到，且较为稳定，在和面后颜色基本不丢失。通过榨汁得到的颜色在和面后明显变淡，与最初的颜色差异大，着色效果非常不理想。</p>
<p>这里记录了部分调色和加上面粉之后的颜色效果。</p>
<table>
<thead>
<tr>
<th>调色效果</th>
<th>和面效果</th>
</tr>
</thead>
<tbody><tr>
<td>黄色：南瓜泥巴；紫红色：草莓+蓝莓+牛奶；紫色：甘蓝汁</td>
<td>黄色：南瓜泥；紫色：紫薯泥；灰色：草莓+蓝莓+牛奶</td>
</tr>
<tr>
<td><img src="https://gdz.oss-cn-shenzhen.aliyuncs.com/hexo/%E9%A6%92%E5%A4%B4%E7%9A%84%E8%87%AA%E6%88%91%E4%BF%AE%E7%82%BC.assets/image-20201220225102760.png" alt="image-20201220225102760"></td>
<td><img src="https://gdz.oss-cn-shenzhen.aliyuncs.com/hexo/%E9%A6%92%E5%A4%B4%E7%9A%84%E8%87%AA%E6%88%91%E4%BF%AE%E7%82%BC.assets/image-20201220225038338.png" alt="image-20201220225038338"></td>
</tr>
<tr>
<td>成品效果（最终口感失败）</td>
<td></td>
</tr>
<tr>
<td><img src="https://gdz.oss-cn-shenzhen.aliyuncs.com/hexo/%E9%A6%92%E5%A4%B4%E7%9A%84%E8%87%AA%E6%88%91%E4%BF%AE%E7%82%BC.assets/image-20201220225647342.png" alt="image-20201220225647342" style="zoom:60%;" /></td>
<td></td>
</tr>
</tbody></table>
<p>此外，调色效果最好的南瓜泥和紫薯泥因本身成分非常重，即要着色成效果较好的黄色需要较多南瓜泥，此时面粉比例被稀释，口感和发面效果都有所影响，不便把控。需要多次探索才能找到较好的解决方式。</p>
<h3 id="人工色素"><a href="#人工色素" class="headerlink" title="人工色素"></a>人工色素</h3><p>人工色素，即人工合成色素，相比于天然色素，其优点众多：色彩鲜艳、着色效果好、性质稳定。但人工色素本身无营养价值，使用过量甚至会有害健康，这点需注意。一定要从正规渠道购买。使用天空蓝着色效果如下</p>
<p><img src="https://gdz.oss-cn-shenzhen.aliyuncs.com/hexo/%E9%A6%92%E5%A4%B4%E7%9A%84%E8%87%AA%E6%88%91%E4%BF%AE%E7%82%BC.assets/image-20201220230646364.png" alt="image-20201220230646364"></p>
<p><strong>重要：人工色素的使用请严格按照GB2760标准使用，一把推荐比例为1:1000，即1kg成品使用1g人工色素。</strong></p>
<h2 id="和"><a href="#和" class="headerlink" title="和"></a>和</h2><p>和面的两个关键点</p>
<ul>
<li>用料比例：用料比例推荐为：面粉:水=2:1；面粉:酵母粉=100:1；面粉:人工色素=1000:1。</li>
<li>和面：体力活，原料按比例混合后，和啊和啊就OK了，和面过程大约会持续十几分钟，直至面不沾手，面不沾盆。当然没经验的同学可能需要几个回合才能学会。</li>
</ul>
<p>关于和面忘记拍照，不过可以参考网上大把的教程，比如这个：<a href="https://www.bilibili.com/video/BV1S7411m72C">https://www.bilibili.com/video/BV1S7411m72C</a></p>
<h2 id="发"><a href="#发" class="headerlink" title="发"></a>发</h2><p>发面是个人认为最最简单但也是最重要的一步，将和好的面摊在盆底，使用保鲜膜封好，放置于30度左右的环境中。</p>
<p>发面的时间依据实际环境温度大约持续1-3小时不等，标准是面蓬松为原先的两倍大即可。</p>
<p><img src="https://gdz.oss-cn-shenzhen.aliyuncs.com/hexo/%E9%A6%92%E5%A4%B4%E7%9A%84%E8%87%AA%E6%88%91%E4%BF%AE%E7%82%BC.assets/image-20201220232103569.png" alt="image-20201220232103569"></p>
<h2 id="预加工"><a href="#预加工" class="headerlink" title="预加工"></a>预加工</h2><p>上锅前预加工包括</p>
<ul>
<li><p>揉出气体</p>
<p>面发开后会产生大量蜂窝状气孔，需再次和面，直至气孔几乎消失，否则会影响馒头形状。检查的方式是用刀切断面团，<strong>横截面几无气孔即可</strong>。</p>
</li>
</ul>
<p><img src="https://gdz.oss-cn-shenzhen.aliyuncs.com/hexo/%E9%A6%92%E5%A4%B4%E7%9A%84%E8%87%AA%E6%88%91%E4%BF%AE%E7%82%BC.assets/image-20201220230646364.png" alt="image-20201220230646364"></p>
<ul>
<li><p>定型</p>
<p>即为上锅的馒头确定形状，可折花、直接刀切、做圆等，可网上搜索具体步骤。我们直接刀切。</p>
<table>
<thead>
<tr>
<th>刀切馒头</th>
<th>刀切馒头、刀切花卷馒头</th>
</tr>
</thead>
<tbody><tr>
<td><img src="https://gdz.oss-cn-shenzhen.aliyuncs.com/hexo/%E9%A6%92%E5%A4%B4%E7%9A%84%E8%87%AA%E6%88%91%E4%BF%AE%E7%82%BC.assets/image-20201220233818840.png" alt="image-20201220233818840"></td>
<td><img src="https://gdz.oss-cn-shenzhen.aliyuncs.com/hexo/%E9%A6%92%E5%A4%B4%E7%9A%84%E8%87%AA%E6%88%91%E4%BF%AE%E7%82%BC.assets/image-20201220233840221.png" alt="image-20201220233840221"></td>
</tr>
</tbody></table>
</li>
</ul>
<h2 id="蒸"><a href="#蒸" class="headerlink" title="蒸"></a>蒸</h2><p>上锅，盖盖，不开火发约15分钟，开大火，水开后转中小火，蒸15分钟。为防水汽四溅，可按下图加上纸巾。</p>
<p><img src="https://gdz.oss-cn-shenzhen.aliyuncs.com/hexo/%E9%A6%92%E5%A4%B4%E7%9A%84%E8%87%AA%E6%88%91%E4%BF%AE%E7%82%BC.assets/image-20201220234554450.png" alt="image-20201220234554450"></p>
<p><strong>熄火后不可马上揭盖，需等待5分钟，否则馒头会遇冷迅速收缩，影响外观和口感。</strong></p>
<p>最终得到结果如下</p>
<table>
<thead>
<tr>
<th>所有馒头</th>
<th>拆开</th>
</tr>
</thead>
<tbody><tr>
<td><img src="https://gdz.oss-cn-shenzhen.aliyuncs.com/hexo/%E9%A6%92%E5%A4%B4%E7%9A%84%E8%87%AA%E6%88%91%E4%BF%AE%E7%82%BC.assets/image-20201220234653166.png" alt="image-20201220234653166"></td>
<td><img src="https://gdz.oss-cn-shenzhen.aliyuncs.com/hexo/%E9%A6%92%E5%A4%B4%E7%9A%84%E8%87%AA%E6%88%91%E4%BF%AE%E7%82%BC.assets/image-20201220234758516.png" alt="image-20201220234758516"></td>
</tr>
</tbody></table>
<h2 id="再加热"><a href="#再加热" class="headerlink" title="再加热"></a>再加热</h2><p>一次蒸馒头太多吃不完怎么办，再加热无法避免。最好的方式当然是上锅蒸咯，这样出来的旧馒头不会因为缺乏水分显得干巴巴。</p>
<p>但公司只有微波炉，因此还是有必要探究一下如何使用微波炉加热馒头，这里做了个实验说明。</p>
<p>加热之前的馒头如下：</p>
<p><img src="https://gdz.oss-cn-shenzhen.aliyuncs.com/hexo/%E9%A6%92%E5%A4%B4%E7%9A%84%E8%87%AA%E6%88%91%E4%BF%AE%E7%82%BC.assets/image-20201220213944476.png" alt="image-20201220213944476"></p>
<p>以不同火候，加热不同的时间，对比如下：</p>
<table>
<thead>
<tr>
<th>中高火、4分钟：糊了</th>
<th>中高火、4分钟、旁边放杯水：干了</th>
<th>中火、2分钟、旁边放杯水：刚好</th>
<th>中火、2分钟、表面喷水：刚好</th>
</tr>
</thead>
<tbody><tr>
<td><img src="https://gdz.oss-cn-shenzhen.aliyuncs.com/hexo/%E9%A6%92%E5%A4%B4%E7%9A%84%E8%87%AA%E6%88%91%E4%BF%AE%E7%82%BC.assets/image-20201220214003262.png" alt="image-20201220214003262"></td>
<td><img src="https://gdz.oss-cn-shenzhen.aliyuncs.com/hexo/%E9%A6%92%E5%A4%B4%E7%9A%84%E8%87%AA%E6%88%91%E4%BF%AE%E7%82%BC.assets/image-20201220214017973.png" alt="image-20201220214017973"></td>
<td><img src="https://gdz.oss-cn-shenzhen.aliyuncs.com/hexo/%E9%A6%92%E5%A4%B4%E7%9A%84%E8%87%AA%E6%88%91%E4%BF%AE%E7%82%BC.assets/image-20201220214031920.png" alt="image-20201220214031920"></td>
<td><img src="https://gdz.oss-cn-shenzhen.aliyuncs.com/hexo/%E9%A6%92%E5%A4%B4%E7%9A%84%E8%87%AA%E6%88%91%E4%BF%AE%E7%82%BC.assets/image-20201220214046563.png" alt="image-20201220214046563"></td>
</tr>
</tbody></table>
<p>可见，中火2分钟较为合适，而表面喷水和一旁放置一杯水得到的效果差别不大。因此暂得出以下推荐方式。</p>
<p><strong>使用微波炉加热，控制在中火、2分钟、与一杯水同时加热为最好</strong>。</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>本文介绍了“我”对面食、对馒头喜爱的由来，介绍了关于蒸馒头的几个关键性问题，并列举了在调色、实际操作上的经验，方式不一定对，但都是自己切身体会，仅供大家参考。如有更好建议，欢迎一起讨论。</p>
<p>蒸馒头步骤总结：和面 -&gt; 发面 -&gt; 预加工 -&gt; 蒸，其中和面和发面至关重要，上锅蒸之前的预发也很重要，以此步骤，多重复几次，定能做出令人满意的结果。</p>
<p>蒸馒头看似简单，但其实相当耗时，以实际经验来看，整个过程比较顺利的情况下也要超过两小时，但在此过程中，找到快乐，享受每一个步骤带来的乐趣，感受蒸锅揭开瞬间时失败带来的失落或成功带来的喜悦，正如年少时的我们在探索未知世界时感受到挫败与成就。这个事，可以做！！！</p>
]]></content>
      <tags>
        <tag>馒头</tag>
      </tags>
  </entry>
  <entry>
    <title>一篇能把LDAP讲明白的文章</title>
    <url>/2021/12/30/%E7%A0%94%E7%A9%B6%E4%B8%80%E4%B8%8BLDAP%E5%90%A7/</url>
    <content><![CDATA[<blockquote>
<p>本文试图清晰明白的讲述LDAP是什么、应用场景、使用方法。</p>
</blockquote>
<p>开篇照例一波吐槽。LDAP这个名字大家不会陌生，即所谓轻量级目录访问协议。无论博客还是论坛，网上对它的讲解太多了，但在我看来，都不得要领。它们中的大多数都仅介绍了冰山一角，还不注明资料来源。想来，作者很可能也不知道这些知识从哪里来的，这篇文章看看、那篇文章参考一下，东拼西凑，再看看库的API，写写代码，然后…it works!!!，再然后就没有然后了吧🤔。</p>
<p>本文试图从协议本身出发，尽量做到系统化。就算读者看了这篇文章还是不能掌握，也可以自己翻看协议文档解决问题。毕竟一手资料才是最可靠的。</p>
<span id="more"></span>

<h2 id="协议介绍"><a href="#协议介绍" class="headerlink" title="协议介绍"></a>协议介绍</h2><p>与LDAP相关的协议很多，但主要是两个系列，这里列出。读者可以不看本文后面内容，直接去翻协议了。</p>
<ul>
<li><p><a href="https://www.itu.int/rec/dologin_pub.asp?lang=e&id=T-REC-X.500-200811-S!!PDF-E&type=items">X.500系列协议</a></p>
<p>目录服务的最初协议，完整地描述了目录、目录服务的组成、目录结构等内容。X.500本身只是一个概览，各部分的实现在其子协议如X.501、X.502中，所以说X.500是一个系列协议。</p>
<p>值得一提的是，常见的X.509公钥证书也属于该系列协议。</p>
</li>
<li><p><a href="https://www.rfc-editor.org/rfc/pdfrfc/rfc4510.txt.pdf">LDAP系列协议</a></p>
<p>LDAP并非只有一个协议文件，其涉及到方方面面，每个方面单独由一个协议文件描述，加星号的必看</p>
<ul>
<li>RFC4511*：通过TCP传输消息的方式，规定了传输层面的消息类型、消息内容，如绑定、查询等</li>
<li>RFC4512*：信息模型，规定了schema、object class、attribute type等内容</li>
<li>RFC4513*：规定了鉴权方式和安全机制：TLS、SASL</li>
<li>RFC4514：规定了DN的字符串表示方式</li>
<li>RFC4515：规定了过滤器的格式，过滤器用于查找时指定条件</li>
<li>RFC4516：规定了统一资源定位符的格式，即LDAP端点长啥样</li>
<li>RFC4517*：语法和匹配规则，列举了所有允许的语法和匹配规则</li>
<li>RFC4518：字符串国际化</li>
<li>RFC4519*：应用程序的schema，列举了所有允许的object class和attribute type</li>
<li>RFC2377*：推荐的DIT组织方式，即目录服务的树的组织方式</li>
</ul>
</li>
</ul>
<h2 id="缩写"><a href="#缩写" class="headerlink" title="缩写"></a>缩写</h2><p>LDAP文章也好、协议也好，总是会有一大堆缩写，让人不明所以，这里列出常见的</p>
<ul>
<li>DAP - Directory Access Protocol，即目录访问协议</li>
<li>LDAP - Lightweight Directory Access Protocol，轻量级目录访问协议</li>
<li>DIB - Directory Information Base，目录信息库</li>
<li>DIT - Directory Information Tree，目录信息树</li>
<li>DUA - Directory User Agent，用户代理</li>
<li>DN - Distinguished Name，可区别名称，即唯一名称</li>
<li>RDN - Relative Distinguished Name，相对唯一名称，指DIT内某个节点上的名称，上层节点的DN配合上本节点的RDN，能够构成本节点的DN</li>
<li>一些属性类型的介绍<ul>
<li>c - country name，国家名</li>
<li>cn - common name，通用名称</li>
<li>dc - domain component，域名组件</li>
<li>o - organization name，机构名</li>
<li>ou - organization unit name，机构的单位名</li>
<li>sn - surname，姓</li>
<li>st - state or province name，州或省</li>
</ul>
</li>
</ul>
<h2 id="Directory-目录or电话簿？"><a href="#Directory-目录or电话簿？" class="headerlink" title="Directory - 目录or电话簿？"></a>Directory - 目录or电话簿？</h2><p>国内将Directory翻译成目录，但如果用Google翻译协议中涉及到的相关内容，会被翻译成电话簿，哪种更好理解呢？从树形结构上看，貌似目录更容易理解，从历史原因看，后者更容易理解。这里顺便解释两个概念</p>
<ul>
<li>白页：个人通信目录，这个在上世纪的美国电影中能见到。为什么是白页—以前使用白色纸张记录个人通信目录。黄页也是这个原因。</li>
<li>黄页：企业和团体通信目录，例如80、90后熟知的hao123网址黄页</li>
</ul>
<p>要我看，翻译成两者都没有问题，但读者要掌握的核心是——树、查找。即Directory服务内部的数据组织形式是树形结构，这样做的目的是方便查找。其最开始存在的目的是做白页、黄页类应用，而我们可以利用这个结构做其它事情，比如用一个LDAP服务管理公司内所有地方的用户信息。</p>
<blockquote>
<p>为了统一，本文将Directory翻译成“目录”</p>
</blockquote>
<h2 id="X-500协议"><a href="#X-500协议" class="headerlink" title="X.500协议"></a>X.500协议</h2><p>如果不看X.500协议，LDAP中的很多东西是看不懂的。X.500定义了目录服务，LDAP只是它的轻量级实现。我们看看它规定了什么。</p>
<h3 id="定义目录系统"><a href="#定义目录系统" class="headerlink" title="定义目录系统"></a>定义目录系统</h3><p>Directory旨在提供一个用户友好的name-address类的映射，其中name不可变，address允许动态变化，即key-value结构。Directory由一批系统组成，每个系统持有对应现实世界的逻辑数据，这些存储的数据叫做<strong>DIB</strong>，即目录信息库。整体架构如下</p>
<img src="https://gdz.oss-cn-shenzhen.aliyuncs.com/local/image-20220103110714678.png" alt="image-20220103110714678" style="zoom:80%;" />

<p>一个标准的目录系统，有以下几部分</p>
<ul>
<li>目录服务</li>
<li>目录服务的用户</li>
<li>目录服务用来暴露自己的访问端点</li>
<li>用户和服务之间使用协议如LDAP进行交互</li>
<li>用户使用LDAP客户端访问目录服务</li>
</ul>
<h3 id="DIB与DIT"><a href="#DIB与DIT" class="headerlink" title="DIB与DIT"></a>DIB与DIT</h3><p>目录信息库，由DIT（目录信息树）、节点Entry、Entry中的属性及属性值构成。</p>
<ul>
<li>Entry代表一个节点，类型可以是object，也可以是alias，后者表示一个object entry的别名</li>
<li>一个Entry内可以拥有多个属性</li>
<li>一个属性内可以拥有一个Type，以及多个Value</li>
</ul>
<p>下图展示了一个DIT的树形结构：</p>
<img src="https://gdz.oss-cn-shenzhen.aliyuncs.com/local/image-20220103111254326.png" alt="image-20220103111254326" style="zoom:80%;" />

<p>一个假设的DIT如下，则DN：{C=GB, L=Winslow, O=Graphic Services, CN=Laser Printer}代表了Laser Printer。</p>
<p><img src="https://gdz.oss-cn-shenzhen.aliyuncs.com/local/image-20220103111455870.png" alt="image-20220103111455870"></p>
<p>你可能会想，DIB和常见的数据库有什么关系呢？实际上他们没什么关系，类似HTTP和TCP。硬要说有关系的话，DIB更加垂直吧🤔，仅适用于这种树形存储结构，查询多、更新少；数据库则更加通用，相对而言也更加底层。DIB只是规定了一种存储键值对数据的树形结构，可以用任何方式实现DIB，包括关系型数据库。理论上，HTTP也可以是其它实现，比如QUIC。</p>
<h3 id="目录服务"><a href="#目录服务" class="headerlink" title="目录服务"></a>目录服务</h3><p>X.500规定了目录复制支持的一些典型的操作，我们大致列举一下</p>
<ul>
<li>读操作<ul>
<li>Read：读指定的entry。LDAP不支持此操作</li>
<li>Compare：比较给的值和指定entry的值是否一致。这个在验证密码时有用</li>
<li>List：列出指定entry的所有子entry</li>
<li>Search：列出满足指定过滤器的所有entry</li>
<li>Abandon：放弃，作用在一个挂起请求上，标识客户端对该请求不在感兴趣</li>
</ul>
</li>
<li>修改操作<ul>
<li>添加entry</li>
<li>移除entry</li>
<li>修改entry</li>
<li>修改DN，修改某个entry的相对名称。如果该entry有子节点，则子节点的这部分名字也会被修改</li>
</ul>
</li>
<li>其它可能的输出<ul>
<li>错误</li>
<li>转移（referral）：可能当前服务无法处理这个请求，它会返回一个新的端点，类似HTTP的重定向</li>
</ul>
</li>
</ul>
<h3 id="分布式Directory"><a href="#分布式Directory" class="headerlink" title="分布式Directory"></a>分布式Directory</h3><p>Directory支持分布式操作，此时的服务端组成如下</p>
<img src="https://gdz.oss-cn-shenzhen.aliyuncs.com/local/image-20220103112541253.png" alt="image-20220103112541253" style="zoom:80%;" />

<ul>
<li>DSA：Directory System Agent。用来连接服务和DUA。他可以缓存Directory数据，可以用本地数据直接响应，也可以单纯做一个转发</li>
<li>LDAP Server：是Directory Service的一部分。他可以直接使用本地数据，也可以转发到其它LDAP Server获取数据</li>
</ul>
<h3 id="其它"><a href="#其它" class="headerlink" title="其它"></a>其它</h3><p>协议还规定了目录服务的访问安全、备份等操作，这里暂时忽略。之后值得探究的倒是其安全协议X.509。</p>
<h2 id="LDAP协议"><a href="#LDAP协议" class="headerlink" title="LDAP协议"></a>LDAP协议</h2><p>通过X.500我们知道了目录服务内部由DIT实现，每个节点上放置的数据貌似可以自由指定，那为什么无论看文章还是自己搭建的LDAP服务，总是以dc、cn之类的属性指定dn呢？这一点我们在schem、dit的组织方式两节解释。目录服务规定了几种访问方式，在LDAP是如何体现的呢？这点在访问一节中解释。</p>
<h3 id="Schema"><a href="#Schema" class="headerlink" title="Schema"></a>Schema</h3><p>LDAP通过RFC4512、RFC4517、RFC4519，对DIT进行了详尽的规定。限制了节点的类型、属性的类型、值的类型，这些限制，叫做schema。具体来说，有几点</p>
<ul>
<li><p>规定了Syntax，即“语法”。规定了attribute value的存储结构</p>
</li>
<li><p>规定了attribute type，即属性的种类</p>
</li>
<li><p>规定了object class，对象类，类之间可以继承，一个类由多个attribute type组成。一个entry必须是某个object class。</p>
<p>object class规定了该entry可以包含哪些属性</p>
</li>
<li><p>规定了匹配规则，用于在执行查找和比较操作时对库中的属性值和请求的属性值进行比较</p>
</li>
</ul>
<p>以面向对象的思维是很好理解的，object class是类、attribute type是属性、Syntax则是属性的类型，齐活。</p>
<p>列举常见数据类型</p>
<table>
<thead>
<tr>
<th>语法</th>
<th>举例</th>
</tr>
</thead>
<tbody><tr>
<td>Bit String</td>
<td>’0101111101’B</td>
</tr>
<tr>
<td>Boolean</td>
<td>TRUE/FALSE</td>
</tr>
<tr>
<td>Country String</td>
<td>UA、AU：两个可打印字符</td>
</tr>
<tr>
<td>Directory String</td>
<td>This is a value of Directory String containing：UTF8字符串</td>
</tr>
<tr>
<td>DN</td>
<td>CN=John Smith, III,DC=example,DC=net：DN的表示</td>
</tr>
<tr>
<td>IA5 String</td>
<td>零个或多个International Alphabet 5的字符</td>
</tr>
<tr>
<td>Integer</td>
<td>整形</td>
</tr>
<tr>
<td>Octet String</td>
<td>八进制字符串</td>
</tr>
<tr>
<td>OID</td>
<td>Object Identifier，对象唯一标识符，比如： 1.3.6.1.4.1.1466.115.121.1.38</td>
</tr>
</tbody></table>
<p>列举常见匹配规则</p>
<table>
<thead>
<tr>
<th>规则</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>bitStringMatch</td>
<td>每一个bit都要相等</td>
</tr>
<tr>
<td>booleanMatch</td>
<td>布尔匹配</td>
</tr>
<tr>
<td>caseIgnoreListMatch</td>
<td>列表匹配，列表中的内容忽略大小写</td>
</tr>
<tr>
<td>integerMatch</td>
<td>整型匹配</td>
</tr>
</tbody></table>
<p>列举常用属性种类</p>
<table>
<thead>
<tr>
<th>种类</th>
<th>父类</th>
<th>语法</th>
<th>匹配方式</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>name</td>
<td>-</td>
<td>Directory String</td>
<td>caseIgnoreMatch</td>
<td>名字，是所有名字类种类的父类</td>
</tr>
<tr>
<td>c</td>
<td>name</td>
<td>Country String</td>
<td></td>
<td>country name，国家名</td>
</tr>
<tr>
<td>cn</td>
<td>name</td>
<td>同name</td>
<td>同name</td>
<td>common name，通用名字</td>
</tr>
<tr>
<td>dc</td>
<td>-</td>
<td>IA5 String</td>
<td>caseIgnoreIA5Match</td>
<td>domain component，域名组件<br />即域名的一部分，比如example.com<br />由dc=example,dc=com两个dc组成</td>
</tr>
<tr>
<td>l</td>
<td>name</td>
<td>同name</td>
<td>同name</td>
<td>locality name，地点名</td>
</tr>
<tr>
<td>o</td>
<td>name</td>
<td>同name</td>
<td>同name</td>
<td>orgnazation name，机构名</td>
</tr>
<tr>
<td>ou</td>
<td>name</td>
<td>同name</td>
<td>同name</td>
<td>orgnazation unit name，机构单位名</td>
</tr>
<tr>
<td>sn</td>
<td>name</td>
<td>同name</td>
<td>同name</td>
<td>surname，姓</td>
</tr>
<tr>
<td>st</td>
<td>name</td>
<td>同name</td>
<td>同name</td>
<td>state or province name，州或省</td>
</tr>
<tr>
<td>uid</td>
<td>-</td>
<td>Directory String</td>
<td>caseIgnoreMatch</td>
<td>user id，用户唯一标识</td>
</tr>
<tr>
<td>userPassword</td>
<td>-</td>
<td>Octet String</td>
<td>octetStringMatch</td>
<td>用户密码</td>
</tr>
</tbody></table>
<p>列举常用object class。</p>
<table>
<thead>
<tr>
<th>class</th>
<th>父类</th>
<th>必包含</th>
<th>可选包含</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>country</td>
<td>top</td>
<td>c</td>
<td>searchGuide\description</td>
<td>国家</td>
</tr>
<tr>
<td>dcObject</td>
<td>top</td>
<td>dc</td>
<td>-</td>
<td>域名对象</td>
</tr>
<tr>
<td>device</td>
<td>top</td>
<td>cn</td>
<td>serialNumber\seeAlso\owner\ou\o\l\description</td>
<td>设备</td>
</tr>
<tr>
<td>organization</td>
<td>top</td>
<td>o</td>
<td>userPassword\searchGuide…超多</td>
<td>组织</td>
</tr>
<tr>
<td>person</td>
<td>top</td>
<td>sn\cn</td>
<td>userPassword\telephoneNumber\seeAlso\description</td>
<td>个人</td>
</tr>
</tbody></table>
<h3 id="DIT组织方式"><a href="#DIT组织方式" class="headerlink" title="DIT组织方式"></a>DIT组织方式</h3><p>schema有了，那么是不是所有节点都可以是任何object class类型呢？理论上是的，但LDAP有推荐的方式构建DIT——RFC2377。我们实际中创建的LDAP服务，也是以这种建议进行构建的。其主要特点是以DNS为基础进行构建，总体如下</p>
<ul>
<li>DIT的上部使用dc，将域名转换为dc类型的entry。比如某公司域名为foo.com，则其根节点的DN为<code>dc=foo,dc=com</code>;它有一个子域名，为account.foo.com，则该节点位于根节点下，其RDN为<code>dc=account</code>，合起来DN为<code>dc=account,dc=foo,dc=com</code>。</li>
<li>DIT的下部，可以是个人、组、机构等。建议使用uid或cn来描述RDN。比如account.foo.com下有一个账户名为zou8944，则其DN为<code>cn=zou8944,dc=account,dc=foo,dc=com</code></li>
</ul>
<blockquote>
<p>这种组织方式看起来理所应当，但其前身X.500却并不是这么规定的。由于历史原因，它使用权威注册的组织机构命名作为DIT的上层。比如<code>o=&quot;Nadir Networks, Inc.&quot;, st=New Jersey, c=US</code>，这表示，在美国的新泽西州的Nadir网络公司。</p>
<p>这样做有两个问题：权威的组织机构注册非常麻烦；跨国公司不好办。于是有了新的基于DNS的划分方式。</p>
</blockquote>
<h3 id="访问"><a href="#访问" class="headerlink" title="访问"></a>访问</h3><p>X.500定义了读、写方面的操作，LDAP又如何呢？这一块位于RFC4511，本文并不打算深入研究，毕竟我不需要去实现一个LDAP库。我们知道几点就好了</p>
<ul>
<li>LDAP传输可以建立在TCP协议之上</li>
<li>主要的消息类型<ul>
<li>Bind：绑定，TCP建立连接后首先绑定。绑定时会进行鉴权。只有绑定后才能进行其它操作。</li>
<li>Unbind：解绑</li>
<li>Search：搜索</li>
<li>Modify：修改entry的值</li>
<li>Add：添加entry</li>
<li>Delete：删除entry</li>
<li>Modify DN：修改某个entry的DN</li>
<li>Compare：比较，比如进行账号密码登录时就可以用Compare操作</li>
<li>Abandon：取消一个未完成的操作</li>
<li>Extended：本协议的扩展操作，目录服务自定义的操作</li>
</ul>
</li>
</ul>
<h3 id="安全"><a href="#安全" class="headerlink" title="安全"></a>安全</h3><p>LDAP的安全主要有三个方面</p>
<ul>
<li>使用TLS安全传输</li>
<li>提供简单的匿名和账号密码认证</li>
<li>支持SASL构建鉴权和安全服务层</li>
</ul>
<p>这块仔细研究还挺复杂的，后面单独研究。</p>
<h2 id="最佳实践-搭建LDAP服务"><a href="#最佳实践-搭建LDAP服务" class="headerlink" title="最佳实践 - 搭建LDAP服务"></a>最佳实践 - 搭建LDAP服务</h2><p>我们将LDAP服务搭建在Kubernetes中，按照本文的Manifest，一定能够搭建成功，本文搭建的特点是</p>
<ul>
<li>搭建两个服务：OpenLDAP-提供LDAP服务；phpldapadmin-提供LDAP的UI服务</li>
<li>OpenLDAP的数据挂载在emptyDir卷，重启后原数据会丢失。如不想这样，请自行创建pv，修改pvc。也可以直接挂载volume</li>
<li>两个服务的账号密码，参考脚本中的环境变量</li>
<li>phpldapadmin从集群中暴露出来的方式，这里未定义，需要读者自己加<ul>
<li>如果在云服务，可以直接再创建一个带外网地址的Service</li>
<li>如果有域名，可以配置Ingress指向phpldapadmin的Service</li>
<li>如果在自己局域网内，则可以直接访问</li>
</ul>
</li>
</ul>
<h3 id="LDAP服务"><a href="#LDAP服务" class="headerlink" title="LDAP服务"></a>LDAP服务</h3><figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">kind:</span> <span class="string">Deployment</span></span><br><span class="line"><span class="attr">apiVersion:</span> <span class="string">apps/v1</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">ldap</span></span><br><span class="line">  <span class="attr">namespace:</span> <span class="string">ldap</span></span><br><span class="line">  <span class="attr">labels:</span></span><br><span class="line">    <span class="attr">app:</span> <span class="string">ldap</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line">  <span class="attr">selector:</span></span><br><span class="line">    <span class="attr">matchLabels:</span></span><br><span class="line">      <span class="attr">app:</span> <span class="string">ldap</span></span><br><span class="line">  <span class="attr">template:</span></span><br><span class="line">    <span class="attr">metadata:</span></span><br><span class="line">      <span class="attr">labels:</span></span><br><span class="line">        <span class="attr">app:</span> <span class="string">ldap</span></span><br><span class="line">    <span class="attr">spec:</span></span><br><span class="line">      <span class="attr">containers:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">ldap</span></span><br><span class="line">        <span class="attr">image:</span> <span class="string">&#x27;osixia/openldap&#x27;</span></span><br><span class="line">        <span class="attr">ports:</span></span><br><span class="line">        <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">tcp-389</span></span><br><span class="line">          <span class="attr">containerPort:</span> <span class="number">389</span></span><br><span class="line">          <span class="attr">protocol:</span> <span class="string">TCP</span></span><br><span class="line">        <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">tcp-636</span></span><br><span class="line">          <span class="attr">containerPort:</span> <span class="number">636</span></span><br><span class="line">          <span class="attr">protocol:</span> <span class="string">TCP</span></span><br><span class="line">        <span class="attr">env:</span></span><br><span class="line">        <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">LDAP_ORGANISATION</span></span><br><span class="line">          <span class="attr">value:</span> <span class="string">devops</span></span><br><span class="line">        <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">LDAP_DOMAIN</span></span><br><span class="line">          <span class="attr">value:</span> <span class="string">zou8944.com</span></span><br><span class="line">        <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">LDAP_ADMIN_PASSWORD</span></span><br><span class="line">          <span class="attr">value:</span> <span class="string">test123</span></span><br><span class="line">        <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">LDAP_CONFIG_PASSWORD</span></span><br><span class="line">          <span class="attr">value:</span> <span class="string">test123</span></span><br><span class="line">        <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">LDAP_BACKEND</span></span><br><span class="line">          <span class="attr">value:</span> <span class="string">mdb</span></span><br><span class="line">        <span class="attr">resources:</span></span><br><span class="line">          <span class="attr">limits:</span></span><br><span class="line">            <span class="attr">cpu:</span> <span class="string">500m</span></span><br><span class="line">            <span class="attr">memory:</span> <span class="string">500Mi</span></span><br><span class="line">          <span class="attr">requests:</span></span><br><span class="line">            <span class="attr">cpu:</span> <span class="string">100m</span></span><br><span class="line">            <span class="attr">memory:</span> <span class="string">100Mi</span></span><br><span class="line">        <span class="attr">volumeMounts:</span></span><br><span class="line">        <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">ldap-config-pvc</span></span><br><span class="line">          <span class="attr">mountPath:</span> <span class="string">/etc/ldap/sldap.d</span></span><br><span class="line">        <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">ldap-data-pvc</span></span><br><span class="line">          <span class="attr">mountPath:</span> <span class="string">/var/lib/ldap</span></span><br><span class="line">      <span class="attr">volumes:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">ldap-config-pvc</span></span><br><span class="line">        <span class="attr">emptyDir:</span> &#123;&#125;</span><br><span class="line">      <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">ldap-data-pvc</span></span><br><span class="line">        <span class="attr">emptyDir:</span> &#123;&#125;</span><br><span class="line"><span class="meta">---</span></span><br><span class="line"><span class="attr">apiVersion:</span> <span class="string">v1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">Service</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">ldap-svc</span></span><br><span class="line">  <span class="attr">namespace:</span> <span class="string">ldap</span></span><br><span class="line">  <span class="attr">labels:</span></span><br><span class="line">    <span class="attr">app:</span> <span class="string">ldap-svc</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line">  <span class="attr">ports:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">tcp-389</span></span><br><span class="line">    <span class="attr">port:</span> <span class="number">389</span></span><br><span class="line">    <span class="attr">protocol:</span> <span class="string">TCP</span></span><br><span class="line">    <span class="attr">targetPort:</span> <span class="number">389</span></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">tcp-636</span></span><br><span class="line">    <span class="attr">port:</span> <span class="number">636</span></span><br><span class="line">    <span class="attr">protocol:</span> <span class="string">TCP</span></span><br><span class="line">    <span class="attr">targetPort:</span> <span class="number">636</span></span><br><span class="line">  <span class="attr">selector:</span></span><br><span class="line">    <span class="attr">app:</span> <span class="string">ldap</span></span><br></pre></td></tr></table></figure>

<h3 id="LDAP管理服务"><a href="#LDAP管理服务" class="headerlink" title="LDAP管理服务"></a>LDAP管理服务</h3><figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">kind:</span> <span class="string">Deployment</span></span><br><span class="line"><span class="attr">apiVersion:</span> <span class="string">apps/v1</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">phpldapadmin</span></span><br><span class="line">  <span class="attr">namespace:</span> <span class="string">ldap</span></span><br><span class="line">  <span class="attr">labels:</span></span><br><span class="line">    <span class="attr">app:</span> <span class="string">phpldapadmin</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line">  <span class="attr">selector:</span></span><br><span class="line">    <span class="attr">matchLabels:</span></span><br><span class="line">      <span class="attr">app:</span> <span class="string">phpldapadmin</span></span><br><span class="line">  <span class="attr">template:</span></span><br><span class="line">    <span class="attr">metadata:</span></span><br><span class="line">      <span class="attr">labels:</span></span><br><span class="line">        <span class="attr">app:</span> <span class="string">phpldapadmin</span></span><br><span class="line">    <span class="attr">spec:</span></span><br><span class="line">      <span class="attr">containers:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">phpldapadmin</span></span><br><span class="line">        <span class="attr">image:</span> <span class="string">&#x27;osixia/phpldapadmin:stable&#x27;</span></span><br><span class="line">        <span class="attr">ports:</span></span><br><span class="line">          <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">tcp-80</span></span><br><span class="line">            <span class="attr">containerPort:</span> <span class="number">80</span></span><br><span class="line">            <span class="attr">protocol:</span> <span class="string">TCP</span></span><br><span class="line">        <span class="attr">env:</span></span><br><span class="line">          <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">PHPLDAPADMIN_HTTPS</span></span><br><span class="line">            <span class="attr">value:</span> <span class="string">&#x27;false&#x27;</span></span><br><span class="line">          <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">PHPLDAPADMIN_LDAP_HOSTS</span></span><br><span class="line">            <span class="attr">value:</span> <span class="string">ldap-svc</span></span><br><span class="line">        <span class="attr">resources:</span></span><br><span class="line">          <span class="attr">limits:</span></span><br><span class="line">            <span class="attr">cpu:</span> <span class="string">500m</span></span><br><span class="line">            <span class="attr">memory:</span> <span class="string">500Mi</span></span><br><span class="line">          <span class="attr">requests:</span></span><br><span class="line">            <span class="attr">cpu:</span> <span class="string">10m</span></span><br><span class="line">            <span class="attr">memory:</span> <span class="string">10Mi</span></span><br><span class="line"><span class="meta">---</span></span><br><span class="line"><span class="attr">apiVersion:</span> <span class="string">v1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">Service</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">phpldapadmin-svc</span></span><br><span class="line">  <span class="attr">namespace:</span> <span class="string">ldap</span></span><br><span class="line">  <span class="attr">labels:</span></span><br><span class="line">    <span class="attr">app:</span> <span class="string">phpldapadmin-svc</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line">  <span class="attr">ports:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">tcp-80</span></span><br><span class="line">    <span class="attr">port:</span> <span class="number">80</span></span><br><span class="line">    <span class="attr">protocol:</span> <span class="string">TCP</span></span><br><span class="line">    <span class="attr">targetPort:</span> <span class="number">80</span></span><br><span class="line">  <span class="attr">selector:</span></span><br><span class="line">    <span class="attr">app:</span> <span class="string">phpldapadmin</span></span><br></pre></td></tr></table></figure>

<h3 id="试试"><a href="#试试" class="headerlink" title="试试"></a>试试</h3><p><code>kubectl apply -f xxx.yaml</code>执行上面的manifest文件，能够得到创建结果</p>
<p><img src="https://gdz.oss-cn-shenzhen.aliyuncs.com/local/image-20220103131116477.png" alt="image-20220103131116477"></p>
<p>这里我多创建了一个phpldapadmin-svc-internet，一个具有外部访问地址的Service，方便访问，然后我们访问一下，来到如下界面。</p>
<p><img src="https://gdz.oss-cn-shenzhen.aliyuncs.com/local/image-20220103131256572.png" alt="image-20220103131256572"></p>
<p>点击左侧的login，输入管理员的DN，password，得以进入</p>
<p><img src="https://gdz.oss-cn-shenzhen.aliyuncs.com/local/image-20220103131418677.png" alt="image-20220103131418677"></p>
<p>进入之后的界面如下</p>
<p><img src="https://gdz.oss-cn-shenzhen.aliyuncs.com/local/image-20220103131515385.png" alt="image-20220103131515385"></p>
<p>其中，左侧的树形结构，就是DIT。上面的schema可以查看当前LDAP服务支持的object class、attribute type等类型；search能够进行查找；导入导出能够将DIB导出成文件。</p>
<p><img src="https://gdz.oss-cn-shenzhen.aliyuncs.com/local/image-20220103131732221.png" alt="image-20220103131732221"></p>
<p>搜索界面也很好理解</p>
<ul>
<li>Base DN：从哪个entry下开始搜索</li>
<li>Search Scope：搜索子树、同级、父节点</li>
<li>Search Filter：搜索过滤器，可以指定entry的类型、属性的类型、属性的值等</li>
<li>Show Attributes：搜索结果展示的属性</li>
</ul>
<p><img src="https://gdz.oss-cn-shenzhen.aliyuncs.com/local/image-20220103131800516.png" alt="image-20220103131800516"></p>
<h2 id="LDAP客户端"><a href="#LDAP客户端" class="headerlink" title="LDAP客户端"></a>LDAP客户端</h2><p>至此，我们已经掌握了目录服务的工作原理，了解DIT的结构、Schema，了解了LDAP访问的类型：也无非是CRUD。</p>
<p>实现LDAP库并不难，按照RFC4511，抽象出Object Class、Attribute、DN、各种操作等即可。</p>
<p><a href="https://docs.spring.io/spring-ldap/docs/current/reference/#spring-ldap-introduction-overview">Spring LDAP</a>就提供了这方面的能力，主要操作都集中在LdapTemplate，它提供了DSL，相比于独立的库，它简化了操作的过程，简化了代码。</p>
<p>看了下Vertx，目前尚不支持LDAP操作，仅支持使用LDAP做鉴权操作。</p>
<p>这里我就不再描述Spring LDAP的能力了，毕竟官方手册不长，而且就是各种自己实现的抽象，我没必要去搬一些API，对读者造成不必要的误导。</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>本文从X.500开始，较为系统第介绍了LDAP的定义、实现方式、Schema约束，并实际动手在Kubernetes上搭建了一个临时的LDAP服务。</p>
<p>总体而言，LDAP是简单的、易于实现的、应用场景小而典型的数据存储及服务方式。</p>
]]></content>
      <categories>
        <category>后端</category>
      </categories>
      <tags>
        <tag>LDAP</tag>
      </tags>
  </entry>
</search>
