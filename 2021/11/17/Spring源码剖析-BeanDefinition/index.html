<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 5.4.0">
  <link rel="apple-touch-icon" sizes="180x180" href="https://thirdwx.qlogo.cn/mmopen/vi_32/DYAIOgq83equib0YGKeGrRww67LyZ7hSONtAW59RHDTd2JuKmSfQLEs8zWIB14hUcHibNG41zNibv5mr5QhM5QDMQ/132">
  <link rel="icon" type="image/png" sizes="32x32" href="https://thirdwx.qlogo.cn/mmopen/vi_32/DYAIOgq83equib0YGKeGrRww67LyZ7hSONtAW59RHDTd2JuKmSfQLEs8zWIB14hUcHibNG41zNibv5mr5QhM5QDMQ/132">
  <link rel="icon" type="image/png" sizes="16x16" href="https://thirdwx.qlogo.cn/mmopen/vi_32/DYAIOgq83equib0YGKeGrRww67LyZ7hSONtAW59RHDTd2JuKmSfQLEs8zWIB14hUcHibNG41zNibv5mr5QhM5QDMQ/132">
  <link rel="mask-icon" href="https://thirdwx.qlogo.cn/mmopen/vi_32/DYAIOgq83equib0YGKeGrRww67LyZ7hSONtAW59RHDTd2JuKmSfQLEs8zWIB14hUcHibNG41zNibv5mr5QhM5QDMQ/132" color="#222">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/lib/font-awesome/css/all.min.css">

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"zou8944.com","root":"/","scheme":"Pisces","version":"7.8.0","exturl":false,"sidebar":{"position":"left","display":"always","padding":18,"offset":12,"onmobile":false},"copycode":{"enable":false,"show_result":false,"style":null},"back2top":{"enable":true,"sidebar":false,"scrollpercent":false},"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":true,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},"path":"search.xml"};
  </script>

  <meta name="description" content="阅读提示：TL;DR。文章包含大量源码，阅读时长较长，认真阅读可能超过20分钟。  回想一下，Spring最最核心的功能，终究是一个容器，用于提供所谓的”Bean“，并负责Bean之间的联结。而我们又知道，Bean有不同的Scope，即作用范围，单例的、原型的、Session的，或自定义的。Bean还能够懒加载。因此，创建Bean的时机可能是运行时的任何时候。Spring使用BeanDefini">
<meta property="og:type" content="article">
<meta property="og:title" content="Spring源码剖析 - BeanDefinition">
<meta property="og:url" content="https://zou8944.com/2021/11/17/Spring%E6%BA%90%E7%A0%81%E5%89%96%E6%9E%90-BeanDefinition/index.html">
<meta property="og:site_name" content="半中二青年">
<meta property="og:description" content="阅读提示：TL;DR。文章包含大量源码，阅读时长较长，认真阅读可能超过20分钟。  回想一下，Spring最最核心的功能，终究是一个容器，用于提供所谓的”Bean“，并负责Bean之间的联结。而我们又知道，Bean有不同的Scope，即作用范围，单例的、原型的、Session的，或自定义的。Bean还能够懒加载。因此，创建Bean的时机可能是运行时的任何时候。Spring使用BeanDefini">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://gdz.oss-cn-shenzhen.aliyuncs.com/local/%E6%88%AA%E5%B1%8F2021-11-17%20%E4%B8%8B%E5%8D%887.52.20.png">
<meta property="og:image" content="https://gdz.oss-cn-shenzhen.aliyuncs.com/local/%E6%88%AA%E5%B1%8F2021-11-17%20%E4%B8%8B%E5%8D%889.45.35.png">
<meta property="og:image" content="https://gdz.oss-cn-shenzhen.aliyuncs.com/local/%E6%88%AA%E5%B1%8F2021-11-18%20%E4%B8%8B%E5%8D%886.33.05.png">
<meta property="article:published_time" content="2021-11-17T10:09:43.000Z">
<meta property="article:modified_time" content="2021-11-21T01:41:42.798Z">
<meta property="article:author" content="果冻">
<meta property="article:tag" content="Spring">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://gdz.oss-cn-shenzhen.aliyuncs.com/local/%E6%88%AA%E5%B1%8F2021-11-17%20%E4%B8%8B%E5%8D%887.52.20.png">

<link rel="canonical" href="https://zou8944.com/2021/11/17/Spring%E6%BA%90%E7%A0%81%E5%89%96%E6%9E%90-BeanDefinition/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : false,
    isPost : true,
    lang   : 'zh-CN'
  };
</script>

  <title>Spring源码剖析 - BeanDefinition | 半中二青年</title>
  


  <script>
    var _hmt = _hmt || [];
    (function() {
      var hm = document.createElement("script");
      hm.src = "https://hm.baidu.com/hm.js?5f106bd9d28ad9215669a37fc984f768";
      var s = document.getElementsByTagName("script")[0];
      s.parentNode.insertBefore(hm, s);
    })();
  </script>




  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <h1 class="site-title">半中二青年</h1>
      <span class="logo-line-after"><i></i></span>
    </a>
      <p class="site-subtitle" itemprop="description">果冻的碎碎念</p>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
        <i class="fa fa-search fa-fw fa-lg"></i>
    </div>
  </div>
</div>




<nav class="site-nav">
  <ul id="menu" class="main-menu menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>归档<span class="badge">117</span></a>

  </li>
        <li class="menu-item menu-item-categories">

    <a href="/categories/" rel="section"><i class="fa fa-th fa-fw"></i>分类<span class="badge">35</span></a>

  </li>
        <li class="menu-item menu-item-tags">

    <a href="/tags/" rel="section"><i class="fa fa-tags fa-fw"></i>标签<span class="badge">88</span></a>

  </li>
        <li class="menu-item menu-item-about">

    <a href="/about/me" rel="section"><i class="fa fa-user fa-fw"></i>关于</a>

  </li>
      <li class="menu-item menu-item-search">
        <a role="button" class="popup-trigger"><i class="fa fa-search fa-fw"></i>搜索
        </a>
      </li>
  </ul>
</nav>



  <div class="search-pop-overlay">
    <div class="popup search-popup">
        <div class="search-header">
  <span class="search-icon">
    <i class="fa fa-search"></i>
  </span>
  <div class="search-input-container">
    <input autocomplete="off" autocapitalize="off"
           placeholder="搜索..." spellcheck="false"
           type="search" class="search-input">
  </div>
  <span class="popup-btn-close">
    <i class="fa fa-times-circle"></i>
  </span>
</div>
<div id="search-result">
  <div id="no-result">
    <i class="fa fa-spinner fa-pulse fa-5x fa-fw"></i>
  </div>
</div>

    </div>
  </div>

</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content post posts-expand">
            

    
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://zou8944.com/2021/11/17/Spring%E6%BA%90%E7%A0%81%E5%89%96%E6%9E%90-BeanDefinition/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="https://thirdwx.qlogo.cn/mmopen/vi_32/DYAIOgq83equib0YGKeGrRww67LyZ7hSONtAW59RHDTd2JuKmSfQLEs8zWIB14hUcHibNG41zNibv5mr5QhM5QDMQ/132">
      <meta itemprop="name" content="果冻">
      <meta itemprop="description" content="果冻的碎碎念">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="半中二青年">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          Spring源码剖析 - BeanDefinition
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2021-11-17 18:09:43" itemprop="dateCreated datePublished" datetime="2021-11-17T18:09:43+08:00">2021-11-17</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2021-11-21 09:41:42" itemprop="dateModified" datetime="2021-11-21T09:41:42+08:00">2021-11-21</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Spring/" itemprop="url" rel="index"><span itemprop="name">Spring</span></a>
                </span>
            </span>

          
            <span id="/2021/11/17/Spring%E6%BA%90%E7%A0%81%E5%89%96%E6%9E%90-BeanDefinition/" class="post-meta-item leancloud_visitors" data-flag-title="Spring源码剖析 - BeanDefinition" title="阅读次数">
              <span class="post-meta-item-icon">
                <i class="fa fa-eye"></i>
              </span>
              <span class="post-meta-item-text">阅读次数：</span>
              <span class="leancloud-visitors-count"></span>
            </span>
            <span class="post-meta-item" title="阅读次数" id="busuanzi_container_page_pv" style="display: none;">
              <span class="post-meta-item-icon">
                <i class="fa fa-eye"></i>
              </span>
              <span class="post-meta-item-text">阅读次数：</span>
              <span id="busuanzi_value_page_pv"></span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
        <blockquote>
<p>阅读提示：TL;DR。文章包含大量源码，阅读时长较长，认真阅读可能超过20分钟。</p>
</blockquote>
<p>回想一下，Spring最最核心的功能，终究是一个容器，用于提供所谓的”<code>Bean</code>“，并负责<code>Bean</code>之间的联结。而我们又知道，<code>Bean</code>有不同的<code>Scope</code>，即作用范围，单例的、原型的、<code>Session</code>的，或自定义的。<code>Bean</code>还能够懒加载。因此，创建<code>Bean</code>的时机可能是运行时的任何时候。Spring使用<code>BeanDefinition</code>描述一个<code>Bean</code>的name、类、scope等元数据，并在需要时候创建。创建过程自然也包括了自动注入的过程。</p>
<span id="more"></span>

<p>本文我们重点关注Spring中对<code>Bean</code>的管理。</p>
<h2 id="如何描述Bean"><a href="#如何描述Bean" class="headerlink" title="如何描述Bean"></a>如何描述Bean</h2><p><img src="https://gdz.oss-cn-shenzhen.aliyuncs.com/local/%E6%88%AA%E5%B1%8F2021-11-17%20%E4%B8%8B%E5%8D%887.52.20.png" alt="截屏2021-11-17 下午7.52.20"></p>
<p>Spring使用<code>BeanDefinition</code>来描述<code>Bean</code>，其继承拓扑图如上，我们只选取了几个具有代表性的来看。根绝<code>BeanDefinition</code>接口的定义，能够知道，Spring中的<code>Bean</code>具有如下特性：</p>
<ul>
<li>基本信息<ul>
<li>名字</li>
<li>描述</li>
<li>用于创建该Bean的Class对象</li>
</ul>
</li>
<li>具有作用范围Scope<ul>
<li>singleton：全局唯一实例</li>
<li>prototype：每次获取都创建新的实例</li>
</ul>
</li>
<li>可以有父子关系</li>
<li>可以有依赖关系，即一个Bean的创建依赖于另一个Bean的存在</li>
<li>可延迟加载</li>
<li>可自动装配<ul>
<li>设置是否参与自动装配（基于类型）</li>
<li>如果有多个类型符合要求，可设置主要的</li>
</ul>
</li>
<li>可自定义Bean实例创建方式<ul>
<li>设置工厂Bean，用另一个Bean来创建该Bean</li>
<li>设置工厂方法，用该方法创建实例</li>
</ul>
</li>
<li>生命周期管理<ul>
<li>可指定初始化方法 <code>initMethod</code></li>
<li>可指定销毁方法 <code>destroyMethod</code></li>
</ul>
</li>
<li>具有角色，目前定义了三种角色，但暂未看到如何使用<ul>
<li><code>ROLE_APPLICATION</code>：该Bean是应用的主体，默认值</li>
<li><code>ROLE_SUPPORT</code>：标识该Bean是其它更大部分的支持部分</li>
<li><code>ROLE_INFRASTRUCTURE</code>：该Bean作为纯基础设施的支持，用户接触不到它</li>
</ul>
</li>
<li>获取构造方法的参数的值</li>
<li>获取<code>MutablePropertyValues</code>，这对应的是Bean的属性键值对，自动注入时会使用。</li>
<li><code>BeanDefinition</code>可包装另一个<code>BeanDefinition</code>，通过<code>BeanDefinition getOriginatingBeanDefinition()</code>获取被包装的定义。</li>
</ul>
<p>至于继承树中其它类，各自有所区别，我们依次看</p>
<h3 id="AbstractBeanDefinition"><a href="#AbstractBeanDefinition" class="headerlink" title="AbstractBeanDefinition"></a>AbstractBeanDefinition</h3><p><code>BeanDefinition</code>的直接实现，从中也可以看到一些特性的默认值</p>
<ul>
<li><code>scope</code>默认为单例</li>
<li>延迟加载默认关闭</li>
<li>自动注入默认关闭</li>
<li>角色默认为<code>ROLE_APPLICATION</code></li>
</ul>
<h3 id="RootBeanDefinition"><a href="#RootBeanDefinition" class="headerlink" title="RootBeanDefinition"></a>RootBeanDefinition</h3><p>说实话直接看这个类时，有点懵，原注释这么说。</p>
<blockquote>
<p>A root bean definition represents the merged bean definition that backs a specific bean in a Spring BeanFactory at runtime. It might have been created from multiple original bean definitions that inherit from each other, typically registered as GenericBeanDefinitions. A root bean definition is essentially the ‘unified’ bean definition view at runtime.<br>Root bean definitions may also be used for registering individual bean definitions in the configuration phase. However, since Spring 2.5, the preferred way to register bean definitions programmatically is the GenericBeanDefinition class. GenericBeanDefinition has the advantage that it allows to dynamically define parent dependencies, not ‘hard-coding’ the role as a root bean definition.</p>
</blockquote>
<p>我看懂了字面意思，却没看懂这串英文背后的含义。什么是<code>MergedBean</code>，关于这点，可以参考<a target="_blank" rel="noopener" href="https://blog.csdn.net/andy_zhang2007/article/details/86514320">这篇文章</a>，所谓合并，就是将具有父子关系的<code>BeanDefinition</code>合并为一个<code>BeanDefinition</code>。”合并“的具体过程，下文”如何创建Bean“将会分析。</p>
<h3 id="GenericBeanDefinition"><a href="#GenericBeanDefinition" class="headerlink" title="GenericBeanDefinition"></a>GenericBeanDefinition</h3><p><code>BeanDefinition</code>的标准实现，相较于<code>AbstractBeanDefinition</code>，它多了对父子关系的实现。我们是可以直接用该类创建自己的<code>BeanDefinition</code>的。如果我们要凭空创建一个<code>BeanDefinition</code>注入容器，可以用它。</p>
<h3 id="AnnotatedBeanDefinition"><a href="#AnnotatedBeanDefinition" class="headerlink" title="AnnotatedBeanDefinition"></a>AnnotatedBeanDefinition</h3><p><code>BeanDefinition</code>的直接扩展接口，向调用者暴露了<code>AnnotationMetadata</code>。那么问题来了，什么是<code>AnnotationMetadata</code>呢？它是Spring为指定类的注解所定义的抽象，通过它可以不加载目标类即可获取到注解信息。类似的还有<code>ClassMetadata</code>。看来，Spring是将Bean定义的方方面面都进行了抽象。</p>
<p><img src="https://gdz.oss-cn-shenzhen.aliyuncs.com/local/%E6%88%AA%E5%B1%8F2021-11-17%20%E4%B8%8B%E5%8D%889.45.35.png" alt="截屏2021-11-17 下午9.45.35"></p>
<h3 id="AnnotatedGenericBeanDefinition"><a href="#AnnotatedGenericBeanDefinition" class="headerlink" title="AnnotatedGenericBeanDefinition"></a>AnnotatedGenericBeanDefinition</h3><p>同时实现了<code>GenericBeanDefinition</code>和<code>AnnotatedBeanDefinition</code>，表明它既具有一个完整<code>BeanDefinition</code>的能力，又持有Bean原类上的注解信息。持有注解信息有什么用呢？当然有用，运行时可以直接获取Bean定义的注解而不加载原类呀，提升性能。</p>
<h3 id="ScannedGenericBeanDefinition"><a href="#ScannedGenericBeanDefinition" class="headerlink" title="ScannedGenericBeanDefinition"></a>ScannedGenericBeanDefinition</h3><p>和<code>AnnotatedGenericBeanDefinition</code>一样，可以说是一模一样。</p>
<h3 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h3><p>Spring关于Bean的描述，其实不止这几个类，但我认为其它都是干扰，因此去掉了。我们的重点，是要通过这些定义看到Spring是如何进行抽象的，以及各级抽象的作用。写代码时不会用到，但它可保看源码时不会懵逼。</p>
<h2 id="Bean定义从何而来"><a href="#Bean定义从何而来" class="headerlink" title="Bean定义从何而来"></a>Bean定义从何而来</h2><p>还是上一篇文章那个例子，一个最最简单的应用方式。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">fun <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    val context = AnnotationConfigApplicationContext(<span class="string">&quot;com.gitee.floyd.springme.core&quot;</span>)</span><br><span class="line">    println(context.getBean(Bean1::class.java))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>我们以<code>org.springframework.context.annotation.AnnotationConfigApplicationContext</code>构造方法为入口，分析Bean定义加载的过程。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">AnnotationConfigApplicationContext</span><span class="params">(String... basePackages)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">this</span>();</span><br><span class="line">  scan(basePackages);</span><br><span class="line">  ... ...</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">AnnotationConfigApplicationContext</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="keyword">this</span>.reader = <span class="keyword">new</span> AnnotatedBeanDefinitionReader(<span class="keyword">this</span>);</span><br><span class="line">  <span class="keyword">this</span>.scanner = <span class="keyword">new</span> ClassPathBeanDefinitionScanner(<span class="keyword">this</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">scan</span><span class="params">(String... basePackages)</span> </span>&#123;</span><br><span class="line">  ... ... </span><br><span class="line">    <span class="keyword">this</span>.scanner.scan(basePackages);</span><br><span class="line">  ... ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这里引入两个新的类：<code>AnnotatedBeanDefinitionReader</code>和<code>ClassPathBeanDefinitionScanner</code>，我们先看它们的能力，再看这个扫描的过程</p>
<h3 id="AnnotatedBeanDefinitionReader"><a href="#AnnotatedBeanDefinitionReader" class="headerlink" title="AnnotatedBeanDefinitionReader"></a>AnnotatedBeanDefinitionReader</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AnnotatedBeanDefinitionReader</span> </span>&#123;</span><br><span class="line">  <span class="comment">// Bean定义注册器，一个注册接口，其实现类一般会持有所有这些注册的BeanDefinition，典型的实现类就是具体的ApplicationContext</span></span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">final</span> BeanDefinitionRegistry registry;</span><br><span class="line">  <span class="comment">// Bean名称生成器，AnnotationBeanNameGenerator是按照@Component注解或其子注解生成名字</span></span><br><span class="line">  <span class="keyword">private</span> BeanNameGenerator beanNameGenerator = AnnotationBeanNameGenerator.INSTANCE;</span><br><span class="line">  <span class="comment">// Scope元信息解析器，AnnotationScopeMetadataResolver解析的是@Scope注解</span></span><br><span class="line">  <span class="keyword">private</span> ScopeMetadataResolver scopeMetadataResolver = <span class="keyword">new</span> AnnotationScopeMetadataResolver();</span><br><span class="line">  <span class="comment">// 条件计算器，用于解析@Conditional注解</span></span><br><span class="line">  <span class="keyword">private</span> ConditionEvaluator conditionEvaluator;</span><br><span class="line"></span><br><span class="line">  ... ...</span><br><span class="line">  <span class="comment">// 注册Bean</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">registerBean</span><span class="params">(Class&lt;?&gt; beanClass)</span> </span>&#123;</span><br><span class="line">    doRegisterBean(beanClass, <span class="keyword">null</span>, <span class="keyword">null</span>, <span class="keyword">null</span>, <span class="keyword">null</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  ... ...</span><br><span class="line">  <span class="comment">// 实际注册Bean，传入bean的类型、名字等</span></span><br><span class="line">  <span class="keyword">private</span> &lt;T&gt; <span class="function"><span class="keyword">void</span> <span class="title">doRegisterBean</span><span class="params">(Class&lt;T&gt; beanClass, <span class="meta">@Nullable</span> String name,</span></span></span><br><span class="line"><span class="params"><span class="function">                                    <span class="meta">@Nullable</span> Class&lt;? extends Annotation&gt;[] qualifiers, <span class="meta">@Nullable</span> Supplier&lt;T&gt; supplier,</span></span></span><br><span class="line"><span class="params"><span class="function">                                    <span class="meta">@Nullable</span> BeanDefinitionCustomizer[] customizers)</span> </span>&#123;</span><br><span class="line">		<span class="comment">// 根据类对象创建AnnotatedGenericBeanDefinition</span></span><br><span class="line">    AnnotatedGenericBeanDefinition abd = <span class="keyword">new</span> AnnotatedGenericBeanDefinition(beanClass);</span><br><span class="line">    <span class="comment">// 判断是否需要忽略该Bean定义</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">this</span>.conditionEvaluator.shouldSkip(abd.getMetadata())) &#123;</span><br><span class="line">      <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">		<span class="comment">// 设置一个实例创建时的回调函数，它作为一种工厂方法的替换</span></span><br><span class="line">    abd.setInstanceSupplier(supplier);</span><br><span class="line">    ScopeMetadata scopeMetadata = <span class="keyword">this</span>.scopeMetadataResolver.resolveScopeMetadata(abd);</span><br><span class="line">    <span class="comment">// 为Bean定义加上Scope</span></span><br><span class="line">    abd.setScope(scopeMetadata.getScopeName());</span><br><span class="line">    <span class="comment">// 生成bean名字</span></span><br><span class="line">    String beanName = (name != <span class="keyword">null</span> ? name : <span class="keyword">this</span>.beanNameGenerator.generateBeanName(abd, <span class="keyword">this</span>.registry));</span><br><span class="line">		<span class="comment">// 处理通用注解：@Lazy、@Primary、@DependsOn、@Role、@Description</span></span><br><span class="line">    AnnotationConfigUtils.processCommonDefinitionAnnotations(abd);</span><br><span class="line">    <span class="comment">// 根据传入的修饰注解决定</span></span><br><span class="line">    <span class="keyword">if</span> (qualifiers != <span class="keyword">null</span>) &#123;</span><br><span class="line">      <span class="keyword">for</span> (Class&lt;? extends Annotation&gt; qualifier : qualifiers) &#123;</span><br><span class="line">        <span class="keyword">if</span> (Primary.class == qualifier) &#123;</span><br><span class="line">          abd.setPrimary(<span class="keyword">true</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (Lazy.class == qualifier) &#123;</span><br><span class="line">          abd.setLazyInit(<span class="keyword">true</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">          abd.addQualifier(<span class="keyword">new</span> AutowireCandidateQualifier(qualifier));</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 应用传入的BeanDefinition定制器</span></span><br><span class="line">    <span class="keyword">if</span> (customizers != <span class="keyword">null</span>) &#123;</span><br><span class="line">      <span class="keyword">for</span> (BeanDefinitionCustomizer customizer : customizers) &#123;</span><br><span class="line">        customizer.customize(abd);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">		</span><br><span class="line">    <span class="comment">// 包装成BeanDefinitionHolder</span></span><br><span class="line">    BeanDefinitionHolder definitionHolder = <span class="keyword">new</span> BeanDefinitionHolder(abd, beanName);</span><br><span class="line">    <span class="comment">// Bean的scope代理模式是封装在BeanDefinitionHolder中的，这里进行设置</span></span><br><span class="line">    definitionHolder = AnnotationConfigUtils.applyScopedProxyMode(scopeMetadata, definitionHolder, <span class="keyword">this</span>.registry);</span><br><span class="line">    <span class="comment">// 将处理完的BeanDefinitionHolder注入registry</span></span><br><span class="line">    BeanDefinitionReaderUtils.registerBeanDefinition(definitionHolder, <span class="keyword">this</span>.registry);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// AnnotationConfigUtils.processCommonDefinitionAnnotations方法</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">processCommonDefinitionAnnotations</span><span class="params">(AnnotatedBeanDefinition abd, AnnotatedTypeMetadata metadata)</span> </span>&#123;</span><br><span class="line">  <span class="comment">// 延迟加载的处理</span></span><br><span class="line">  AnnotationAttributes lazy = attributesFor(metadata, Lazy.class);</span><br><span class="line">  <span class="keyword">if</span> (lazy != <span class="keyword">null</span>) &#123;</span><br><span class="line">    abd.setLazyInit(lazy.getBoolean(<span class="string">&quot;value&quot;</span>));</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">else</span> <span class="keyword">if</span> (abd.getMetadata() != metadata) &#123;</span><br><span class="line">    lazy = attributesFor(abd.getMetadata(), Lazy.class);</span><br><span class="line">    <span class="keyword">if</span> (lazy != <span class="keyword">null</span>) &#123;</span><br><span class="line">      abd.setLazyInit(lazy.getBoolean(<span class="string">&quot;value&quot;</span>));</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">	<span class="comment">// primary的处理</span></span><br><span class="line">  <span class="keyword">if</span> (metadata.isAnnotated(Primary.class.getName())) &#123;</span><br><span class="line">    abd.setPrimary(<span class="keyword">true</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 依赖的处理</span></span><br><span class="line">  AnnotationAttributes dependsOn = attributesFor(metadata, DependsOn.class);</span><br><span class="line">  <span class="keyword">if</span> (dependsOn != <span class="keyword">null</span>) &#123;</span><br><span class="line">    abd.setDependsOn(dependsOn.getStringArray(<span class="string">&quot;value&quot;</span>));</span><br><span class="line">  &#125;</span><br><span class="line">	<span class="comment">// 角色的处理</span></span><br><span class="line">  AnnotationAttributes role = attributesFor(metadata, Role.class);</span><br><span class="line">  <span class="keyword">if</span> (role != <span class="keyword">null</span>) &#123;</span><br><span class="line">    abd.setRole(role.getNumber(<span class="string">&quot;value&quot;</span>).intValue());</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 描述的处理</span></span><br><span class="line">  AnnotationAttributes description = attributesFor(metadata, Description.class);</span><br><span class="line">  <span class="keyword">if</span> (description != <span class="keyword">null</span>) &#123;</span><br><span class="line">    abd.setDescription(description.getString(<span class="string">&quot;value&quot;</span>));</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>要点总结</p>
<ul>
<li><code>AnnotatedBeanDefinitionReader</code>，封装了<code>BeanDefinition</code>构建并注入<code>BeanDefinitionRegistry</code>的流程，这里<code>BeanDefinitionRegistry</code>就是我们的容器</li>
<li><code>BeanDefinitionRegistry</code>，在前面介绍<code>ApplicationContext</code>就已经介绍过，用于接收并持有Bean定义</li>
<li>bean名称生成器：<code>AnnotationBeanNameGenerator</code>，按照<code>@Component</code>及其子注解、<code>@ManagedBean</code>、<code>@Named</code>生成，详细分析见下</li>
<li><code>Scope</code>元信息，包含了<code>Scope</code>的作用范围、代理模式，通过<code>@Scope</code>注解标识，<code>AnnotationScopeMetadataResolver</code>就是解析<code>@Scope</code>注解的。如果未指定<code>@Scope</code>注解，得到的结果是：单例+不代理。</li>
<li><code>ConditionEvaluator</code>，条件解析器。针对<code>@Conditional</code>进行解析。详细分析见下文。</li>
</ul>
<h4 id="bean名称生成逻辑"><a href="#bean名称生成逻辑" class="headerlink" title="bean名称生成逻辑"></a>bean名称生成逻辑</h4><p>AnnotationBeanNameGenerator这个类值得看一看，它有一些隐藏的功能</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AnnotationBeanNameGenerator</span> <span class="keyword">implements</span> <span class="title">BeanNameGenerator</span> </span>&#123;</span><br><span class="line">  <span class="comment">// @Compenent注解通过字面量的形式呈现</span></span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String COMPONENT_ANNOTATION_CLASSNAME = <span class="string">&quot;org.springframework.stereotype.Component&quot;</span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 核心方法</span></span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> String <span class="title">generateBeanName</span><span class="params">(BeanDefinition definition, BeanDefinitionRegistry registry)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 如果Bean有注解，则根据注解生成名称</span></span><br><span class="line">    <span class="keyword">if</span> (definition <span class="keyword">instanceof</span> AnnotatedBeanDefinition) &#123;</span><br><span class="line">      String beanName = determineBeanNameFromAnnotation((AnnotatedBeanDefinition) definition);</span><br><span class="line">      <span class="keyword">if</span> (StringUtils.hasText(beanName)) &#123;</span><br><span class="line">        <span class="comment">// Explicit bean name found.</span></span><br><span class="line">        <span class="keyword">return</span> beanName;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 如果Bean没有注解，则直接使用类名的首字母小写形式</span></span><br><span class="line">    <span class="keyword">return</span> buildDefaultBeanName(definition, registry);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">protected</span> String <span class="title">determineBeanNameFromAnnotation</span><span class="params">(AnnotatedBeanDefinition annotatedDef)</span> </span>&#123;</span><br><span class="line">    AnnotationMetadata amd = annotatedDef.getMetadata();</span><br><span class="line">    Set&lt;String&gt; types = amd.getAnnotationTypes();</span><br><span class="line">    String beanName = <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">for</span> (String type : types) &#123;</span><br><span class="line">      AnnotationAttributes attributes = AnnotationConfigUtils.attributesFor(amd, type);</span><br><span class="line">      <span class="keyword">if</span> (attributes != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="comment">// 获取元注解，即注解的注解，这样才能检测到@Service、@Repository之类的注解</span></span><br><span class="line">        Set&lt;String&gt; metaTypes = <span class="keyword">this</span>.metaAnnotationTypesCache.computeIfAbsent(type, key -&gt; &#123;</span><br><span class="line">          Set&lt;String&gt; result = amd.getMetaAnnotationTypes(key);</span><br><span class="line">          <span class="keyword">return</span> (result.isEmpty() ? Collections.emptySet() : result);</span><br><span class="line">        &#125;);</span><br><span class="line">        <span class="keyword">if</span> (isStereotypeWithNameValue(type, metaTypes, attributes)) &#123;</span><br><span class="line">          <span class="comment">// 注解的value属性必须有值，且不为空串，才会取</span></span><br><span class="line">          Object value = attributes.get(<span class="string">&quot;value&quot;</span>);</span><br><span class="line">          <span class="keyword">if</span> (value <span class="keyword">instanceof</span> String) &#123;</span><br><span class="line">            String strVal = (String) value;</span><br><span class="line">            <span class="keyword">if</span> (StringUtils.hasLength(strVal)) &#123;</span><br><span class="line">              <span class="keyword">if</span> (beanName != <span class="keyword">null</span> &amp;&amp; !strVal.equals(beanName)) &#123;</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(<span class="string">&quot;Stereotype annotations suggest inconsistent &quot;</span> +</span><br><span class="line">                                                <span class="string">&quot;component names: &#x27;&quot;</span> + beanName + <span class="string">&quot;&#x27; versus &#x27;&quot;</span> + strVal + <span class="string">&quot;&#x27;&quot;</span>);</span><br><span class="line">              &#125;</span><br><span class="line">              beanName = strVal;</span><br><span class="line">            &#125;</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> beanName;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// </span></span><br><span class="line">  <span class="function"><span class="keyword">protected</span> <span class="keyword">boolean</span> <span class="title">isStereotypeWithNameValue</span><span class="params">(String annotationType, Set&lt;String&gt; metaAnnotationTypes, <span class="meta">@Nullable</span> Map&lt;String, Object&gt; attributes)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 这里也可以看到，还支持@ManagedBean、Named这样的JSR规定的注解</span></span><br><span class="line">    <span class="keyword">boolean</span> isStereotype = annotationType.equals(COMPONENT_ANNOTATION_CLASSNAME) ||</span><br><span class="line">      metaAnnotationTypes.contains(COMPONENT_ANNOTATION_CLASSNAME) ||</span><br><span class="line">      annotationType.equals(<span class="string">&quot;javax.annotation.ManagedBean&quot;</span>) ||</span><br><span class="line">      annotationType.equals(<span class="string">&quot;javax.inject.Named&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> (isStereotype &amp;&amp; attributes != <span class="keyword">null</span> &amp;&amp; attributes.containsKey(<span class="string">&quot;value&quot;</span>));</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">protected</span> String <span class="title">buildDefaultBeanName</span><span class="params">(BeanDefinition definition)</span> </span>&#123;</span><br><span class="line">    String beanClassName = definition.getBeanClassName();</span><br><span class="line">    Assert.state(beanClassName != <span class="keyword">null</span>, <span class="string">&quot;No bean class name set&quot;</span>);</span><br><span class="line">    String shortClassName = ClassUtils.getShortName(beanClassName);</span><br><span class="line">    <span class="keyword">return</span> Introspector.decapitalize(shortClassName);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>要点</p>
<ul>
<li>支持生成Bean名称的注解有：<code>@Component</code>及其子注解、<code>@MangedBean</code>、<code>@Named</code></li>
<li>如果这些注解没有显式指明名称，则回退成默认规则：类名首字母小写</li>
</ul>
<h4 id="判定BeanDefinition是否需要被加载"><a href="#判定BeanDefinition是否需要被加载" class="headerlink" title="判定BeanDefinition是否需要被加载"></a>判定BeanDefinition是否需要被加载</h4><p>ConditionEvaluator这个类也值得一看，它解释了<code>@Conditional</code>注解的工作原理。整个类就暴露一个方法：<code>shouldSkip()</code></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">shouldSkip</span><span class="params">(<span class="meta">@Nullable</span> AnnotatedTypeMetadata metadata, <span class="meta">@Nullable</span> ConfigurationPhase phase)</span> </span>&#123;</span><br><span class="line">  <span class="comment">// 如果目标类没有被Conditional注解，则不应被跳过</span></span><br><span class="line">  <span class="keyword">if</span> (metadata == <span class="keyword">null</span> || !metadata.isAnnotated(Conditional.class.getName())) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (phase == <span class="keyword">null</span>) &#123;</span><br><span class="line">  	<span class="comment">// 如果没有指定配置过程，就根据其它条件判断是属于配置阶段还是创建Bean阶段</span></span><br><span class="line">    <span class="keyword">if</span> (metadata <span class="keyword">instanceof</span> AnnotationMetadata &amp;&amp; ConfigurationClassUtils.isConfigurationCandidate((AnnotationMetadata) metadata)) &#123;</span><br><span class="line">      <span class="keyword">return</span> shouldSkip(metadata, ConfigurationPhase.PARSE_CONFIGURATION);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> shouldSkip(metadata, ConfigurationPhase.REGISTER_BEAN);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  List&lt;Condition&gt; conditions = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">  <span class="comment">// 从@Conditional注解中提取出Condition条件</span></span><br><span class="line">  <span class="keyword">for</span> (String[] conditionClasses : getConditionClasses(metadata)) &#123;</span><br><span class="line">    <span class="keyword">for</span> (String conditionClass : conditionClasses) &#123;</span><br><span class="line">      Condition condition = getCondition(conditionClass, <span class="keyword">this</span>.context.getClassLoader());</span><br><span class="line">      conditions.add(condition);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">	<span class="comment">// 排序</span></span><br><span class="line">  AnnotationAwareOrderComparator.sort(conditions);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span> (Condition condition : conditions) &#123;</span><br><span class="line">    ConfigurationPhase requiredPhase = <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">if</span> (condition <span class="keyword">instanceof</span> ConfigurationCondition) &#123;</span><br><span class="line">      requiredPhase = ((ConfigurationCondition) condition).getConfigurationPhase();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 当阶段匹配，且条件不匹配时，则跳过Bean注册</span></span><br><span class="line">    <span class="keyword">if</span> ((requiredPhase == <span class="keyword">null</span> || requiredPhase == phase) &amp;&amp; !condition.matches(<span class="keyword">this</span>.context, metadata)) &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">	<span class="comment">// 其它情况，不应当跳过</span></span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>分析一下<code>ConfigurationClassUtils.isConfigurationCandidate()</code></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Set&lt;String&gt; candidateIndicators = <span class="keyword">new</span> HashSet&lt;&gt;(<span class="number">8</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> &#123;</span><br><span class="line">  <span class="comment">// 有下面这四个注解，就说明是配置Bean</span></span><br><span class="line">  candidateIndicators.add(Component.class.getName());</span><br><span class="line">  candidateIndicators.add(ComponentScan.class.getName());</span><br><span class="line">  candidateIndicators.add(Import.class.getName());</span><br><span class="line">  candidateIndicators.add(ImportResource.class.getName());</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">boolean</span> <span class="title">isConfigurationCandidate</span><span class="params">(AnnotationMetadata metadata)</span> </span>&#123;</span><br><span class="line">  <span class="comment">// 接口上的注解不考虑</span></span><br><span class="line">  <span class="keyword">if</span> (metadata.isInterface()) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">  &#125;</span><br><span class="line">	<span class="comment">// 只要被上面那四个注解注解了，就说明是配置Bean</span></span><br><span class="line">  <span class="keyword">for</span> (String indicator : candidateIndicators) &#123;</span><br><span class="line">    <span class="keyword">if</span> (metadata.isAnnotated(indicator)) &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">	<span class="comment">// 否则，如果其内部存在被@Bean注解的方法，也算配置Bean</span></span><br><span class="line">  <span class="keyword">return</span> hasBeanMethods(metadata);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">boolean</span> <span class="title">hasBeanMethods</span><span class="params">(AnnotationMetadata metadata)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> metadata.hasAnnotatedMethods(Bean.class.getName());</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">catch</span> (Throwable ex) &#123;</span><br><span class="line">    ... ...</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>理解关键</p>
<ul>
<li><code>AnnotatedTypeMetadata</code>要理解，前面<code>AnnotatedBeanDefinition</code>看到过，Spring将<code>Bean</code>上的注解信息和类信息进行了抽象，使得不需要加载具体的类就能获取其上的注解，使用方便。</li>
<li><code>Condition</code>条件，它只有一个匹配方法<code>boolean matches(ConditionContext context, AnnotatedTypeMetadata metadata)</code>，用于匹配指定Bean在容器中是否满足条件，我们常用的<code>@ConditionalOnClassMissingBean</code>之类的注解，就是<code>@Conditional</code>派生注解+<code>Condition</code>派生类组合完成的。</li>
</ul>
<p>要点总结</p>
<ul>
<li><code>ConditionEvaluator</code>是用来判断某个Bean定义是否符合加载条件，是加载还是有应该被忽略。判断逻辑<ul>
<li>如果不存在<code>@Conditional</code>注解，则需要加载</li>
<li>如果存在<code>@Conditional</code>注解，则需要看该注解的作用阶段和其内部<code>Condition</code>的行为<ul>
<li>如果<code>Condition</code>所指定的阶段与<code>@Conditional</code>实际作用的阶段不一致，则需要加载</li>
<li>否则，根据<code>Condition.matches()</code>的结果来判定是否需要加载</li>
</ul>
</li>
</ul>
</li>
<li>当一个Bean定义被<code>@Component、@ComponentScan、@Import、@ImportResource</code>注解，或其内含有<code>@Bean</code>注解方法时，说明它是一个配置Bean。即作用阶段是<code>ConfigurationPhase.PARSE_CONFIGURATION</code>，否则，作用阶段是<code>ConfigurationPhase.REGISTER_BEAN</code>，作用阶段，也可以用来判断是否需要加载该Bean定义：当声明的作用阶段和<code>Condition</code>类的作用阶段不一致时，将忽略匹配过程，直接加载</li>
</ul>
<h3 id="ClassPathBeanDefinitionScanner"><a href="#ClassPathBeanDefinitionScanner" class="headerlink" title="ClassPathBeanDefinitionScanner"></a>ClassPathBeanDefinitionScanner</h3><p><img src="https://gdz.oss-cn-shenzhen.aliyuncs.com/local/%E6%88%AA%E5%B1%8F2021-11-18%20%E4%B8%8B%E5%8D%886.33.05.png" alt="截屏2021-11-18 下午6.33.05"></p>
<p>继承树如上</p>
<ul>
<li><code>ClassPathScanningCandidateComponentProvider</code>用于在指定包下扫描并提供Bean定义（所谓的<code>CandidateComponent</code>），核心逻辑在<code>public Set&lt;BeanDefinition&gt; findCandidateComponents(String basePackage)</code>方法。</li>
<li><code>ClassPathBeanDefinitionScanner</code>用于批量扫描包下的Bean定义，核心逻辑在<code>protected Set&lt;BeanDefinitionHolder&gt; doScan(String... basePackages)</code>方法。</li>
</ul>
<p>我们按照调用关系来看，从scan方法看起</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">scan</span><span class="params">(String... basePackages)</span> </span>&#123;</span><br><span class="line">  <span class="comment">// 扫描：从包下扫描出BeanDefinition，然后注入registry，详情见下</span></span><br><span class="line">  doScan(basePackages);</span><br><span class="line">  <span class="keyword">if</span> (<span class="keyword">this</span>.includeAnnotationConfig) &#123;</span><br><span class="line">    <span class="comment">// 注册一批后置处理器，这个我们忽略，它注册了一批内部的后置处理器</span></span><br><span class="line">    AnnotationConfigUtils.registerAnnotationConfigProcessors(<span class="keyword">this</span>.registry);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// return什么不重要</span></span><br><span class="line">  <span class="keyword">return</span> ...</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">protected</span> Set&lt;BeanDefinitionHolder&gt; <span class="title">doScan</span><span class="params">(String... basePackages)</span> </span>&#123;</span><br><span class="line">  Set&lt;BeanDefinitionHolder&gt; beanDefinitions = <span class="keyword">new</span> LinkedHashSet&lt;&gt;();</span><br><span class="line">  <span class="keyword">for</span> (String basePackage : basePackages) &#123;</span><br><span class="line">    <span class="comment">// 调用父类的findCandidateComponents，在指定包下找到符合要求的BeanDefinition</span></span><br><span class="line">    Set&lt;BeanDefinition&gt; candidates = findCandidateComponents(basePackage);</span><br><span class="line">    <span class="keyword">for</span> (BeanDefinition candidate : candidates) &#123;</span><br><span class="line">      <span class="comment">// 解析Scope元信息</span></span><br><span class="line">      ScopeMetadata scopeMetadata = <span class="keyword">this</span>.scopeMetadataResolver.resolveScopeMetadata(candidate);</span><br><span class="line">      candidate.setScope(scopeMetadata.getScopeName());</span><br><span class="line">      <span class="comment">// 生成bean名称</span></span><br><span class="line">      String beanName = <span class="keyword">this</span>.beanNameGenerator.generateBeanName(candidate, <span class="keyword">this</span>.registry);</span><br><span class="line">      <span class="keyword">if</span> (candidate <span class="keyword">instanceof</span> AbstractBeanDefinition) &#123;</span><br><span class="line">        <span class="comment">// 一波附加逻辑，详情见下</span></span><br><span class="line">        postProcessBeanDefinition((AbstractBeanDefinition) candidate, beanName);</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">if</span> (candidate <span class="keyword">instanceof</span> AnnotatedBeanDefinition) &#123;</span><br><span class="line">        <span class="comment">// 处理一波通用注解：@Lazy、@Primary、@DependsOn、@Role、@Description，该方法前面已经分析过了</span></span><br><span class="line">        AnnotationConfigUtils.processCommonDefinitionAnnotations((AnnotatedBeanDefinition) candidate);</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="comment">// 检查新建的BeanDefinition是否合法，主要是检查容器中是否已经有同名Bean了</span></span><br><span class="line">      <span class="keyword">if</span> (checkCandidate(beanName, candidate)) &#123;</span><br><span class="line">        <span class="comment">// 构建BeanDefinitionHolder</span></span><br><span class="line">        BeanDefinitionHolder definitionHolder = <span class="keyword">new</span> BeanDefinitionHolder(candidate, beanName);</span><br><span class="line">        <span class="comment">// 应用scope的代理mode</span></span><br><span class="line">        definitionHolder = AnnotationConfigUtils.applyScopedProxyMode(scopeMetadata, definitionHolder, <span class="keyword">this</span>.registry);</span><br><span class="line">        beanDefinitions.add(definitionHolder);</span><br><span class="line">        <span class="comment">// 注入registry</span></span><br><span class="line">        registerBeanDefinition(definitionHolder, <span class="keyword">this</span>.registry);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> beanDefinitions;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">postProcessBeanDefinition</span><span class="params">(AbstractBeanDefinition beanDefinition, String beanName)</span> </span>&#123;</span><br><span class="line">  <span class="comment">// 应用默认设置：延迟加载、自动注入mode、依赖检查、初始化方法、销毁方法等</span></span><br><span class="line">  beanDefinition.applyDefaults(<span class="keyword">this</span>.beanDefinitionDefaults);</span><br><span class="line">  <span class="keyword">if</span> (<span class="keyword">this</span>.autowireCandidatePatterns != <span class="keyword">null</span>) &#123;</span><br><span class="line">    <span class="comment">// 设置是否参与自动注入</span></span><br><span class="line">    beanDefinition.setAutowireCandidate(PatternMatchUtils.simpleMatch(<span class="keyword">this</span>.autowireCandidatePatterns, beanName));</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">applyDefaults</span><span class="params">(BeanDefinitionDefaults defaults)</span> </span>&#123;</span><br><span class="line">  Boolean lazyInit = defaults.getLazyInit();</span><br><span class="line">  <span class="keyword">if</span> (lazyInit != <span class="keyword">null</span>) &#123;</span><br><span class="line">    setLazyInit(lazyInit);</span><br><span class="line">  &#125;</span><br><span class="line">  setAutowireMode(defaults.getAutowireMode());</span><br><span class="line">  setDependencyCheck(defaults.getDependencyCheck());</span><br><span class="line">  setInitMethodName(defaults.getInitMethodName());</span><br><span class="line">  setEnforceInitMethod(<span class="keyword">false</span>);</span><br><span class="line">  setDestroyMethodName(defaults.getDestroyMethodName());</span><br><span class="line">  setEnforceDestroyMethod(<span class="keyword">false</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上面有调用到<code>ClassPathScanningCandidateComponentProvider</code>的<code>findCandidateComponents</code>方法，我们再看</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> Set&lt;BeanDefinition&gt; <span class="title">findCandidateComponents</span><span class="params">(String basePackage)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (<span class="keyword">this</span>.componentsIndex != <span class="keyword">null</span> &amp;&amp; indexSupportsIncludeFilters()) &#123;</span><br><span class="line">    <span class="comment">// 通过Index进行组件扫描</span></span><br><span class="line">    <span class="keyword">return</span> addCandidateComponentsFromIndex(<span class="keyword">this</span>.componentsIndex, basePackage);</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="comment">// 直接扫描</span></span><br><span class="line">    <span class="keyword">return</span> scanCandidateComponents(basePackage);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 直接扫描的过程：</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> Set&lt;BeanDefinition&gt; <span class="title">scanCandidateComponents</span><span class="params">(String basePackage)</span> </span>&#123;</span><br><span class="line">  Set&lt;BeanDefinition&gt; candidates = <span class="keyword">new</span> LinkedHashSet&lt;&gt;();</span><br><span class="line">  <span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="comment">// 路径：classpath*:&#123;包转换后的路径名&#125;/**/*.class，即所有jar包下的置顶包名下的所有层级的所有class文件</span></span><br><span class="line">    String packageSearchPath = ResourcePatternResolver.CLASSPATH_ALL_URL_PREFIX + resolveBasePackage(basePackage) + <span class="string">&#x27;/&#x27;</span> + <span class="keyword">this</span>.resourcePattern;</span><br><span class="line">    Resource[] resources = getResourcePatternResolver().getResources(packageSearchPath);</span><br><span class="line">    <span class="keyword">for</span> (Resource resource : resources) </span><br><span class="line">      <span class="keyword">if</span> (resource.isReadable()) &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">          MetadataReader metadataReader = getMetadataReaderFactory().getMetadataReader(resource);</span><br><span class="line">          <span class="comment">// 必须符合includeFilters中的过滤器要求才会被扫描出来</span></span><br><span class="line">          <span class="keyword">if</span> (isCandidateComponent(metadataReader)) &#123;</span><br><span class="line">            <span class="comment">// 刚扫描出来的BeanDefinition，只创建了Bean定义的实例，还没开始解析，解析留给子类。</span></span><br><span class="line">            ScannedGenericBeanDefinition sbd = <span class="keyword">new</span> ScannedGenericBeanDefinition(metadataReader);</span><br><span class="line">            sbd.setSource(resource);</span><br><span class="line">            <span class="keyword">if</span> (isCandidateComponent(sbd)) &#123;</span><br><span class="line">              candidates.add(sbd);</span><br><span class="line">            &#125;</span><br><span class="line">          &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Throwable ex) &#123;</span><br><span class="line">          <span class="keyword">throw</span> <span class="keyword">new</span> BeanDefinitionStoreException(<span class="string">&quot;Failed to read candidate component class: &quot;</span> + resource, ex);</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125; <span class="keyword">catch</span> (IOException ex) &#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> BeanDefinitionStoreException(<span class="string">&quot;I/O failure during classpath scanning&quot;</span>, ex);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> candidates;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">boolean</span> <span class="title">isCandidateComponent</span><span class="params">(MetadataReader metadataReader)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">  <span class="comment">// 在排除过滤器中，直接不符合要求</span></span><br><span class="line">  <span class="keyword">for</span> (TypeFilter tf : <span class="keyword">this</span>.excludeFilters) &#123;</span><br><span class="line">    <span class="keyword">if</span> (tf.match(metadataReader, getMetadataReaderFactory())) &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 在include过滤器中匹配才符合要求</span></span><br><span class="line">  <span class="keyword">for</span> (TypeFilter tf : <span class="keyword">this</span>.includeFilters) &#123;</span><br><span class="line">    <span class="keyword">if</span> (tf.match(metadataReader, getMetadataReaderFactory())) &#123;</span><br><span class="line">      <span class="keyword">return</span> isConditionMatch(metadataReader);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上面只贴出了直接从类中扫描的代码，但另一个<code>addCandidateComponentsFromIndex</code>没说。我们需要先知道一下Spring中的Index是什么。可以参考<a target="_blank" rel="noopener" href="https://juejin.cn/post/6844904014509768712">这篇文章</a>:</p>
<blockquote>
<p>在项目中使用了<code>@Indexed</code>之后，编译打包的时候会在项目中自动生成<code>META-INT/spring.components</code>文件。 当Spring应用上下文执行<code>ComponentScan</code>扫描时，<code>META-INT/spring.components</code>将会被<code>CandidateComponentsIndexLoader</code> 读取并加载，转换为<code>CandidateComponentsIndex</code>对象，这样的话<code>@ComponentScan</code>不在扫描指定的package，而是读取<code>CandidateComponentsIndex</code>对象，从而达到提升性能的目的。</p>
</blockquote>
<p>此时我们再去跟踪<code>addCandidateComponentsFromIndex()</code>方法，会发现和上面说的可以说是一模一样了。</p>
<p>要点总结</p>
<ul>
<li><p>可以看到，<code>ClassPathBeanDefinitionScanner</code>做的事和<code>AnnotatedBeanDefinitionReader</code>差不多，都是构建<code>BeanDefinition</code>并向容器中注册；唯一的差别是，前者的Bean定义是自己扫描得来的，而后者的Bean定义是外界调用方法注册来的</p>
</li>
<li><p>通过<code>ClassPathScanningCandidateComponentProvider.findCandidateComponents()</code>我们知道，它只提供最原始的扫描并生成<code>BeanDefinition</code>的逻辑，而<code>BeanDefinition</code>各种属性的解析和设置放在其子类<code>ClassPathBeanDefinitionScanner</code>中了。</p>
</li>
</ul>
<h3 id="小结-1"><a href="#小结-1" class="headerlink" title="小结"></a>小结</h3><p>这一个Reader，一个Scanner，都只是一个工具，最终完成了容器中的<code>BeanDefinition</code>创建。</p>
<h2 id="如何创建Bean"><a href="#如何创建Bean" class="headerlink" title="如何创建Bean"></a>如何创建Bean</h2><h3 id="Bean的创建逻辑"><a href="#Bean的创建逻辑" class="headerlink" title="Bean的创建逻辑"></a>Bean的创建逻辑</h3><p>Bean的创建有几个时机</p>
<ul>
<li>对于非延迟加载的单例Bean，在容器refresh时就会被创建，在<code>ApplicationContext</code>源码分析时我们看到过</li>
<li>对于延迟加载的单例Bean，在第一次被获取时会被创建</li>
<li>对于原型Bean，每次被获取时都会被创建</li>
</ul>
<p>我们先看第一种情况，直接进<code>org.springframework.beans.factory.support.DefaultListableBeanFactory#preInstantiateSingletons</code>，我删掉了不重要的代码。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">preInstantiateSingletons</span><span class="params">()</span> <span class="keyword">throws</span> BeansException </span>&#123;</span><br><span class="line">  <span class="comment">// Iterate over a copy to allow for init methods which in turn register new bean definitions.</span></span><br><span class="line">  <span class="comment">// While this may not be part of the regular factory bootstrap, it does otherwise work fine.</span></span><br><span class="line">  List&lt;String&gt; beanNames = <span class="keyword">new</span> ArrayList&lt;&gt;(<span class="keyword">this</span>.beanDefinitionNames);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Trigger initialization of all non-lazy singleton beans...</span></span><br><span class="line">  <span class="keyword">for</span> (String beanName : beanNames) &#123;</span><br><span class="line">    <span class="comment">// 获取合并后的BeanDefinition</span></span><br><span class="line">    RootBeanDefinition bd = getMergedLocalBeanDefinition(beanName);</span><br><span class="line">    <span class="comment">// 单例且非延迟加载才会创建</span></span><br><span class="line">    <span class="keyword">if</span> (!bd.isAbstract() &amp;&amp; bd.isSingleton() &amp;&amp; !bd.isLazyInit()) &#123;</span><br><span class="line">      <span class="keyword">if</span> (isFactoryBean(beanName)) &#123;</span><br><span class="line">        <span class="comment">// 工厂Bean的名字有特殊前缀：&amp;</span></span><br><span class="line">        Object bean = getBean(FACTORY_BEAN_PREFIX + beanName);</span><br><span class="line">        <span class="keyword">if</span> (bean <span class="keyword">instanceof</span> FactoryBean) &#123;</span><br><span class="line">          FactoryBean&lt;?&gt; factory = (FactoryBean&lt;?&gt;) bean;</span><br><span class="line">          <span class="comment">// 针对SmartFactoryBean的特殊处理</span></span><br><span class="line">          <span class="keyword">boolean</span> isEagerInit = (factory <span class="keyword">instanceof</span> SmartFactoryBean &amp;&amp; ((SmartFactoryBean&lt;?&gt;) factory).isEagerInit());</span><br><span class="line">          <span class="keyword">if</span> (isEagerInit) &#123;</span><br><span class="line">            <span class="comment">// 真的去创建Bean</span></span><br><span class="line">            getBean(beanName);</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// 真的去创建Bean</span></span><br><span class="line">        getBean(beanName);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span> (String beanName : beanNames) &#123;</span><br><span class="line">    <span class="comment">// 针对SmartInitializingSingleton的特殊处理</span></span><br><span class="line">    Object singletonInstance = getSingleton(beanName);</span><br><span class="line">    <span class="keyword">if</span> (singletonInstance <span class="keyword">instanceof</span> SmartInitializingSingleton) &#123;</span><br><span class="line">      SmartInitializingSingleton smartSingleton = (SmartInitializingSingleton) singletonInstance;</span><br><span class="line">      smartSingleton.afterSingletonsInstantiated();</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> Object <span class="title">getBean</span><span class="params">(String name)</span> <span class="keyword">throws</span> BeansException </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> doGetBean(name, <span class="keyword">null</span>, <span class="keyword">null</span>, <span class="keyword">false</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 真的去创建Bean</span></span><br><span class="line"><span class="comment"> * name: bean的名称</span></span><br><span class="line"><span class="comment"> * requiedType: 希望解析出来的Bean的类型</span></span><br><span class="line"><span class="comment"> * args: 用于创建bean时的构造方法的参数。如果只是获取已有的bean，则不需要</span></span><br><span class="line"><span class="comment"> * typeCheckOnly: 只检查得到的bean与目标类型是否匹配，而不真正地标记创建</span></span><br><span class="line"><span class="comment"> **/</span></span><br><span class="line"><span class="keyword">protected</span> &lt;T&gt; <span class="function">T <span class="title">doGetBean</span><span class="params">(String name, <span class="meta">@Nullable</span> Class&lt;T&gt; requiredType, <span class="meta">@Nullable</span> Object[] args, <span class="keyword">boolean</span> typeCheckOnly)</span> </span>&#123;</span><br><span class="line">  <span class="comment">// 名字转换：主要是处理别名，根据别名获取真名</span></span><br><span class="line">  String beanName = transformedBeanName(name);</span><br><span class="line">  Object beanInstance;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Eagerly check singleton cache for manually registered singletons.</span></span><br><span class="line">  <span class="comment">// 从单例缓存中获取已经注册号的单例Bean实例</span></span><br><span class="line">  Object sharedInstance = getSingleton(beanName);</span><br><span class="line">  <span class="keyword">if</span> (sharedInstance != <span class="keyword">null</span> &amp;&amp; args == <span class="keyword">null</span>) &#123;</span><br><span class="line">    <span class="comment">// 根据共享实例创建Bean实例，如果共享实例是factoryBean，则用它创建一个Bean</span></span><br><span class="line">    beanInstance = getObjectForBeanInstance(sharedInstance, name, beanName, <span class="keyword">null</span>);</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="comment">// Check if bean definition exists in this factory.</span></span><br><span class="line">    BeanFactory parentBeanFactory = getParentBeanFactory();</span><br><span class="line">    <span class="comment">// 如果父容器中还不存在该Bean，则尝试从父容器中获取该Bean，逻辑和本类一致。</span></span><br><span class="line">    <span class="keyword">if</span> (parentBeanFactory != <span class="keyword">null</span> &amp;&amp; !containsBeanDefinition(beanName)) &#123;</span><br><span class="line">      String nameToLookup = originalBeanName(name);</span><br><span class="line">      <span class="keyword">if</span> (parentBeanFactory <span class="keyword">instanceof</span> AbstractBeanFactory) &#123;</span><br><span class="line">        <span class="keyword">return</span> ((AbstractBeanFactory) parentBeanFactory).doGetBean(nameToLookup, requiredType, args, typeCheckOnly);</span><br><span class="line">      &#125; <span class="keyword">else</span> <span class="keyword">if</span> (args != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="comment">// Delegation to parent with explicit args.</span></span><br><span class="line">        <span class="keyword">return</span> (T) parentBeanFactory.getBean(nameToLookup, args);</span><br><span class="line">      &#125; <span class="keyword">else</span> <span class="keyword">if</span> (requiredType != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="comment">// No args -&gt; delegate to standard getBean method.</span></span><br><span class="line">        <span class="keyword">return</span> parentBeanFactory.getBean(nameToLookup, requiredType);</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> (T) parentBeanFactory.getBean(nameToLookup);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 标记已创建</span></span><br><span class="line">    <span class="keyword">if</span> (!typeCheckOnly) &#123;</span><br><span class="line">      markBeanAsCreated(beanName);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 从缓存和父容器中都没有获取到，就要重新创建了，这里获取BeanDefinition，用于创建</span></span><br><span class="line">    RootBeanDefinition mbd = getMergedLocalBeanDefinition(beanName);</span><br><span class="line">    <span class="comment">// Guarantee initialization of beans that the current bean depends on.</span></span><br><span class="line">    <span class="comment">// 获取依赖</span></span><br><span class="line">    String[] dependsOn = mbd.getDependsOn();</span><br><span class="line">    <span class="keyword">if</span> (dependsOn != <span class="keyword">null</span>) &#123;</span><br><span class="line">      <span class="keyword">for</span> (String dep : dependsOn) &#123;</span><br><span class="line">        <span class="comment">// 如果当前Bean又被它的依赖所依赖，就产生的循环依赖，报错</span></span><br><span class="line">        <span class="keyword">if</span> (isDependent(beanName, dep)) &#123;</span><br><span class="line">          <span class="keyword">throw</span> <span class="keyword">new</span> BeanCreationException(mbd.getResourceDescription(), beanName, <span class="string">&quot;Circular depends-on relationship between &#x27;&quot;</span> + beanName + <span class="string">&quot;&#x27; and &#x27;&quot;</span> + dep + <span class="string">&quot;&#x27;&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">          <span class="comment">// 创建该依赖的Bean，逻辑还是本方法的逻辑</span></span><br><span class="line">          getBean(dep);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (NoSuchBeanDefinitionException ex) &#123;</span><br><span class="line">          <span class="keyword">throw</span> <span class="keyword">new</span> BeanCreationException(mbd.getResourceDescription(), beanName, <span class="string">&quot;&#x27;&quot;</span> + beanName + <span class="string">&quot;&#x27; depends on missing bean &#x27;&quot;</span> + dep + <span class="string">&quot;&#x27;&quot;</span>, ex);</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Create bean instance.</span></span><br><span class="line">    <span class="comment">// 如果是单例的，从缓存中获取共享实例，如果没有共享实例，则创建它</span></span><br><span class="line">    <span class="keyword">if</span> (mbd.isSingleton()) &#123;</span><br><span class="line">      sharedInstance = getSingleton(beanName, () -&gt; &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">          <span class="comment">// 创建Bean</span></span><br><span class="line">          <span class="keyword">return</span> createBean(beanName, mbd, args);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (BeansException ex) &#123;</span><br><span class="line">          <span class="comment">// Explicitly remove instance from singleton cache: It might have been put there</span></span><br><span class="line">          <span class="comment">// eagerly by the creation process, to allow for circular reference resolution.</span></span><br><span class="line">          <span class="comment">// Also remove any beans that received a temporary reference to the bean.</span></span><br><span class="line">          destroySingleton(beanName);</span><br><span class="line">          <span class="keyword">throw</span> ex;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;);</span><br><span class="line">      <span class="comment">// 根据共享实例创建Bean实例，如果共享实例是factoryBean，则用它创建一个Bean</span></span><br><span class="line">      beanInstance = getObjectForBeanInstance(sharedInstance, name, beanName, mbd);</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (mbd.isPrototype()) &#123;</span><br><span class="line">      <span class="comment">// 如果是原型的，则每次都创建新的</span></span><br><span class="line">      <span class="comment">// It&#x27;s a prototype -&gt; create a new instance.</span></span><br><span class="line">      Object prototypeInstance = <span class="keyword">null</span>;</span><br><span class="line">      <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">// 创建前回调：标记该bean正在创建</span></span><br><span class="line">        beforePrototypeCreation(beanName);</span><br><span class="line">        <span class="comment">// 创建Bean</span></span><br><span class="line">        prototypeInstance = createBean(beanName, mbd, args);</span><br><span class="line">      &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        <span class="comment">// 创建后回调：标记该bean已经没在创建</span></span><br><span class="line">        afterPrototypeCreation(beanName);</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="comment">// 根据共享实例创建Bean实例，如果共享实例是factoryBean，则用它创建一个Bean</span></span><br><span class="line">      beanInstance = getObjectForBeanInstance(prototypeInstance, name, beanName, mbd);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="comment">// 原型和单例之外的scope</span></span><br><span class="line">      String scopeName = mbd.getScope();</span><br><span class="line">      <span class="comment">// 从scopes缓存中获取指定的Scope，该对象就是一个Bean持有器</span></span><br><span class="line">      Scope scope = <span class="keyword">this</span>.scopes.get(scopeName);</span><br><span class="line">      <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">// 整个scope只有一个实例，从中取，没有则创建。</span></span><br><span class="line">        Object scopedInstance = scope.get(beanName, () -&gt; &#123;</span><br><span class="line">          <span class="comment">// 创建前回调：标记该bean正在创建</span></span><br><span class="line">          beforePrototypeCreation(beanName);</span><br><span class="line">          <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">// 创建Bean</span></span><br><span class="line">            <span class="keyword">return</span> createBean(beanName, mbd, args);</span><br><span class="line">          &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            <span class="comment">// 创建后回调：标记该bean已经没在创建</span></span><br><span class="line">            afterPrototypeCreation(beanName);</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">        <span class="comment">// 根据共享实例创建Bean实例，如果共享实例是factoryBean，则用它创建一个Bean</span></span><br><span class="line">        beanInstance = getObjectForBeanInstance(scopedInstance, name, beanName, mbd);</span><br><span class="line">      &#125; <span class="keyword">catch</span> (IllegalStateException ex) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> ScopeNotActiveException(beanName, scopeName, ex);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 做最后的调整，如果实例化出来的类型和想要的类型不一致，还要进行一个类型转换</span></span><br><span class="line">  <span class="keyword">return</span> adaptBeanInstance(name, beanInstance, requiredType);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&lt;T&gt; <span class="function">T <span class="title">adaptBeanInstance</span><span class="params">(String name, Object bean, <span class="meta">@Nullable</span> Class&lt;?&gt; requiredType)</span> </span>&#123;</span><br><span class="line">  <span class="comment">// Check if required type matches the type of the actual bean instance.</span></span><br><span class="line">  <span class="keyword">if</span> (requiredType != <span class="keyword">null</span> &amp;&amp; !requiredType.isInstance(bean)) &#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">      Object convertedBean = getTypeConverter().convertIfNecessary(bean, requiredType);</span><br><span class="line">      <span class="keyword">if</span> (convertedBean == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> BeanNotOfRequiredTypeException(name, requiredType, bean.getClass());</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">return</span> (T) convertedBean;</span><br><span class="line">    &#125; <span class="keyword">catch</span> (TypeMismatchException ex) &#123;</span><br><span class="line">      <span class="keyword">throw</span> <span class="keyword">new</span> BeanNotOfRequiredTypeException(name, requiredType, bean.getClass());</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> (T) bean;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上面虽然只是预加载单例Bean的代码，但方法<code>doGetBean()</code>却是获取Bean的通用方法，对此，可以有所总结：</p>
<ul>
<li>单例Bean的创建， 先从缓存中获取；如果没有，再从父容器中获取，如果再没有，则执行创建逻辑</li>
<li>如果一个Bean有依赖的Bean，则该依赖Bean将会首先被创建；如果被依赖的Bean又依赖了原Bean，则构成循环依赖，Spring将会抛出异常</li>
<li>scope的实现只有三种情况<ul>
<li>单例：当<code>BeanDefinition</code>的scope没有值（即默认单例）或为<code>singleton</code>时，为单例，整个容器只维护一份实例</li>
<li>原型：当<code>BeanDefinition</code>的scope为<code>prototye</code>时，为原型，每次都会执行一遍新建Bean的逻辑</li>
<li>其它：当<code>BeanDefinition</code>的scope非上述任何一种时，为其它，实现方式是容器维护一个名为<code>scopes</code>的Map，每个entry的值为<code>Scope</code>对象，它就是一个容器，新建的Bean会放入该容器。构成对同一个<code>Scope</code>只存在一份Bean。</li>
</ul>
</li>
<li>创建完成的Bean实例，并不能直接使用：如果有指定预期的类型，还要调用容器内维护的类型转换器进行一次类型转换，得到最终值</li>
</ul>
<p>对于正常情况下的Bean获取方法如<code>org.springframework.context.support.AbstractApplicationContext#getBean(java.lang.String)</code>，有如下</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> Object <span class="title">getBean</span><span class="params">(String name)</span> <span class="keyword">throws</span> BeansException </span>&#123;</span><br><span class="line">  assertBeanFactoryActive();</span><br><span class="line">  <span class="keyword">return</span> getBeanFactory().getBean(name);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> Object <span class="title">getBean</span><span class="params">(String name)</span> <span class="keyword">throws</span> BeansException </span>&#123;</span><br><span class="line">  <span class="comment">// 可以看到它又是调用了doGetBean()，还是那个通用方法</span></span><br><span class="line">  <span class="keyword">return</span> doGetBean(name, <span class="keyword">null</span>, <span class="keyword">null</span>, <span class="keyword">false</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>可以看到它又是调用了doGetBean()，还是那个通用方法，这里略过不记。</p>
<h3 id="MergedBeanDefinition"><a href="#MergedBeanDefinition" class="headerlink" title="MergedBeanDefinition"></a>MergedBeanDefinition</h3><p>先说明，没有这个类或接口定义，但是前文”如何描述Bean“提到了合并Bean定义的概念，”Bean的创建逻辑“又再次看到了这个概念，它到底什么意思？我们从<code>org.springframework.beans.factory.support.AbstractBeanFactory#getMergedLocalBeanDefinition</code>方法来看</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> RootBeanDefinition <span class="title">getMergedLocalBeanDefinition</span><span class="params">(String beanName)</span> <span class="keyword">throws</span> BeansException </span>&#123;</span><br><span class="line">  <span class="comment">// 先从缓存中获取结果</span></span><br><span class="line">  RootBeanDefinition mbd = <span class="keyword">this</span>.mergedBeanDefinitions.get(beanName);</span><br><span class="line">  <span class="keyword">if</span> (mbd != <span class="keyword">null</span> &amp;&amp; !mbd.stale) &#123;</span><br><span class="line">    <span class="keyword">return</span> mbd;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> getMergedBeanDefinition(beanName, getBeanDefinition(beanName));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">protected</span> RootBeanDefinition <span class="title">getMergedBeanDefinition</span><span class="params">(String beanName, BeanDefinition bd)</span> <span class="keyword">throws</span> BeanDefinitionStoreException </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> getMergedBeanDefinition(beanName, bd, <span class="keyword">null</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 真实的获取mergedBeanDefinition的方法</span></span><br><span class="line"><span class="comment"> * 参数说明</span></span><br><span class="line"><span class="comment"> * beanName: bean的名称</span></span><br><span class="line"><span class="comment"> * bd: bean的定义</span></span><br><span class="line"><span class="comment"> * contaningBd: 包含该bean的bean定义（该bean是一个内部bean）</span></span><br><span class="line"><span class="comment"> **/</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> RootBeanDefinition <span class="title">getMergedBeanDefinition</span><span class="params">(String beanName, BeanDefinition bd, <span class="meta">@Nullable</span> BeanDefinition containingBd)</span> <span class="keyword">throws</span> BeanDefinitionStoreException </span>&#123;</span><br><span class="line">  <span class="keyword">synchronized</span> (<span class="keyword">this</span>.mergedBeanDefinitions) &#123;</span><br><span class="line">    RootBeanDefinition mbd = <span class="keyword">null</span>;</span><br><span class="line">    RootBeanDefinition previous = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Check with full lock now in order to enforce the same merged instance.</span></span><br><span class="line">    <span class="keyword">if</span> (containingBd == <span class="keyword">null</span>) &#123;</span><br><span class="line">      mbd = <span class="keyword">this</span>.mergedBeanDefinitions.get(beanName);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (mbd == <span class="keyword">null</span> || mbd.stale) &#123;</span><br><span class="line">      previous = mbd;</span><br><span class="line">      <span class="comment">// 如果当前Bean定义没有父Bean定义，则创建RootBeanDefinition</span></span><br><span class="line">      <span class="keyword">if</span> (bd.getParentName() == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="comment">// Use copy of given root bean definition.</span></span><br><span class="line">        <span class="keyword">if</span> (bd <span class="keyword">instanceof</span> RootBeanDefinition) &#123;</span><br><span class="line">          mbd = ((RootBeanDefinition) bd).cloneBeanDefinition();</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">          mbd = <span class="keyword">new</span> RootBeanDefinition(bd);</span><br><span class="line">        &#125;</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// 否则，该Bean定义是一个子Bean定义，则需要和父Bean定义进行合并</span></span><br><span class="line">        <span class="comment">// Child bean definition: needs to be merged with parent.</span></span><br><span class="line">        BeanDefinition pbd;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">          String parentBeanName = transformedBeanName(bd.getParentName());</span><br><span class="line">          <span class="comment">// 递归逻辑获取父Bean定义，从当前容器或父容器中获取</span></span><br><span class="line">          <span class="keyword">if</span> (!beanName.equals(parentBeanName)) &#123;</span><br><span class="line">            pbd = getMergedBeanDefinition(parentBeanName);</span><br><span class="line">          &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            BeanFactory parent = getParentBeanFactory();</span><br><span class="line">            <span class="keyword">if</span> (parent <span class="keyword">instanceof</span> ConfigurableBeanFactory) &#123;</span><br><span class="line">              pbd = ((ConfigurableBeanFactory) parent).getMergedBeanDefinition(parentBeanName);</span><br><span class="line">            &#125;</span><br><span class="line">          &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (NoSuchBeanDefinitionException ex) &#123;</span><br><span class="line">          <span class="keyword">throw</span> <span class="keyword">new</span> BeanDefinitionStoreException(bd.getResourceDescription(), beanName,</span><br><span class="line">                                                 <span class="string">&quot;Could not resolve parent bean definition &#x27;&quot;</span> + bd.getParentName() + <span class="string">&quot;&#x27;&quot;</span>, ex);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// Deep copy with overridden values.</span></span><br><span class="line">        mbd = <span class="keyword">new</span> RootBeanDefinition(pbd);</span><br><span class="line">        <span class="comment">// 用子Bean定义覆盖父Bean定义，得到一个”合并“后的Bean定义</span></span><br><span class="line">        mbd.overrideFrom(bd);</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="comment">// Set default singleton scope, if not configured before.</span></span><br><span class="line">      <span class="comment">// 默认设置为单例</span></span><br><span class="line">      <span class="keyword">if</span> (!StringUtils.hasLength(mbd.getScope())) &#123;</span><br><span class="line">        mbd.setScope(SCOPE_SINGLETON);</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="comment">// A bean contained in a non-singleton bean cannot be a singleton itself.</span></span><br><span class="line">      <span class="comment">// Let&#x27;s correct this on the fly here, since this might be the result of</span></span><br><span class="line">      <span class="comment">// parent-child merging for the outer bean, in which case the original inner bean</span></span><br><span class="line">      <span class="comment">// definition will not have inherited the merged outer bean&#x27;s singleton status.</span></span><br><span class="line">      <span class="comment">// bean需要和包含它的bean的scope保持一致</span></span><br><span class="line">      <span class="keyword">if</span> (containingBd != <span class="keyword">null</span> &amp;&amp; !containingBd.isSingleton() &amp;&amp; mbd.isSingleton()) &#123;</span><br><span class="line">        mbd.setScope(containingBd.getScope());</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="comment">// Cache the merged bean definition for the time being</span></span><br><span class="line">      <span class="comment">// (it might still get re-merged later on in order to pick up metadata changes)</span></span><br><span class="line">      <span class="keyword">if</span> (containingBd == <span class="keyword">null</span> &amp;&amp; isCacheBeanMetadata()) &#123;</span><br><span class="line">        <span class="keyword">this</span>.mergedBeanDefinitions.put(beanName, mbd);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 合并后的Bean定义可被标记为stale，标识需要重新被合并，这里执行合并逻辑</span></span><br><span class="line">    <span class="keyword">if</span> (previous != <span class="keyword">null</span>) &#123;</span><br><span class="line">      copyRelevantMergedBeanDefinitionCaches(previous, mbd);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> mbd;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">copyRelevantMergedBeanDefinitionCaches</span><span class="params">(RootBeanDefinition previous, RootBeanDefinition mbd)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (ObjectUtils.nullSafeEquals(mbd.getBeanClassName(), previous.getBeanClassName()) &amp;&amp;</span><br><span class="line">      ObjectUtils.nullSafeEquals(mbd.getFactoryBeanName(), previous.getFactoryBeanName()) &amp;&amp;</span><br><span class="line">      ObjectUtils.nullSafeEquals(mbd.getFactoryMethodName(), previous.getFactoryMethodName())) &#123;</span><br><span class="line">    ResolvableType targetType = mbd.targetType;</span><br><span class="line">    ResolvableType previousTargetType = previous.targetType;</span><br><span class="line">    <span class="keyword">if</span> (targetType == <span class="keyword">null</span> || targetType.equals(previousTargetType)) &#123;</span><br><span class="line">      mbd.targetType = previousTargetType;</span><br><span class="line">      mbd.isFactoryBean = previous.isFactoryBean;</span><br><span class="line">      mbd.resolvedTargetType = previous.resolvedTargetType;</span><br><span class="line">      mbd.factoryMethodReturnType = previous.factoryMethodReturnType;</span><br><span class="line">      mbd.factoryMethodToIntrospect = previous.factoryMethodToIntrospect;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>关键是父Bean定义被子Bean定义覆盖，看<code>org.springframework.beans.factory.support.AbstractBeanDefinition#overrideFrom</code></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 不过你看，貌似也没什么不同，就正常的Bean定义的属性呀</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">overrideFrom</span><span class="params">(BeanDefinition other)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (StringUtils.hasLength(other.getBeanClassName())) &#123;</span><br><span class="line">    setBeanClassName(other.getBeanClassName());</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> (StringUtils.hasLength(other.getScope())) &#123;</span><br><span class="line">    setScope(other.getScope());</span><br><span class="line">  &#125;</span><br><span class="line">  setAbstract(other.isAbstract());</span><br><span class="line">  <span class="keyword">if</span> (StringUtils.hasLength(other.getFactoryBeanName())) &#123;</span><br><span class="line">    setFactoryBeanName(other.getFactoryBeanName());</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> (StringUtils.hasLength(other.getFactoryMethodName())) &#123;</span><br><span class="line">    setFactoryMethodName(other.getFactoryMethodName());</span><br><span class="line">  &#125;</span><br><span class="line">  setRole(other.getRole());</span><br><span class="line">  setSource(other.getSource());</span><br><span class="line">  copyAttributesFrom(other);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (other <span class="keyword">instanceof</span> AbstractBeanDefinition) &#123;</span><br><span class="line">    AbstractBeanDefinition otherAbd = (AbstractBeanDefinition) other;</span><br><span class="line">    <span class="keyword">if</span> (otherAbd.hasBeanClass()) &#123;</span><br><span class="line">      setBeanClass(otherAbd.getBeanClass());</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (otherAbd.hasConstructorArgumentValues()) &#123;</span><br><span class="line">      getConstructorArgumentValues().addArgumentValues(other.getConstructorArgumentValues());</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (otherAbd.hasPropertyValues()) &#123;</span><br><span class="line">      getPropertyValues().addPropertyValues(other.getPropertyValues());</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (otherAbd.hasMethodOverrides()) &#123;</span><br><span class="line">      getMethodOverrides().addOverrides(otherAbd.getMethodOverrides());</span><br><span class="line">    &#125;</span><br><span class="line">    Boolean lazyInit = otherAbd.getLazyInit();</span><br><span class="line">    <span class="keyword">if</span> (lazyInit != <span class="keyword">null</span>) &#123;</span><br><span class="line">      setLazyInit(lazyInit);</span><br><span class="line">    &#125;</span><br><span class="line">    setAutowireMode(otherAbd.getAutowireMode());</span><br><span class="line">    setDependencyCheck(otherAbd.getDependencyCheck());</span><br><span class="line">    setDependsOn(otherAbd.getDependsOn());</span><br><span class="line">    setAutowireCandidate(otherAbd.isAutowireCandidate());</span><br><span class="line">    setPrimary(otherAbd.isPrimary());</span><br><span class="line">    copyQualifiersFrom(otherAbd);</span><br><span class="line">    setInstanceSupplier(otherAbd.getInstanceSupplier());</span><br><span class="line">    setNonPublicAccessAllowed(otherAbd.isNonPublicAccessAllowed());</span><br><span class="line">    setLenientConstructorResolution(otherAbd.isLenientConstructorResolution());</span><br><span class="line">    <span class="keyword">if</span> (otherAbd.getInitMethodName() != <span class="keyword">null</span>) &#123;</span><br><span class="line">      setInitMethodName(otherAbd.getInitMethodName());</span><br><span class="line">      setEnforceInitMethod(otherAbd.isEnforceInitMethod());</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (otherAbd.getDestroyMethodName() != <span class="keyword">null</span>) &#123;</span><br><span class="line">      setDestroyMethodName(otherAbd.getDestroyMethodName());</span><br><span class="line">      setEnforceDestroyMethod(otherAbd.isEnforceDestroyMethod());</span><br><span class="line">    &#125;</span><br><span class="line">    setSynthetic(otherAbd.isSynthetic());</span><br><span class="line">    setResource(otherAbd.getResource());</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">else</span> &#123;</span><br><span class="line">    getConstructorArgumentValues().addArgumentValues(other.getConstructorArgumentValues());</span><br><span class="line">    getPropertyValues().addPropertyValues(other.getPropertyValues());</span><br><span class="line">    setLazyInit(other.isLazyInit());</span><br><span class="line">    setResourceDescription(other.getResourceDescription());</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>要点总结：所谓合并，就是有父子关系的<code>BeanDefinition</code>的合并，将他们合并为一个<code>BeanDefinition</code>，合并逻辑是：用子<code>BeanDefinition</code>覆盖父<code>BeanDefinition</code>，最终结果用<code>RootBeanDefinition</code>表示。</p>
<h3 id="自动注入"><a href="#自动注入" class="headerlink" title="自动注入"></a>自动注入</h3><blockquote>
<p>自动注入这块的代码实在太多，这里分成几个部分分别来说</p>
</blockquote>
<p>到现在为止，我们还没看到自动注入，<code>BeanPostProcessor</code>等的执行逻辑，它们都在<code>org.springframework.beans.factory.support.AbstractAutowireCapableBeanFactory#createBean(java.lang.String, org.springframework.beans.factory.support.RootBeanDefinition, java.lang.Object[])</code>中，前文创建Bean的源码有调用它</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> Object <span class="title">createBean</span><span class="params">(String beanName, RootBeanDefinition mbd, <span class="meta">@Nullable</span> Object[] args)</span> <span class="keyword">throws</span> BeanCreationException </span>&#123;</span><br><span class="line">  RootBeanDefinition mbdToUse = mbd;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Make sure bean class is actually resolved at this point, and</span></span><br><span class="line">  <span class="comment">// clone the bean definition in case of a dynamically resolved Class</span></span><br><span class="line">  <span class="comment">// which cannot be stored in the shared merged bean definition.</span></span><br><span class="line">  Class&lt;?&gt; resolvedClass = resolveBeanClass(mbd, beanName);</span><br><span class="line">  <span class="keyword">if</span> (resolvedClass != <span class="keyword">null</span> &amp;&amp; !mbd.hasBeanClass() &amp;&amp; mbd.getBeanClassName() != <span class="keyword">null</span>) &#123;</span><br><span class="line">    mbdToUse = <span class="keyword">new</span> RootBeanDefinition(mbd);</span><br><span class="line">    mbdToUse.setBeanClass(resolvedClass);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Prepare method overrides.</span></span><br><span class="line">  <span class="comment">// 不用管</span></span><br><span class="line">  mbdToUse.prepareMethodOverrides();</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Give BeanPostProcessors a chance to return a proxy instead of the target bean instance.</span></span><br><span class="line">  <span class="comment">// 在某些情况下，获得的Bean可能是一个代理，此时并不需要真正执行Bean的创建逻辑，InstantiationAwareBeanPostProcessor就是用来做这个事的</span></span><br><span class="line">  Object bean = resolveBeforeInstantiation(beanName, mbdToUse);</span><br><span class="line">  <span class="keyword">if</span> (bean != <span class="keyword">null</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> bean;</span><br><span class="line">  &#125;</span><br><span class="line">	<span class="comment">// 如果没有什么额外设置，就真的去创建Bean</span></span><br><span class="line">  Object beanInstance = doCreateBean(beanName, mbdToUse, args);</span><br><span class="line">  <span class="keyword">return</span> beanInstance;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>这里唯一需要注意的点：可以通过<code>InstantiationAwareBeanPostProcessor</code>提供一个代理实例，这为Spy之类的测试功能提供了方便，使得他们可以伪造bean，构建测试环境。</li>
</ul>
<h4 id="创建实例前的操作"><a href="#创建实例前的操作" class="headerlink" title="创建实例前的操作"></a>创建实例前的操作</h4><p>对<code>resolveBeforeInstantiation</code>，有</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> Object <span class="title">resolveBeforeInstantiation</span><span class="params">(String beanName, RootBeanDefinition mbd)</span> </span>&#123;</span><br><span class="line">  Object bean = <span class="keyword">null</span>;</span><br><span class="line">  <span class="keyword">if</span> (!Boolean.FALSE.equals(mbd.beforeInstantiationResolved)) &#123;</span><br><span class="line">    <span class="comment">// Make sure bean class is actually resolved at this point.</span></span><br><span class="line">    <span class="keyword">if</span> (!mbd.isSynthetic() &amp;&amp; hasInstantiationAwareBeanPostProcessors()) &#123;</span><br><span class="line">      <span class="comment">// 确定Bean的类型</span></span><br><span class="line">      Class&lt;?&gt; targetType = determineTargetType(beanName, mbd);</span><br><span class="line">      <span class="keyword">if</span> (targetType != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="comment">// 应用InstantiationAwareBeanPostProcessor，产生的一般都是代理</span></span><br><span class="line">        bean = applyBeanPostProcessorsBeforeInstantiation(targetType, beanName);</span><br><span class="line">        <span class="keyword">if</span> (bean != <span class="keyword">null</span>) &#123;</span><br><span class="line">          <span class="comment">// 如果产生了代理，就当成已经实例化，应用所有后置处理器。注意这里为什么要调用后置处理器，因为上面产生的代理将会直接返回，不会走bean创建逻辑了</span></span><br><span class="line">          bean = applyBeanPostProcessorsAfterInitialization(bean, beanName);</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    mbd.beforeInstantiationResolved = (bean != <span class="keyword">null</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> bean;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 应用InstantiationAwareBeanPostProcessor.postProcessBeforeInstantiation，该接口专门用于实例化之前调用，以便我们能够返回一个目标对象的代理</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> Object <span class="title">applyBeanPostProcessorsBeforeInstantiation</span><span class="params">(Class&lt;?&gt; beanClass, String beanName)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">for</span> (InstantiationAwareBeanPostProcessor bp : getBeanPostProcessorCache().instantiationAware) &#123;</span><br><span class="line">    Object result = bp.postProcessBeforeInstantiation(beanClass, beanName);</span><br><span class="line">    <span class="keyword">if</span> (result != <span class="keyword">null</span>) &#123;</span><br><span class="line">      <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 实例化后调用所有的后置处理器</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> Object <span class="title">applyBeanPostProcessorsAfterInitialization</span><span class="params">(Object existingBean, String beanName)</span> <span class="keyword">throws</span> BeansException </span>&#123;</span><br><span class="line">  Object result = existingBean;</span><br><span class="line">  <span class="keyword">for</span> (BeanPostProcessor processor : getBeanPostProcessors()) &#123;</span><br><span class="line">    Object current = processor.postProcessAfterInitialization(result, beanName);</span><br><span class="line">    <span class="keyword">if</span> (current == <span class="keyword">null</span>) &#123;</span><br><span class="line">      <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">    result = current;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>注意点同上</li>
</ul>
<h4 id="创建实例操作总览"><a href="#创建实例操作总览" class="headerlink" title="创建实例操作总览"></a>创建实例操作总览</h4><p>对创建的实际操作，有</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> Object <span class="title">doCreateBean</span><span class="params">(String beanName, RootBeanDefinition mbd, <span class="meta">@Nullable</span> Object[] args)</span> <span class="keyword">throws</span> BeanCreationException </span>&#123;</span><br><span class="line">  <span class="comment">// Instantiate the bean.</span></span><br><span class="line">  <span class="comment">// 创建的Bean并不是直接以对象的形式存在，而是以BeanWrapper的形式存在的</span></span><br><span class="line">  BeanWrapper instanceWrapper = <span class="keyword">null</span>;</span><br><span class="line">  <span class="keyword">if</span> (mbd.isSingleton()) &#123;</span><br><span class="line">    <span class="comment">// 如果是单例，从缓存中移除BeanWrapper</span></span><br><span class="line">    instanceWrapper = <span class="keyword">this</span>.factoryBeanInstanceCache.remove(beanName);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> (instanceWrapper == <span class="keyword">null</span>) &#123;</span><br><span class="line">    <span class="comment">// 真实创建步骤</span></span><br><span class="line">    instanceWrapper = createBeanInstance(beanName, mbd, args);</span><br><span class="line">  &#125;</span><br><span class="line">  Object bean = instanceWrapper.getWrappedInstance();</span><br><span class="line">  Class&lt;?&gt; beanType = instanceWrapper.getWrappedClass();</span><br><span class="line">  <span class="keyword">if</span> (beanType != NullBean.class) &#123;</span><br><span class="line">    <span class="comment">// 回填最终信息</span></span><br><span class="line">    mbd.resolvedTargetType = beanType;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Allow post-processors to modify the merged bean definition.</span></span><br><span class="line">  <span class="keyword">synchronized</span> (mbd.postProcessingLock) &#123;</span><br><span class="line">    <span class="keyword">if</span> (!mbd.postProcessed) &#123;</span><br><span class="line">      <span class="comment">// 应用所有的MergedBeanDefinitionPostProcessor</span></span><br><span class="line">      applyMergedBeanDefinitionPostProcessors(mbd, beanType, beanName);</span><br><span class="line">      mbd.postProcessed = <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Eagerly cache singletons to be able to resolve circular references</span></span><br><span class="line">  <span class="comment">// even when triggered by lifecycle interfaces like BeanFactoryAware.</span></span><br><span class="line">  <span class="comment">// 提前暴露单例Bean引用，主要为解决循环引用问题</span></span><br><span class="line">  <span class="keyword">boolean</span> earlySingletonExposure = (mbd.isSingleton() &amp;&amp; <span class="keyword">this</span>.allowCircularReferences &amp;&amp; isSingletonCurrentlyInCreation(beanName));</span><br><span class="line">  <span class="keyword">if</span> (earlySingletonExposure) &#123;</span><br><span class="line">    addSingletonFactory(beanName, () -&gt; getEarlyBeanReference(beanName, mbd, bean));</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Initialize the bean instance.</span></span><br><span class="line">  Object exposedObject = bean;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 执行Bean注入</span></span><br><span class="line">  populateBean(beanName, mbd, instanceWrapper);</span><br><span class="line">  <span class="comment">// 初始化Bean</span></span><br><span class="line">  exposedObject = initializeBean(beanName, exposedObject, mbd);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (earlySingletonExposure) &#123;</span><br><span class="line">    <span class="comment">// 循环依赖检查：正常来说，提前暴露那个对象，和初始化后的bean对象，应该是一个，否则就说明出现了问题</span></span><br><span class="line">    Object earlySingletonReference = getSingleton(beanName, <span class="keyword">false</span>);</span><br><span class="line">    <span class="keyword">if</span> (earlySingletonReference != <span class="keyword">null</span>) &#123;</span><br><span class="line">      <span class="keyword">if</span> (exposedObject == bean) &#123;</span><br><span class="line">        exposedObject = earlySingletonReference;</span><br><span class="line">      &#125; <span class="keyword">else</span> <span class="keyword">if</span> (!<span class="keyword">this</span>.allowRawInjectionDespiteWrapping &amp;&amp; hasDependentBean(beanName)) &#123;</span><br><span class="line">        String[] dependentBeans = getDependentBeans(beanName);</span><br><span class="line">        Set&lt;String&gt; actualDependentBeans = <span class="keyword">new</span> LinkedHashSet&lt;&gt;(dependentBeans.length);</span><br><span class="line">        <span class="keyword">for</span> (String dependentBean : dependentBeans) &#123;</span><br><span class="line">          <span class="keyword">if</span> (!removeSingletonIfCreatedForTypeCheckOnly(dependentBean)) &#123;</span><br><span class="line">            actualDependentBeans.add(dependentBean);</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (!actualDependentBeans.isEmpty()) &#123;</span><br><span class="line">          <span class="keyword">throw</span> ... ...</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Register bean as disposable.</span></span><br><span class="line">  <span class="comment">// 将该bean注册到对应Scope的销毁回调上</span></span><br><span class="line">  registerDisposableBeanIfNecessary(beanName, bean, mbd);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> exposedObject;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>注意点1：创建Bean的步骤：创建、执行注入、执行初始化操作</li>
<li>注意点2：循环引用的解决方式</li>
</ul>
<h5 id="循环引用的解决方式"><a href="#循环引用的解决方式" class="headerlink" title="循环引用的解决方式"></a>循环引用的解决方式</h5><p>需要注意的是，这里有两种循环引用的方式</p>
<ul>
<li><p><code>Scope</code>为单例时，则如”创建实例操作总览“中的代码那样，确切来说，应该这么梳理</p>
<p>首先，Spring维护三个有关单例缓存</p>
<ul>
<li><code>singletonObjects</code>：用于维护已经创建好的单例对象</li>
<li><code>earlySingletonObjects</code>：用于维护创建了但尚未执行自动注入和初始化的单例对象</li>
<li><code>singletonFactories</code>：用于维护单例对象产生的工厂实例</li>
</ul>
<p>然后来看注入的具体方法，比如按照name注入，它还是调用了<code>getBean</code>方法获取Bean，其中会调用<code>getSingleton</code>方法获取实例对象</p>
<ul>
<li>先从<code>singletonObjects</code>中获取已经创建好的单例对象</li>
<li>再尝试从<code>earlySingletonObjects</code>中获取创建到一般的单例对象</li>
<li>再尝试用对应的<code>singletonFactories</code>创建出一个单例对象，注意该对象会加入<code>earlySingletonObjects</code>，所以其实为了理解方便，<code>singletonFactories</code>您可以暂时忽略</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> Object <span class="title">getSingleton</span><span class="params">(String beanName, <span class="keyword">boolean</span> allowEarlyReference)</span> </span>&#123;</span><br><span class="line">  <span class="comment">// 已经简化成这样</span></span><br><span class="line">  singletonObject = <span class="keyword">this</span>.singletonObjects.get(beanName);</span><br><span class="line">  <span class="keyword">if</span> (singletonObject == <span class="keyword">null</span>) &#123;</span><br><span class="line">    singletonObject = <span class="keyword">this</span>.earlySingletonObjects.get(beanName);</span><br><span class="line">    <span class="keyword">if</span> (singletonObject == <span class="keyword">null</span>) &#123;</span><br><span class="line">      ObjectFactory&lt;?&gt; singletonFactory = <span class="keyword">this</span>.singletonFactories.get(beanName);</span><br><span class="line">      <span class="keyword">if</span> (singletonFactory != <span class="keyword">null</span>) &#123;</span><br><span class="line">        singletonObject = singletonFactory.getObject();</span><br><span class="line">        <span class="keyword">this</span>.earlySingletonObjects.put(beanName, singletonObject);</span><br><span class="line">        <span class="keyword">this</span>.singletonFactories.remove(beanName);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> singletonObject;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>然后再看创建Bean时干了什么（截取前文的代码）：增加了一个<code>singletonFactory</code>，结合前面的分析，其实就是把刚创建但还没有注入属性和初始化的bean放在了<code>earlySingletonObjects</code>中，使得如果有循环依赖时能够直接获取到该bean。避免死循环。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (earlySingletonExposure) &#123;</span><br><span class="line">  <span class="comment">// getEarlyBeanReference方法，其实就是直接将传入的bean传回来了</span></span><br><span class="line">  addSingletonFactory(beanName, () -&gt; getEarlyBeanReference(beanName, mbd, bean));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>总结来说，这里的重点是将bean的创建和初始化（包括注入）分开进行，保有一个半初始化的状态，使得能够注入半初始化状态的Bean。</p>
<p><strong>但是，这是setter注入时才可以这么做，构造器注入又当如何呢？</strong>事实上，因为构造器注入时，当前对象尚未创建完成，没法有一个半初始化状态，因此构造器注入不允许循环依赖。</p>
</li>
<li><p><code>Scope</code>为原型时，参考<code>AbstractBeanFactory.doCreate.273行</code>，这里有检查当前线程下同名的原型Bean是否正在创建。Spring是一个同步框架，在创建原型Bean时，同一个线程不可能同时创建两个原型Bean，那么很明显了，就如注释所说，这里是不允许原型Bean循环引用。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Fail if we&#x27;re already creating this bean instance:</span></span><br><span class="line"><span class="comment">// We&#x27;re assumably within a circular reference.</span></span><br><span class="line"><span class="keyword">if</span> (isPrototypeCurrentlyInCreation(beanName)) &#123;</span><br><span class="line">  <span class="keyword">throw</span> <span class="keyword">new</span> BeanCurrentlyInCreationException(beanName);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>为什么原型时不支持循环依赖？因为Spring不会缓存任何有关原型的状态，虽然它也能有中间状态，但Spring并不缓存它，这是一个技术上可以实现，但Spring的设计思想上不允许存在的场景：所谓原型，每次获取Bean都要创建一个新的，那么当循环依赖时，应该获得的是一个与”我“完全不同的Bean。</p>
</li>
</ul>
<h4 id="BeanWrapper是什么"><a href="#BeanWrapper是什么" class="headerlink" title="BeanWrapper是什么"></a>BeanWrapper是什么</h4><p>该类不是给我们直接使用的，而是在容器内部流通。用于提供实际Bean实例的分析和操作，如针对属性的操作、查询等。它常用的只有一个实现类<code>BeanWrapperImpl</code>。了解它有助于源码的查看，这里我们简要看一下接口定义</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">BeanWrapper</span> <span class="keyword">extends</span> <span class="title">ConfigurablePropertyAccessor</span> </span>&#123;</span><br><span class="line">	<span class="comment">// 获取真实的Bean实例</span></span><br><span class="line">	<span class="function">Object <span class="title">getWrappedInstance</span><span class="params">()</span></span>;</span><br><span class="line">	<span class="comment">// 获取真实的Bean类</span></span><br><span class="line">	Class&lt;?&gt; getWrappedClass();</span><br><span class="line">	<span class="comment">// 获取所有实例的属性描述符</span></span><br><span class="line">	PropertyDescriptor[] getPropertyDescriptors();</span><br><span class="line">	<span class="comment">// 获取指定属性的属性描述符</span></span><br><span class="line">	<span class="function">PropertyDescriptor <span class="title">getPropertyDescriptor</span><span class="params">(String propertyName)</span> <span class="keyword">throws</span> InvalidPropertyException</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="创建实例的确切操作"><a href="#创建实例的确切操作" class="headerlink" title="创建实例的确切操作"></a>创建实例的确切操作</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> BeanWrapper <span class="title">createBeanInstance</span><span class="params">(String beanName, RootBeanDefinition mbd, <span class="meta">@Nullable</span> Object[] args)</span> </span>&#123;</span><br><span class="line">  <span class="comment">// Make sure bean class is actually resolved at this point.</span></span><br><span class="line">  <span class="comment">// 解析真实的bean类对象</span></span><br><span class="line">  Class&lt;?&gt; beanClass = resolveBeanClass(mbd, beanName);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 如果BeanDefinitino有提供用于创建实例的Supplier，则直接用它创建。Supplier的应用场景，有待探索</span></span><br><span class="line">  Supplier&lt;?&gt; instanceSupplier = mbd.getInstanceSupplier();</span><br><span class="line">  <span class="keyword">if</span> (instanceSupplier != <span class="keyword">null</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> obtainFromSupplier(instanceSupplier, beanName);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 如果有指定工厂方法，直接通过工厂方法创建</span></span><br><span class="line">  <span class="keyword">if</span> (mbd.getFactoryMethodName() != <span class="keyword">null</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> instantiateUsingFactoryMethod(beanName, mbd, args);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Shortcut when re-creating the same bean...</span></span><br><span class="line">  <span class="keyword">boolean</span> resolved = <span class="keyword">false</span>;</span><br><span class="line">  <span class="keyword">boolean</span> autowireNecessary = <span class="keyword">false</span>;</span><br><span class="line">  <span class="keyword">if</span> (args == <span class="keyword">null</span>) &#123;</span><br><span class="line">    <span class="keyword">synchronized</span> (mbd.constructorArgumentLock) &#123;</span><br><span class="line">      <span class="keyword">if</span> (mbd.resolvedConstructorOrFactoryMethod != <span class="keyword">null</span>) &#123;</span><br><span class="line">        resolved = <span class="keyword">true</span>;</span><br><span class="line">        autowireNecessary = mbd.constructorArgumentsResolved;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 如果BeanDefinition的构造器已经被解析出来了，则直接用他们创建</span></span><br><span class="line">  <span class="keyword">if</span> (resolved) &#123;</span><br><span class="line">    <span class="keyword">if</span> (autowireNecessary) &#123;</span><br><span class="line">      <span class="comment">// 通过构造器创建，并注入构造器参数</span></span><br><span class="line">      <span class="keyword">return</span> autowireConstructor(beanName, mbd, <span class="keyword">null</span>, <span class="keyword">null</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="comment">// 直接使用无参构造器创建</span></span><br><span class="line">      <span class="keyword">return</span> instantiateBean(beanName, mbd);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 如果有SmartInstantiationAwareBeanPostProcessor提供构造器，则使用该构造器创建</span></span><br><span class="line">  Constructor&lt;?&gt;[] ctors = determineConstructorsFromBeanPostProcessors(beanClass, beanName);</span><br><span class="line">  <span class="keyword">if</span> (ctors != <span class="keyword">null</span> || mbd.getResolvedAutowireMode() == AUTOWIRE_CONSTRUCTOR ||</span><br><span class="line">      mbd.hasConstructorArgumentValues() || !ObjectUtils.isEmpty(args)) &#123;</span><br><span class="line">    <span class="keyword">return</span> autowireConstructor(beanName, mbd, ctors, args);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 使用默认构造器创建</span></span><br><span class="line">  ctors = mbd.getPreferredConstructors();</span><br><span class="line">  <span class="keyword">if</span> (ctors != <span class="keyword">null</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> autowireConstructor(beanName, mbd, ctors, <span class="keyword">null</span>);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 直接使用无参构造器创建</span></span><br><span class="line">  <span class="keyword">return</span> instantiateBean(beanName, mbd);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>创建备选方式的顺序<ol>
<li>提前设置的<code>Supplier</code></li>
<li>指定的工厂方法</li>
<li>使用<code>BeanDefinition</code>提前解析好的构造器创建</li>
<li>使用<code>SmartInstantiationAwareBeanPostProcessor</code>提供的构造器创建</li>
<li>使用类自带的有参构造器创建，参数来自容器，自动注入</li>
<li>使用类自带的无参构造器创建</li>
</ol>
</li>
</ul>
<h5 id="按有参构造器注入并创建"><a href="#按有参构造器注入并创建" class="headerlink" title="按有参构造器注入并创建"></a>按有参构造器注入并创建</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> BeanWrapper <span class="title">autowireConstructor</span><span class="params">(String beanName, RootBeanDefinition mbd, <span class="meta">@Nullable</span> Constructor&lt;?&gt;[] chosenCtors, <span class="meta">@Nullable</span> Object[] explicitArgs)</span> </span>&#123;</span><br><span class="line">  BeanWrapperImpl bw = <span class="keyword">new</span> BeanWrapperImpl();</span><br><span class="line">  <span class="comment">// 这里初始化只是注入了类型转换相关内容</span></span><br><span class="line">  <span class="keyword">this</span>.beanFactory.initBeanWrapper(bw);</span><br><span class="line"></span><br><span class="line">  Constructor&lt;?&gt; constructorToUse = <span class="keyword">null</span>;</span><br><span class="line">  ArgumentsHolder argsHolderToUse = <span class="keyword">null</span>;</span><br><span class="line">  Object[] argsToUse = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (explicitArgs != <span class="keyword">null</span>) &#123;</span><br><span class="line">    <span class="comment">// 给了args就直接用</span></span><br><span class="line">    argsToUse = explicitArgs;</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="comment">// 没给args，就从BeanDefinition中找到args拿出来用</span></span><br><span class="line">    Object[] argsToResolve = <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">synchronized</span> (mbd.constructorArgumentLock) &#123;</span><br><span class="line">      constructorToUse = (Constructor&lt;?&gt;) mbd.resolvedConstructorOrFactoryMethod;</span><br><span class="line">      <span class="keyword">if</span> (constructorToUse != <span class="keyword">null</span> &amp;&amp; mbd.constructorArgumentsResolved) &#123;</span><br><span class="line">        <span class="comment">// Found a cached constructor...</span></span><br><span class="line">        argsToUse = mbd.resolvedConstructorArguments;</span><br><span class="line">        <span class="keyword">if</span> (argsToUse == <span class="keyword">null</span>) &#123;</span><br><span class="line">          argsToResolve = mbd.preparedConstructorArguments;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (argsToResolve != <span class="keyword">null</span>) &#123;</span><br><span class="line">      argsToUse = resolvePreparedArguments(beanName, mbd, bw, constructorToUse, argsToResolve);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (constructorToUse == <span class="keyword">null</span> || argsToUse == <span class="keyword">null</span>) &#123;</span><br><span class="line">    <span class="comment">// Take specified constructors, if any.</span></span><br><span class="line">    Constructor&lt;?&gt;[] candidates = chosenCtors;</span><br><span class="line">    <span class="comment">// 获取类的所有构造方法作为候选</span></span><br><span class="line">    <span class="keyword">if</span> (candidates == <span class="keyword">null</span>) &#123;</span><br><span class="line">      Class&lt;?&gt; beanClass = mbd.getBeanClass();</span><br><span class="line">      candidates = (mbd.isNonPublicAccessAllowed() ? beanClass.getDeclaredConstructors() : beanClass.getConstructors());</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 如果对象只有一个无参构造器，则可以直接创建对象，不需要走自动注入</span></span><br><span class="line">    <span class="keyword">if</span> (candidates.length == <span class="number">1</span> &amp;&amp; explicitArgs == <span class="keyword">null</span> &amp;&amp; !mbd.hasConstructorArgumentValues()) &#123;</span><br><span class="line">      Constructor&lt;?&gt; uniqueCandidate = candidates[<span class="number">0</span>];</span><br><span class="line">      <span class="keyword">if</span> (uniqueCandidate.getParameterCount() == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">synchronized</span> (mbd.constructorArgumentLock) &#123;</span><br><span class="line">          mbd.resolvedConstructorOrFactoryMethod = uniqueCandidate;</span><br><span class="line">          mbd.constructorArgumentsResolved = <span class="keyword">true</span>;</span><br><span class="line">          mbd.resolvedConstructorArguments = EMPTY_ARGS;</span><br><span class="line">        &#125;</span><br><span class="line">        bw.setBeanInstance(instantiate(beanName, mbd, uniqueCandidate, EMPTY_ARGS));</span><br><span class="line">        <span class="keyword">return</span> bw;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Need to resolve the constructor.</span></span><br><span class="line">    <span class="comment">// 需要自动注入的判断标准：有构造器，或者BeanDefinition的注入模式为构造器注入</span></span><br><span class="line">    <span class="keyword">boolean</span> autowiring = (chosenCtors != <span class="keyword">null</span> || mbd.getResolvedAutowireMode() == AutowireCapableBeanFactory.AUTOWIRE_CONSTRUCTOR);</span><br><span class="line">    ConstructorArgumentValues resolvedValues = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> minNrOfArgs;</span><br><span class="line">    <span class="keyword">if</span> (explicitArgs != <span class="keyword">null</span>) &#123;</span><br><span class="line">      minNrOfArgs = explicitArgs.length;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      ConstructorArgumentValues cargs = mbd.getConstructorArgumentValues();</span><br><span class="line">      resolvedValues = <span class="keyword">new</span> ConstructorArgumentValues();</span><br><span class="line">      minNrOfArgs = resolveConstructorArguments(beanName, mbd, bw, cargs, resolvedValues);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    AutowireUtils.sortConstructors(candidates);</span><br><span class="line">    <span class="keyword">int</span> minTypeDiffWeight = Integer.MAX_VALUE;</span><br><span class="line">    Set&lt;Constructor&lt;?&gt;&gt; ambiguousConstructors = <span class="keyword">null</span>;</span><br><span class="line">    Deque&lt;UnsatisfiedDependencyException&gt; causes = <span class="keyword">null</span>;</span><br><span class="line">    <span class="comment">// 寻找要用哪个构造器创建Bean</span></span><br><span class="line">    <span class="keyword">for</span> (Constructor&lt;?&gt; candidate : candidates) &#123;</span><br><span class="line">      <span class="keyword">int</span> parameterCount = candidate.getParameterCount();</span><br><span class="line"></span><br><span class="line">      ArgumentsHolder argsHolder;</span><br><span class="line">      Class&lt;?&gt;[] paramTypes = candidate.getParameterTypes();</span><br><span class="line">      <span class="keyword">if</span> (resolvedValues != <span class="keyword">null</span>) &#123;</span><br><span class="line">        String[] paramNames = ConstructorPropertiesChecker.evaluate(candidate, parameterCount);</span><br><span class="line">        <span class="keyword">if</span> (paramNames == <span class="keyword">null</span>) &#123;</span><br><span class="line">          ParameterNameDiscoverer pnd = <span class="keyword">this</span>.beanFactory.getParameterNameDiscoverer();</span><br><span class="line">          <span class="keyword">if</span> (pnd != <span class="keyword">null</span>) &#123;</span><br><span class="line">            paramNames = pnd.getParameterNames(candidate);</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 这里在容器中寻找符合要求的bean，构建出符合要求的参数，以便在后面使用</span></span><br><span class="line">        argsHolder = createArgumentArray(beanName, mbd, resolvedValues, bw, paramTypes, paramNames, getUserDeclaredConstructor(candidate), autowiring, candidates.length == <span class="number">1</span>);</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// Explicit arguments given -&gt; arguments length must match exactly.</span></span><br><span class="line">        <span class="keyword">if</span> (parameterCount != explicitArgs.length) &#123;</span><br><span class="line">          <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        argsHolder = <span class="keyword">new</span> ArgumentsHolder(explicitArgs);</span><br><span class="line">      &#125;</span><br><span class="line">			<span class="comment">// 权重计算规则：将给的参数类型和实际构造器对应位置的参数进行类型对比，越符合得分越高。</span></span><br><span class="line">      <span class="keyword">int</span> typeDiffWeight = (mbd.isLenientConstructorResolution() ?  argsHolder.getTypeDifferenceWeight(paramTypes) : argsHolder.getAssignabilityWeight(paramTypes));</span><br><span class="line">      <span class="comment">// Choose this constructor if it represents the closest match.</span></span><br><span class="line">      <span class="comment">// 冒泡法找出最符合要求那个，如果两个权重一致，则加入 ”无法区分“ 的列表</span></span><br><span class="line">      <span class="keyword">if</span> (typeDiffWeight &lt; minTypeDiffWeight) &#123;</span><br><span class="line">        constructorToUse = candidate;</span><br><span class="line">        argsHolderToUse = argsHolder;</span><br><span class="line">        argsToUse = argsHolder.arguments;</span><br><span class="line">        minTypeDiffWeight = typeDiffWeight;</span><br><span class="line">        ambiguousConstructors = <span class="keyword">null</span>;</span><br><span class="line">      &#125; <span class="keyword">else</span> <span class="keyword">if</span> (constructorToUse != <span class="keyword">null</span> &amp;&amp; typeDiffWeight == minTypeDiffWeight) &#123;</span><br><span class="line">        <span class="keyword">if</span> (ambiguousConstructors == <span class="keyword">null</span>) &#123;</span><br><span class="line">          ambiguousConstructors = <span class="keyword">new</span> LinkedHashSet&lt;&gt;();</span><br><span class="line">          ambiguousConstructors.add(constructorToUse);</span><br><span class="line">        &#125;</span><br><span class="line">        ambiguousConstructors.add(candidate);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 最终没有构造器被选中，报错</span></span><br><span class="line">    <span class="keyword">if</span> (constructorToUse == <span class="keyword">null</span>) &#123;</span><br><span class="line">      <span class="keyword">throw</span> <span class="keyword">new</span> BeanCreationException(......);</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (ambiguousConstructors != <span class="keyword">null</span> &amp;&amp; !mbd.isLenientConstructorResolution()) &#123;</span><br><span class="line">      <span class="comment">// 最终有多个构造器符合条件，无法区分用哪个，也报错</span></span><br><span class="line">      <span class="keyword">throw</span> <span class="keyword">new</span> BeanCreationException(......);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  Assert.state(argsToUse != <span class="keyword">null</span>, <span class="string">&quot;Unresolved constructor arguments&quot;</span>);</span><br><span class="line">  <span class="comment">// 利用反射创建Bean实例</span></span><br><span class="line">  bw.setBeanInstance(instantiate(beanName, mbd, constructorToUse, argsToUse));</span><br><span class="line">  <span class="keyword">return</span> bw;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>Spring会先从容器中找出满足类型要求的参数组合，然后找出与这些参数类型最为匹配的构造器，用以创建实例</li>
<li>可以想见，只要有精确类型的bean被创建，就一定能够实例化成功，因为不可能有完全一样参数类型的构造器嘛</li>
</ul>
<h5 id="使用无参构造器创建"><a href="#使用无参构造器创建" class="headerlink" title="使用无参构造器创建"></a>使用无参构造器创建</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> BeanWrapper <span class="title">instantiateBean</span><span class="params">(String beanName, RootBeanDefinition mbd)</span> </span>&#123;</span><br><span class="line">  <span class="comment">// 这里不用再追进去看了，它就是获取了类的无参构造方法，然后通过反射实例化</span></span><br><span class="line">  Object beanInstance = getInstantiationStrategy().instantiate(mbd, beanName, <span class="keyword">this</span>);</span><br><span class="line">  <span class="comment">// 包装成BeanWrapper</span></span><br><span class="line">  BeanWrapper bw = <span class="keyword">new</span> BeanWrapperImpl(beanInstance);</span><br><span class="line">  initBeanWrapper(bw);</span><br><span class="line">  <span class="keyword">return</span> bw;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="自动注入逻辑的执行"><a href="#自动注入逻辑的执行" class="headerlink" title="自动注入逻辑的执行"></a>自动注入逻辑的执行</h4><p>对自动注入的逻辑，即<code>populateBean()</code>，有</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 执行Bean注入</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">populateBean</span><span class="params">(String beanName, RootBeanDefinition mbd, <span class="meta">@Nullable</span> BeanWrapper bw)</span> </span>&#123;</span><br><span class="line">  <span class="comment">// Give any InstantiationAwareBeanPostProcessors the opportunity to modify the</span></span><br><span class="line">  <span class="comment">// state of the bean before properties are set. This can be used, for example,</span></span><br><span class="line">  <span class="comment">// to support styles of field injection.</span></span><br><span class="line">  <span class="keyword">if</span> (!mbd.isSynthetic() &amp;&amp; hasInstantiationAwareBeanPostProcessors()) &#123;</span><br><span class="line">    <span class="comment">// 应用InstantiationAwareBeanPostProcessor，在实例刚刚创建后，属性被设置之前执行</span></span><br><span class="line">    <span class="keyword">for</span> (InstantiationAwareBeanPostProcessor bp : getBeanPostProcessorCache().instantiationAware) &#123;</span><br><span class="line">      <span class="keyword">if</span> (!bp.postProcessAfterInstantiation(bw.getWrappedInstance(), beanName)) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  PropertyValues pvs = (mbd.hasPropertyValues() ? mbd.getPropertyValues() : <span class="keyword">null</span>);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 自定注入模式：自动检测、按名字、按类型；</span></span><br><span class="line">  <span class="keyword">int</span> resolvedAutowireMode = mbd.getResolvedAutowireMode();</span><br><span class="line">  <span class="keyword">if</span> (resolvedAutowireMode == AUTOWIRE_BY_NAME || resolvedAutowireMode == AUTOWIRE_BY_TYPE) &#123;</span><br><span class="line">    MutablePropertyValues newPvs = <span class="keyword">new</span> MutablePropertyValues(pvs);</span><br><span class="line">    <span class="comment">// Add property values based on autowire by name if applicable.</span></span><br><span class="line">    <span class="keyword">if</span> (resolvedAutowireMode == AUTOWIRE_BY_NAME) &#123;</span><br><span class="line">      <span class="comment">// 按名称注入</span></span><br><span class="line">      autowireByName(beanName, mbd, bw, newPvs);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// Add property values based on autowire by type if applicable.</span></span><br><span class="line">    <span class="keyword">if</span> (resolvedAutowireMode == AUTOWIRE_BY_TYPE) &#123;</span><br><span class="line">      <span class="comment">// 按类型注入</span></span><br><span class="line">      autowireByType(beanName, mbd, bw, newPvs);</span><br><span class="line">    &#125;</span><br><span class="line">    pvs = newPvs;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">boolean</span> hasInstAwareBpps = hasInstantiationAwareBeanPostProcessors();</span><br><span class="line">  <span class="keyword">boolean</span> needsDepCheck = (mbd.getDependencyCheck() != AbstractBeanDefinition.DEPENDENCY_CHECK_NONE);</span><br><span class="line"></span><br><span class="line">  PropertyDescriptor[] filteredPds = <span class="keyword">null</span>;</span><br><span class="line">  <span class="keyword">if</span> (hasInstAwareBpps) &#123;</span><br><span class="line">    <span class="keyword">if</span> (pvs == <span class="keyword">null</span>) &#123;</span><br><span class="line">      pvs = mbd.getPropertyValues();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 应用InstantiationAwareBeanPostProcessor.postProcessProperties和postProcessPropertyValues方法</span></span><br><span class="line">    <span class="keyword">for</span> (InstantiationAwareBeanPostProcessor bp : getBeanPostProcessorCache().instantiationAware) &#123;</span><br><span class="line">      PropertyValues pvsToUse = bp.postProcessProperties(pvs, bw.getWrappedInstance(), beanName);</span><br><span class="line">      <span class="keyword">if</span> (pvsToUse == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (filteredPds == <span class="keyword">null</span>) &#123;</span><br><span class="line">          filteredPds = filterPropertyDescriptorsForDependencyCheck(bw, mbd.allowCaching);</span><br><span class="line">        &#125;</span><br><span class="line">        pvsToUse = bp.postProcessPropertyValues(pvs, filteredPds, bw.getWrappedInstance(), beanName);</span><br><span class="line">        <span class="keyword">if</span> (pvsToUse == <span class="keyword">null</span>) &#123;</span><br><span class="line">          <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">      pvs = pvsToUse;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> (needsDepCheck) &#123;</span><br><span class="line">    <span class="keyword">if</span> (filteredPds == <span class="keyword">null</span>) &#123;</span><br><span class="line">      filteredPds = filterPropertyDescriptorsForDependencyCheck(bw, mbd.allowCaching);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 依赖检查：检查是否所有需要的属性都已被设置</span></span><br><span class="line">    checkDependencies(beanName, mbd, filteredPds, pvs);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> (pvs != <span class="keyword">null</span>) &#123;</span><br><span class="line">    <span class="comment">// 真正地去应用这些属性</span></span><br><span class="line">    applyPropertyValues(beanName, mbd, bw, pvs);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 按照名称注入，就是从容器中找出指定名称的bean，然后加到暂存的属性集中，以便后面使用</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">autowireByName</span><span class="params">(String beanName, AbstractBeanDefinition mbd, BeanWrapper bw, MutablePropertyValues pvs)</span> </span>&#123;</span><br><span class="line">  String[] propertyNames = unsatisfiedNonSimpleProperties(mbd, bw);</span><br><span class="line">  <span class="keyword">for</span> (String propertyName : propertyNames) &#123;</span><br><span class="line">    <span class="keyword">if</span> (containsBean(propertyName)) &#123;</span><br><span class="line">      <span class="comment">// 获取指定名称的Bean</span></span><br><span class="line">      Object bean = getBean(propertyName);</span><br><span class="line">      pvs.add(propertyName, bean);</span><br><span class="line">      <span class="comment">// 注册Bean依赖缓存</span></span><br><span class="line">      registerDependentBean(propertyName, beanName);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 按类型注入，稍微复杂一点，大致就是从容器找出符合类型的所有bean，再按照一定规则得到确切的那个</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">autowireByType</span><span class="params">(String beanName, AbstractBeanDefinition mbd, BeanWrapper bw, MutablePropertyValues pvs)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  TypeConverter converter = getCustomTypeConverter();</span><br><span class="line">  <span class="keyword">if</span> (converter == <span class="keyword">null</span>) &#123;</span><br><span class="line">    converter = bw;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  Set&lt;String&gt; autowiredBeanNames = <span class="keyword">new</span> LinkedHashSet&lt;&gt;(<span class="number">4</span>);</span><br><span class="line">  String[] propertyNames = unsatisfiedNonSimpleProperties(mbd, bw);</span><br><span class="line">  <span class="keyword">for</span> (String propertyName : propertyNames) &#123;</span><br><span class="line">    PropertyDescriptor pd = bw.getPropertyDescriptor(propertyName);</span><br><span class="line">    <span class="comment">// Don&#x27;t try autowiring by type for type Object: never makes sense,</span></span><br><span class="line">    <span class="comment">// even if it technically is a unsatisfied, non-simple property.</span></span><br><span class="line">    <span class="keyword">if</span> (Object.class != pd.getPropertyType()) &#123;</span><br><span class="line">      <span class="comment">// 获取属性的set方法</span></span><br><span class="line">      MethodParameter methodParam = BeanUtils.getWriteMethodParameter(pd);</span><br><span class="line">      <span class="comment">// Do not allow eager init for type matching in case of a prioritized post-processor.</span></span><br><span class="line">      <span class="keyword">boolean</span> eager = !(bw.getWrappedInstance() <span class="keyword">instanceof</span> PriorityOrdered);</span><br><span class="line">      DependencyDescriptor desc = <span class="keyword">new</span> AutowireByTypeDependencyDescriptor(methodParam, eager);</span><br><span class="line">      Object autowiredArgument = resolveDependency(desc, beanName, autowiredBeanNames, converter);</span><br><span class="line">      <span class="keyword">if</span> (autowiredArgument != <span class="keyword">null</span>) &#123;</span><br><span class="line">        pvs.add(propertyName, autowiredArgument);</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">for</span> (String autowiredBeanName : autowiredBeanNames) &#123;</span><br><span class="line">        <span class="comment">// 注册Bean依赖缓存</span></span><br><span class="line">        registerDependentBean(autowiredBeanName, beanName);</span><br><span class="line">      &#125;</span><br><span class="line">      autowiredBeanNames.clear();</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="实例初始化的操作"><a href="#实例初始化的操作" class="headerlink" title="实例初始化的操作"></a>实例初始化的操作</h4><p>对初始化的逻辑有</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 初始化Bean</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> Object <span class="title">initializeBean</span><span class="params">(String beanName, Object bean, <span class="meta">@Nullable</span> RootBeanDefinition mbd)</span> </span>&#123;</span><br><span class="line">  <span class="comment">// 调用xxxAware，注入对应内容，这里管的有：BeanNameAware、BeanClassLoaderAware、BeanFactoryAware三个</span></span><br><span class="line">  invokeAwareMethods(beanName, bean);</span><br><span class="line">  Object wrappedBean = bean;</span><br><span class="line">  <span class="keyword">if</span> (mbd == <span class="keyword">null</span> || !mbd.isSynthetic()) &#123;</span><br><span class="line">    <span class="comment">// 应用所有的BeanPostProcessor.postProcessBeforeInitialization方法</span></span><br><span class="line">    wrappedBean = applyBeanPostProcessorsBeforeInitialization(wrappedBean, beanName);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 调用初始化方法，这里管的有：InitializingBean.afterPropertiesSet、自定义的init方法</span></span><br><span class="line">  invokeInitMethods(beanName, wrappedBean, mbd);</span><br><span class="line">  <span class="keyword">if</span> (mbd == <span class="keyword">null</span> || !mbd.isSynthetic()) &#123;</span><br><span class="line">    <span class="comment">// 应用所有BeanPostProcessor.postProcessAfterInitialization方法</span></span><br><span class="line">    wrappedBean = applyBeanPostProcessorsAfterInitialization(wrappedBean, beanName);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> wrappedBean;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>实例化包含内容<ul>
<li><code>BeanxxxAware</code>接口的调用</li>
<li><code>BeanPostProcessor.postProcessBeforeInitialization</code>的调用</li>
<li><code>InitializingBean.afterPropertiesSet</code>的调用</li>
<li>自定义初始化方法的调用</li>
<li><code>BeanPostProcessor.postProcessAfterInitialization</code>的调用</li>
</ul>
</li>
</ul>
<h4 id="根据依赖类型得到依赖实例的操作"><a href="#根据依赖类型得到依赖实例的操作" class="headerlink" title="根据依赖类型得到依赖实例的操作"></a>根据依赖类型得到依赖实例的操作</h4><p>在执行自动注入逻辑时，有用到如下方法，我们一起来看看它干了什么：<code>org.springframework.beans.factory.config.AutowireCapableBeanFactory#resolveDependency(org.springframework.beans.factory.config.DependencyDescriptor, java.lang.String, java.util.Set&lt;java.lang.String&gt;, org.springframework.beans.TypeConverter)</code></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br></pre></td><td class="code"><pre><span class="line">javaxInjectProviderClass = ClassUtils.forName(<span class="string">&quot;javax.inject.Provider&quot;</span>, DefaultListableBeanFactory.class.getClassLoader());</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 在当前容器下，解析指定的依赖所对应的Bean</span></span><br><span class="line"><span class="comment"> * desciptor: 依赖描述类，该依赖可以是字段、方法、构造器依赖，该描述类包含了这些参数信息</span></span><br><span class="line"><span class="comment"> * requestingBeanName: 声明该依赖的bean名称</span></span><br><span class="line"><span class="comment"> * autowiredBeanNames: 一个放结果的地方，用来存找到的依赖的bean名称</span></span><br><span class="line"><span class="comment"> * typeConverter: 需要用到的类型转换器</span></span><br><span class="line"><span class="comment"> * 返回值：返回依赖的Bean</span></span><br><span class="line"><span class="comment"> **/</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> Object <span class="title">resolveDependency</span><span class="params">(DependencyDescriptor descriptor, <span class="meta">@Nullable</span> String requestingBeanName, <span class="meta">@Nullable</span> Set&lt;String&gt; autowiredBeanNames, <span class="meta">@Nullable</span> TypeConverter typeConverter)</span> <span class="keyword">throws</span> BeansException </span>&#123;</span><br><span class="line">  <span class="comment">// 初始化参数名搜索器</span></span><br><span class="line">  descriptor.initParameterNameDiscovery(getParameterNameDiscoverer());</span><br><span class="line">  <span class="keyword">if</span> (Optional.class == descriptor.getDependencyType()) &#123;</span><br><span class="line">    <span class="comment">// 如果依赖的类型是Optional的，则按照对应逻辑创建</span></span><br><span class="line">    <span class="keyword">return</span> createOptionalDependency(descriptor, requestingBeanName);</span><br><span class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span> (ObjectFactory.class == descriptor.getDependencyType() || ObjectProvider.class == descriptor.getDependencyType()) &#123;</span><br><span class="line">    <span class="comment">// 如果依赖的类型是工厂或Provider（也是工厂的一种），则返回DependencyObjectProvider</span></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> DependencyObjectProvider(descriptor, requestingBeanName);</span><br><span class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span> (javaxInjectProviderClass == descriptor.getDependencyType()) &#123;</span><br><span class="line">    <span class="comment">// 如果依赖的类型是javax.inject.Provider，则按照JSR330解析</span></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> Jsr330Factory().createDependencyProvider(descriptor, requestingBeanName);</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="comment">// 如果支持延迟创建，则解析结果是一个代理</span></span><br><span class="line">    Object result = getAutowireCandidateResolver().getLazyResolutionProxyIfNecessary(descriptor, requestingBeanName);</span><br><span class="line">    <span class="keyword">if</span> (result == <span class="keyword">null</span>) &#123;</span><br><span class="line">      <span class="comment">// 这才是真正的创建</span></span><br><span class="line">      result = doResolveDependency(descriptor, requestingBeanName, autowiredBeanNames, typeConverter);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> Object <span class="title">doResolveDependency</span><span class="params">(DependencyDescriptor descriptor, <span class="meta">@Nullable</span> String beanName, <span class="meta">@Nullable</span> Set&lt;String&gt; autowiredBeanNames, <span class="meta">@Nullable</span> TypeConverter typeConverter)</span> <span class="keyword">throws</span> BeansException </span>&#123;</span><br><span class="line">  <span class="comment">// 获取该依赖的类型</span></span><br><span class="line">  Class&lt;?&gt; type = descriptor.getDependencyType();</span><br><span class="line">  <span class="comment">// 获取用户设置注入时显式指定的值，比如@Qualifier中的值，这里的suggest是用户建议的意思，并非自动推算出来的</span></span><br><span class="line">  Object value = getAutowireCandidateResolver().getSuggestedValue(descriptor);</span><br><span class="line">  <span class="keyword">if</span> (value != <span class="keyword">null</span>) &#123;</span><br><span class="line">    <span class="comment">// 如果建议值为字符串，则解析该字符串，并从容器中获取解析后对应的name的容器</span></span><br><span class="line">    <span class="keyword">if</span> (value <span class="keyword">instanceof</span> String) &#123;</span><br><span class="line">      <span class="comment">// 解析字符串，这意味着该字符串可以是SPEL表达式</span></span><br><span class="line">      String strVal = resolveEmbeddedValue((String) value);</span><br><span class="line">      BeanDefinition bd = (beanName != <span class="keyword">null</span> &amp;&amp; containsBean(beanName) ? getMergedBeanDefinition(beanName) : <span class="keyword">null</span>);</span><br><span class="line">      <span class="comment">// 获取最终值，这里的BeanDefinition传进去只是为了获取scope值</span></span><br><span class="line">      value = evaluateBeanDefinitionString(strVal, bd);</span><br><span class="line">    &#125;</span><br><span class="line">    TypeConverter converter = (typeConverter != <span class="keyword">null</span> ? typeConverter : getTypeConverter());</span><br><span class="line">    <span class="comment">// 类型转换</span></span><br><span class="line">    <span class="keyword">return</span> converter.convertIfNecessary(value, type, descriptor.getTypeDescriptor());</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 尝试将Bean当做集合类型取解析</span></span><br><span class="line">  Object multipleBeans = resolveMultipleBeans(descriptor, beanName, autowiredBeanNames, typeConverter);</span><br><span class="line">  <span class="keyword">if</span> (multipleBeans != <span class="keyword">null</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> multipleBeans;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 从整个容器中获取符合要求的bean</span></span><br><span class="line">  Map&lt;String, Object&gt; matchingBeans = findAutowireCandidates(beanName, type, descriptor);</span><br><span class="line">  <span class="keyword">if</span> (matchingBeans.isEmpty()) &#123;</span><br><span class="line">    <span class="keyword">if</span> (isRequired(descriptor)) &#123;</span><br><span class="line">      raiseNoMatchingBeanFound(type, descriptor.getResolvableType(), descriptor);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 还是找不到，就是null</span></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  String autowiredBeanName;</span><br><span class="line">  Object instanceCandidate;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 如果匹配到的bean个数大于1，则需要做一个挑选</span></span><br><span class="line">  <span class="keyword">if</span> (matchingBeans.size() &gt; <span class="number">1</span>) &#123;</span><br><span class="line">    <span class="comment">// 首先根据Primary进行挑选，然后根据Priority进行排序挑选，最后根据找到的name和依赖的name是否一致进行挑选</span></span><br><span class="line">    autowiredBeanName = determineAutowireCandidate(matchingBeans, descriptor);</span><br><span class="line">    <span class="comment">// 当没有Primary，又没有实现Priority，名字又不匹配时，就可能找不到</span></span><br><span class="line">    <span class="keyword">if</span> (autowiredBeanName == <span class="keyword">null</span>) &#123;</span><br><span class="line">      <span class="keyword">if</span> (isRequired(descriptor) || !indicatesMultipleBeans(type)) &#123;</span><br><span class="line">        <span class="comment">// 有可能描述符有自己定义的应办法</span></span><br><span class="line">        <span class="keyword">return</span> descriptor.resolveNotUnique(descriptor.getResolvableType(), matchingBeans);</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// In case of an optional Collection/Map, silently ignore a non-unique case:</span></span><br><span class="line">        <span class="comment">// possibly it was meant to be an empty collection of multiple regular beans</span></span><br><span class="line">        <span class="comment">// (before 4.3 in particular when we didn&#x27;t even look for collection beans).</span></span><br><span class="line">        <span class="comment">// 描述符都没有，那就诶null</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 这就是匹配到的那个</span></span><br><span class="line">    instanceCandidate = matchingBeans.get(autowiredBeanName);</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="comment">// We have exactly one match.</span></span><br><span class="line">    <span class="comment">// 刚好有一个匹配时，一切都很美好</span></span><br><span class="line">    Map.Entry&lt;String, Object&gt; entry = matchingBeans.entrySet().iterator().next();</span><br><span class="line">    autowiredBeanName = entry.getKey();</span><br><span class="line">    instanceCandidate = entry.getValue();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (autowiredBeanNames != <span class="keyword">null</span>) &#123;</span><br><span class="line">    <span class="comment">// 将找到的bean name放到接收集合中</span></span><br><span class="line">    autowiredBeanNames.add(autowiredBeanName);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> (instanceCandidate <span class="keyword">instanceof</span> Class) &#123;</span><br><span class="line">    <span class="comment">// 解析得到最终的实例</span></span><br><span class="line">    instanceCandidate = descriptor.resolveCandidate(autowiredBeanName, type, <span class="keyword">this</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  Object result = instanceCandidate;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">protected</span> Map&lt;String, Object&gt; <span class="title">findAutowireCandidates</span><span class="params">(<span class="meta">@Nullable</span> String beanName, Class&lt;?&gt; requiredType, DependencyDescriptor descriptor)</span> </span>&#123;</span><br><span class="line">  <span class="comment">// 获取当前容器和所有父容器中指定类型的所有bean名字，作为候选</span></span><br><span class="line">  String[] candidateNames = BeanFactoryUtils.beanNamesForTypeIncludingAncestors(<span class="keyword">this</span>, requiredType, <span class="keyword">true</span>, descriptor.isEager());</span><br><span class="line">  Map&lt;String, Object&gt; result = CollectionUtils.newLinkedHashMap(candidateNames.length);</span><br><span class="line">  <span class="keyword">for</span> (Map.Entry&lt;Class&lt;?&gt;, Object&gt; classObjectEntry : <span class="keyword">this</span>.resolvableDependencies.entrySet()) &#123;</span><br><span class="line">    Class&lt;?&gt; autowiringType = classObjectEntry.getKey();</span><br><span class="line">    <span class="keyword">if</span> (autowiringType.isAssignableFrom(requiredType)) &#123;</span><br><span class="line">      Object autowiringValue = classObjectEntry.getValue();</span><br><span class="line">      autowiringValue = AutowireUtils.resolveAutowiringValue(autowiringValue, requiredType);</span><br><span class="line">      <span class="keyword">if</span> (requiredType.isInstance(autowiringValue)) &#123;</span><br><span class="line">        result.put(ObjectUtils.identityToString(autowiringValue), autowiringValue);</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">for</span> (String candidate : candidateNames) &#123;</span><br><span class="line">    <span class="comment">// 如果这些候选bean开启了自动注入开关</span></span><br><span class="line">    <span class="keyword">if</span> (!isSelfReference(beanName, candidate) &amp;&amp; isAutowireCandidate(candidate, descriptor)) &#123;</span><br><span class="line">      <span class="comment">// 加入候选</span></span><br><span class="line">      addCandidateEntry(result, candidate, descriptor, requiredType);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  ... ...</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">addCandidateEntry</span><span class="params">(Map&lt;String, Object&gt; candidates, String candidateName, DependencyDescriptor descriptor, Class&lt;?&gt; requiredType)</span> </span>&#123;</span><br><span class="line">  <span class="comment">// 下面就是不同类型的描述符的不同解析方式，这里不深究。</span></span><br><span class="line">  <span class="keyword">if</span> (descriptor <span class="keyword">instanceof</span> MultiElementDescriptor) &#123;</span><br><span class="line">    Object beanInstance = descriptor.resolveCandidate(candidateName, requiredType, <span class="keyword">this</span>);</span><br><span class="line">    <span class="keyword">if</span> (!(beanInstance <span class="keyword">instanceof</span> NullBean)) &#123;</span><br><span class="line">      candidates.put(candidateName, beanInstance);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span> (containsSingleton(candidateName) || (descriptor <span class="keyword">instanceof</span> StreamDependencyDescriptor &amp;&amp; ((StreamDependencyDescriptor) descriptor).isOrdered())) &#123;</span><br><span class="line">    Object beanInstance = descriptor.resolveCandidate(candidateName, requiredType, <span class="keyword">this</span>);</span><br><span class="line">    candidates.put(candidateName, (beanInstance <span class="keyword">instanceof</span> NullBean ? <span class="keyword">null</span> : beanInstance));</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    candidates.put(candidateName, getType(candidateName));</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="小结-2"><a href="#小结-2" class="headerlink" title="小结"></a>小结</h3><p>Bean的创建，可说是重中之重，因为它关系到Spring的生命周期，这是面试中超高频率被问到的问题。有了上面的分析，我们可以自己总结一波创建过程会经过哪些关键过程，这其实有两种case</p>
<p><strong>case1</strong></p>
<ol>
<li>首先执行<code>InstantiationAwareBeanPostProcessor.postProcessBeforeInstantiation()</code>提供一个创建代理的机会，如果代理创建成功</li>
<li>执行所有的<code>BeanPostProcessor.postProcessAfterInitialization()</code>方法</li>
<li>对于预加载的单例Bean，还会调用<code>SmartInitializingSingleton.afterSingletonsInstantiated()</code></li>
<li>结束</li>
</ol>
<p><strong>case2</strong></p>
<ol>
<li>实例化Bean<ol>
<li>尝试使用指定的工厂方法创建</li>
<li>尝试使用构造方法创建，如果使用有参构造方法，构造方法的参数会被自动注入</li>
</ol>
</li>
<li>应用<code>InstantiationAwareBeanPostProcessor.postProcessAfterInstantiation()</code></li>
<li>对需要的属性进行自动注入，按名称或类型从容器中寻找符合要求的Bean，注入</li>
<li>调用<code>BeanNameAware、BeanClassLoaderAware、BeanFactoryAware</code></li>
<li>应用<code>BeanPostProcessor.postProcessBeforeInitialization()</code></li>
<li>应用<code>InitializingBean.afterPropertiesSet()</code></li>
<li>应用自定义init方法</li>
<li>应用<code>BeanPostProcessor.postProcessAfterInitialization</code></li>
<li>对于预加载的单例Bean，还会调用<code>SmartInitializingSingleton.afterSingletonsInstantiated()</code></li>
<li>结束</li>
</ol>
<p>注意这里讨论的是Spring中Bean的生命周期，而不是Spring的生命周期，如果是后者，请翻看第一篇文章分析。</p>
<h2 id="如何销毁Bean"><a href="#如何销毁Bean" class="headerlink" title="如何销毁Bean"></a>如何销毁Bean</h2><p>JVM中的对象，通过可达性分析，垃圾回收机制，进行回收；Spring中的Bean对象，总是被容器持有，岂不是永远不可能被垃圾回收？这个想法是正确的，这种设计也是合理的。但要注意到有一个前提：<code>Scope</code>，正因为有它的存在，Bean的生命周期管理才变得方便。</p>
<ul>
<li>对于<code>Scope</code>为单例的Bean，容器全局唯一，被容器引用，当然不会也不能被销毁</li>
<li>对于<code>Scope</code>为原型的Bean，创建完成后容器内部并没有引用，交给应用程序，这和普通new出来的对象一致，是能够被回收的</li>
<li>对于<code>Scope</code>为其它的Bean，则看<code>Scope</code>而定，<code>Scope</code>销毁，Bean对象一并被回收，这种情况没见过；要不然就交给<code>Scope</code>自己处理了，这倒是见过，比如web里面的Request或Session范围的Scope，它是将Bean对象保存在<code>HttpServletRequest</code>或<code>HttpSession</code>中，即生命周期随请求或Session的销毁而结束。</li>
</ul>
<p>我们关注两个点：随容器一起销毁的Bean如何销毁；生命周期不跟随容器的Bean如何销毁</p>
<h3 id="被容器销毁"><a href="#被容器销毁" class="headerlink" title="被容器销毁"></a>被容器销毁</h3><p>容器的销毁方法</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">doClose</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="comment">// Check whether an actual close attempt is necessary...</span></span><br><span class="line">  <span class="keyword">if</span> (<span class="keyword">this</span>.active.get() &amp;&amp; <span class="keyword">this</span>.closed.compareAndSet(<span class="keyword">false</span>, <span class="keyword">true</span>)) &#123;</span><br><span class="line">    <span class="comment">// 发布容器关闭事件</span></span><br><span class="line">    publishEvent(<span class="keyword">new</span> ContextClosedEvent(<span class="keyword">this</span>));</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 调用生命周期处理器的关闭方法.</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">this</span>.lifecycleProcessor != <span class="keyword">null</span>) &#123;</span><br><span class="line">      <span class="keyword">this</span>.lifecycleProcessor.onClose();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 重头戏：销毁Bean</span></span><br><span class="line">    destroyBeans();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Close the state of this context itself.</span></span><br><span class="line">    <span class="comment">// 其实没干啥</span></span><br><span class="line">    closeBeanFactory();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Let subclasses do some final clean-up if they wish...</span></span><br><span class="line">    <span class="comment">// 容器的生命周期方法</span></span><br><span class="line">    onClose();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Switch to inactive.</span></span><br><span class="line">    <span class="keyword">this</span>.active.set(<span class="keyword">false</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">destroyBeans</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  getBeanFactory().destroySingletons();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">destroySingletons</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  String[] disposableBeanNames;</span><br><span class="line">  <span class="keyword">synchronized</span> (<span class="keyword">this</span>.disposableBeans) &#123;</span><br><span class="line">    disposableBeanNames = StringUtils.toStringArray(<span class="keyword">this</span>.disposableBeans.keySet());</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = disposableBeanNames.length - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line">    destroySingleton(disposableBeanNames[i]);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">destroySingleton</span><span class="params">(String beanName)</span> </span>&#123;</span><br><span class="line">  ... ... </span><br><span class="line">  destroyBean(beanName, disposableBean);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">destroyBean</span><span class="params">(String beanName, <span class="meta">@Nullable</span> DisposableBean bean)</span> </span>&#123;</span><br><span class="line">  ... ...</span><br><span class="line">  bean.destroy();</span><br><span class="line">  ... ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>可以看到，容器关闭时，只销毁了单例Bean，调用了两个有关生命周期的方法</p>
<ul>
<li><code>LifyCycle.close()</code></li>
<li><code>DisposableBean.destroy()</code></li>
</ul>
<p>但还有一种Bean的销毁回调没有被我们看到：自定义销毁方法的调用</p>
<h3 id="被JVM销毁"><a href="#被JVM销毁" class="headerlink" title="被JVM销毁"></a>被JVM销毁</h3><p>正如注解方法<code>org.springframework.context.annotation.Bean#destroyMethod</code>上的注释而言，只有生命周期被容器完全控制的Bean才能正常被容器调用各种销毁方法，也就是单例，其它<code>Scope</code>都无法保证。因此类似原型、上面说的Session之类的生命周期方法，都是不能被正常调用的，因为容器管不了他们呀。</p>
<blockquote>
<p>Note: Only invoked on beans whose lifecycle is under the full control of the factory, which is always the case for singletons but not guaranteed for any other scope.</p>
</blockquote>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>这文章写了三天你能信？？？</p>
<p>总结一下，本文从源码的角度，介绍了Spring如何描述Bean，如何在容器创建时扫描Bean，在不同的时机如何创建Bean，Bean的循环依赖的解决方式，自动注入的逻辑，不同<code>Scope</code>的Bean的销毁场景等问题。但已就算是走马观花，不过今后遇到问题时应该很快能够定位问题吧🤔。</p>
<h3 id="命名规则"><a href="#命名规则" class="headerlink" title="命名规则"></a>命名规则</h3><ul>
<li>xxxxProvider：Provider算是策略模式+抽象工厂模式的结合。所谓抽象工厂模式，意味着它封装了创建实例的过程；所谓策略模式，意味着它可以被当做策略传入其它以他为基础的类中。比如<code>ClassPathScanningCandidateComponentProvider</code>之于<code>AnnotationConfigApplicationContext</code>。</li>
</ul>
<h3 id="下一篇写什么"><a href="#下一篇写什么" class="headerlink" title="下一篇写什么"></a>下一篇写什么</h3><p>Spring源码剖析 - 强大的<code>BeanPostProcessor</code></p>

    </div>

    
    
    

      <footer class="post-footer">
          <div class="post-tags">
              <a href="/tags/Spring/" rel="tag"># Spring</a>
          </div>

        


        
    <div class="post-nav">
      <div class="post-nav-item">
    <a href="/2021/11/16/Spring%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90-ApplicationContext/" rel="prev" title="Spring源码解析 - ApplicationContext">
      <i class="fa fa-chevron-left"></i> Spring源码解析 - ApplicationContext
    </a></div>
      <div class="post-nav-item">
    <a href="/2021/11/23/%E5%88%BB%E6%84%8F%E7%BB%83%E4%B9%A0/" rel="next" title="刻意练习">
      刻意练习 <i class="fa fa-chevron-right"></i>
    </a></div>
    </div>
      </footer>
    
  </article>
  
  
  



          </div>
          
    
  <div class="comments">
    <div id="lv-container" data-id="city" data-uid="MTAyMC80NjUyOC8yMzAzOA=="></div>
  </div>
  

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
          <div class="post-toc motion-element"><ol class="nav"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%A6%82%E4%BD%95%E6%8F%8F%E8%BF%B0Bean"><span class="nav-number">1.</span> <span class="nav-text">如何描述Bean</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#AbstractBeanDefinition"><span class="nav-number">1.1.</span> <span class="nav-text">AbstractBeanDefinition</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#RootBeanDefinition"><span class="nav-number">1.2.</span> <span class="nav-text">RootBeanDefinition</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#GenericBeanDefinition"><span class="nav-number">1.3.</span> <span class="nav-text">GenericBeanDefinition</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#AnnotatedBeanDefinition"><span class="nav-number">1.4.</span> <span class="nav-text">AnnotatedBeanDefinition</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#AnnotatedGenericBeanDefinition"><span class="nav-number">1.5.</span> <span class="nav-text">AnnotatedGenericBeanDefinition</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#ScannedGenericBeanDefinition"><span class="nav-number">1.6.</span> <span class="nav-text">ScannedGenericBeanDefinition</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%B0%8F%E7%BB%93"><span class="nav-number">1.7.</span> <span class="nav-text">小结</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Bean%E5%AE%9A%E4%B9%89%E4%BB%8E%E4%BD%95%E8%80%8C%E6%9D%A5"><span class="nav-number">2.</span> <span class="nav-text">Bean定义从何而来</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#AnnotatedBeanDefinitionReader"><span class="nav-number">2.1.</span> <span class="nav-text">AnnotatedBeanDefinitionReader</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#bean%E5%90%8D%E7%A7%B0%E7%94%9F%E6%88%90%E9%80%BB%E8%BE%91"><span class="nav-number">2.1.1.</span> <span class="nav-text">bean名称生成逻辑</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%88%A4%E5%AE%9ABeanDefinition%E6%98%AF%E5%90%A6%E9%9C%80%E8%A6%81%E8%A2%AB%E5%8A%A0%E8%BD%BD"><span class="nav-number">2.1.2.</span> <span class="nav-text">判定BeanDefinition是否需要被加载</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#ClassPathBeanDefinitionScanner"><span class="nav-number">2.2.</span> <span class="nav-text">ClassPathBeanDefinitionScanner</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%B0%8F%E7%BB%93-1"><span class="nav-number">2.3.</span> <span class="nav-text">小结</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%A6%82%E4%BD%95%E5%88%9B%E5%BB%BABean"><span class="nav-number">3.</span> <span class="nav-text">如何创建Bean</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#Bean%E7%9A%84%E5%88%9B%E5%BB%BA%E9%80%BB%E8%BE%91"><span class="nav-number">3.1.</span> <span class="nav-text">Bean的创建逻辑</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#MergedBeanDefinition"><span class="nav-number">3.2.</span> <span class="nav-text">MergedBeanDefinition</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%87%AA%E5%8A%A8%E6%B3%A8%E5%85%A5"><span class="nav-number">3.3.</span> <span class="nav-text">自动注入</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%88%9B%E5%BB%BA%E5%AE%9E%E4%BE%8B%E5%89%8D%E7%9A%84%E6%93%8D%E4%BD%9C"><span class="nav-number">3.3.1.</span> <span class="nav-text">创建实例前的操作</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%88%9B%E5%BB%BA%E5%AE%9E%E4%BE%8B%E6%93%8D%E4%BD%9C%E6%80%BB%E8%A7%88"><span class="nav-number">3.3.2.</span> <span class="nav-text">创建实例操作总览</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#%E5%BE%AA%E7%8E%AF%E5%BC%95%E7%94%A8%E7%9A%84%E8%A7%A3%E5%86%B3%E6%96%B9%E5%BC%8F"><span class="nav-number">3.3.2.1.</span> <span class="nav-text">循环引用的解决方式</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#BeanWrapper%E6%98%AF%E4%BB%80%E4%B9%88"><span class="nav-number">3.3.3.</span> <span class="nav-text">BeanWrapper是什么</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%88%9B%E5%BB%BA%E5%AE%9E%E4%BE%8B%E7%9A%84%E7%A1%AE%E5%88%87%E6%93%8D%E4%BD%9C"><span class="nav-number">3.3.4.</span> <span class="nav-text">创建实例的确切操作</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#%E6%8C%89%E6%9C%89%E5%8F%82%E6%9E%84%E9%80%A0%E5%99%A8%E6%B3%A8%E5%85%A5%E5%B9%B6%E5%88%9B%E5%BB%BA"><span class="nav-number">3.3.4.1.</span> <span class="nav-text">按有参构造器注入并创建</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E4%BD%BF%E7%94%A8%E6%97%A0%E5%8F%82%E6%9E%84%E9%80%A0%E5%99%A8%E5%88%9B%E5%BB%BA"><span class="nav-number">3.3.4.2.</span> <span class="nav-text">使用无参构造器创建</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E8%87%AA%E5%8A%A8%E6%B3%A8%E5%85%A5%E9%80%BB%E8%BE%91%E7%9A%84%E6%89%A7%E8%A1%8C"><span class="nav-number">3.3.5.</span> <span class="nav-text">自动注入逻辑的执行</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%AE%9E%E4%BE%8B%E5%88%9D%E5%A7%8B%E5%8C%96%E7%9A%84%E6%93%8D%E4%BD%9C"><span class="nav-number">3.3.6.</span> <span class="nav-text">实例初始化的操作</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%A0%B9%E6%8D%AE%E4%BE%9D%E8%B5%96%E7%B1%BB%E5%9E%8B%E5%BE%97%E5%88%B0%E4%BE%9D%E8%B5%96%E5%AE%9E%E4%BE%8B%E7%9A%84%E6%93%8D%E4%BD%9C"><span class="nav-number">3.3.7.</span> <span class="nav-text">根据依赖类型得到依赖实例的操作</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%B0%8F%E7%BB%93-2"><span class="nav-number">3.4.</span> <span class="nav-text">小结</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%A6%82%E4%BD%95%E9%94%80%E6%AF%81Bean"><span class="nav-number">4.</span> <span class="nav-text">如何销毁Bean</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%A2%AB%E5%AE%B9%E5%99%A8%E9%94%80%E6%AF%81"><span class="nav-number">4.1.</span> <span class="nav-text">被容器销毁</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%A2%ABJVM%E9%94%80%E6%AF%81"><span class="nav-number">4.2.</span> <span class="nav-text">被JVM销毁</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%80%BB%E7%BB%93"><span class="nav-number">5.</span> <span class="nav-text">总结</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%91%BD%E5%90%8D%E8%A7%84%E5%88%99"><span class="nav-number">5.1.</span> <span class="nav-text">命名规则</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%B8%8B%E4%B8%80%E7%AF%87%E5%86%99%E4%BB%80%E4%B9%88"><span class="nav-number">5.2.</span> <span class="nav-text">下一篇写什么</span></a></li></ol></li></ol></div>
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <img class="site-author-image" itemprop="image" alt="果冻"
      src="https://thirdwx.qlogo.cn/mmopen/vi_32/DYAIOgq83equib0YGKeGrRww67LyZ7hSONtAW59RHDTd2JuKmSfQLEs8zWIB14hUcHibNG41zNibv5mr5QhM5QDMQ/132">
  <p class="site-author-name" itemprop="name">果冻</p>
  <div class="site-description" itemprop="description">果冻的碎碎念</div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">117</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
            <a href="/categories/">
          
        <span class="site-state-item-count">35</span>
        <span class="site-state-item-name">分类</span></a>
      </div>
      <div class="site-state-item site-state-tags">
            <a href="/tags/">
          
        <span class="site-state-item-count">88</span>
        <span class="site-state-item-name">标签</span></a>
      </div>
  </nav>
</div>
  <div class="links-of-author motion-element">
      <span class="links-of-author-item">
        <a href="https://blog.csdn.net/zou8944" title="低质博客平台 → https:&#x2F;&#x2F;blog.csdn.net&#x2F;zou8944" rel="noopener" target="_blank"><i class="fa fa-th-large fa-fw"></i>低质博客平台</a>
      </span>
      <span class="links-of-author-item">
        <a href="https://github.com/zou8944" title="同性交友网站 → https:&#x2F;&#x2F;github.com&#x2F;zou8944" rel="noopener" target="_blank"><i class="fab fa-github fa-fw"></i>同性交友网站</a>
      </span>
  </div>



      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

        
  <div class="beian"><a href="https://beian.miit.gov.cn/" rel="noopener" target="_blank">粤ICP备2021024139号 </a>
  </div>

<div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2022</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">果冻</span>
</div>
  <div class="powered-by">由 <a href="https://hexo.io/" class="theme-link" rel="noopener" target="_blank">Hexo</a> & <a href="https://pisces.theme-next.org/" class="theme-link" rel="noopener" target="_blank">NexT.Pisces</a> 强力驱动
  </div>


    <script async src="//dn-lbstatics.qbox.me/busuanzi/2.3/busuanzi.pure.mini.js"></script>


        
<div class="busuanzi-count">
  <script async src="https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>
    <span class="post-meta-item" id="busuanzi_container_site_uv" style="display: none;">
      <span class="post-meta-item-icon">
        <i class="fa fa-user"></i>
      </span>
      <span class="site-uv" title="总访客量">
        <span id="busuanzi_value_site_uv"></span>
      </span>
    </span>
    <span class="post-meta-divider">|</span>
    <span class="post-meta-item" id="busuanzi_container_site_pv" style="display: none;">
      <span class="post-meta-item-icon">
        <i class="fa fa-eye"></i>
      </span>
      <span class="site-pv" title="总访问量">
        <span id="busuanzi_value_site_pv"></span>
      </span>
    </span>
</div>






<script>
  (function() {
    function leancloudSelector(url) {
      url = encodeURI(url);
      return document.getElementById(url).querySelector('.leancloud-visitors-count');
    }

    function addCount(Counter) {
      var visitors = document.querySelector('.leancloud_visitors');
      var url = decodeURI(visitors.id);
      var title = visitors.dataset.flagTitle;

      Counter('get', '/classes/Counter?where=' + encodeURIComponent(JSON.stringify({ url })))
        .then(response => response.json())
        .then(({ results }) => {
          if (results.length > 0) {
            var counter = results[0];
            leancloudSelector(url).innerText = counter.time + 1;
            Counter('put', '/classes/Counter/' + counter.objectId, { time: { '__op': 'Increment', 'amount': 1 } })
              .catch(error => {
                console.error('Failed to save visitor count', error);
              });
          } else {
              Counter('post', '/classes/Counter', { title, url, time: 1 })
                .then(response => response.json())
                .then(() => {
                  leancloudSelector(url).innerText = 1;
                })
                .catch(error => {
                  console.error('Failed to create', error);
                });
          }
        })
        .catch(error => {
          console.error('LeanCloud Counter Error', error);
        });
    }

    function showTime(Counter) {
      var visitors = document.querySelectorAll('.leancloud_visitors');
      var entries = [...visitors].map(element => {
        return decodeURI(element.id);
      });

      Counter('get', '/classes/Counter?where=' + encodeURIComponent(JSON.stringify({ url: { '$in': entries } })))
        .then(response => response.json())
        .then(({ results }) => {
          for (let url of entries) {
            let target = results.find(item => item.url === url);
            leancloudSelector(url).innerText = target ? target.time : 0;
          }
        })
        .catch(error => {
          console.error('LeanCloud Counter Error', error);
        });
    }

    let { app_id, app_key, server_url } = {"enable":true,"app_id":"ryE8EmVPz7F7UoBoHgb0sS3o-gzGzoHsz","app_key":"ts5Wga1uMoWcqyj4ABElP6uF","server_url":"https://www.zou8944.com","security":false};
    function fetchData(api_server) {
      var Counter = (method, url, data) => {
        return fetch(`${api_server}/1.1${url}`, {
          method,
          headers: {
            'X-LC-Id'     : app_id,
            'X-LC-Key'    : app_key,
            'Content-Type': 'application/json',
          },
          body: JSON.stringify(data)
        });
      };
      if (CONFIG.page.isPost) {
        if (CONFIG.hostname !== location.hostname) return;
        addCount(Counter);
      } else if (document.querySelectorAll('.post-title-link').length >= 1) {
        showTime(Counter);
      }
    }

    let api_server = app_id.slice(-9) !== '-MdYXbMMI' ? server_url : `https://${app_id.slice(0, 8).toLowerCase()}.api.lncldglobal.com`;

    if (api_server) {
      fetchData(api_server);
    } else {
      fetch('https://app-router.leancloud.cn/2/route?appId=' + app_id)
        .then(response => response.json())
        .then(({ api_server }) => {
          fetchData('https://' + api_server);
        });
    }
  })();
</script>


      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>

<script src="/js/utils.js"></script>

<script src="/js/motion.js"></script>


<script src="/js/schemes/pisces.js"></script>


<script src="/js/next-boot.js"></script>




  




  
<script src="/js/local-search.js"></script>













  

  

<script>
NexT.utils.loadComments(document.querySelector('#lv-container'), () => {
  window.livereOptions = {
    refer: location.pathname.replace(CONFIG.root, '').replace('index.html', '')
  };
  (function(d, s) {
    var j, e = d.getElementsByTagName(s)[0];
    if (typeof LivereTower === 'function') { return; }
    j = d.createElement(s);
    j.src = 'https://cdn-city.livere.com/js/embed.dist.js';
    j.async = true;
    e.parentNode.insertBefore(j, e);
  })(document, 'script');
});
</script>

</body>
</html>
